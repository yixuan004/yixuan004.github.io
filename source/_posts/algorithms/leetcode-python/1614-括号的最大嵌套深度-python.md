---
title: 1614.括号的最大嵌套深度-python
date: 2022-01-07 01:07:44
tags:
    - 栈
    - 字符串
    - EASY
categories:
	- LeetCode-python
---

1614.括号的最大嵌套深度（简单）

题目大意：

如果字符串满足以下条件之一，则可以称之为**有效括号字符串（valid parentheses string**，可以简写为**VPS**）：

- 字符串是一个空字符串```""```，或者是一个不为```"("```或```")"```的单字符。
- 字符串可以写为```AB```（```A```与```B```字符串连接），其中```A```和```B```都是 有效括号字符串 。
- 字符串可以写为```(A)```，其中```A```是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串```S```的 嵌套深度```depth(S)```：

- ```depth("") = 0```
- ```depth(C) = 0```，其中```C```是单个字符的字符串，且该字符不是```"("```或者```")"```
- ```depth(A + B) = max(depth(A), depth(B))```，其中```A```和```B```都是 有效括号字符串
- ```epth("(" + A + ")") = 1 + depth(A)```，其中```A```是一个 有效括号字符串

例如：```""```、```"()()"```、```"()(()())"```都是 有效括号字符串（嵌套深度分别为 0、1、2），而```")("```、```"(()"```都不是 有效括号字符串 。

给你一个**有效括号字符串**```s```，返回该字符串的```s```**嵌套深度**。

<!--more-->

# 题目

[题目链接](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

题目大意：

如果字符串满足以下条件之一，则可以称之为**有效括号字符串（valid parentheses string**，可以简写为**VPS**）：

- 字符串是一个空字符串```""```，或者是一个不为```"("```或```")"```的单字符。
- 字符串可以写为```AB```（```A```与```B```字符串连接），其中```A```和```B```都是 有效括号字符串 。
- 字符串可以写为```(A)```，其中```A```是一个 有效括号字符串 。

类似地，可以定义任何有效括号字符串```S```的 嵌套深度```depth(S)```：

- ```depth("") = 0```
- ```depth(C) = 0```，其中```C```是单个字符的字符串，且该字符不是```"("```或者```")"```
- ```depth(A + B) = max(depth(A), depth(B))```，其中```A```和```B```都是 有效括号字符串
- ```epth("(" + A + ")") = 1 + depth(A)```，其中```A```是一个 有效括号字符串

例如：```""```、```"()()"```、```"()(()())"```都是 有效括号字符串（嵌套深度分别为 0、1、2），而```")("```、```"(()"```都不是 有效括号字符串 。

给你一个**有效括号字符串**```s```，返回该字符串的```s```**嵌套深度**。

示例1：
```
输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
```

示例2：
```
输入：s = "(1)+((2))+(((3)))"
输出：3
```

示例3：
```
输入：s = "1+(2*3)/(2-1)"
输出：1
```

示例4：
```
输入：s = "1"
输出：0
```

提示：
- 1 <= s.length <= 100
- s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
- 题目数据保证括号表达式 s 是 有效的括号表达式


## 分析和解答

这个题如果是python的话只要搞个list模拟栈就可以了，每次操作的时候判断当前list的长度，来更新max_depth还是很简单的

```python
class Solution(object):
    def maxDepth(self, s):
        """
        :type s: str
        :rtype: int
        """
        stack = []
        max_depth = -1
        for i, c in enumerate(s):
            if c == '(':
                stack.append(c)
            elif c == ')':
                stack = stack[:-1]  # 截断到最后一个
            
            max_depth = max(max_depth, len(stack))
        return max_depth
```