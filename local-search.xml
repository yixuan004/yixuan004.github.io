<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL报错解决</title>
    <link href="/2022/11/20/develop/mysql/MySQL%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
    <url>/2022/11/20/develop/mysql/MySQL%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>这里记录MySQL一些报错的解决过程，主要以ERROR CODE作为标识</p><span id="more"></span><h1 id="MySQL报错解决"><a href="#MySQL报错解决" class="headerlink" title="MySQL报错解决"></a>MySQL报错解决</h1><h2 id="1-报错-状态码解决"><a href="#1-报错-状态码解决" class="headerlink" title="1. 报错+状态码解决"></a>1. 报错+状态码解决</h2><h3 id="1-1-ERROR-CODE-2003"><a href="#1-1-ERROR-CODE-2003" class="headerlink" title="1.1 [ERROR CODE 2003]"></a>1.1 [ERROR CODE 2003]</h3><p> <strong>2003 - Can’t connect to MySQL server on ‘10.109.246.188’ (61 “Connection refused”)</strong></p><p>reference: <a href="https://blog.csdn.net/kechuno/article/details/107122814">https://blog.csdn.net/kechuno/article/details/107122814</a></p><p>在经过上面的配置后，使用navicat远程连接访问可能会出现这个错误，通过如下方法进行解决</p><p>检查mysql是否运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">bupt@h9:~$ sudo systemctl status mysql.service<br>● mysql.service - MySQL Community Server<br>     Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)<br>     Active: active (running) since Sun 2022-11-20 17:04:54 CST; 4h 53min ago<br>    Process: 214161 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS)<br>   Main PID: 214169 (mysqld)<br>     Status: &quot;Server is operational&quot;<br>      Tasks: 39 (limit: 154203)<br>     Memory: 367.0M<br>     CGroup: /system.slice/mysql.service<br>             └─214169 /usr/sbin/mysqld<br><br>11月 20 17:04:53 h9 systemd[1]: Starting MySQL Community Server...<br>11月 20 17:04:54 h9 systemd[1]: Started MySQL Community Server.<br></code></pre></td></tr></table></figure><p>检查监听端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bupt@h9:~$ netstat -ln | grep mysql<br>unix  2      [ ACC ]     流        LISTENING     58584142 /var/run/mysqld/mysqlx.sock<br>unix  2      [ ACC ]     流        LISTENING     58584144 /var/run/mysqld/mysqld.sock<br></code></pre></td></tr></table></figure><p>修改mysql的配置，主要是修改这个bind-address</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bupt@h9:~$ cd /etc/mysql/mysql.conf.d/<br>bupt@h9:/etc/mysql/mysql.conf.d$ sudo vim mysqld.cnf<br>修改：bind-address = 0.0.0.0<br></code></pre></td></tr></table></figure><p>重启mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bupt@h9:~$ service mysql restart<br></code></pre></td></tr></table></figure><h3 id="1-2-ERROR-CODE-1130"><a href="#1-2-ERROR-CODE-1130" class="headerlink" title="1.2 [ERROR CODE 1130]"></a>1.2 [ERROR CODE 1130]</h3><p><strong>1130 - Host ‘10.28.232.177’ is not allowed to connect to this MySQL server</strong></p><p>在解决上面2003的问题后，新出现了这个1130的错误，查看博客如下</p><p>reference: <a href="https://www.php.cn/mysql-tutorials-380131.html">https://www.php.cn/mysql-tutorials-380131.html</a></p><p>连接服务器后，通过<code>show databases;</code>查看库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span><br>+--------------------+<br>| Database           |<br>+--------------------+<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| sys                |<br>+--------------------+<br>4 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>进入<code>mysql</code>数据库，并<code>show tables;</code>显示数据库表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">use mysql;</span><br>Reading table information for completion of table and column names<br>You can turn off this feature to get a quicker startup with -A<br><br>Database changed<br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show tables;</span><br>+------------------------------------------------------+<br>| Tables_in_mysql                                      |<br>+------------------------------------------------------+<br>| columns_priv                                         |<br>| component                                            |<br>| db                                                   |<br>| default_roles                                        |<br>| engine_cost                                          |<br>| func                                                 |<br>| general_log                                          |<br>| global_grants                                        |<br>| gtid_executed                                        |<br>| help_category                                        |<br>| help_keyword                                         |<br>| help_relation                                        |<br>| help_topic                                           |<br>| innodb_index_stats                                   |<br>| innodb_table_stats                                   |<br>| password_history                                     |<br>| plugin                                               |<br>| procs_priv                                           |<br>| proxies_priv                                         |<br>| replication_asynchronous_connection_failover         |<br>| replication_asynchronous_connection_failover_managed |<br>| replication_group_configuration_version              |<br>| replication_group_member_actions                     |<br>| role_edges                                           |<br>| server_cost                                          |<br>| servers                                              |<br>| slave_master_info                                    |<br>| slave_relay_log_info                                 |<br>| slave_worker_info                                    |<br>| slow_log                                             |<br>| tables_priv                                          |<br>| time_zone                                            |<br>| time_zone_leap_second                                |<br>| time_zone_name                                       |<br>| time_zone_transition                                 |<br>| time_zone_transition_type                            |<br>| user                                                 |<br>+------------------------------------------------------+<br>37 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>查看user表中的数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">select Host, User from user;</span><br>+-----------+------------------+<br>| Host      | User             |<br>+-----------+------------------+<br>| localhost | debian-sys-maint |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>| localhost | root             |<br>+-----------+------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>修改<code>User=&#39;root&#39;</code>的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">update user <span class="hljs-built_in">set</span> Host=<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-built_in">where</span> User=<span class="hljs-string">&#x27;root&#x27;</span>;</span><br>Query OK, 1 row affected (0.00 sec)<br>Rows matched: 1  Changed: 1  Warnings: 0<br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">select Host, User from user;</span><br>+-----------+------------------+<br>| Host      | User             |<br>+-----------+------------------+<br>| %         | root             |<br>| localhost | debian-sys-maint |<br>| localhost | mysql.infoschema |<br>| localhost | mysql.session    |<br>| localhost | mysql.sys        |<br>+-----------+------------------+<br>5 rows in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>最后刷新一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">flush privileges;</span><br></code></pre></td></tr></table></figure><p>通过navicat测试，这时候可以连接，证明上述操作成功</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20221120222628018.png" alt="image-20221120222628018"></p>]]></content>
    
    
    <categories>
      
      <category>develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu服务器MySQL的安装及基础命令</title>
    <link href="/2022/11/20/develop/mysql/Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/11/20/develop/mysql/Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>背景：之前只基本在服务器上使用mysql，也曾经尝试过安装但是没有整理笔记，这次顺着项目部署，整理一下笔记</p><span id="more"></span><h1 id="Ubuntu服务器MySQL的安装-amp-基础命令-amp-BUG"><a href="#Ubuntu服务器MySQL的安装-amp-基础命令-amp-BUG" class="headerlink" title="Ubuntu服务器MySQL的安装&amp;基础命令&amp;BUG"></a>Ubuntu服务器MySQL的安装&amp;基础命令&amp;BUG</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><h3 id="1-1-安装mysql"><a href="#1-1-安装mysql" class="headerlink" title="1.1 安装mysql"></a>1.1 安装mysql</h3><p>进入root用户， 执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install mysql-server mysql-client<br></code></pre></td></tr></table></figure><p>成功安装后，系统会有如下输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">done!<br>update-alternatives: 使用 /var/lib/mecab/dic/ipadic-utf8 来在自动模式中提供 /var/lib/mecab/dic/debian (mecab-dictionary)<br>正在设置 mysql-server-8.0 (8.0.31-0ubuntu0.20.04.1) ...<br>update-alternatives: 使用 /etc/mysql/mysql.cnf 来在自动模式中提供 /etc/mysql/my.cnf (my.cnf)<br>Renaming removed key_buffer and myisam-recover options (if present)<br>mysqld will log errors to /var/log/mysql/error.log<br>mysqld is running as pid 190567<br>Created symlink /etc/systemd/system/multi-user.target.wants/mysql.service → /lib/systemd/system/mysql.service.<br></code></pre></td></tr></table></figure><p>这里不会有密码的显示，直接使用<code>sudo mysql</code>命令进入<code>mysql&gt;</code>命令行管理界面，再之后，通过一系列的命令修改mysql root的密码，修改完成后不要忘记restart</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">bupt@h9:~$ sudo mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">选择管理user表的数据库</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">use mysql;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将authentication_string 置空</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">update user <span class="hljs-built_in">set</span> authentication_string=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将plugin改为以前版本的密码认证方式</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">update user <span class="hljs-built_in">set</span> plugin=<span class="hljs-string">&#x27;mysql_native_password&#x27;</span> <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span>;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">刷新</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">FLUSH PRIVILEGES;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改密码</span><br><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">alter user <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified by <span class="hljs-string">&#x27;newpassword&#x27;</span>;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启MySQL</span><br>bupt@h9:~$ service mysql restart<br></code></pre></td></tr></table></figure><p>在之后，即可使用<code>mysql -u root -p</code>命令登录管理界面，注意这里使用其他用户也是可以登录的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h9:~$ mysql -u root -p<br>Enter password: <br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 15<br>Server version: 8.0.31-0ubuntu0.20.04.1 (Ubuntu)<br><br>Copyright (c) 2000, 2022, Oracle and/or its affiliates.<br><br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br><br>Type &#x27;help;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">mysql&gt; </span><br></code></pre></td></tr></table></figure><h3 id="1-2-查看mysql的端口"><a href="#1-2-查看mysql的端口" class="headerlink" title="1.2 查看mysql的端口"></a>1.2 查看mysql的端口</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash">show global variables like <span class="hljs-string">&#x27;port&#x27;</span>;</span><br>+---------------+-------+<br>| Variable_name | Value |<br>+---------------+-------+<br>| port          | 3306  |<br>+---------------+-------+<br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><h2 id="2-使用Navicat连接数据库"><a href="#2-使用Navicat连接数据库" class="headerlink" title="2. 使用Navicat连接数据库"></a>2. 使用Navicat连接数据库</h2><p>这里需要解决一些报错码的配置，详见另外一篇博客：<strong>MySQL报错解决</strong></p><p>如下配置，即可使用Navicat连接数据库，主要注意是选择<strong>常规</strong>这个tab</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20221120223114869.png" alt="image-20221120223114869"></p>]]></content>
    
    
    <categories>
      
      <category>develop</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改hosts文件使得服务器可以访问github</title>
    <link href="/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/"/>
    <url>/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/</url>
    
    <content type="html"><![CDATA[<p>之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用</p><p>在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改<code>/etc/hosts</code>文件的方式</p><span id="more"></span><h1 id="修改hosts文件使得服务器可以访问github"><a href="#修改hosts文件使得服务器可以访问github" class="headerlink" title="修改hosts文件使得服务器可以访问github"></a>修改hosts文件使得服务器可以访问github</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>首先登录如下网站，找到一个可以ping到的github ip地址：<a href="https://ping.chinaz.com/github.com">https://ping.chinaz.com/github.com</a></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20221119200639129.png" alt="image-20221119200639129"></p><p>通过root账号修改<code>/etc/hosts</code>文件，加入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">140.82.113.3www.github.com<br>140.82.113.3github.com<br></code></pre></td></tr></table></figure><p>加入后效果如下，再次<code>ping www.github.com</code>，可以得到响应，证明正确</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20221119200931544.png" alt="image-20221119200931544" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20221119201002658.png" alt="image-20221119201002658" style="zoom:50%;">]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo图片路径的配置</title>
    <link href="/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>在使用hexo搭建博客的时候，<code>./sourcehttp://yixuan004.oss-cn-hangzhou.aliyuncs.com/img</code>路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到</p><p>但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在</p><p>所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移</p><span id="more"></span><h1 id="hexo图片路径的配置"><a href="#hexo图片路径的配置" class="headerlink" title="hexo图片路径的配置"></a>hexo图片路径的配置</h1><h2 id="1-安装插件hexo-asset-image"><a href="#1-安装插件hexo-asset-image" class="headerlink" title="1. 安装插件hexo-asset-image"></a>1. 安装插件hexo-asset-image</h2><h3 id="1-1-reference"><a href="#1-1-reference" class="headerlink" title="1.1 reference"></a>1.1 reference</h3><p><a href="https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2">https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2</a></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2 操作"></a>1.2 操作</h3><p>使用npm进行安装，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>注意，这里很多其他博客提供的安装命令如下，但实际尝试的时候可能由于版本等问题，导致无法生效，这些命令可能不好使</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-marked --save<br>npm install hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>之后，将<code>_config.yml</code>文件的做如下修改（注：后面的marked可能是不需要的，可能是对应<code>hexo-render-marked</code>的配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">_config.yml<br>post_asset_folder: true<br>marked:<br>  prependRoot: true<br>  postAsset: true<br></code></pre></td></tr></table></figure><p>在上述配置后，在执行<code>hexo new [FILENAME]</code>的时候，会自动生成这个文件名字的md和对应的文件名字的文件夹，这里可以在文件夹后加入<code>.assets</code>，和目前我自己本机的typora环境对应上</p><p>至此操作完成</p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT源代码阅读学习</title>
    <link href="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习</p><span id="more"></span><h1 id="BERT源代码阅读学习"><a href="#BERT源代码阅读学习" class="headerlink" title="BERT源代码阅读学习"></a>BERT源代码阅读学习</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>BERT源代码学习：<a href="https://zhuanlan.zhihu.com/p/360988428">https://zhuanlan.zhihu.com/p/360988428</a></p><p>Attention is all you need： <a href="https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf</a></p><p>BERT：<a href="https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ">https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ</a></p><p>Attention机制详解：<a href="https://zhuanlan.zhihu.com/p/47282410">https://zhuanlan.zhihu.com/p/47282410</a></p><p>positional embedding absolute&#x2F;relative等不同方式：<a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>torch中的einsum：<a href="https://zhuanlan.zhihu.com/p/361209187">https://zhuanlan.zhihu.com/p/361209187</a></p><p>Self-Attention with Relative Position Representations: <a href="https://arxiv.org/pdf/1803.02155.pdf">https://arxiv.org/pdf/1803.02155.pdf</a></p><h2 id="1-模型结构（论文-amp-Transformer架构截图）"><a href="#1-模型结构（论文-amp-Transformer架构截图）" class="headerlink" title="1. 模型结构（论文&amp;Transformer架构截图）"></a>1. 模型结构（论文&amp;Transformer架构截图）</h2><h3 id="1-1-论文-amp-Transformer架构截图"><a href="#1-1-论文-amp-Transformer架构截图" class="headerlink" title="1.1 论文&amp;Transformer架构截图"></a>1.1 论文&amp;Transformer架构截图</h3><h4 id="1-1-1-Transformer架构图"><a href="#1-1-1-Transformer架构图" class="headerlink" title="1.1.1 Transformer架构图"></a>1.1.1 Transformer架构图</h4><p>左边代表Encoder部分，右边代表Decoder部分。两边的区别个人理解是：</p><ul><li>Encoder是作为NLU（Natrual Language Understanding）来使用的，所以在输入的时候Encoder是能看到全局信息的。从目前接触到的任务来说还是Encoder这边的结构更加常用一些，大部分任务感觉还是属于在NLU的范畴，NLG那边的有些就显得不太好评测或者不是很靠谱；</li><li>但是在输入Decoder的时候，因为Decoder一般被NLG（Natural Language Generation）类的任务来使用，所以其需要根据上文来生成下文，故在输入的时候需要加mask，即 <code>Masked Multi-Head Attention</code>。此外在decoder部分中还有一个接收来自Encoder那边信息的Multi-Head Attention，也被称作 <code>encoder-decoder attention layer</code>，这个地方query来自于前一级的decoder层输出，但其key和value来自于encoder的输出，那么理解来说就是decoder的每一个位置作为key和encoder那边key计算相似度，然后聚合来自encoder那边的value信息；</li><li><font color="red">和同学讨论后补充：对于Transformer架构的信息，像T5这样的encoder-decoder模型，或者说像是一类依据文本生成文本的，比如翻译任务，那就是使用到整个Transformer架构，其中的encoder-decoder attention可以理解为我需要看着原来的文本来做生成，然后把query看做普通RNN架构中的x，这样x需要聚合来自全部输入文本的信息做attention；对于BERT这类就是只用到Encoder架构；对于GPT类的可能就只是用Decoder部分，里面就没有encoder-decoder attention那个部分了；</font></li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711105616573.png" alt="image-20220711105616573" style="zoom:50%;"><h4 id="1-1-2-Multi-Head-Self-Attention"><a href="#1-1-2-Multi-Head-Self-Attention" class="headerlink" title="1.1.2 Multi-Head Self Attention"></a>1.1.2 Multi-Head Self Attention</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711105642016.png" alt="image-20220711105642016"></p><h4 id="1-1-3-BERT-Embedding"><a href="#1-1-3-BERT-Embedding" class="headerlink" title="1.1.3 BERT Embedding"></a>1.1.3 BERT Embedding</h4><p>这个是bert模型结构的embedding输入，也需要联合代码看一下这个过程是怎么实现的。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711110109758.png" alt="image-20220711110109758"></p><p>这里补充贴一张LUKE的图，虽然没看过但是看起来加了一个Entity Type Embedding，好像还是个比较有名的工作</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712195033334.png" alt="image-20220712195033334"></p><h2 id="2-代码学习"><a href="#2-代码学习" class="headerlink" title="2. 代码学习"></a>2. 代码学习</h2><h3 id="2-1-基础简化pipeline代码"><a href="#2-1-基础简化pipeline代码" class="headerlink" title="2.1 基础简化pipeline代码"></a>2.1 基础简化pipeline代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> modeling_bert  <span class="hljs-comment"># 从这里看源代码</span><br><br><span class="hljs-comment"># 预训练模型加载</span><br>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br>model = BertModel.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br><br><span class="hljs-comment"># 输入&amp;输出</span><br>text = <span class="hljs-string">&quot;Germany beat Argentina 2-0 in the World Cup Final.&quot;</span><br>encoded_input = tokenizer(text, return_tensors=<span class="hljs-string">&#x27;pt&#x27;</span>)<br>output = model(**encoded_input)<br><br><span class="hljs-comment"># 获取一句话的输出，还有cls token的输出</span><br><span class="hljs-built_in">print</span>(output[<span class="hljs-string">&#x27;pooler_output&#x27;</span>].shape)  <span class="hljs-comment"># torch.Size([1, 768])</span><br><span class="hljs-built_in">print</span>(output[<span class="hljs-string">&#x27;last_hidden_state&#x27;</span>].shape)  <span class="hljs-comment"># torch.Size([1, 14, 768])</span><br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>总结：加载<strong>config.json</strong>、<strong>vocab.txt</strong>还有<strong>pytorch_model.bin</strong>三个文件。其中通过 <code>from_pretrained(&quot;./bert_base_uncased&quot;)</code>进行指定路径，如果不指定路径的话好像会从huggingface那边下载model，指定路径的话就需要文件夹下有这三个文件；</p><h3 id="2-2-model"><a href="#2-2-model" class="headerlink" title="2.2 model"></a>2.2 model</h3><h4 id="2-2-1-embeddings、encoder、pooler（※重点）"><a href="#2-2-1-embeddings、encoder、pooler（※重点）" class="headerlink" title="2.2.1 embeddings、encoder、pooler（※重点）"></a>2.2.1 embeddings、encoder、pooler（※重点）</h4><p>通过<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code>加载模型后，首先可以在这里调试model这个对象包含的内容，model是BertModel的实例化，模型结构主要由<code>model.embeddings </code>（BERTEmbeddings类对象），<code>model.encoder</code>（BertEncoder类对象），<code>model.pooler</code>（BertPooler对象）组成。点开后可以看到各个地方的模型结构与层数，之后会随着模型调试查看数据流向和数据维度的变化。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711135726421.png" alt="image-20220711135726421"></p><h5 id="·-class-BertEmbeddings层结构"><a href="#·-class-BertEmbeddings层结构" class="headerlink" title="· class BertEmbeddings层结构"></a>· class BertEmbeddings层结构</h5><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;modeling_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertEmbeddings</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Construct the embeddings from word, position and token_type embeddings.&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h6 id="1-init"><a href="#1-init" class="headerlink" title="1) init"></a>1) <strong>init</strong></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=config.pad_token_id)<br>    self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)<br>    self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)<br><br>    <span class="hljs-comment"># self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load</span><br>    <span class="hljs-comment"># any TensorFlow checkpoint file</span><br>    self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>    self.dropout = nn.Dropout(config.hidden_dropout_prob)<br>    <span class="hljs-comment"># position_ids (1, len position emb) is contiguous in memory and exported when serialized</span><br>    self.position_embedding_type = <span class="hljs-built_in">getattr</span>(config, <span class="hljs-string">&quot;position_embedding_type&quot;</span>, <span class="hljs-string">&quot;absolute&quot;</span>)<br>    self.register_buffer(<span class="hljs-string">&quot;position_ids&quot;</span>, torch.arange(config.max_position_embeddings).expand((<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">if</span> version.parse(torch.__version__) &gt; version.parse(<span class="hljs-string">&quot;1.6.0&quot;</span>):<br>        self.register_buffer(<br>            <span class="hljs-string">&quot;token_type_ids&quot;</span>,<br>            torch.zeros(self.position_ids.size(), dtype=torch.long),<br>            persistent=<span class="hljs-literal">False</span>,<br>        )<br></code></pre></td></tr></table></figure><p>简单对init进行解释，这里有三个<code>nn.Embedding</code>层：</p><ul><li>self.word_embeddings：维度从vocab_size（30522）到hidden_size（768）转化，<font color="red">TODO：padding_idx的参数是做什么用的？</font> </li><li>self.position_embeddings：维度从max_position_embeddings（512）到hidden_size（768）转化；</li><li>self.token_type_embeddings：维度从config.type_vocab_size（2，这里的2代表的是有两种类别的，第一个[SEP]前都是0，第二个[SEP]前都是1，这样交叉的）到到hidden_size（768），或者是用来表示padding地方的差异；</li></ul><p>这里的<code>self.LayerNorm</code>和<code>self.dropout</code>是剩下两个和forward比较相关的层，初始化都比较正常</p><p><font color="red">和同学讨论下这个nn.Embedding层的用处，之前对这个层一直不是太理解，大概目前的理解是传入的一个比如input_ids是[1, 14]这个shape的，首先其被转化成一个one-hot的表示也就是[1, 14, 30522(这个维度类似一个词典大小)]，然后过一个[30522, 768]的，两个乘在一起就有一种对应位把元素取出来的感觉，这样就得到了最终的embedding表示[1, 14, 768]</font> </p><p><font color="red">词表大小30522是针对input_ids embedding的，那么针对positional embedding就是max_seq_len，针对token type的就是2（只有0和1代表两类交替的）</font></p><h6 id="2-forward"><a href="#2-forward" class="headerlink" title="2) forward"></a>2) forward</h6><p>forward传入的参数中</p><ul><li>input_ids **[1, seq_len]**：tensor([[ 101, 2762, 3786, 5619, 1016, 1011, 1014, 1998, 2180, 1996, 2088, 2452, 2345,  102]])，这是tokenizer.convert_tokens_to_ids()的结果应该，那边BERT好像还对应了个wordpiecetoken，101是[CLS]，102是[PAD]</li><li>token_type_ids **[1, seq_len]**：tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])，传入的没有[SEP]，只有一类token</li><li>position_ids：暂时为None</li><li>inputs_embeds：暂时为None</li></ul><p>step1：根据input_ids提取得到的seq_len长度，初始化position_ids **[1, seq_len]**：tensor([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13]])</p><p>step2：获取input_embeds和token_type_embeddings，通过上面的传入参数以及nn.Embedding层，并把这两个加在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> inputs_embeds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    inputs_embeds = self.word_embeddings(input_ids)<br>token_type_embeddings = self.token_type_embeddings(token_type_ids)<br><br>embeddings = inputs_embeds + token_type_embeddings<br></code></pre></td></tr></table></figure><p>embeddings.shape <strong>[1, seq_len, hidden_dim]</strong></p><p>step3：如果self.position_embedding_type是”absolute”绝对的话，就传入后加上position_embeddings，此时embeddings.shape **[1, seq_len, hidden_dim]**没有变化；absolute就是绝对位置编码，理解是[0, 1, 2, 3…]这样的绝对位置；<font color="red">还有一种position_embedding是相对位置编码的embedding，部分代码整合在了BertSelfAttention这个类中，博客参考：<a href="https://blog.csdn.net/chenf1995/article/details/122971023">https://blog.csdn.net/chenf1995/article/details/122971023</a></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;absolute&quot;</span>:<br>    position_embeddings = self.position_embeddings(position_ids)<br>    embeddings += position_embeddings<br></code></pre></td></tr></table></figure><p>step4：过LayerNorm和dropout，维度不会改变，BertEmbeddings这个类最终输出了一个embeddings <strong>[1, seq_len, hidden_dim]<strong>的信息，代表将要输入进入encoder结构部分的embedding</strong>input_embedding+token_type_embedding+position_embedding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">embeddings = self.LayerNorm(embeddings)<br>embeddings = self.dropout(embeddings)<br><span class="hljs-keyword">return</span> embeddings<br></code></pre></td></tr></table></figure><h6 id="3-综合别人博客做一个总结"><a href="#3-综合别人博客做一个总结" class="headerlink" title="3) 综合别人博客做一个总结"></a>3) 综合别人博客做一个总结</h6><p>word_embeddings是上文中subword tokenization对应的词嵌入；</p><p>token_type_embeddings是用于表示当前词所在的句子，辅助区别句子与padding，句子对通过[SEP]分隔之间的差异；</p><p>position_embeddings是句子中每个词的位置嵌入，用于区别词的顺序，博客说这个地方是训练出来的（从代码看确实如此），而不是计算得到固定嵌入，可能固定嵌入不利于拓展；</p><p>三个embedding层不带权重直接加在一起，过LayerNorm+dropout后产生输出，大小为**[batch_size, seq_len, hidden_size]**</p><h6 id="4-补充：positional-embedding的不同方式"><a href="#4-补充：positional-embedding的不同方式" class="headerlink" title="4) 补充：positional embedding的不同方式"></a>4) 补充：positional embedding的不同方式</h6><p><a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>背景：</p><p>词与词之间的顺序关系往往影响整个句子的含义，因此在对文本数据进行建模的时候需要考虑词与词之间的顺序关系；</p><p>建模文本中的顺序关系必须要使用positional encoding吗？-&gt; 不一定，只有使用位置不敏感的模型对文本数据进行建模的时候，才需要额外使用positional encoding；如果模型的输出会随着输入文本数据顺序的变化而变化，那么这个模型就是关于位置敏感的，反之则是位置不敏感的；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713092751251.png" alt="image-20220713092751251"></p><p>在常用的文本模型中，RNN类的就是关于位置敏感的，使用RNN类模型对文本数据建模的时候，模型结构天然考虑了文本中词与词之间的顺序关系。<strong>而以attention机制为核心的transformer则是位置不敏感的，使用这一类位置不敏感的模型的时候需要额外加入positional encoding引入文本中词与词的顺序关系；</strong></p><p>具体操作：</p><p>对于transformer模型的positional encoding有两种主流方式：即绝对位置编码和相对位置编码</p><p>其中<strong>absolute positional embedding（绝对位置编码）</strong>是相对简单理解的，直接对不同位置随机初始化一个positional embedding，加到word embedding和token_type embedding上输入模型作为参数进行训练</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711110109758.png" alt="image-20220711110109758"></p><p>另一种是<strong>relative positional embedding（相对位置编码）</strong>，首先motivation是不同位置的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1 2和3 4距离都只差1，这些关于位置的<strong>相对含义</strong>模型通过绝对位置编码是否能够学习？绝对位置编码没有约束位置之间这些隐含关系，只能期待他隐式的学习到，所以是否有更合理的方法能够显式的让模型理解位置的相对关系？</p><p><font color="blue">11111</font> </p><p>详细看一下huggingface transformer代码中的这个部分，参数有”absolute”、”relative_key”和”relative_key_query”三种，这些参数在<code>class BertSelfAttention(nn.Module)</code>这个类中，而不是在最开始的<code>BertEmbedding</code>那块的</p><ul><li><code>absolute</code>：默认值，这部分就不用处理（对这个地方的处理在Embedding层）</li><li><code>relative_key</code>：对key_layer作处理，将其与这里的<code>positional_embedding</code>和key矩阵相乘作为key相关的位置编码；</li><li><code>relative_key_query</code>：对key和value都进行相乘以作为位置编码。</li></ul><p><font color="red">用下面代码简单加一下注释</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        ...<br>        <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>          self.max_position_embeddings = config.max_position_embeddings  <span class="hljs-comment"># 512</span><br>          self.distance_embedding = nn.Embedding(<span class="hljs-number">2</span> * config.max_position_embeddings - <span class="hljs-number">1</span>, self.attention_head_size)  <span class="hljs-comment"># [512*2-1, 64 (即hidden//head_num)]</span><br>        ...<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>    seq_length = hidden_states.size()[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 14</span><br>    position_ids_l = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [14, 1]shape的tensor</span><br>    position_ids_r = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># [1, 14]</span><br>    distance = position_ids_l - position_ids_r  <span class="hljs-comment"># [seqlen, seq_len]</span><br>    positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - <span class="hljs-number">1</span>)  <span class="hljs-comment"># [seqlen, seqlen, hidden_size]</span><br>    positional_embedding = positional_embedding.to(dtype=query_layer.dtype)  <span class="hljs-comment"># fp16 compatibility</span><br><br>    <br>    <span class="hljs-comment"># query_layer : batchsize, seqlen, hidden -&gt; batchsize, head_num, seqlen, hidden//head_num【multi-head】</span><br><br>    <span class="hljs-comment"># bhld,lrd -&gt; bhld不变，lrd去掉一个维度变成rd -&gt; bhld不变, rd转置变成dr -&gt; 乘 -&gt; bhlr</span><br>    <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span>:<br>        relative_position_scores = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>        attention_scores = attention_scores + relative_position_scores<br>    <span class="hljs-keyword">elif</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>        relative_position_scores_query = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>        relative_position_scores_key = torch.einsum(<span class="hljs-string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)<br>        attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key<br></code></pre></td></tr></table></figure><ul><li><code>seq_length</code>：这句话的长度，比如14</li><li><code>position_ids_l</code>：初始化是一个例如[14, 1]的向量，存储的类似于[[0], [1], [2] …]这样的</li><li><code>position_ids_r</code>：初始化是一个例如[1, 14]的向量，存储的类似于[[0, 1, 2, 3, 4]]这样的</li><li><code>distance</code>：初始化直接用<code>position_ids_l</code>-<code>position_ids_r</code>，这里直接广播减法，是一个[14, 14]维度的</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713165208863.png" alt="image-20220713165208863"></p><p>因为这个地方是在attention这块来做的embedding，attention那边的scoreshape是[batch, head, seq_len, seq_len]的，代表query每个位置处对于key的注意力，那么可以在这里对query和key都搞positional embedding</p><p>通过上面几个做操作搞了一个<code>positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1)</code>，这个有点不为什么每个要把512-1给加上，这样处理完后distance变成了如下所示的tensor</p><p><font color="red">两个距离相隔最远是512，那么这样处理后能保证所有数字都是&gt;&#x3D;0的，因为离的最远的也就是512了，然后最远的将会到达1023那个感觉</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713170145685.png" alt="image-20220713170145685"></p><p>positional_embedding由distance_embedding层后得到，distance_embedding层的传入参数是[512<em>2-1, 64 (即hidden&#x2F;&#x2F;head_num)]也能理解了，因为词表大小是差不多0-1023的；；positional_embedding的shape是</em>*[seq_len, seq_len, hidden]**的，如果是一个batch的话，那么应该是这个batch里面最大的那个seq_len？</p><p>下面代码把query_layer[1, 12, 14, 64]和positional_embedding[14, 14, 64]作为这个<code>torch.einsum</code>的输入，这个地方参考文档<a href="https://zhuanlan.zhihu.com/p/361209187%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%8A%E5%BD%A2%E7%8A%B6bhld,lrd%E7%9A%84%E4%B8%A4%E4%B8%AAtensor%E5%8A%A0%E6%88%90%E4%B8%80%E4%B8%AAbhlr%E7%9A%84%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E7%94%A8%E4%B8%A4%E4%B8%AAl%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%89%8D%E9%9D%A2%E4%B8%A4%E4%B8%AAseq_len%E6%9C%AC%E8%B4%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Equery%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Ekey%EF%BC%8C%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E9%95%BF%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%AD%89%E9%95%BF%E7%9A%84%E4%BA%86%EF%BC%9B">https://zhuanlan.zhihu.com/p/361209187，就是把形状bhld,lrd的两个tensor加成一个bhlr的，这里为什么没用两个l可能是因为前面两个seq_len本质上一个来自于query，一个来自于key，而实际上是不需要等长的，只是一般操作默认为等长的了；</a></p><p>重点：这里以第一个作为示例，l和d在前后的箭头中都出现了，那就是在这两个维度上操作,query_layer[1, 12, <strong>14</strong>, <strong>64</strong>]和positional_embedding[<strong>14</strong>, 14, <strong>64</strong>]，转置乘，出来一个relative_position_scores_query**[1, 12, 14, 14]**的，聚合来自position的信息</p><p><font color="red">TODO：还弄得没那么明白，大概明白个意思，之后还要详细看看</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">relative_position_scores_query = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>relative_position_scores_key = torch.einsum(<span class="hljs-string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)<br></code></pre></td></tr></table></figure><p>最后，执行下述代码，注意这个<strong>相对位置编码</strong>过程可以只对query做，也可以对query和key同时做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key<br></code></pre></td></tr></table></figure><p><font color="red">TODO：</font> <a href="https://zhuanlan.zhihu.com/p/121126531%E8%BF%99%E9%87%8C%E8%BF%98%E4%BB%8B%E7%BB%8D%E5%88%B0%E4%BA%86%EF%BC%9ASinusoidal">https://zhuanlan.zhihu.com/p/121126531这里还介绍到了：Sinusoidal</a> Position Encoding和Complex embedding</p><h5 id="·class-BertSelfAttention：被BertAttention调用（※重点）"><a href="#·class-BertSelfAttention：被BertAttention调用（※重点）" class="headerlink" title="·class BertSelfAttention：被BertAttention调用（※重点）"></a>·class BertSelfAttention：被BertAttention调用（※重点）</h5><h6 id="1-init-1"><a href="#1-init-1" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-keyword">if</span> config.hidden_size % config.num_attention_heads != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(config, <span class="hljs-string">&quot;embedding_size&quot;</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">f&quot;The hidden size (<span class="hljs-subst">&#123;config.hidden_size&#125;</span>) is not a multiple of the number of attention &quot;</span><br>                <span class="hljs-string">f&quot;heads (<span class="hljs-subst">&#123;config.num_attention_heads&#125;</span>)&quot;</span><br>            )<br><br>        self.num_attention_heads = config.num_attention_heads<br>        self.attention_head_size = <span class="hljs-built_in">int</span>(config.hidden_size / config.num_attention_heads)<br>        self.all_head_size = self.num_attention_heads * self.attention_head_size<br><br>        self.query = nn.Linear(config.hidden_size, self.all_head_size)<br>        self.key = nn.Linear(config.hidden_size, self.all_head_size)<br>        self.value = nn.Linear(config.hidden_size, self.all_head_size)<br><br>        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)<br>        self.position_embedding_type = position_embedding_type <span class="hljs-keyword">or</span> <span class="hljs-built_in">getattr</span>(<br>            config, <span class="hljs-string">&quot;position_embedding_type&quot;</span>, <span class="hljs-string">&quot;absolute&quot;</span><br>        )<br>        <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>            self.max_position_embeddings = config.max_position_embeddings<br>            self.distance_embedding = nn.Embedding(<span class="hljs-number">2</span> * config.max_position_embeddings - <span class="hljs-number">1</span>, self.attention_head_size)<br><br>        self.is_decoder = config.is_decoder<br></code></pre></td></tr></table></figure><p>这个地方是整个BERT架构中非常核心的区域</p><ul><li>self.num_attention_heads &#x3D; config.num_attention_heads：几头注意力机制，在config文件里这里设置为12（一般BERT也是12）</li><li>self.attention_head_size &#x3D; int(config.hidden_size &#x2F; config.num_attention_heads)：config.hidden_size是768，所以每个头的hidden_size将会是768&#x2F;12&#x3D;64；</li><li>self.all_head_size是self.num_attention_heads（12）再乘回self.attention_head_size（64），猜测这样的原因是因为整除造成的可能回来后就不是768了；<font color="red">从其他博客也看到和剪枝有关</font> </li><li>self.query、self.key、self.value三个权重矩阵，都是一个hidden_size（768）到内部这个all_head_size（可能是768，也可能有损失）的转化；</li><li>self.dropout &#x3D; nn.Dropout(config.attention_probs_dropout_prob)：简单的dropout层；</li><li>self.position_embedding_type：这与相对&#x2F;绝对位置编码有关，如果是绝对位置编码那么在BertEmbedding层里面已经给结合进去了，<font color="blue">如果是相对位置编码要在这里实现，不过这个地方暂时先跳过了</font>；</li><li>self.is_decoder &#x3D; config.is_decoder：标识是否decoder，BERT只是一个encoder就不涉及到这个部分了；</li></ul><h6 id="2-forward-1"><a href="#2-forward-1" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transpose_for_scores</span>(<span class="hljs-params">self, x</span>):<br>    new_x_shape = x.size()[:-<span class="hljs-number">1</span>] + (self.num_attention_heads, self.attention_head_size)<br>    x = x.view(new_x_shape)<br>    <span class="hljs-keyword">return</span> x.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>首先是这个函数，这个函数是拆多头用的，输入的x是[batch, seq_len, hidden]的，先指定new_shape是[batch, seq_len, num_attention_heads, attention_head_size]（一般可以认为是[batch, seq_len, 12, 64]），然后.view转化，然后再通过permute改变顺序为**[batch, attention_head_size, seq_len, num_attention_heads]**，这样是因为attention_head_size可以归为”batch“那边的维度了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    mixed_query_layer = self.query(hidden_states)<br><br><span class="hljs-comment"># 忽略了cross-attention部分</span><br>    <span class="hljs-comment"># hidden_states [batch, seqlen, hidden]</span><br>    key_layer = self.transpose_for_scores(self.key(hidden_states))  <span class="hljs-comment"># [batch, num_head, seqlen_key, hidden//num_head]</span><br>    value_layer = self.transpose_for_scores(self.value(hidden_states))<br>    query_layer = self.transpose_for_scores(mixed_query_layer) <span class="hljs-comment"># [batch, num_head, seqlen_query, hidden//num_head]</span><br><br>    <span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>    attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))  <span class="hljs-comment"># </span><br><br>    <span class="hljs-comment"># 忽略了相对位置编码的处理</span><br><br>    attention_scores = attention_scores / math.sqrt(self.attention_head_size)<br>    <span class="hljs-keyword">if</span> attention_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span><br>        attention_scores = attention_scores + attention_mask<br><br>    <span class="hljs-comment"># Normalize the attention scores to probabilities.</span><br>    attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># This is actually dropping out entire tokens to attend to, which might</span><br>    <span class="hljs-comment"># seem a bit unusual, but is taken from the original Transformer paper.</span><br>    attention_probs = self.dropout(attention_probs)<br><br>    <span class="hljs-comment"># Mask heads if we want to</span><br>    <span class="hljs-keyword">if</span> head_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        attention_probs = attention_probs * head_mask<br><br>    context_layer = torch.matmul(attention_probs, value_layer)  <span class="hljs-comment"># [batch, num_head, seqlen, hidden//num_head]</span><br><br>    context_layer = context_layer.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).contiguous()<br>    new_context_layer_shape = context_layer.size()[:-<span class="hljs-number">2</span>] + (self.all_head_size,)<br>    context_layer = context_layer.view(new_context_layer_shape)<br><br>    outputs = (context_layer, attention_probs) <span class="hljs-keyword">if</span> output_attentions <span class="hljs-keyword">else</span> (context_layer,)<br><br>    <span class="hljs-comment"># 忽略了is_decoder部分</span><br>    <br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>上面贴出来的这段代码省略了针对<code>is_cross_attention</code>（即encoder-decoder attention那个部分的一些处理），此外还忽略了<code>if self.is_decoder:</code>部分的处理，并且忽略了<code>if self.position_embedding_type == &quot;relative_key&quot; </code>相对位置编码部分的处理；</p><p>step1：首先是这个部分，hidden_states**[batch, seq_len, hidden_size]<strong>这个tensor过了self.query、self.value、self.key三个linear矩阵，由于这三个linear一般不改变hidden_size，这样得到的是三个</strong>[batch, seq_len, hidden_size]<strong>形状的tensor，通过上面提到的transpose_for_scores进行reshape，得到三个</strong>[batch, head_num, seq_len, attention_head_size]**（一般可以是[1, 12, seq_len, 768]）这样的tensor，并且被命名为key_layer、value_layer、query_layer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mixed_query_layer = self.query(hidden_states)<br>key_layer = self.transpose_for_scores(self.key(hidden_states))<br>value_layer = self.transpose_for_scores(self.value(hidden_states))<br>query_layer = self.transpose_for_scores(mixed_query_layer)<br></code></pre></td></tr></table></figure><p>step2：这里就是Q·K^T那个部分了，转置就是在后两个维度上转置，输出的attention_scores是**[batch, head_num, seq_len, seq_len]**形状的tensor，代表query中每个位置处对key全局所有的注意力（后面要过softmax）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>step3：依照博客简单理解一下不同的positional_embedding_type，<font color="blue">这个部分暂时忽略了</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">absolute：默认值，这部分就不用处理；<br>relative_key：对key_layer作处理，将其与这里的positional_embedding和key矩阵相乘作为key相关的位置编码；<br>relative_key_query：对key和value都进行相乘以作为位置编码。<br></code></pre></td></tr></table></figure><p>step4：计算attention_scores，attention_probs；attention_scores在计算query和key的点乘后除以根号下d_k，<strong>注意这里的self.attention_head_size是64那个地方的，也就是分成12个头后每个头的hidden_size</strong>，如果带有attention_mask的话<font color="red">（注意，一般来说肯定是会有atttention_mask的，应该会在调用这个BertAttention的时候传给他，因为一个batch中大家不等长，肯定要通过mask padding到512这种感觉的）</font> ；；在计算attention_scores时候用的是加法，因为softmax那块要一个很大的负数，比如-1e9这样的，然后过softmax，注意softmax的维度是-1代表query中每个token对所有key位置处的token的attention；；；最后过一个self.dropout，<font color="red">TODO：暂时有点没理解为什么在这里过dropout，而不是乘了之后</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br><br><span class="hljs-comment"># 忽略了相对位置编码的处理</span><br><br>attention_scores = attention_scores / math.sqrt(self.attention_head_size)<br><span class="hljs-keyword">if</span> attention_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span><br>    attention_scores = attention_scores + attention_mask<br><br><span class="hljs-comment"># Normalize the attention scores to probabilities.</span><br>attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># This is actually dropping out entire tokens to attend to, which might</span><br><span class="hljs-comment"># seem a bit unusual, but is taken from the original Transformer paper.</span><br>attention_probs = self.dropout(attention_probs)<br></code></pre></td></tr></table></figure><p>step5：这里主要就是输出整合了，再reshape回去，变成了**[batch, seq_len, hidden_size]**的这个形状，另外看到config中output_attentions那个参数的作用，要不要把每层的这个attention返回回去，至此<code>class BertSelfAttention(nn.Module)</code>这个地方的forward结束了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">context_layer = torch.matmul(attention_probs, value_layer)<br><br>context_layer = context_layer.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).contiguous()<br>new_context_layer_shape = context_layer.size()[:-<span class="hljs-number">2</span>] + (self.all_head_size,)<br>context_layer = context_layer.view(new_context_layer_shape)<br><br>outputs = (context_layer, attention_probs) <span class="hljs-keyword">if</span> output_attentions <span class="hljs-keyword">else</span> (context_layer,)<br><span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><h5 id="·class-BertSelfOutput-被BertAttention调用"><a href="#·class-BertSelfOutput-被BertAttention调用" class="headerlink" title="·class BertSelfOutput: 被BertAttention调用"></a>·class BertSelfOutput: 被BertAttention调用</h5><h6 id="1-init-amp-forward"><a href="#1-init-amp-forward" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfOutput</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.hidden_size)<br>        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>        self.dropout = nn.Dropout(config.hidden_dropout_prob)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.dropout(hidden_states)<br>        hidden_states = self.LayerNorm(hidden_states + input_tensor)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>这个地方代码结构是相对比较简单的，<font color="red"><strong>这里也展现出了BERT中存在的一层add&amp;norm操作，这里应该还只是attention这个部分的内容</strong></font> </p><h5 id="·class-BertAttention：被BertLayer调用"><a href="#·class-BertAttention：被BertLayer调用" class="headerlink" title="·class BertAttention：被BertLayer调用"></a>·class BertAttention：被BertLayer调用</h5><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712110214629.png" alt="image-20220712110214629" style="zoom:50%;"><h6 id="1-init-2"><a href="#1-init-2" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.self = BertSelfAttention(config, position_embedding_type=position_embedding_type)<br>        self.output = BertSelfOutput(config)<br>        self.pruned_heads = <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>attention的实现还是不在这里，self.self这个是multi-head self attention机制的实现，self.output的操作是第一个这里完成的部分；</p><p>该层中使用到了<code>self.pruned_heads = set()</code>这样一种节约显存的技术，暂时没有了解太深；</p><h6 id="2-forward-2"><a href="#2-forward-2" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    self_outputs = self.self(<br>        hidden_states,<br>        attention_mask,<br>        head_mask,<br>        encoder_hidden_states,<br>        encoder_attention_mask,<br>        past_key_value,<br>        output_attentions,<br>    )<br>    attention_output = self.output(self_outputs[<span class="hljs-number">0</span>], hidden_states)<br>    outputs = (attention_output,) + self_outputs[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># add attentions if we output them</span><br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>有了上面的<code>BertSelfAttention</code>和<code>BertSelfOutput</code>后，这个组件就比较好理解了</p><h5 id="·class-BertIntermediate-被BertLayer调用"><a href="#·class-BertIntermediate-被BertLayer调用" class="headerlink" title="·class BertIntermediate: 被BertLayer调用"></a>·class BertIntermediate: 被BertLayer调用</h5><p>在BertAttention这个模块后，还有一个FFNN的操作，这里包含有激活函数；<font color="red">TODO：为什么有些地方需要激活函数，有些地方就不用？像CV那边的话，经常几个层过后就来一个激活，但是这里比如BertAttention里面就没有激活</font> </p><h6 id="1-init-amp-forward-1"><a href="#1-init-amp-forward-1" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertIntermediate</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config.hidden_act, <span class="hljs-built_in">str</span>):<br>            self.intermediate_act_fn = ACT2FN[config.hidden_act]<br>        <span class="hljs-keyword">else</span>:<br>            self.intermediate_act_fn = config.hidden_act<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.intermediate_act_fn(hidden_states)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>这个里面调用了<code>config.hidden_act</code>，在config文件那边的话这个地方是<code>&quot;gelu&quot;</code>，对应的也就是gelu激活函数，整体来看这个层结构还是很简单的，<font color="red">其中注意dense这个层把768转化为一个config.intermediate_size3072了</font> </p><h5 id="·class-BertOutput-被BertLayer调用"><a href="#·class-BertOutput-被BertLayer调用" class="headerlink" title="·class BertOutput: 被BertLayer调用"></a>·class BertOutput: 被BertLayer调用</h5><p><font color="red">注意这里不是BertSelfOutput，刚才那个是中间层的，这个是一个BLOCK的</font> </p><h6 id="1-init-amp-forward-2"><a href="#1-init-amp-forward-2" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertOutput</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)<br>        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>        self.dropout = nn.Dropout(config.hidden_dropout_prob)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.dropout(hidden_states)<br>        hidden_states = self.LayerNorm(hidden_states + input_tensor)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>主要负责的也是一些整合，还有residual的部分，<font color="red">其中注意dense层把intermidiate_size又转化会config.hidden_size了</font> </p><h5 id="·-class-BertLayer-nn-Module-：被BertEncoder调用"><a href="#·-class-BertLayer-nn-Module-：被BertEncoder调用" class="headerlink" title="· class BertLayer(nn.Module)：被BertEncoder调用"></a>· class BertLayer(nn.Module)：被BertEncoder调用</h5><h6 id="1-init-3"><a href="#1-init-3" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.chunk_size_feed_forward = config.chunk_size_feed_forward<br>    self.seq_len_dim = <span class="hljs-number">1</span><br>    self.attention = BertAttention(config)<br>    self.is_decoder = config.is_decoder<br>    self.add_cross_attention = config.add_cross_attention<br>    <span class="hljs-keyword">if</span> self.add_cross_attention:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_decoder:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self&#125;</span> should be used as a decoder model if cross attention is added&quot;</span>)<br>        self.crossattention = BertAttention(config, position_embedding_type=<span class="hljs-string">&quot;absolute&quot;</span>)<br>    self.intermediate = BertIntermediate(config)<br>    self.output = BertOutput(config)<br></code></pre></td></tr></table></figure><p>可以简单理解为，依次调用了BertAttention、BertIntermediate、BertOutput完成了一个BLOCK的操作</p><h6 id="2-forward-3"><a href="#2-forward-3" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    <span class="hljs-comment"># decoder uni-directional self-attention cached key/values tuple is at positions 1,2</span><br>    self_attn_past_key_value = past_key_value[:<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> past_key_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    self_attention_outputs = self.attention(<br>        hidden_states,<br>        attention_mask,<br>        head_mask,<br>        output_attentions=output_attentions,<br>        past_key_value=self_attn_past_key_value,<br>    )<br>    <span class="hljs-comment"># 忽略一些is_decoder的操作</span><br>    <br>    attention_output = self_attention_outputs[<span class="hljs-number">0</span>]<br><br>    outputs = self_attention_outputs[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># add self attentions if we output attention weights</span><br><br>    layer_output = apply_chunking_to_forward(<br>        self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output<br>    )<br>    outputs = (layer_output,) + outputs<br><br>    <span class="hljs-comment"># if decoder, return the attn key/values as the last output</span><br>    <span class="hljs-keyword">if</span> self.is_decoder:<br>        outputs = outputs + (present_key_value,)<br><br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>组装起来</p><h5 id="·-class-BertEncoder-nn-Module-层结构"><a href="#·-class-BertEncoder-nn-Module-层结构" class="headerlink" title="· class BertEncoder(nn.Module)层结构"></a>· class BertEncoder(nn.Module)层结构</h5><h6 id="1-init-4"><a href="#1-init-4" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.config = config<br>    self.layer = nn.ModuleList([BertLayer(config) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(config.num_hidden_layers)])<br>    self.gradient_checkpointing = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在这里通过<code>config.num_hidden_layers</code>指定了这个<code>BertLayer</code>结构的层数，进一步详细查看<code>BertLayer</code>层的代码，应该对应的就是Transformer架构中如图所示的N×这个部分</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712093703201.png" alt="image-20220712093703201" style="zoom:50%;"><h6 id="2-forward-4"><a href="#2-forward-4" class="headerlink" title="2) forward"></a>2) forward</h6><p>主要是把N个Layer串接起来forward，返回值封装了一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_outputs.py</span><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModelOutputWithPastAndCrossAttentions</span>(<span class="hljs-title class_ inherited__">ModelOutput</span>):<br></code></pre></td></tr></table></figure><h5 id="·-class-BertPooler："><a href="#·-class-BertPooler：" class="headerlink" title="· class BertPooler："></a>· class BertPooler：</h5><p>这个主要是针对[CLS]token又过了一个pooler</p><p>禁用的话：bertmodel初始化有一个配置add_pooling_layer默认为True，改成false就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertPooler</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.hidden_size)<br>        self.activation = nn.Tanh()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:<br>        <span class="hljs-comment"># We &quot;pool&quot; the model by simply taking the hidden state corresponding</span><br>        <span class="hljs-comment"># to the first token.</span><br>        first_token_tensor = hidden_states[:, <span class="hljs-number">0</span>]<br>        pooled_output = self.dense(first_token_tensor)<br>        pooled_output = self.activation(pooled_output)<br>        <span class="hljs-keyword">return</span> pooled_output<br></code></pre></td></tr></table></figure><p><font color="red">TODO：这里还有些内容不是很明白，待和zkh讨论，比如说为什么叫pool，然后[CLS]这个token为什么要做这些的操作</font> </p><h5 id="·-class-BertModel-各层组合在一起整体的说明"><a href="#·-class-BertModel-各层组合在一起整体的说明" class="headerlink" title="· class BertModel(): 各层组合在一起整体的说明"></a>· class BertModel(): 各层组合在一起整体的说明</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertModel</span>(<span class="hljs-title class_ inherited__">BertPreTrainedModel</span>):<br>embedding_output = self.embeddings(<br>    input_ids=input_ids,<br>    position_ids=position_ids,<br>    token_type_ids=token_type_ids,<br>    inputs_embeds=inputs_embeds,<br>    past_key_values_length=past_key_values_length,<br>)<br>encoder_outputs = self.encoder(<br>    embedding_output,<br>    attention_mask=extended_attention_mask,<br>    head_mask=head_mask,<br>    encoder_hidden_states=encoder_hidden_states,<br>    encoder_attention_mask=encoder_extended_attention_mask,<br>    past_key_values=past_key_values,<br>    use_cache=use_cache,<br>    output_attentions=output_attentions,<br>    output_hidden_states=output_hidden_states,<br>    return_dict=return_dict,<br>)<br>sequence_output = encoder_outputs[<span class="hljs-number">0</span>]<br>pooled_output = self.pooler(sequence_output) <span class="hljs-keyword">if</span> self.pooler <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>重点代码感觉在这个部分，其他部分在制作一些mask类的地方</p><h4 id="2-2-2-model-state-dict"><a href="#2-2-2-model-state-dict" class="headerlink" title="2.2.2 model.state_dict()"></a>2.2.2 model.state_dict()</h4><h5 id="·-加载预训练model"><a href="#·-加载预训练model" class="headerlink" title="· 加载预训练model"></a>· 加载预训练model</h5><p><font color="red">这里加载的时候应该是用到了config.json文件和pytorch_model.bin这两个文件，而vocab.txt应该是tokenizer.from_pretrained()时候用到的，这里详细看一下config.json文件和pytorch_model.bin这两个文件是怎么被用到的</font> </p><p>在加载模型后，可以通过打印<code>model.state_dict()</code>调试看到模型的各个参数，这里因为是from_pretrained的，所以已经加载了pytorch_model.bin文件中的内容，而且每次加载出来的结果也都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预训练版本</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br>config = BertConfig()<br>model = BertModel.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711141124709.png" alt="image-20220711141124709"></p><p>加载model，也就是<code>BertModel.from_pretrained(pretrained_model_name_or_path)</code>对应的函数在如下路径，<strong>这个地方只要是bert的模型结构，不管是bert-base还是bert-large</strong>是都可以通过这里加载的，主要就是读取对应的<strong>config.json文件和pytorch_model.bin这两个文件</strong>：</p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;modeling_utils.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Optional</span>[<span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike]], *model_args, **kwargs</span>):<br></code></pre></td></tr></table></figure><h6 id="1-注解说明"><a href="#1-注解说明" class="headerlink" title="1) 注解说明"></a>1) 注解说明</h6><ul><li><p>从预训练的模型配置中实例化预训练的pytorch模型，该模型默认使用 <code>model.eval()</code>设置为评估模式；</p><p><font color="red">和同学讨论后补充：model.eval()一般涉及到dropout层与normalization层；；；在BERT和这种NLP领域下，因为BN不怎么用，所以LN实际上只是单个样本内部在seq_len这个维度上做norm，就不涉及到eval这块了，也就是说在NLP任务的eval这里可能只影响到dropout层；</font> </p><p><font color="red">再补充一些BN上的细节，BN在做训练的时候，均值和方差来自于这一组batch的计算，在inference的时候，使用<strong>全局</strong>的均值和方差，这个全局的均值和方差由之前的每个mini-batch记录而来。</font> </p><p><font color="red">设是[batch, seq_len, hidden]，那么BN会计算出来一个[1, seq_len, hidden]的均值；；；LN就会计算出来一个[batch, 1, hidden]的均值，然后怎么怎么处理</font> </p></li><li><p>输出的警告<code>Weights from XXX not initialized from pretrained model</code>表示XXX部分的权重没有出现，将使用模型其余部分进行训练，可以通过下游任务来微调这些权重：</p><p>如果把config文件的层数增加，比如从12层增加到14层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of BertModel were not initialized from the model checkpoint at .&#x2F;bert_base_uncased and are newly initialized: [‘bert.encoder.layer.13.attention.output.dense.weight’, ‘bert.encoder.layer.12.intermediate.dense.bias’, ‘bert.encoder.layer.13.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.dense.bias’, ‘bert.encoder.layer.13.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.weight’, ‘bert.encoder.layer.13.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.13.output.dense.bias’, ‘bert.encoder.layer.13.intermediate.dense.bias’, ‘bert.encoder.layer.13.output.LayerNorm.bias’, ‘bert.encoder.layer.13.output.dense.weight’, ‘bert.encoder.layer.12.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.bias’, ‘bert.encoder.layer.13.output.LayerNorm.weight’, ‘bert.encoder.layer.12.output.LayerNorm.weight’, ‘bert.encoder.layer.13.attention.self.query.bias’, ‘bert.encoder.layer.13.attention.self.query.weight’, ‘bert.encoder.layer.12.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.12.attention.output.dense.bias’, ‘bert.encoder.layer.12.attention.self.key.bias’, ‘bert.encoder.layer.12.output.dense.weight’, ‘bert.encoder.layer.12.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.13.intermediate.dense.weight’, ‘bert.encoder.layer.12.output.LayerNorm.bias’, ‘bert.encoder.layer.13.attention.self.key.bias’, ‘bert.encoder.layer.12.intermediate.dense.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.12.output.dense.bias’, ‘bert.encoder.layer.12.attention.output.dense.weight’]</p></blockquote></li><li><p>输出的警告<code>Weights from XXX not used in YYY</code>表示预训练文件中的层XXX不被YYY使用，因此那些权重将被丢弃；</p><p>如果把config文件的层数减少，比如从12层减小到10层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of the model checkpoint at .&#x2F;bert_base_uncased were not used when initializing BertModel: [‘bert.encoder.layer.10.intermediate.dense.weight’, ‘cls.predictions.decoder.weight’, ‘cls.predictions.transform.dense.bias’, ‘bert.encoder.layer.11.attention.self.value.bias’, ‘bert.encoder.layer.11.attention.output.dense.bias’, ‘bert.encoder.layer.10.output.dense.bias’, ‘bert.encoder.layer.10.attention.self.key.bias’, ‘bert.encoder.layer.10.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.value.weight’, ‘bert.encoder.layer.11.attention.self.key.bias’, ‘bert.encoder.layer.11.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.LayerNorm.bias’, ‘bert.encoder.layer.11.output.dense.bias’, ‘cls.predictions.transform.LayerNorm.weight’, ‘bert.encoder.layer.10.attention.output.dense.bias’, ‘cls.seq_relationship.bias’, ‘bert.encoder.layer.10.attention.self.value.bias’, ‘bert.encoder.layer.10.attention.output.dense.weight’, ‘cls.predictions.bias’, ‘bert.encoder.layer.10.attention.self.query.weight’, ‘bert.encoder.layer.11.attention.self.query.bias’, ‘cls.predictions.transform.LayerNorm.bias’, ‘bert.encoder.layer.11.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.query.bias’, ‘cls.predictions.transform.dense.weight’, ‘bert.encoder.layer.10.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.dense.weight’, ‘bert.encoder.layer.11.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.self.query.weight’, ‘cls.seq_relationship.weight’, ‘bert.encoder.layer.11.attention.self.value.weight’, ‘bert.encoder.layer.11.intermediate.dense.weight’, ‘bert.encoder.layer.10.output.LayerNorm.weight’, ‘bert.encoder.layer.11.attention.output.dense.weight’, ‘bert.encoder.layer.10.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.dense.weight’, ‘bert.encoder.layer.11.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.output.LayerNorm.weight’]</p></blockquote><p>这里额外输出了几个<code>cls.xxx</code>，就是说没有使用这些检查点的权重，从一些解释来看这些内容应该是要被下游分类器用到的，这些内容将被初始化重新训练。目前代码里只是直接简单应用了这个的输出，而没有针对下游任务fine-tune那些的过程；</p></li></ul><h6 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2) 参数说明"></a>2) 参数说明</h6><ul><li><p><code> pretrained_model_name_or_path (`str` or `os.PathLike`, *optional*)</code></p><p>1）可以是一个字符串代表<code>model id</code>，这个model id可以从huggingface.co上获取，比如直接使用<code>bert-base-uncased</code>，或者使用带有用户名称的这个model id例如<code>hfl/chinese-macbert-base</code>，这种使用方法下可能会从huggingface那边完成下载；</p><p>2）可以是一个包含有pytorch_model.bin和config.json文件的路径，例如<code>./bert_base_uncased/</code>，注意这个目录下的内容需要通过<code>PreTrainedModel.save_pretrained</code>方法来得到，否则保存出来的文件可能和transformer（huggingface这一套）不太配合；</p><p>3）其余用法不太常见或者一般不使用，好像可以从tensorflow和flax的checkpoint进行加载，如果设置为None的话就是通过其他办法已经把config和state_dict给加载进去了；</p></li><li><p><code>output_attentions</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code></p><p>这是一个可能相对再常用一点的参数，模型输出的output包含了一个<code>output[&#39;attentions&#39;]</code>的参数输出，在调试的时候发现他是一个长度为12的tuple（这里的长度12是bert的层数），tuple中每个位置上是 <code>shape[1,12, seq_len, seq_len]</code>（这里的长度12应该是multi-head的头数目），output_attentions应该是 <code>softmax((query · key)/sqrt(d_k))</code>的结果；注意<code>shape[1,12, seq_len, seq_len]</code>这个地方，softmax应该是在-1dim上做的，代表<strong>query中的每个位置处，对于每一个key的attention score</strong>，所以来做求和的话，应该能得到一个1的结果；</p><p><font color="red">在后面看forward代码的时候，还要回来看一下这个地方</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711172228802.png" alt="image-20220711172228802"></p></li><li><p><code>hidden_states</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;, output_hidden_states=True)</code></p><p>这是中间层（隐层）tensor的output输出，<font color="red">和output_attentions一样，这些内容既可以在from_pretrained中给带过去，<strong>也可以直接写在config.json</strong>文件里</font></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711173534108.png" alt="image-20220711173534108"></p></li><li><p>上面可能是一些相对常用的参数，暂时理解来说在<code>.from_pretrained(&quot;./bert_base_uncased&quot;)</code>这个方法中带的其他一些参数可以和config加参数起到同样的效果，也就证明这个方法用到了config.json这个文件</p></li></ul><h6 id="3-内部流程说明（※重点）"><a href="#3-内部流程说明（※重点）" class="headerlink" title="3) 内部流程说明（※重点）"></a>3) 内部流程说明（※重点）</h6><p>内部这个地方还是写的比较详细的，像各种Exception也都实现的非常完整，大概理解一下其中的重点部分，主要目标就是加载config.json和pytorch_model.bin两个文件。</p><p><font color="red"><strong>config.json和pytorch_model.bin应该只有model这边用到，tokenizer那边只用到vocab.txt；；从model.from_pretrained接收参数是一个路径，而tokenizer.from_pretrained接收参数是一个vocab.txt文件的路径或者上级路径感觉也能证明这一点</strong></font> </p><ul><li><p>首先加载config.json</p><p>在下面这段代码中，config_path加载到了pretrained_model_name_or_path中的内容，也就是<code>&quot;./bert_base_uncased&quot;</code>，向下层<code>cls.config_class.from_pretrained</code>传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-comment"># Load config if we don&#x27;t provide a configuration</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(config, PretrainedConfig):<br>    config_path = config <span class="hljs-keyword">if</span> config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> pretrained_model_name_or_path<br>    config, model_kwargs = cls.config_class.from_pretrained(<br>        config_path,<br>        cache_dir=cache_dir,<br>        return_unused_kwargs=<span class="hljs-literal">True</span>,<br>        force_download=force_download,<br>        resume_download=resume_download,<br>        proxies=proxies,<br>        local_files_only=local_files_only,<br>        use_auth_token=use_auth_token,<br>        revision=revision,<br>        _from_auto=from_auto_class,<br>        _from_pipeline=from_pipeline,<br>        **kwargs,<br>    )<br><span class="hljs-keyword">else</span>:<br>    model_kwargs = kwargs<br></code></pre></td></tr></table></figure><p>这里debug调试了一下<code>cls.config_class</code>：<code>&lt;class &#39;transformers.models.bert.configuration_bert.BertConfig&#39;&gt;</code>，于是在去看<code>BertConfig</code>这块的<code>.from_pretrained</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike], **kwargs</span>) -&gt; <span class="hljs-string">&quot;PretrainedConfig&quot;</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    一些注释，为了放在md里暂时删除了</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;model_type&quot;</span> <span class="hljs-keyword">in</span> config_dict <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&quot;model_type&quot;</span>) <span class="hljs-keyword">and</span> config_dict[<span class="hljs-string">&quot;model_type&quot;</span>] != cls.model_type:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;You are using a model of type <span class="hljs-subst">&#123;config_dict[<span class="hljs-string">&#x27;model_type&#x27;</span>]&#125;</span> to instantiate a model of type &quot;</span><br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;cls.model_type&#125;</span>. This is not supported for all configurations of models and can yield errors.&quot;</span><br>        )<br><br>    <span class="hljs-keyword">return</span> cls.from_dict(config_dict, **kwargs)<br></code></pre></td></tr></table></figure><p>在往下看，调用了<code>cls.get_config_dict</code>这个函数，最后一路往下找，直到找到这里，加载json文件，返回一个dict对象，在上面那段代码里最后return了一个<code>cls.from_dict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_dict_from_json_file</span>(<span class="hljs-params">cls, json_file: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike]</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(json_file, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> reader:<br>        text = reader.read()<br>    <span class="hljs-keyword">return</span> json.loads(text)<br></code></pre></td></tr></table></figure><p>看了一下<code>cls.from_dict</code>，应该是这里最终返回了一个BertConfig类的对象，<font color="red">这里字典前面加两个*号是将字典解开成为独立的元素作为形参</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711232228890.png" alt="image-20220711232228890" style="zoom:50%;"></li><li><p>其次加载pytorch_model.bin文件</p><p>通过在<code>config_path</code>目录下寻找文件，命中了<code>pytorch_model.bin</code>这个pytorch的checkpoint文件</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711224750910.png" alt="image-20220711224750910"></p><p>找到这个文件后，这里做了一个和cache判断的操作，这个和huggingface这里实现可以到远程下载有关，如果过了这个函数后还是本地的路径，那就说明是用的本地的文件实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-comment"># Load from URL or cache if already cached</span><br>resolved_archive_file = cached_path(<br>    archive_file,<br>    cache_dir=cache_dir,<br>    force_download=force_download,<br>    proxies=proxies,<br>    resume_download=resume_download,<br>    local_files_only=local_files_only,<br>    use_auth_token=use_auth_token,<br>    user_agent=user_agent,<br>)<br></code></pre></td></tr></table></figure><p>因为是pytorch形式的checkpoint，在这里<code>load_state_dict()</code></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711233904281.png" alt="image-20220711233904281"></p><p>把<code>state_dict</code>传入这里，进一步进行处理，这里返回就会有<code>missing unexpect</code>这些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-keyword">elif</span> from_pt:<br>    <span class="hljs-keyword">if</span> low_cpu_mem_usage:<br>        cls._load_pretrained_model_low_mem(model, loaded_state_dict_keys, resolved_archive_file)<br>    <span class="hljs-keyword">else</span>:<br>        model, missing_keys, unexpected_keys, mismatched_keys, error_msgs = cls._load_pretrained_model(<br>            model,<br>            state_dict,<br>            resolved_archive_file,<br>            pretrained_model_name_or_path,<br>            ignore_mismatched_sizes=ignore_mismatched_sizes,<br>            sharded_metadata=sharded_metadata,<br>            _fast_init=_fast_init,<br>        )<br></code></pre></td></tr></table></figure><p>在如下函数中完成比对操作，<strong>这里一些的输出错误经过<code>state_dict</code>的比对而发现，也就对应了“2.2.2节中，加载预训练model中第一部分，作者在开头给出的注解说明”</strong>，至此这两个文件</p><p><font color="blue"></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_load_pretrained_model</span>(<span class="hljs-params"></span><br><span class="hljs-params">    cls,</span><br><span class="hljs-params">    model,</span><br><span class="hljs-params">    state_dict,</span><br><span class="hljs-params">    resolved_archive_file,</span><br><span class="hljs-params">    pretrained_model_name_or_path,</span><br><span class="hljs-params">    ignore_mismatched_sizes=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">    sharded_metadata=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    _fast_init=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params"></span>):<br>    <span class="hljs-comment"># Retrieve missing &amp; unexpected_keys</span><br>    model_state_dict = model.state_dict()<br>    expected_keys = <span class="hljs-built_in">list</span>(model_state_dict.keys())<br>    loaded_keys = <span class="hljs-built_in">list</span>(state_dict.keys()) <span class="hljs-keyword">if</span> state_dict <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> sharded_metadata[<span class="hljs-string">&quot;all_checkpoint_keys&quot;</span>]<br>    prefix = model.base_model_prefix<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fix_key</span>(<span class="hljs-params">key</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;beta&quot;</span> <span class="hljs-keyword">in</span> key:<br>            <span class="hljs-keyword">return</span> key.replace(<span class="hljs-string">&quot;beta&quot;</span>, <span class="hljs-string">&quot;bias&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;gamma&quot;</span> <span class="hljs-keyword">in</span> key:<br>            <span class="hljs-keyword">return</span> key.replace(<span class="hljs-string">&quot;gamma&quot;</span>, <span class="hljs-string">&quot;weight&quot;</span>)<br>        <span class="hljs-keyword">return</span> key<br><br>    loaded_keys = [_fix_key(key) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> loaded_keys]<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prefix) &gt; <span class="hljs-number">0</span>:<br>        has_prefix_module = <span class="hljs-built_in">any</span>(s.startswith(prefix) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> loaded_keys)<br>        expects_prefix_module = <span class="hljs-built_in">any</span>(s.startswith(prefix) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys)<br>    <span class="hljs-keyword">else</span>:<br>        has_prefix_module = <span class="hljs-literal">False</span><br>        expects_prefix_module = <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># key re-naming operations are never done on the keys</span><br>    <span class="hljs-comment"># that are loaded, but always on the keys of the newly initialized model</span><br>    remove_prefix_from_model = <span class="hljs-keyword">not</span> has_prefix_module <span class="hljs-keyword">and</span> expects_prefix_module<br>    add_prefix_to_model = has_prefix_module <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> expects_prefix_module<br><br>    <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>        expected_keys_not_prefixed = [s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s.startswith(prefix)]<br>        expected_keys = [<span class="hljs-string">&quot;.&quot;</span>.join(s.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:]) <span class="hljs-keyword">if</span> s.startswith(prefix) <span class="hljs-keyword">else</span> s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys]<br>    <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>        expected_keys = [<span class="hljs-string">&quot;.&quot;</span>.join([prefix, s]) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys]<br><br>    missing_keys = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(expected_keys) - <span class="hljs-built_in">set</span>(loaded_keys))<br>    unexpected_keys = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(loaded_keys) - <span class="hljs-built_in">set</span>(expected_keys))<br><br>    <span class="hljs-comment"># Some models may have keys that are not in the state by design, removing them before needlessly warning</span><br>    <span class="hljs-comment"># the user.</span><br>    <span class="hljs-keyword">if</span> cls._keys_to_ignore_on_load_missing <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> pat <span class="hljs-keyword">in</span> cls._keys_to_ignore_on_load_missing:<br>            missing_keys = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> missing_keys <span class="hljs-keyword">if</span> re.search(pat, k) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-keyword">if</span> cls._keys_to_ignore_on_load_unexpected <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> pat <span class="hljs-keyword">in</span> cls._keys_to_ignore_on_load_unexpected:<br>            unexpected_keys = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> unexpected_keys <span class="hljs-keyword">if</span> re.search(pat, k) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-keyword">if</span> _fast_init:<br>        <span class="hljs-comment"># retrieve unintialized modules and initialize</span><br>        uninitialized_modules = model.retrieve_modules_from_names(<br>            missing_keys, add_prefix=add_prefix_to_model, remove_prefix=remove_prefix_from_model<br>        )<br>        <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> uninitialized_modules:<br>            model._init_weights(module)<br><br>    <span class="hljs-comment"># Make sure we are able to load base models as well as derived models (with heads)</span><br>    start_prefix = <span class="hljs-string">&quot;&quot;</span><br>    model_to_load = model<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cls.base_model_prefix) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(model, cls.base_model_prefix) <span class="hljs-keyword">and</span> has_prefix_module:<br>        start_prefix = cls.base_model_prefix + <span class="hljs-string">&quot;.&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cls.base_model_prefix) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(model, cls.base_model_prefix) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> has_prefix_module:<br>        model_to_load = <span class="hljs-built_in">getattr</span>(model, cls.base_model_prefix)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(key <span class="hljs-keyword">in</span> expected_keys_not_prefixed <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> loaded_keys):<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">&quot;The state dictionary of the model you are training to load is corrupted. Are you sure it was &quot;</span><br>                <span class="hljs-string">&quot;properly saved?&quot;</span><br>            )<br><br>    <span class="hljs-keyword">if</span> state_dict <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Whole checkpoint</span><br>        mismatched_keys = []<br>        <span class="hljs-keyword">if</span> ignore_mismatched_sizes:<br>            <span class="hljs-keyword">for</span> checkpoint_key <span class="hljs-keyword">in</span> loaded_keys:<br>                model_key = checkpoint_key<br>                <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>                    <span class="hljs-comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span><br>                    model_key = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prefix&#125;</span>.<span class="hljs-subst">&#123;checkpoint_key&#125;</span>&quot;</span><br>                <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>                    <span class="hljs-comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span><br>                    model_key = <span class="hljs-string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:])<br><br>                <span class="hljs-keyword">if</span> (<br>                    model_key <span class="hljs-keyword">in</span> model_state_dict<br>                    <span class="hljs-keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape<br>                ):<br>                    mismatched_keys.append(<br>                        (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)<br>                    )<br>                    <span class="hljs-keyword">del</span> state_dict[checkpoint_key]<br><br>        error_msgs = _load_state_dict_into_model(model_to_load, state_dict, start_prefix)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># Sharded checkpoint</span><br>        <span class="hljs-comment"># This should always be a list but, just to be sure.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(resolved_archive_file, <span class="hljs-built_in">list</span>):<br>            resolved_archive_file = [resolved_archive_file]<br><br>        error_msgs = []<br>        <span class="hljs-keyword">for</span> shard_file <span class="hljs-keyword">in</span> resolved_archive_file:<br>            state_dict = load_state_dict(shard_file)<br>            <span class="hljs-comment"># Mistmatched keys contains tuples key/shape1/shape2 of weights in the checkpoint that have a shape not</span><br>            <span class="hljs-comment"># matching the weights in the model.</span><br>            mismatched_keys = []<br>            <span class="hljs-keyword">if</span> ignore_mismatched_sizes:<br>                <span class="hljs-keyword">for</span> checkpoint_key <span class="hljs-keyword">in</span> loaded_keys:<br>                    model_key = checkpoint_key<br>                    <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>                        <span class="hljs-comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span><br>                        model_key = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prefix&#125;</span>.<span class="hljs-subst">&#123;checkpoint_key&#125;</span>&quot;</span><br>                    <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>                        <span class="hljs-comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span><br>                        model_key = <span class="hljs-string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:])<br><br>                    <span class="hljs-keyword">if</span> (<br>                        model_key <span class="hljs-keyword">in</span> model_state_dict<br>                        <span class="hljs-keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape<br>                    ):<br>                        mismatched_keys.append(<br>                            (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)<br>                        )<br>                        <span class="hljs-keyword">del</span> state_dict[checkpoint_key]<br><br>            error_msgs += _load_state_dict_into_model(model_to_load, state_dict, start_prefix)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(error_msgs) &gt; <span class="hljs-number">0</span>:<br>        error_msg = <span class="hljs-string">&quot;\n\t&quot;</span>.join(error_msgs)<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Error(s) in loading state_dict for <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>:\n\t<span class="hljs-subst">&#123;error_msg&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(unexpected_keys) &gt; <span class="hljs-number">0</span>:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> were not used when &quot;</span><br>            <span class="hljs-string">f&quot;initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>: <span class="hljs-subst">&#123;unexpected_keys&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;- This IS expected if you are initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model trained on another task &quot;</span><br>            <span class="hljs-string">f&quot;or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).\n&quot;</span><br>            <span class="hljs-string">f&quot;- This IS NOT expected if you are initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model that you expect &quot;</span><br>            <span class="hljs-string">f&quot;to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).&quot;</span><br>        )<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">f&quot;All model checkpoint weights were used when initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>.\n&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(missing_keys) &gt; <span class="hljs-number">0</span>:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span><br>            <span class="hljs-string">f&quot;and are newly initialized: <span class="hljs-subst">&#123;missing_keys&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span><br>        )<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(mismatched_keys) == <span class="hljs-number">0</span>:<br>        logger.info(<br>            <span class="hljs-string">f&quot;All the weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span>.\n&quot;</span><br>            <span class="hljs-string">f&quot;If your task is similar to the task the model of the checkpoint was trained on, &quot;</span><br>            <span class="hljs-string">f&quot;you can already use <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> for predictions without further training.&quot;</span><br>        )<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mismatched_keys) &gt; <span class="hljs-number">0</span>:<br>        mismatched_warning = <span class="hljs-string">&quot;\n&quot;</span>.join(<br>            [<br>                <span class="hljs-string">f&quot;- <span class="hljs-subst">&#123;key&#125;</span>: found shape <span class="hljs-subst">&#123;shape1&#125;</span> in the checkpoint and <span class="hljs-subst">&#123;shape2&#125;</span> in the model instantiated&quot;</span><br>                <span class="hljs-keyword">for</span> key, shape1, shape2 <span class="hljs-keyword">in</span> mismatched_keys<br>            ]<br>        )<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span><br>            <span class="hljs-string">f&quot;and are newly initialized because the shapes did not match:\n<span class="hljs-subst">&#123;mismatched_warning&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span><br>        )<br><br>    <span class="hljs-keyword">return</span> model, missing_keys, unexpected_keys, mismatched_keys, error_msgs<br></code></pre></td></tr></table></figure></li></ul><h6 id="4-额外补充"><a href="#4-额外补充" class="headerlink" title="4) 额外补充"></a>4) 额外补充</h6><p>应该是这里的实例化把config给model传进去了，于是model需要的key可能少于、或者多于提供给他的key（pytorch_model.bin）,这里是一个<code>super().__init__()</code>，可能是调用到<code>nn.Module</code>这个上层了，然后依据传入的config不知道怎么操作，把层数什么的网络结构给拼上了；<font color="red">另：也有可能是要加载到这个&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;modeling_bert.py里面的BertModel类，这样BertModel类是super代表的上层？</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712001457966.png" alt="image-20220712001457966"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712001307673.png" alt="image-20220712001307673"></p><h5 id="·-通过config加载空模型并设置seed"><a href="#·-通过config加载空模型并设置seed" class="headerlink" title="· 通过config加载空模型并设置seed"></a>· 通过config加载空模型并设置seed</h5><p>如果是没有from_pretrained，而是通过<code>model = BertModel()</code>加载空模型的话，打印会看到初始化的参数，如下所示（另外注意，这种不从预训练文件中读取的话，需要加载config参数）：<br><font color="blue">BertConfig、BertModel、BertTokenizer</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空模型加载版本</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br>config = BertConfig()<br>model = BertModel(config)<br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711141742912.png" alt="image-20220711141742912"></p><p>这里如果再次尝试加载空模型的时候，因为参数是随机初始化的，所以参数初始化结果可能有所不同，如下图所示</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220711142519040.png" alt="image-20220711142519040"></p><p>通过set_seed进行指定，可以保证每次加载空模型时初始化的参数是一样的，set_seed的代码段如下，（实际使用上来说其实不一定需要写成这种函数的方式，直接写个几行就可以）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_seed</span>(<span class="hljs-params">seed</span>):<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)<br>    np.random.seed(seed)<br>    random.seed(seed)<br>    torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><br>setup_seed(<span class="hljs-number">42</span>)  <span class="hljs-comment"># 设置随机数种子</span><br></code></pre></td></tr></table></figure><p><font color="red">这个地方加载config的时候直接用到的是config &#x3D; BertConfig()，也就是BertConfig类中的内容，对这里进行了一下详细的调试，目前的理解是他实现了一个BertConfig类，继承自PretrainedConfig这个大类。平常在fine-tune阶段直接用到的config.json文件应该是从这个BertConfig保存而来的；；；如果要是自己训练的话，可能可以实现一个新的<strong>XxxConfig</strong>类，然后内部把参数什么的都设置为自己想要的，比如层数减少一些什么的</font> </p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;configuration_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertConfig</span>(<span class="hljs-title class_ inherited__">PretrainedConfig</span>):<br>  ...<br>    model_type = <span class="hljs-string">&quot;bert&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        vocab_size=<span class="hljs-number">30522</span>,</span><br><span class="hljs-params">        hidden_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">        num_hidden_layers=<span class="hljs-number">12</span>,</span><br><span class="hljs-params">        num_attention_heads=<span class="hljs-number">12</span>,</span><br><span class="hljs-params">        intermediate_size=<span class="hljs-number">3072</span>,</span><br><span class="hljs-params">        hidden_act=<span class="hljs-string">&quot;gelu&quot;</span>,</span><br><span class="hljs-params">        hidden_dropout_prob=<span class="hljs-number">0.1</span>,</span><br><span class="hljs-params">        attention_probs_dropout_prob=<span class="hljs-number">0.1</span>,</span><br><span class="hljs-params">        max_position_embeddings=<span class="hljs-number">512</span>,</span><br><span class="hljs-params">        type_vocab_size=<span class="hljs-number">2</span>,</span><br><span class="hljs-params">        initializer_range=<span class="hljs-number">0.02</span>,</span><br><span class="hljs-params">        layer_norm_eps=<span class="hljs-number">1e-12</span>,</span><br><span class="hljs-params">        pad_token_id=<span class="hljs-number">0</span>,</span><br><span class="hljs-params">        position_embedding_type=<span class="hljs-string">&quot;absolute&quot;</span>,</span><br><span class="hljs-params">        use_cache=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params">        classifier_dropout=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        **kwargs</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-built_in">super</span>().__init__(pad_token_id=pad_token_id, **kwargs)<br><br>        self.vocab_size = vocab_size<br>        self.hidden_size = hidden_size<br>        self.num_hidden_layers = num_hidden_layers<br>        self.num_attention_heads = num_attention_heads<br>        self.hidden_act = hidden_act<br>        self.intermediate_size = intermediate_size<br>        self.hidden_dropout_prob = hidden_dropout_prob<br>        self.attention_probs_dropout_prob = attention_probs_dropout_prob<br>        self.max_position_embeddings = max_position_embeddings<br>        self.type_vocab_size = type_vocab_size<br>        self.initializer_range = initializer_range<br>        self.layer_norm_eps = layer_norm_eps<br>        self.position_embedding_type = position_embedding_type<br>        self.use_cache = use_cache<br>        self.classifier_dropout = classifier_dropout<br></code></pre></td></tr></table></figure><h5 id="·-保存模型"><a href="#·-保存模型" class="headerlink" title="· 保存模型"></a>· 保存模型</h5><p>通过如下命令可以完成一个模型的保存，这样会在目录下生成<strong>config.json</strong>、<strong>pytorch_model.bin</strong>这两个文件，结合上面的BertConfig，如果有一个自己的模型的话，就可以魔改一下那边的XxxConfig，比如减小一些层数训练什么的，下次通过from_pretrained应该就可以加载回来了；；；这里也要集合下上面那个<strong>加载预训练model</strong>来一起看；；；</p><p><font color="red">或者说，这套BertConfig和<code>from transformers.models.bert import modeling_bert </code>那边的bert模型是对应的，只要修改BertConfig这些参数就可以制作自己的bert了，比如可能有BertTiny，或者其他版本的，都可以通过Bert这边的pipeline来走这样一个流程</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.save_pretrained(<span class="hljs-string">&quot;directory_on_my_computer&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-3-tokenizer"><a href="#2-3-tokenizer" class="headerlink" title="2.3 tokenizer"></a>2.3 tokenizer</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">tokenizer</span> <span class="hljs-operator">=</span> BertTokenizer(<span class="hljs-string">&quot;./bert_base_uncased/vocab.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>tokenizer的from_pretrain在这里</p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;tokenization_utils_base.py</p></blockquote><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712122136461.png" alt="image-20220712122136461"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike], *init_inputs, **kwargs</span>):<br><br>    <span class="hljs-comment"># 这里省略了一些类似于本地没读到就远程下载的操作，绥中得到一个resolved_vocab_files文件向_from_pretrained传递</span><br><br>    <span class="hljs-keyword">return</span> cls._from_pretrained(<br>      resolved_vocab_files,<br>      pretrained_model_name_or_path,<br>      init_configuration,<br>      *init_inputs,<br>      use_auth_token=use_auth_token,<br>      cache_dir=cache_dir,<br>      **kwargs,<br>    )<br></code></pre></td></tr></table></figure><p><font color="red">TODO：这里是不是还有些加入特殊token的操作，曾经在一些论文代码里见过</font> </p><p>tokenizer的作用就是把一句话按照vocab中转成一个id那个感觉，tokenizer.tokenize、tokenizer.convert_tokens_to_ids()和其反向的tokenizer_convert_ids_to_tokens比较常用；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712123154538.png" alt="image-20220712123154538"></p><h2 id="3-Transformer-amp-BERT论文阅读中的重点记录"><a href="#3-Transformer-amp-BERT论文阅读中的重点记录" class="headerlink" title="3. Transformer&amp;BERT论文阅读中的重点记录"></a>3. Transformer&amp;BERT论文阅读中的重点记录</h2><h3 id="3-1-Attention-is-all-you-need"><a href="#3-1-Attention-is-all-you-need" class="headerlink" title="3.1 Attention is all you need"></a>3.1 Attention is all you need</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712214108979.png" alt="image-20220712214108979"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712214133925.png" alt="image-20220712214133925"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712214114211.png" alt="image-20220712214114211"></p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712214155672.png" alt="image-20220712214155672" style="zoom:50%;"><p>就是那个指数，如果有一个特别大的，他softmax算出来就很趋向于1了</p><p>这个现象会随着指数的增大而明显，比如指数是3的时候，就不明显，指数是20的时候就很明显</p><h3 id="3-2-BERT"><a href="#3-2-BERT" class="headerlink" title="3.2 BERT"></a>3.2 BERT</h3><p>TODO</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器连接github与token的配置</title>
    <link href="/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>有时候换了常用的git开发环境，在一个新环境上<code>git clone</code>，<code>git push</code>项目的时候，需要重新输入用户名和密码（token）</p><p>在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存</p><span id="more"></span><h1 id="服务器连接github与token配置"><a href="#服务器连接github与token配置" class="headerlink" title="服务器连接github与token配置"></a>服务器连接github与token配置</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>在github头像 -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens -&gt; Generate new token</p><p>这里生成一个新的token，clone等操作的时候用这个token就可以</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-11-18-16-42-36.png"></p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl-short2021_SCD论文阅读整理</title>
    <link href="/2022/08/17/research/papers/contrastive-learning/acl-short2021_SCD/"/>
    <url>/2022/08/17/research/papers/contrastive-learning/acl-short2021_SCD/</url>
    
    <content type="html"><![CDATA[<h1 id="acl-short2021-SCD论文阅读整理"><a href="#acl-short2021-SCD论文阅读整理" class="headerlink" title="acl-short2021_SCD论文阅读整理"></a>acl-short2021_SCD论文阅读整理</h1><p>SCD: Self-Contrastive Decorrelation for Sentence Embeddings 句子嵌入的自对比去相关</p><p>个人总结文章亮点如下：</p><p>1）考虑到negative pair不好构造，或者说受到一些batch大小的限制，提出来自己过encoder两种不同dropout rate的方法，这两个之间的h（首次embedding那个地方的输出）要在一种相似度监视下远离，而过了projection layer后维度扩充，这些维度两个样本之间似乎又要在一个主对角线上接近一些？</p><p>2）一些指标写的是自己复现的指标，那么后期如果为了和他对比的话，可以用这个来对比？</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>source code: <a href="https://github.com/SAP-samples/acl2022-self-contrastive-decorrelation/%EF%BC%8C%E7%9C%8B%E8%B5%B7%E6%9D%A5%E4%B9%9F%E6%98%AFSimCSE%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E8%BF%87%E6%9D%A5%E7%9A%84%EF%BC%9B">https://github.com/SAP-samples/acl2022-self-contrastive-decorrelation/，看起来也是SimCSE直接修改过来的；</a></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>在本文中，我们提出了自对比去相关（SCD），一种自监督方法。给定一个输入句子，它优化了联合自对比和去相关目标。</p><p><font color="red">这个自对比可以理解，去相关（decorrelation）该怎么理解，可能还要看到method那个章节再看看</font> </p><p>通过利用不同比率的标准dropout实例化所产生的对比学习来促进表征的学习。</p><p>所提出的方法在概念上是简单的，但在经验上是强大的。它在不使用contrasitive pair的情况下，在多个基准上取得了与最先进方法相当的结果。这项研究为<strong>高效的自我监督学习方法开辟了途径</strong>，这些方法比目前的对比性方法更加强大。</p><p><font color="red">这里说的compareable performance，然后又说了efficient，所以要从效率这个方面做一些文章吗？</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>% 第一段</p><p>表征的无监督学习（又称嵌入）是NLP中的一个基本问题，在文献中已经被广泛研究。句子嵌入对许多语言处理应用来说是必不可少的，如机器翻译、情感分析、信息检索和语义搜索。<font color="red">（不仅可以在STS上和别人拼，还可以看下游任务有哪些，然后在下游任务搞一些创新？）</font> 最近，自监督的预训练方案已经成功地应用于Transformer架构的背景下，导致了自然语言处理和理解模式的改变。这里的想法是采用一个辅助任务，在训练期间强制执行一个额外的目标。通常情况下，这需要根据上下文的信息子集来进行预测。在实践中发现，大多数有效的目标是非常简单的。这些pretext task的一些成功例子是掩码语言模型（Masked Language Modeling，MLM）、下句预测（Next Sentence Prediction, NSP）、句子顺序预测（Sentence Order Prediction）等。</p><p>在处理无标签的数据的时候，对比学习是自监督方法中最强大的方法之一。对比性学习的目标是以这样一种方式学习一个嵌入空间，即类似的样本对（positive pair）保持彼此接近。同时，不相似的样本对（即负数对）被远远推开。为此，统一样本的不同扩增视图和不同的样本扩增视图被用作正负对<font color="red">（这里是在说SimCLR的内容）</font> 。这些方法从视觉到文本表征学习的各种任务中显示出令人印象深刻的结果。</p><p>% 第二段</p><p>已经有多种不同的正负对选择技术被提出。举例来说：</p><p>DeCLUTR：将同一文件中的不同跨度作为positive pair；</p><p>CT：对来自两个不同编码器的同一句子的嵌入进行调整；</p><p>CERT：应用回译来创建原始句子的增强表示；</p><p>IS-BERT：使全局和局部特征之间的一致性最大化；</p><p>CLEAR：采用多种句子层面的增强策略来学习一个句子的表述；</p><p>尽管这些方法很简单，但他们需要仔细处理negative pair，依赖大的batch size或者复杂的记忆策略（sophisticated memory strategies）。其中包括memory bank或者定制的挖掘策略来有效的检索负数对。</p><p>特别是在NLP中，”hard negative mining“的努力在无监督的情况下变得特别具有挑战性。增加训练批次的大小或内存库的大小隐含地引入了更多的hard negative样本，同时也带来了大内存需求的沉重负担。</p><p>% 第三段</p><p>在本文中，我们介绍了SCD，一种用于自我监督学习的句子嵌入学习的新算法。与最先进的对比学习方法相比，SCD在基于句子相似性的任务方面取得了相当的性能，<strong>不采用</strong>，例如：明确的对比对。</p><p>相反，为了学习句子表征，所提出的方法对单一样本的增强所施加的自我对比。在这方面，该方法建立在对句子进行足够强的扰动以反应句子的语义变化这一想法之上。然而，目前还不清楚哪种扰动只是对句子进行了轻微的改动，而没有改变语义（positive pair），哪种扰动充分修改了语义，形成了一个负样本。<strong>这种模糊性表现在增强的样本同时具有负面和正面样本的特征</strong><font color="red">（之前一些讨论时候感觉出来的，很难界定什么是negative 什么是 postiive，而且还有一些从句法层面来说的）</font> 。</p><p><font color="purple">这里突然想到之前那个双重否定based那种方法，是一个更强的正例的感觉？</font> </p><p><font color="purple">句法层面的相关性，减弱，而增强语义层面的相关性</font> </p><p>为了适应这一点，我们提出了一个由两个对立项组成的目标函数，它作用与一个样本的增强pair：</p><ul><li><p>i）自相背离（排斥）</p></li><li><p>ii）特征相关性（吸引）</p></li></ul><p>第一个term将两个augmentation作为一个negative pair，推开不同的view；<font color="red">这怎么感觉和以前的base想法都不一样了，也可能这里augmentation是一些比较特殊的</font> </p><p>与此相反的是，第二项关注的是作为positive pair的增量。因此，它最大限度的提高了同一特征在各视图中的相关性，学习了对增强的不变性；</p><p>考虑到目标的对立性，将他们整合到一个联合损失中会产生一个最小-最大优化方案。所提出的方案通过将表征学习的目标设定为吸引-排斥的权衡来避免退化的嵌入。同时，他还能学习改善表征的语义表达能力。</p><p>由于NLP中扩增的难度，所提出的方法是为批次中的每个样本“即时”产生扩增。为此，通过改变每个样本的dropout rate来产生多个数据增强；<font color="purple">这里终于说到一些方法相关的内容，就是说对同一个样本不同的dropout rate</font> </p><p>我们根据经验观察到，与成对的对比性方法相比，SCD对数据增强的选择更加稳健。我们认为，不依赖对比性的配对是主要原因之一，这一观察在自监督学习的文献中也有体现，与BYOL。虽然其他方法采取不同的增强或不同的模型副本，但我们利用了标准dropout的同一句子的不同输出。</p><p>% 第四段</p><p>与我们的论文最相关的是（SimCSE）。该论文考虑在对比学习的背景下使用dropout作为数据增强。我们的方法的一个关键创新点是，我们使用dropout来创建<strong>自我对比对，这可以作为正向和负向来使用</strong>。最后，我们注意到，我们的模型不同于成对的特征去重或whiting，后者鼓励在一个样本的增强视图之间进行类似的表示，同时尽量减少表示向量中的冗余度。与这些方法相比，一个关键的区别是，它们完全忽略了对比性目标。相比之下，我们的方法考虑到了这一点，<strong>并提供了将自相矛盾的观点同时作为正反两方面的手段。</strong></p><p>% 第五段 </p><p>Contribution被归纳为以下几点：</p><p>1）通过使用不同的dropout来生成句子嵌入；</p><p>2）消除对使用自我对比的负面对的依赖性；<font color="purple">以前方法负面对不一定负面，而这里是一定负面？</font> </p><p>3）为NLP中的非对比性自监督学习提出特征去重目标；</p><p><font color="purple">看完前面还没办法很get到这个motivation</font> </p><h2 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816160610960.png" alt="image-20220816160610960"></p><p>图1：提出方法的示意图（最好以彩色显示）。从一个输入句子（左）开始，通过改变编码器的dropout rate产生两个嵌入。编码器内的斑点表示由于dropout造成的mask。不同的dropout rate和由此产生的嵌入用颜色编码，绿色代表低rate的dropout，橙色代表高的dropout。自我对比的损失函数在embedding上进行（中间部分）。Projector将嵌入映射到一个高维的特征空间，其中的特征是去相关的（右）。<font color="purple">和DiffCSE一样，我觉得很难大概了解到一个作者的motivation是什么</font> </p><p><font color="blue">最右边是个理想情况，要让输出和理想情况比较接近</font> </p><p>% 第一段</p><p>我们的方法依赖于生成样本的两个视图A和B。为此，在嵌入空间为批次$X$中的每个样本$x_i$生成增强。批次是由一个set的sample来创建的，$\mathcal{D}&#x3D;{(x_i)}<em>{i&#x3D;1}^{N}$，其中$ N $代表样本数。数据增强由encoder$f_\theta$完成，其中$\theta$代表参数。编码器的输出是$X$中样本的嵌入，表示为$H^{A}\in\tau$ and $H^{B}\in\tau$。其中$\tau$代表embedding空间。之后，我们使得$h_i\in\tau$表示句子的相关表示。于是，每个 样本产生的增强嵌入被表示为$h</em>{i}^{A}$和$h_{i}^{B}$。</p><p>为了获取不同的嵌入，我们利用一个Transformer语言模型作为编码器，并结合不同的dropout rate。具体来说，一个augmentation基于较高的dropout rate，第一个augmentation基于较低的dropout rate。这就需要在编码阶段采用不同的随机掩码。随机掩码与不同的比率有关，$r_A$和$r_B$，其中$r_A&lt;r_B$。将不同的dropout rate整合到编码器中，我们得到：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816162450758.png" alt="image-20220816162450758" style="zoom:50%;"></p><p>给定嵌入，我们利用联合损失，由两个目标组成：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816162607313.png" alt="image-20220816162607313"></p><p>其中$\alpha \in R$代表一个超参数，$p$代表$\tau\rightarrow\mathcal{P}$是一个由参数$\theta_2$构成的projector MLP层。这里$|P|&gt;&gt;|\tau|$<font color="red">例如在embedding那个层输出是768，那么这里说后面远远大于前边，猜测后面是一个4096这样一个更大的？</font> 。</p><ul><li>$\mathcal{L}<em>S$的目标是增强嵌入的对比度，将嵌入$h</em>{i}^{A}$和$h_{i}^{B}$推远。</li><li>$\mathcal{L}_C$是为了减少冗余，并促进在高维空间中的增量的不变性。</li></ul><p><font color="purple">这里能否从句法层面做一些理解，之前印象里那个句法层面的一些说法还是很有印象的</font> </p><h3 id="2-1-Self-Contrastive-Divergence"><a href="#2-1-Self-Contrastive-Divergence" class="headerlink" title="2.1 Self-Contrastive Divergence"></a>2.1 Self-Contrastive Divergence</h3><p>自对比的差异化</p><p>自我对比试图在他不用dropout之间产生的embedding之间形成对比，因此$\mathcal{L}_s$由批次中的样本的余弦相似度组成，为：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816163817932.png" alt="image-20220816163817932" style="zoom:67%;"><p><font color="blue">平均余弦相似度</font> </p><p><font color="purple">越像，余弦相似度越大，那么loss越大是有问题的；；需要通过学习的梯度反向传播，让两个不同rate的dropout两者比较远离，这样两者余弦相似度更小，loss就越小了；；；</font> </p><p><font color="purple">这里如果说问题的话：首先两个dropout的rate要控制吧，比如我虽然一个大一个小，但是比较接近的时候，我可以用SimCSE那样的，就是说把SimCSE那个结合进来；；但是两个比较远的时候，可以用现在这样的？</font> </p><p><font color="blue">对比学习不一定</font> </p><h3 id="2-2-Feature-Decorrelation"><a href="#2-2-Feature-Decorrelation" class="headerlink" title="2.2 Feature Decorrelation"></a>2.2 Feature Decorrelation</h3><p>特征装饰关系</p><p>$\mathcal{L}_C$试图使嵌入不受增强的影响，同时减少特征中的冗余。为此，嵌入的$h_i$从$\mathcal{T}$向上投射到一个高维空间$\mathcal{P}$。其中进行了去相关性。</p><p>为了避免符号上的混乱，我们使得$p_{i}^{<em>}&#x3D;p(h_{i}^{</em>})$，$*\in{A,B}$。表示应用$p(·)$投影后样本$x_i$的增强嵌入向量。然后从投影嵌入计算出一个相关矩阵。其条目$C_{j,k}$是：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816165510757.png" alt="image-20220816165510757"></p><p><font color="blue">求和里面是每个数据的，然后把32个加起来</font> </p><p>其中$p_{i,j}^{*}\in R$，表示投影嵌入向量中的第j个分量。</p><p><font color="purple">这个公式在这里有些看不懂了，主要在于维度上，这里每个都是什么维度的？如果我认为$h_i$肯定是一个768这样维度的，比如说一个CLStoken，那么我是有i个样本的，每个样本的dim可以是一个4096这样一个更扩了高维的，我的Cjk是第j个样本，在第k个维度（4096中的一个）的一个相似度，暂时只能这么理解了？这个在每个维度（4096上）的相似度室友什么含义的表示吗？</font> </p><p><font color="purple">这里我C的维度，看起来像是一个batch_size*4096，每个样本两种数据增强方法（不同dropout）上的在每个扩增维度$\mathcal{P}$上的相似度</font> </p><p>那么，特征装饰相关的损失目标定义为：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816170803520.png" alt="image-20220816170803520"></p><p><font color="purple">这里自己看公式的时候总觉得维度是对不上的，根据图里来说，我这个Cjk的维度应该是4096×4096的？也就是说我i（batch）那个维度，在前面已经求和过了，这里4096×4096的</font> </p><p><font color="blue">从相似度来看，公式1，认为5% 和 15%反例；；；L_{C}是为了减小高维度的冗余并且促进不变性；；可能是不太关心非对角线，或者说非对角线元素比较多？</font> </p><p><font color="blue">$\lambda$和4096是配套的</font> </p><p>第一个term试图通过沿对角线的交叉相关最大化来实现变量的增加。</p><p>第二个term旨在通过最小化对角线以外的相关性来减少特征表示中的冗余度。</p><p><font color="purple">然后再结合图来尝试理解下这个式子：不清楚为什么前面这一项要加上负号，一些解释上说第一项通过最大化对角线互相关来增强不变性，而第二项最小化对角线之外的相关性来减少冗余；；；；；；很难理解为什么要这么做，另外这里的维护变化也很奇怪，i的维度在式子3上是怎么消掉的？</font> </p><h2 id="3-Experiments-amp-Results"><a href="#3-Experiments-amp-Results" class="headerlink" title="3. Experiments &amp; Results"></a>3. Experiments &amp; Results</h2><h3 id="3-1-Traning-Setup"><a href="#3-1-Traning-Setup" class="headerlink" title="3.1 Traning Setup"></a>3.1 Traning Setup</h3><p>从一个预训练的Transformer LM开始训练。使用HuggingFace中的Bert和Roberta。对于sentence representation，我们使用[CLS]token。相似于SimCSE的，我们从10^6数量级无监督的wikipedia数据集的数据进行训练。MLP那里输出应该是4096的；</p><p>两个dropout的比率大概是$r_{A}&#x3D;5.0%$，$r_{B}&#x3D;15.0%$。（BERT）；$r_{A}&#x3D;6.5%$，$r_{B}&#x3D;24.0%$。（Roberta）</p><p>这些值是通过网格搜索得到的。首先，一个粗略的网格被放置在那里，α的步长为0.1，辍学率rA和rB为10%。对于λ，粗网格包括不同的大小{0.1, 0.01, 0.001}。其次，在一个细网格上，步长分别为0.01和1%。</p><h3 id="3-2-Evaluation-Setup"><a href="#3-2-Evaluation-Setup" class="headerlink" title="3.2 Evaluation Setup"></a>3.2 Evaluation Setup</h3><p>STS tasks and TransferTasks</p><h3 id="3-3-Main-Results"><a href="#3-3-Main-Results" class="headerlink" title="3.3 Main Results"></a>3.3 Main Results</h3><ul><li>STS</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816210036258.png" alt="image-20220816210036258" style="zoom:70%;"><p><font color="purple">只在部分数据集上超过了别人，而且这个地方如果从evaluation的trick来说还是很多的，还有个地方是为什么这里引用的SimCSE的指标这么低啊，这个感觉也是有问题的？</font> </p><ul><li>downstream transfer tasks</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816210501120.png" alt="image-20220816210501120" style="zoom:67%;"><p>这这里也是，作者这个指标引的不太对啊，而且也不是一定比别人好。</p><p><font color="purple">要是在实验用对比的话，可以说指标是这里来的，或者reproduce和他这个指标差不多</font> </p><h3 id="3-4-Analysis"><a href="#3-4-Analysis" class="headerlink" title="3.4 Analysis"></a>3.4 Analysis</h3><h4 id="3-4-1-Ablation-Study"><a href="#3-4-1-Ablation-Study" class="headerlink" title="3.4.1 Ablation Study"></a>3.4.1 Ablation Study</h4><p>这里似乎没说是验证集还是测试集，应该指的是测试集了</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816210739792.png" alt="image-20220816210739792"></p><h4 id="3-4-2-Uniformity-and-Alignment-Analysis"><a href="#3-4-2-Uniformity-and-Alignment-Analysis" class="headerlink" title="3.4.2 Uniformity and Alignment Analysis:"></a>3.4.2 Uniformity and Alignment Analysis:</h4><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220816210918082.png" alt="image-20220816210918082" style="zoom:67%;"><p>uniformity比较好，但是Alignment不太行</p><h2 id="4-Conclusion-amp-Future-Work"><a href="#4-Conclusion-amp-Future-Work" class="headerlink" title="4. Conclusion &amp; Future Work"></a>4. Conclusion &amp; Future Work</h2><p>我们提出了一种自我监督的表征学习方法，它利用了通过dropout获得的增强样本的自我对比度。尽管它很简单，但它在多个基准上取得了与先进技术相当的结果。未来的工作将涉及特定样本的增强，以改善嵌入，特别是表征的一致性。</p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>naacl2022_diffCSE论文阅读整理</title>
    <link href="/2022/08/17/research/papers/contrastive-learning/naacl2022_diffCSE/"/>
    <url>/2022/08/17/research/papers/contrastive-learning/naacl2022_diffCSE/</url>
    
    <content type="html"><![CDATA[<h1 id="naacl2022-diffCSE论文阅读整理"><a href="#naacl2022-diffCSE论文阅读整理" class="headerlink" title="naacl2022_diffCSE论文阅读整理"></a>naacl2022_diffCSE论文阅读整理</h1><p><strong>DiffCSE: Difference-based Contrastive Learning for Sentence Embeddings</strong></p><p>DiffCSE：基于差异的句子嵌入对比性学习，NAACL2022 MIT的文章，相对比较新</p><p>个人总结文章亮点如下：</p><p>1）motivation：SimCSE等研究发现，基于dropout的那种方法相较于同义词替换等等数据增强方法更好，这是不奇怪的。从对比学习的本质来说，虽然对比学习的目标鼓励一句话的表征不受增强转化的影响，但对于输入的直接增强（删除、替换）往往还是会改变句子含义的，也就是说，理想的句子嵌入不应该对这样的嵌入保持不变。<font color="purple">即使是增强的这种替换类的操作，也应该一定程度上改变了句子的embedding表示？；；；作者：对转化敏感，但不一定不变？</font> </p><p>2）在method那块，一方面类似SimCSE的那种两种dropout作为不敏感的变化，另一方面用replaced token decision(rtd)作为敏感的变化，借鉴了CV的内容；</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/503701001%EF%BC%9ADiffCSE%EF%BC%9ADifference-based">https://zhuanlan.zhihu.com/p/503701001：DiffCSE：Difference-based</a> Contrastive Learning for SentenceEmbeddings （NAACL 2022）</li><li>ELECTRA：<a href="https://huggingface.co/google/electra-base-discriminator">https://huggingface.co/google/electra-base-discriminator</a></li><li>他这份代码也是在SimCSE基础上魔改的，<a href="https://github.com/voidism/DiffCSE">https://github.com/voidism/DiffCSE</a></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li>pooler choice对着代码看一下</li><li>讨论为什么work</li><li>discriminator那块是怎么搞的，怎么把h结合进去的？</li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>我们提出DiffCSE，一个用于学习句子嵌入的无监督对比学习框架。DiffCSE学习的句子嵌入对原始句子和编辑过的句子（edited sentence）之间的差异很敏感，其中编辑过的句子是通过随机掩码掉原始句子，然后从掩码过的语言模型中采样得到的。</p><p><font color="red">从这里还不是太明白这个从掩码过的语言模型中采样是什么一种方法，先mask又弄回去的感觉？</font> </p><p>我们表明，DiffSCE是一个等变（equivariant）对比学习的实例（Dangovski等人，2021），它概括了对比学习，并学习了对某些类型的增强不敏感而对其他 “有害”类型的增强敏感的表征。我们的实验表明，<strong>DiffCSE在无监督的句子表征学习方法中取得了最先进的结果，在文本语义相似性任务中，比无监督的SimCSE表现搞出了2.3个绝对的点数。</strong></p><p><font color="red">看这个abstract有些看不懂了，可能还要结合着方法看一看</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>学习通用的句子表征，捕捉丰富的语义信息，同时在广泛的下游NLP任务中表现良好，无需特定任务的微调，是该领域的一个重要的开放性问题。最近的工作表明，通过对比学习对预训练的语言模型进行微调，可以在没有任何标记数据的情况下学习到好的句子嵌入。对比学习在单个数据上使用多种增强方法来构建positive pair，其表征被训练为比negative pair更加相似。</p><p>虽然不同的数据增强（随机裁剪、颜色抖动、旋转等）已被发现对预训练视觉模型至关重要，在应用于句子嵌入的对比学习时，这种增强的方法通常是不成功的。事实上，SimCSE发现，通过简单的基于dropout的扩增来构建positive pair的效果比更复杂的数据增强方法要好得多，比如基于同义词或屏蔽语言模型的词汇删除或替换。事后看来，这也许并不奇怪；虽然对比学习的训练目标鼓励表征不受增强转化的影响，<strong>但对输入的直接增强（如删除、替换）往往会改变句子的含义。也就是说，理想的句子嵌入不应该对这样的转换保持不变。</strong></p><p><font color="red">替换的方法从原理上就有些违背了？</font> </p><p>我们提出去学习句子的表征，他们意识到但不一定是不变的，对于这种直接的表面层面的数据增强。<font color="purple">这句话的原文英文不太好懂，写的也就比较绕：We propose to learn sentence representations<br>that are aware of, but not necessarily invariant to, such direct surface-level augmentations</font> </p><p>这是一个等变对比学习的例子，这通过使用不敏感图像变换（例如灰度）上的对比损失和敏感图像变换上的预测损失（例如旋转）来改进视觉表示学习。我们通过使用基于dropout的噪声作为不敏感转换（如SimCSE）和基于MLM的单词替换作为敏感变换，对句子进行等变对比学习。这导致了基于原始句子和转换句子之间差异的额外交叉熵损失。</p><p><font color="purple">额外的交叉熵损失，L_{RTD}这个之前也有人用过了吧</font> </p><p>我们在7个语义文本相似性任务（STS）和7个来自SentEval（Conneau and Kiela, 2018）的转移任务上进行了实验，发现这种基于差异的学习比标准的对比性学习有很大的改善。我们的DiffCSE方法在STS数据集上比之前最先进的模型SimCSE能实现约2.3%的绝对改善。我们还进行了一系列的消融研究，以证明我们设计的架构是合理的。定性研究和分析也包括对DiffCSE的嵌入空间的研究。</p><h2 id="2-Background-and-Related-Work"><a href="#2-Background-and-Related-Work" class="headerlink" title="2. Background and Related Work"></a>2. Background and Related Work</h2><h3 id="2-1-Learning-Sentence-Embeddings"><a href="#2-1-Learning-Sentence-Embeddings" class="headerlink" title="2.1 Learning Sentence Embeddings"></a>2.1 Learning Sentence Embeddings</h3><p>这里暂时简化了，作者从最开始的SentenceBERT一路说到对比性学习开创性工作SimCLR，最后说到SimCSE。</p><p>最后，SimCSE（Gao等人，2021年）提出了一个极其简单的增强策略，只需切换dropout掩码。虽然简单，<strong>但以这种方式学到的句子嵌入已被证明比其他更复杂的增强方法更好。</strong></p><h3 id="2-2-Equivariant-Contrastive-Learning"><a href="#2-2-Equivariant-Contrastive-Learning" class="headerlink" title="2.2 Equivariant Contrastive Learning"></a>2.2 Equivariant Contrastive Learning</h3><p>DiffCSE的灵感来自于最近计算机视觉中的对比学习的概括，即等价对比学习（Dangovski等人，2021）。我们解释一下这种CV技术如何适应于自然语言。</p><p>了解输入转换<font color="red">（这里自己觉得好像是一些数据增强类的转化？）</font> 对于成功的对比学习至关重要。过去的实证研究揭示了对比性学习的有用转化，比如计算机视觉的随机调整大小的裁剪和颜色抖动，以及NLP的dropout。对比学习鼓励表征对这些转换不敏感，也就是说，编码器被训练成对一组人工选择的转换不敏感。上述CV和NLP的研究也揭示了对对比学习有害的转换。例如，Chen等人（2020）表明，使表征对旋转不敏感会降低ImageNet线性探测的准确性，而Gao等人（2021）表明，使用MLM替换15%的单词会大大降低STS-B的性能。虽然以前的工作只是在对比性预训练中省略了这些转换，但在这里我们认为，我们还是应该通过学习对这些转换敏感（但不一定不变）的表征来利用这些转换；</p><p>敏感性的概念可以由数学中更普遍的等值属性来捕获。让$T$是来自一个group $G$的变换，然后使得$T(x)$代表对于一个sentence$x$的转化。等变性是指在输出特征上存在一个诱导的群组变换$T’$的特性，这个特性的数学表达如下：</p><p>$f(T(x))&#x3D;T’(f(x))$</p><p>在对比性学习的特殊情况下， $T’$的目标是身份转换，我们说$f$被训练成“对$T$不变量”</p><p><font color="purple"><strong>这里作者这个表述一开始没有理解，现在来说的话就是groupG可能代表了多种变化操作，那么我们选择多种变化中的一种T，于是T(x)可以代表对x的一种变化操作的转化；这里从论文的这个公式来说不是很了解，可能要讨论一下；最后这个f被训练成对T不变量，就是说在等值这种情况下，我们的f应该对两种变化输出不变？</strong></font> </p><p>然而，不变性只是等价的一个微不足道的情况，我们可以设计一些训练目标，其中$T’$对某些转换（如MLM）不是同一的，而对其他转换（如dropout）是同一的。Dangovski等人（2021）表明，以这种方式将对比性学习推广到等值，可以提高CV中特征的语义质量，这里我们表明，不变性和等值的互补性延伸到NLP领域。关键的观察点是，<strong>编码器应该基于MLM的扩增具有等价性，而不是不变性</strong>。我们可以通过使用一个条件判断器来操作这一点，该判别器将句子表示与编辑过的句子相结合，然后预测原始句子与编辑过的句子之间的差异。</p><p>这基本是ELECTRA模型的条件版本，该模型通过一个二进制discriminator来检测一个标记是来自原始句子还是来自生成器，从而使编码器与MLM等效。我们假设，用我们的句子编码器的表征来调节ELECTRA模型的一个有用的目标，以鼓励$f$是“等效于MLM”</p><p><font color="red">可能要看过方法后再反过来看看这一段，很多内容可能就理解了</font> </p><p>就我们所知，我们是第一个 观察并强调上述CV和NLP之间的平行关系。特别是，我们表明，等价对比学习超出了CV的范围，它甚至适用于没有代数结构的转换，比如对句子的差异操作。此外，由于NLP中有用的转换的典型集合不如CV中那么确定，DiffCSE可以作为NLP研究者的诊断工具来发现有用的转换。</p><h2 id="3-Difference-based-Contrastive-Learning"><a href="#3-Difference-based-Contrastive-Learning" class="headerlink" title="3. Difference-based Contrastive Learning"></a>3. Difference-based Contrastive Learning</h2><p><font color="red">翻阅的时候发现这个章节长度很短，可能也是一种比较简单即插即用的方法？</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815120722307.png" alt="image-20220815120722307"></p><p><font color="blue">motivation：之前对某些句子修改是不敏感的，文本是离散的每个token稍微改变一下对语义影响都很大。模型对某些特定类型的增强是不敏感的，又对某些伤害了语义的增强的敏感的。x’ x’’有些替换是敏感的，有些是不敏感的，通过discriminator要鉴别一些语义变化敏感的。h的语义要表达出来是有变化的</font> </p><p><font color="blue">左边h作为CLS放过来，h在encoder的映射中会和各个token会交互，起到交互作用了，引导…</font> </p><p><font color="blue">x’’是作为正例了还是负例了？通过多任务学习改善预训练表征，在discriminator这块引入了一个新的；；为什么generator这块要用这样生成的方式来，而不是同义词替换，反义词替换；</font> </p><p><font color="blue">代码simcse和diffcse来对比看，x’’已经出来文本了，在ELECTRA没法同步更新Discriminator和gen；；；；debiased 和simcse；；；右边的替换不当做正例和负例来看，只是看做一个替换RTD，又把左边的这个参与进来了；；；discriminator，我喜欢吃苹果 我爱吃苹果 很难判断出来，对这种不伤害语义的就不敏感</font> </p><p><font color="blue">discriminator，我喜欢吃苹果 我爱吃苹果 很难判断出来，对这种不伤害语义的就不敏感；；x’’是我讨厌吃苹果，左边x是我喜欢吃苹果，cls输入进来后，就容易鉴别出来，cls；；；；多任务，增强了某个点上的表征，文本层面修改上的表征，自适应的敏感&#x2F;不敏感，符合语义</font> </p><p>图1：DiffCSE的图解。左边是一个标准的SimCSE模型，它是用常规的对比损失训练出来的dropout转换模型。右边是一个条件差异预测模型，它将句子向量h作为输入，预测预测x和x’’之间的差异。在测试过程中，我们抛弃了deiscriminator，只使用h作为句子嵌入。</p><p><font color="purple">自己写一下对这个图和为什么是work的理解：右边的discriminator也把h当做输入了，这样在梯度回传上会回传到sentence encoder上，这个h是怎么交互的还要理解，也就是说在一个h的引导下，希望能学习到这个差异？那么这个引导方式需要注意一下，因为之前CLINE那篇论文不需要这么做，也能够进行一个鉴别？</font> </p><p>我们的方法很简单，可以看作是将SimCSE的标准对比学习目标（图1左）与差异预测目标（图一右）相结合。</p><ul><li>对SimCSE部分的解释，这个已经见过很多次了</li></ul><p>给定一个无标签的输入句子x，SimCSE通过应用不同的dropout掩码，为其创建了一个positive example x+。通过使用BERT_base编码器f，我们可以得到x的句子嵌入h&#x3D;f(x)，SimCSE的训练目标是：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815142645967.png" alt="image-20220815142645967" style="zoom:80%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815142704389.png" alt="image-20220815142704389" style="zoom:80%;"><ul><li>对右边这个差异预测目标的解释（还要从loss函数的设计上，看看为什么能够引导到左边encoder来学习到更好的表示）：</li></ul><p>图1的右侧是ELECTRA（Clark等人，2020）中<strong>使用的差异预测目标的条件版本</strong><font color="red">这里的条件是否指的是把h作为输入了，要交互一下有一个条件？</font> ，它包含一个生成器和一个判别器。给定长度为$T$的一句话$x&#x3D;[x_{(1)},x_{(2)},…,x_{(T)}]$，我们首先将其进行随机的掩码$m&#x3D;[m_{(1)},m_{(2)},…,m_{(T)}]，m_{(t)}\in[0,1]$，然后获取$x’&#x3D;m·x$。我们使用另一个预训练的MLM作为生成器$G$，进行掩码语言建模，恢复$x’$中的随机掩码标记，得到编辑过的句子$x’’&#x3D;G(x)$<font color="red">这里这个G是fix住的，不知道使用什么搞的</font> 。然后，我们使用判别器$D$来执行标记检测（RTD）任务。对于句子中的每个标记，模型需要预测它是否被替换，单个句子$x$的交叉熵损失为：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815144235938.png" alt="image-20220815144235938" style="zoom:80%;"><p>对于一个batch来说，要把这个loss求和：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815144423225.png" alt="image-20220815144423225" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815144442378.png" alt="image-20220815144442378" style="zoom:50%;"></p><p>最后，我们将这两种损失与一个加权系数λ一起进行优化：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815144513200.png" alt="image-20220815144513200" style="zoom:80%;"><p>我们的模型和ELECTRA的区别在于，我们的判别器$D$是有条件的，所以它可以使用压缩在固定维度向量$h&#x3D;f(x)$中的$x$的信息。$D$的梯度可以通过$h$反向传播到$f$。通过这样做，$f$将被鼓励使得$h$的信息量足以覆盖$x$的全部含义，这样$D$就可以区分$x$和$x’’$之间的微小差别。这种方法实质上是让条件判别器进行 “差异操作”，因此被称为DiffCSE。</p><p><font color="purple"><strong>读完method章节还是不太明白，主要是不明白这么操作是怎么和他motivation对上的，就是说我最后sentence encoder这边输出的h表征，既在SimCSE的引导下具有alignment和uniformity的特性，通过拉近正例推远负例增强了橘子的表征，但是这种可能导致了转化不敏感；；然后通过右边那个在h的引导下做鉴别，也就是说我这个h有能力覆盖含义，这样D就可以区分两者之间微小的差别（可能某几个词被替换了）；；；句子表征h既有不敏感变化的能力，也有敏感变化的能力？</strong></font> </p><p><font color="purple">对于两句话，h能够很好的输出这两句话的表征，一种是差距比较大的比如两句话很离谱的那种通过SimCSE，然后一种差距不太大的，比如可能句法层面一样，而且只是换了几个词这样的我们也应当要敏感，那么通过右边的这种鉴别架构来学习，h要使得鉴别器具有更好的区分能力？</font> </p><p><font color="purple">感觉还是想不到作者一个比较明确的motivation是什么：</font> </p><p>当我们训练DiffCSE模型时，我们固定生成器G，只有句子编码器f和判别器D被优化。训练结束后，我们丢弃D，只用f（保持固定）来提取句子嵌入，以便在下游任务中进行评估。</p><h2 id="3‘：知乎解读中一些要点的记录"><a href="#3‘：知乎解读中一些要点的记录" class="headerlink" title="3‘：知乎解读中一些要点的记录"></a>3‘：知乎解读中一些要点的记录</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/503701001">https://zhuanlan.zhihu.com/p/503701001</a></li></ul><p><strong>motivation：</strong></p><p>通过对比学习来学习sentence embedding的表示，一般的思路就是对单个样本使用multiple augmentation的方式来构造positive pair。这些方法的训练目标是在于让表征对于增广变换是不变的。（如SimCSE那种dropout-based的方法）</p><p>然而有些augumentation的方法，比如对input进行delete或者替换，往往会改变句子的含义，因此理想的augumentation的方法对于这些transformations因当时变化的（not invariat）。</p><p><strong>在计算机视觉领域，这被称作equivariantcontrastive learning，在不敏感的image transformations（如灰度变化）使用对比损失，而在敏感的image transformations（如图片的旋转）上使用prediction loss；</strong></p><p><font color="purple">想想这和CLINE的方法冲突不冲突，CLINE那篇好像不太专注的是句子表征这种下游任务，而是一些下游的一些攻击对抗那种例子</font> </p><p><font color="purple">现在是用一个普通的方法生成的，那么如果是CLINE那种的呢，直接同义词反义词？</font> </p><h2 id="3‘’：ELECTRA记录"><a href="#3‘’：ELECTRA记录" class="headerlink" title="3‘’：ELECTRA记录"></a>3‘’：ELECTRA记录</h2><ul><li><a href="https://huggingface.co/google/electra-base-discriminator">https://huggingface.co/google/electra-base-discriminator</a></li></ul><p>ELECTRA: Pre-training Text Encoders as Discriminators Rather Than Generators</p><p>ELECTRA：预先训练文本编码器作为鉴别器，而不是生成器</p><p>是一种自我监督的语言表征学习的新方法。它可以用相对较少的计算量来预训练Transformer网络。ELECTRA模型被训练来区分 “真实 “的输入标记与另一个神经网络产生的 “虚假 “输入标记，类似于GAN的判别器。在小规模下，ELECTRA即使在单个GPU上训练也能取得很好的效果。在大规模情况下，ELECTRA在SQuAD 2.0数据集上取得了最先进的结果。</p><p>For a detailed description and experimental results, please refer to our paper <a href="https://openreview.net/pdf?id=r1xMH1BtvB">ELECTRA: Pre-training Text Encoders as Discriminators Rather Than Generators</a>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> ElectraForPreTraining, ElectraTokenizerFast<br><span class="hljs-keyword">import</span> torch<br><br>discriminator = ElectraForPreTraining.from_pretrained(<span class="hljs-string">&quot;google/electra-base-discriminator&quot;</span>)<br>tokenizer = ElectraTokenizerFast.from_pretrained(<span class="hljs-string">&quot;google/electra-base-discriminator&quot;</span>)<br><br>sentence = <span class="hljs-string">&quot;The quick brown fox jumps over the lazy dog&quot;</span><br>fake_sentence = <span class="hljs-string">&quot;The quick brown fox fake over the lazy dog&quot;</span>  <span class="hljs-comment"># 这里有fake</span><br><br>fake_tokens = tokenizer.tokenize(fake_sentence)<br>fake_inputs = tokenizer.encode(fake_sentence, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)  <span class="hljs-comment"># </span><br>discriminator_outputs = discriminator(fake_inputs)  <span class="hljs-comment"># </span><br>predictions = torch.<span class="hljs-built_in">round</span>((torch.sign(discriminator_outputs[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 符号函数，应该是能预测出来哪些是错的？</span><br><br>[<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%7s&quot;</span> % token, end=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> fake_tokens]<br><br>[<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%7s&quot;</span> % <span class="hljs-built_in">int</span>(prediction), end=<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> prediction <span class="hljs-keyword">in</span> predictions.tolist()]<br><br></code></pre></td></tr></table></figure><p>作者的ELECTRA-with-Condition是怎么实现的？而且还说discriminator那块使用的是bert或者roberta，好像就是多了一个cls_input那块，然后把cls替换了，但是这样为什么就能起到更好的作用了，实在还是不太理解；</p><h2 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h2><h3 id="4-1-Setup"><a href="#4-1-Setup" class="headerlink" title="4.1 Setup"></a>4.1 Setup</h3><p>在我们的实验中，我们遵循无监督的SimCSE（Gao等人，2021）的设置，并基于他们的PyTorch实现建立我们的模型。</p><p>我们还使用BERT（Devlin等人，2019）和RoBERTa（Liu等人，2019）的检查点作为我们句子编码器的初始化$f$</p><p>我们在[CLS]表示的基础上增加了一个MLP层，用batchnorm作为句子嵌入。我们将在第5节比较有&#x2F;无batchnorm的模型。</p><p>对于判别器D，我们使用与句子编码器f（BERT&#x2F;RoBERTa）相同的模型。</p><p><font color="purple">这里的判别器能用这样的模型吗，那么他那个h输入进去是怎么用上的，怎么好像也没有公式说明</font> </p><p>对于generator G，我们使用较小的DistilBERT和DistilRoBERTa以提高效率</p><p>请注意，与ELECTRA论文（Clark等人，2020）不同，generator在训练期间是固定的。我们将在第5节中比较使用不同大小模型的generator的结果。更多的训练细节显示在附录A。</p><p><font color="purple">可以说这里的生成器是不关键的吗，是否有改进空间？好像也不是传统那种对抗训练的方式？</font> </p><h3 id="4-2-Data"><a href="#4-2-Data" class="headerlink" title="4.2 Data"></a>4.2 Data</h3><p>对于无监督的预训练，我们使用了SimCSE的源代码所提供的10^6个从英语维基百科中随机抽出的句子。</p><p>We evaluate our model on 7 semantic textual similarity (STS) and 7 transfer tasks in SentEval.</p><p>STS tasks includes STS 2012– 2016 (Agirre et al., 2016), STS Benchmark (Cer et al., 2017) and SICK-Relatedness (Marelli et al., 2014). All the STS experiments are fully unsupervised, which means no STS training datasets are used and all embeddings are fixed once they are trained.</p><p>STS任务包括STS 2012- 2016（Agirre等人，2016）、STS基准（Cer等人，2017）和SICK-Relatedness（Marelli等人，2014）。所有的STS实验都是完全无监督的，这意味着没有使用STS训练数据集，所有的嵌入一旦训练完成就会被固定。</p><p><font color="purple">这里应该也补充了之前数据集那块的疑问，STS这边应该是没有用到train那块的，而且他是和SimCSE作对比，那SimCSE应该也是没有用</font> </p><p>Transfer Task是各种感官分类任务，包括MR（Pang和Lee，2005）、CR（Hu和Liu，2004）、SUBJ（Pang和Lee，2004）、MPQA（Wiebe等，2005）、SST- 2（Socher等，2013）、TREC（Voorhees和Tice，2000）和MRPC（Dolan和Brockett，2005）。在这些Transfer Task中，我们将按照标准设置，使用在冻结的句子嵌入之上训练的逻辑回归分类器。</p><p><font color="purple">下游训练分类器，SentEval提供了一些默认设置，应该和那里对齐就可以</font> </p><h3 id="4-3-Results"><a href="#4-3-Results" class="headerlink" title="4.3 Results"></a>4.3 Results</h3><h4 id="4-3-1-Baselines"><a href="#4-3-1-Baselines" class="headerlink" title="4.3.1 Baselines"></a>4.3.1 Baselines</h4><p>选用了一些baseline作为对比的</p><h4 id="4-3-2-Semantic-Textual-Similarity（STS）"><a href="#4-3-2-Semantic-Textual-Similarity（STS）" class="headerlink" title="4.3.2 Semantic Textual Similarity（STS）"></a>4.3.2 Semantic Textual Similarity（STS）</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815155147000.png" alt="image-20220815155147000"></p><p><font color="red">这里提供了一个SimCSE-reproduct的指标，应该是作者去跑了一下代码，从自己跑实验来说应该也是确实差一点能能到达SimCSE所宣称的指标</font> </p><p><font color="red">这个选择还挺tricky的，每项都比reproduce的好？</font> </p><h4 id="4-3-3-Transfer-Tasks"><a href="#4-3-3-Transfer-Tasks" class="headerlink" title="4.3.3 Transfer Tasks"></a>4.3.3 Transfer Tasks</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815155452019.png" alt="image-20220815155452019"></p><p><font color="red">加上MLM作为训练目标后，会好一些？</font> </p><p>Note that the CMLM-BERTbase (Yang et al., 2020) can achieve even better performance than DiffCSE. However, they use 1TB of the training data from Common Crawl dumps while our model only use 115MB of the Wikipedia data for pretraining. We put their scores in Table 2 for reference.</p><p>这个方法可能有些表现更好，但是用了很多额外的数据，而且这个数据规模是很大的；</p><p>In Sim- CSE, the authors propose to use MLM as an auxiliary task for the sentence encoder to further boost the performance of transfer tasks. Compared with the results of SimCSE with MLM, DiffCSE still can have a little improvement around 0.2%.</p><p>这里SimCSE原文是这么写的，没有放在正文里好像：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815155840502.png" alt="image-20220815155840502"></p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815155905789.png" alt="image-20220815155905789" style="zoom:80%;"><p>MLM在transfer任务中会更好？</p><h2 id="5-Ablation-Studies"><a href="#5-Ablation-Studies" class="headerlink" title="5. Ablation Studies"></a>5. Ablation Studies</h2><p>我们进行了一系列广泛的消融研究，以支持我们的模型设计。我们使用BERTbase模型对STS-B的开发集和转移任务进行评估</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815163525656.png" alt="image-20220815163525656" style="zoom:50%;"><h3 id="5-1-Removing-Contrasitve-Loss"><a href="#5-1-Removing-Contrasitve-Loss" class="headerlink" title="5.1 Removing Contrasitve Loss"></a>5.1 Removing Contrasitve Loss</h3><p>This result shows that it is important to have insensitive and sensitive attributes that exist together in the representation space.</p><p>这一结果表明，在表示空间中，不敏感和敏感的属性一起存在是很重要的。</p><h3 id="5-2-Next-Sentence-vs-Same-Sentence"><a href="#5-2-Next-Sentence-vs-Same-Sentence" class="headerlink" title="5.2 Next Sentence vs. Same Sentence"></a>5.2 Next Sentence vs. Same Sentence</h3><p>一些无监督句子嵌入的方法，如Quick-Thoughts（Logeswaran和Lee，2018）和CMLM（Yang等人，2020）预测下一句话作为训练目标。我们还体验了DiffCSE的一个变种，即根据下一句话来调节ELECTRA损失。请注意，这种模型不是在两个相似的句子之间进行 “差异操作”，也不是一个等价对比学习的实例。如表3所示（对x′使用下一个句子），STS-B的得分与DiffCSE相比明显下降，而转移性能仍然是相似的。</p><p>我们也尝试过同时使用同一个句子和下一个句子来调节ELECTRA目标（对x′使用同一个+下一个发送），但没有观察到改进。</p><p><font color="purple">不理解这里的next-sentence是怎么搞的</font> </p><h3 id="5-3-Other-Conditional-Pretraining-Tasks"><a href="#5-3-Other-Conditional-Pretraining-Tasks" class="headerlink" title="5.3 Other Conditional Pretraining Tasks"></a>5.3 Other Conditional Pretraining Tasks</h3><p>在右边那个架构使用其他的辅助任务，貌似效果不如现在这种MLM好；</p><h3 id="5-4-Augumentation-Methods-Insert-x2F-Delete-x2F-Replace"><a href="#5-4-Augumentation-Methods-Insert-x2F-Delete-x2F-Replace" class="headerlink" title="5.4 Augumentation Methods: Insert&#x2F;Delete&#x2F;Replace"></a>5.4 Augumentation Methods: Insert&#x2F;Delete&#x2F;Replace</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815164740634.png" alt="image-20220815164740634"></p><p><font color="purple">文字描述只解释了这个现象，但是好像没有解释为什么，从自己的感觉来说，那么如果是换成其他的了，我这个编码器输出的h还能够有那种作用吗？两边变化就比较大了？不过还是不太理解这个编码器h的作用；</font> </p><h3 id="5-5-Pooler-Choice"><a href="#5-5-Pooler-Choice" class="headerlink" title="5.5 Pooler Choice"></a>5.5 Pooler Choice</h3><p>在SimCSE中，作者使用BERT原始实现中的池器（一个带有tanh激活函数的线性层）作为最后一层，以提取特征来计算对比损失。在我们的实现中（详见附录A），我们发现使用带有批量归一化（Batch- Norm）（Ioffe和Szegedy，2015）的两层池器更好，这在计算机视觉的对比学习框架中常用（Chen等人，2020；Grill等人，2020；Chen和He，2021；华等人，2021）。我们在表5中显示了消融的结果。我们可以看到，添加BatchNorm有利于DiffCSE或SimCSE在STS-B和转移任务上获得更好的表现。</p><p><font color="red">这里应该说的是那个MLP Layer的地方吧，要去对着代码看一下</font> </p><h3 id="5-6-Size-of-the-Generator"><a href="#5-6-Size-of-the-Generator" class="headerlink" title="5.6 Size of the Generator"></a>5.6 Size of the <strong>Generator</strong></h3><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815165520599.png" alt="image-20220815165520599" style="zoom:80%;"><p>Notice that although DistilBERTbase has only half the number of layers of BERT, it can retain 97% of BERT’s performance due to knowledge distillation</p><p>我们在表6中显示了我们的结果，我们可以看到Transfer task的性能在不同的generator中没有太大的变化。</p><p>然而，当我们从BERT-中型转换到BERT-小型时，STS-B的得分下降了。这一发现与ELECTRA不同，ELECTRA在生成器为判别器1&#x2F;4-1&#x2F;2大小时效果最好。因为我们的鉴别器是以句子向量为条件的，所以鉴别器将更容易执行RTD任务。因此，使用更强的生成器（BERTbase，DistilBERTbase）来增加RTD的难度将有助于鉴别器更好地学习。然而，当使用像BERTlarge这样的大型模型时，它可能是一个对判别器来说太有挑战性的任务。在我们的实验中，使用DistilBERTbase，它的能力接近但比BERTbase略差，给了我们最好的性能。</p><p><font color="purple">鉴别器是带有那个句子向量h作为条件的，所以鉴别器将更容易执行RTD任务。使用bert-base和distilBERT-base这种比medium、small大的作为generator，将更加有利于鉴别器的学习，因为其增加了RTD的难度….</font> </p><p><font color="purple">但是当使用到large的时候，可能这个任务又太难了导致学不好，最后选用了distilbert</font> </p><h3 id="5-7-Masking-Ratio"><a href="#5-7-Masking-Ratio" class="headerlink" title="5.7 Masking Ratio"></a>5.7 Masking Ratio</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815170442612.png" alt="image-20220815170442612"></p><h3 id="5-8-Coefficient-lambda-（两边loss的平衡）"><a href="#5-8-Coefficient-lambda-（两边loss的平衡）" class="headerlink" title="5.8 Coefficient $\lambda$（两边loss的平衡）"></a>5.8 Coefficient $\lambda$（两边loss的平衡）</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815170530101.png" alt="image-20220815170530101"></p><h2 id="6-Analysis"><a href="#6-Analysis" class="headerlink" title="6. Analysis"></a>6. Analysis</h2><h3 id="6-1-定性研究"><a href="#6-1-定性研究" class="headerlink" title="6.1 定性研究"></a>6.1 定性研究</h3><p>句子嵌入的一个非常普遍的应用的一个非常常见的应用是检索任务。这里我们展示了一些检索实例，以定性地解释为什么DiffCSE能比SimCSE表现更好。</p><p>使用STS-B测试集的2758个句子作为语料库，然后使用句子查询，通过计算余弦相似度来检索句子嵌入空间中的最近邻居。</p><p>我们在表9中显示了检索到的前3个例子。</p><ul><li><p>第一个查询句子是 “你也可以这样做”。SimCSE模型检索到一个非常相似的句子，但其含义略有不同（”你也可以用它。”）作为排名第一的答案。相比之下，DiffCSE可以分辨出微小的差别，所以它检索出gt答案作为等级1的答案。</p></li><li><p>二个查询句子是 “这不是一个问题”。SimCSE检索到了一个意思相反但措辞非常相似的句子，而DiffCSE可以检索到措辞不太相似的正确答案。</p></li><li><p>我们还提供了第三个例子，SimCSE和DiffCSE都不能检索到一个使用双重否定的查询句子的正确答案。<font color="purple">双重否定这里，有没有性能提升的一些创新思路？或者这几个case能不能和CLINE那边结合</font></p></li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815172229588.png" alt="image-20220815172229588" style="zoom:50%;"><h3 id="6-2-Retrieval-Task"><a href="#6-2-Retrieval-Task" class="headerlink" title="6.2 Retrieval Task"></a>6.2 Retrieval Task</h3><p>除了定性研究，我们还展示了检索任务的定量结果。在这里，我们也使用STS-B测试集中的所有2758个句子作为语料库。在这个语料库中，有97个阳性对（从人类注释中得到5个语义相似度分数）。对于每个阳性对，我们用一个句子来检索另一个句子，看另一个句子是否在前1&#x2F;5&#x2F;10的排名中。检索任务的召回率@1&#x2F;5&#x2F;10见表10。我们可以看到，DiffCSE的召回率@1&#x2F;5&#x2F;10超过了SimCSE，显示了使用DiffCSE进行检索任务的有效性。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815172603102.png" alt="image-20220815172603102" style="zoom:67%;"><p>diffCSE使得检索更准了</p><h3 id="6-3-Distribution-of-Sentence-Embeddings"><a href="#6-3-Distribution-of-Sentence-Embeddings" class="headerlink" title="6.3 Distribution of Sentence Embeddings"></a>6.3 Distribution of Sentence Embeddings</h3><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815175452191.png" alt="image-20220815175452191" style="zoom:67%;"><p>图2：STS-B测试集的SimCSE&#x2F;DiffCSE的余弦相似度分布。沿着y轴是基于人类评分的5组数据分割。X轴是余弦相似度。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220815175723349.png" alt="image-20220815175723349" style="zoom:80%;"><p>为了研究DiffCSE的表示空间，我们在图2中绘制了SimCSE和DiffCSE的STS-B测试集的感官相似度的余弦分布。我们观察到，SimCSE和DiffCSE都能分配与人类评分一致的余弦值。</p><p>然而，我们也观察到，在相同的人类评分下，DiffCSE分配的余弦相似度比SimCSE略高。这一现象可能是由于ELECTRA和其他基Transformer的预训练语言模型有挤压表示空间的问题，正如Meng等人（2021）所提到的。由于我们使用句子嵌入作为ELECTRA的输入来进行有条件的ELECTRA训练，因此感性句子嵌入将不可避免地被挤压以适应ELECTRA的输入分布。我们遵循先前的研究（Wang and Isola, 2020; Gao et al., 2021），在表11中使用统一性和对齐性（详见附录C）来衡量DiffCSE和SimCSE的代表空间质量。与平均的BERT嵌入相比，Sim- CSE具有相似的对齐度（0.177对0.172），但均匀性更好（-2.313）。相比之下，DiffCSE的均匀性与Avg. BERT(-1.438 v.s. -1.468)，但对齐度要好得多（0.097）。这表明SimCSE和DiffCSE在两个不同的方向上优化了表示空间。而DiffCSE的改进可能来自于它更好的对齐方式。</p><p>这里是一个从alignment 和 uniformity角度进行的分析；</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7. Conclusion"></a>7. Conclusion</h2><p>在本文中，我们提出了DiffCSE，一个新的无监督的句子嵌入框架，它意识到了基于MLM的单词替换，但并没有对其产生影响。在语义文本相似性任务和转移任务上的实证结果都显示了DiffCSE与当前最先进的句子嵌入方法相比的有效性。我们还进行了广泛的消减研究，以证明DiffCSE的不同建模选择。定性研究和检索结果也表明，DiffCSE可以为句子检索提供一个更好的嵌入空间。<strong>我们工作的一个局限性是，我们没有探索使用人类标记的NLI数据集来进一步提高性能的监督环境。我们把这个话题留给未来的工作。</strong>我们相信，我们的工作可以为NLP社区的重新搜索者提供一种利用自然语言增强的新方法，从而产生更好的句子嵌入。</p><p><font color="red">把NLI那些用上，提升检索上的一些，或者transfer任务上的？或者去CLINE那种数据集里搞</font> </p><h2 id="8-Coding角度"><a href="#8-Coding角度" class="headerlink" title="8. Coding角度"></a>8. Coding角度</h2><p>这里discriminator的，把那个h作为CLS的输入？</p><p><a href="https://github.com/voidism/DiffCSE/blob/f724b2cc921efdfb4e4bd85cd7ca13a8f0d1f0cf/diffcse/models.py#L199">https://github.com/voidism/DiffCSE/blob/f724b2cc921efdfb4e4bd85cd7ca13a8f0d1f0cf/diffcse/models.py#L199</a></p><p>discriminator是这里：<a href="https://github.com/voidism/DiffCSE/blob/f724b2cc921efdfb4e4bd85cd7ca13a8f0d1f0cf/diffcse/models.py#L338">https://github.com/voidism/DiffCSE/blob/f724b2cc921efdfb4e4bd85cd7ca13a8f0d1f0cf/diffcse/models.py#L338</a></p><p>BERTmodel中的这里，他这个h的结合方式来看，</p><p><a href="https://github.com/voidism/DiffCSE/blob/26096ee54ffc5cd323b0fc690c3d21811b3b90bf/transformers-4.2.1/src/transformers/models/bert/modeling_bert.py#L876">https://github.com/voidism/DiffCSE/blob/26096ee54ffc5cd323b0fc690c3d21811b3b90bf/transformers-4.2.1/src/transformers/models/bert/modeling_bert.py#L876</a></p><p><a href="https://github.com/voidism/DiffCSE/blob/26096ee54ffc5cd323b0fc690c3d21811b3b90bf/transformers-4.2.1/src/transformers/models/bert/modeling_bert.py#L961">https://github.com/voidism/DiffCSE/blob/26096ee54ffc5cd323b0fc690c3d21811b3b90bf/transformers-4.2.1/src/transformers/models/bert/modeling_bert.py#L961</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">embedding_output = torch.cat([cls_input.unsqueeze(<span class="hljs-number">1</span>), embedding_output[:, <span class="hljs-number">1</span>:, :]], dim=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里就是把其中的cls给替换了，作为一个最初始的，虽然不知道为什么这样就能作用于他这个motivation吧</p><p><strong>他这份代码也是在SimCSE基础上魔改的；</strong></p><h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220817110642213.png" alt="image-20220817110642213"></p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Contrastive Learning 论文整理</title>
    <link href="/2022/08/11/research/papers/contrastive-learning/Contrasitve%20Learning%20%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/"/>
    <url>/2022/08/11/research/papers/contrastive-learning/Contrasitve%20Learning%20%E8%AE%BA%E6%96%87%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Contrastive-Learning-论文整理"><a href="#Contrastive-Learning-论文整理" class="headerlink" title="Contrastive Learning 论文整理"></a>Contrastive Learning 论文整理</h1><h2 id="1-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations"><a href="#1-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations" class="headerlink" title="1. A Simple Framework for Contrastive Learning of Visual Representations"></a>1. A Simple Framework for Contrastive Learning of Visual Representations</h2><h3 id="1-1-简介-amp-总结"><a href="#1-1-简介-amp-总结" class="headerlink" title="1.1  简介&amp;总结"></a>1.1  简介&amp;总结</h3><p>SimCLR，对比学习开创性的工作，是一种无监督（或者称为自监督的）的方法通过一张图片的两种数据增强方法之间互为正例，在一个batch批次为N的数据中，通过两种数据增强方法构建2N个例子，那么每个i会与其它2N-2个互为负例，这样通过infoNCE损失函数完成拉近正样本，推远负样本。注意这里引入了projection head将隐层表征$h_i$线性变换后的$g_i$用来计算对比损失，但是在使用表征的时候仍然使用$h_i$；</p><h3 id="1-2-算法实现过程"><a href="#1-2-算法实现过程" class="headerlink" title="1.2 算法实现过程"></a>1.2 算法实现过程</h3><ul><li><strong>Figure2：A simple framework for contrastive learning of visual representations</strong></li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807143950162.png" alt="image-20220807143950162" style="zoom:80%;"><ol><li><p>一个样本$x$经过两种数据增强方法生成$\tilde{x}_i$和$\tilde{x}_j$（例如计算机视觉中常用的裁剪，旋转等等）；</p></li><li><p>他们经过同样的$f(·)$层线性学习提取得到图像的特征（这里一般是ResNet类的Encoder的特征提取结构，对应到NLP就一般是一个BERT类的Transformer-Encoder架构），得到的图像表征是$h_i$和$h_j$；</p></li><li><p>将图像表征$h_i$和$h_j$通过projection head $g(·)$层，得到表征$z_i$和$z_j$；</p></li><li><p>通过InfoNCE等函数拉近positive pair之间的距离，推远negative pair之间的距离（注意这里分母不包含h1_1、h1_1这一项自己到的自己的，但是包含正例之间的h1_1、h1_2这一项）；</p></li></ol><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807145540738.png" alt="image-20220807145540738" style="zoom:80%;"><ol start="5"><li>在使用表征进行下游任务的时候，使用$f(·)$而丢弃$g(·)$</li></ol><ul><li><strong>Algorithm1：summarizes the proposed method</strong></li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807150236938.png" alt="image-20220807150236938" style="zoom:80%;"><ol><li>对于一个batch大小为N的数据批次，指定温度常数$\tau$，以及数据增强方法$T$、encoder结构$f$，projection head结构$g$；</li><li>把batch中的每个数据使用两种$T$中的数据增强方法，生成共计2N个数据；</li><li>将这2N个数据分别通过$f(·)$和$g(·)$，得到表征$h_{2k-1} h_{2k}$和$z_{2k-1} z_{2k}$；</li><li>对于2N个数据，两两计算相似度，这里使用的是余弦相似度；</li><li>将2N中的每个样本作为anchor，与其他所有样本计算损失，这个计算损失的过程中分母不包含自己到自己这一项，而分子是其与其另外一种的数据增强方式之间互相为正例；</li><li>更新网络参数，优化损失函数$L$，最终在使用表征的时候选用$f(·)$而丢弃$g(·)$；</li></ol><h2 id="2-CLINE-Contrastive-Learning-with-Semantic-Negative-Examples-for-Natural-Language-Understanding"><a href="#2-CLINE-Contrastive-Learning-with-Semantic-Negative-Examples-for-Natural-Language-Understanding" class="headerlink" title="2. CLINE: Contrastive Learning with Semantic Negative Examples for Natural Language Understanding"></a>2. CLINE: Contrastive Learning with Semantic Negative Examples for Natural Language Understanding</h2><h3 id="2-1-简介-amp-总结"><a href="#2-1-简介-amp-总结" class="headerlink" title="2.1 简介&amp;总结"></a>2.1 简介&amp;总结</h3><p>CLINE，ACL2021年的工作，这时候还是这种数据增强的手段比较经常出现，一句话经过同义词替换生成对抗性的例子（Adversarial example），经过反义词替换生成对比性的例子（contrast example），原句和同义词替换后的互为positive pair，和反义词替换后的互为negative pair；</p><p>损失函数使用三种加在一块，Masked Language Modeling（MLM，同BERT）、Replaced Token Detection（RTD）还有Contrastive Objective（CTS）。前两者MLM和RTD提升语义表达能力，CTS则是一个对比性目标</p><h3 id="2-2-算法实现过程"><a href="#2-2-算法实现过程" class="headerlink" title="2.2 算法实现过程"></a>2.2 算法实现过程</h3><ul><li>Figure1：An illustration of our model, note that we use the embedding of [CLS] as the sentence representation</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807151350448.png" alt="image-20220807151350448"></p><ol><li><p>给定原数据（一句话）$x^{ori}$，对其使用spaCy算法库进行分词（segment）与词性标注（POS，part of speech tagging），之后对于$x^{syn}$同义词替换40%，对于反义词$x^{ant}$替换20%完成数据预处理；</p></li><li><p>将他们经过同样的一个BERT $h&#x3D;E_\phi(x)$，获取$h^{ori}$、$h^{syn}$、$h^{cnt}$三种表征</p></li><li><p>损失函数第一项$L_{MLM}$：同BERT中的MLM任务，这个应该是直接集成在这个方法基础上的，作者没有给新的公式；</p></li><li><p>损失函数第二项$L_{RTD}$：只对于同义词替换和反义词替换的数据进行，预测哪些词是被同义词&#x2F;反义词替换了的，过一个线性层sigmoid后得到每个位置被替换的概率（注意这里是sigmoid，看做一个多分类任务）。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807153141484.png" alt="image-20220807153141484" style="zoom:80%;"><p>通过交叉熵损失函数计算这个$L_{RTD}$：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807153421702.png" alt="image-20220807153421702" style="zoom:80%;"></li><li><p>损失函数第三项$L_{CTS}$：对比性学习损失，相似性计算方式选择点乘相似度，这里没有引入温度常数$\tau$，一个句子的表征使用的是[CLS]token的embedding：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807153716064.png" alt="image-20220807153716064" style="zoom:80%;"></p><p>拉近$x^{ori}$和$x^{syn}$之间的距离，推远$x^{ori}$和$x^{ant}$之间的距离，这里在损失函数的计算上不涉及到和其他样本之间的关系，只是和自己的ori和ant之间来计算，最后也没有什么mean的操作</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807153940436.png" alt="image-20220807153940436" style="zoom:80%;"></li><li><p>最终损失函数被表征为多项加在一起：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807154023804.png" alt="image-20220807154023804" style="zoom:80%;"></li></ol><h2 id="3-Self-Guided-Contrastive-Learning-for-BERT-Sentence-Representations"><a href="#3-Self-Guided-Contrastive-Learning-for-BERT-Sentence-Representations" class="headerlink" title="3. Self-Guided Contrastive Learning for BERT Sentence Representations"></a>3. Self-Guided Contrastive Learning for BERT Sentence Representations</h2><h3 id="3-1-简介-amp-总结"><a href="#3-1-简介-amp-总结" class="headerlink" title="3.1 简介&amp;总结"></a>3.1 简介&amp;总结</h3><p>使用两个BERT构造正负例：①一个是不参与参数优化的BERT，对所有transformer层的隐藏层做maxpooling，即(batch,len,768)-&gt;(batch,1,768)，再取均值作为句子的输出表征；②一个是参数优化的BERT，直接用最后一层[CLS]作为句子表征。这样处理之后，来自同一个句子的①②构造positive pair，来自不同句子的①②构建negative pair。</p><h3 id="3-2-算法实现过程"><a href="#3-2-算法实现过程" class="headerlink" title="3.2 算法实现过程"></a>3.2 算法实现过程</h3><ul><li>Figure2：Self-guided contrastive learning framework, we clone BERT into two copies at the begining of training. BERT_T(except Layer 0) is then fine-tuned to optimize the sentence vector c_i while BERT_F is  fixed.</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807154921152.png" alt="image-20220807154921152"></p><ol><li><p>将BERT拷贝为两个副本，其中$BERT_F$在训练中被fix住，而$BERT_T$在训练时候的参数会更新，这里的意思应该也是会把pretrained的参数给load进去后fix住，否则不可能凭空来更新的；</p></li><li><p>在一个mini-batch中给定b句话$s_1,s_2, .. ,s_b$，输入到$BERT_F$中来获取这句话在每个层的隐藏表征$H_{i,k} \in R^{len(s_i)×d}$</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807160303611.png" alt="image-20220807160303611" style="zoom:80%;"></li><li><p>在各层的这个表征$H_{i,k}$之中，存储的是每个token的一个tensor的shape，使用池化方法$p$获取一个集合的单个token的表征，即$h_{i,k}&#x3D;p(H_{i,k})$，在这里作者选用的是最大池化。</p></li><li><p>从多个层中通过采样方法$\sigma$随机选择一个层的$h_i$，这里选用的是uniform sampler，这背后的motivation是把每一个看做是同样重要的，而不同BERT层表征了不同的语言concept</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807160929201.png" alt="image-20220807160929201" style="zoom:80%;"></li><li><p>把$s_i$输入到$BERT_T$中，这里选用BERT最后一层的[CLS]token作为最后的输出表征：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807161255476.png" alt="image-20220807161255476" style="zoom:80%;"></li><li><p>计算损失函数$L^{base}_{m}$，图中的绿色代表需要拉近，橙色代表需要远离，损失函数是类似SimCLR的那种，相似度使用的是余弦相似度，并且使用了projection head，这里也使用到了时间常数$\tau$：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807161603512.png" alt="image-20220807161603512" style="zoom:80%;"></li><li><p>额外在对比性学习损失函数$L^{base}_{m}$的基础上，使用了一个regularzation的损失函数，这是由于$BERT_F$是一个fix住的，在训练的过程中他的表征空间可能要和$BERT_T$远离了</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807162336333.png" alt="image-20220807162336333" style="zoom:80%;"></li><li><p>最终的损失函数通过下面这个式子来一起表示：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807162444923.png" alt="image-20220807162444923" style="zoom:80%;"></li></ol><ul><li><p>Figure3：Four factors of the original NT-Xent loss，green and yellow arrows represent the force of attraction and repulsion, respectively（attraction and repulsion：吸引力和排斥力）</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807162719245.png" alt="image-20220807162719245" style="zoom:80%;"><p>原始的损失函数要拉近图中的绿色边，而推远图中的黄色边，作者认为尽管这四种都起到确定的作用，一些元素可能是useless的或者甚至起到了与目标相反的目标，具体来说最近有报告说，在图像表示学习中，只有（1）是至关重要的，而其他都是不重要的。</p><p>原始的方法中，分母是（2b-1项，除了自己和自己）：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807163630359.png" alt="image-20220807163630359" style="zoom:67%;"></p><ol><li><p>第一种提升方法，加强$c_i$和$h_i$之间的关系</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807163732581.png" alt="image-20220807163732581" style="zoom:80%;"><p>$h$是$BERT_{FIX}$那边出来的，这种情况下删除掉了第(4)种类型的边，也就是只使用ci作为anchor</p></li><li><p>第二种提升方法，删除第2种类型的边：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807164239862.png" alt="image-20220807164239862" style="zoom:80%;"></li><li><p>使用$BERT_{FIX}$那边multiple的${h_{i,k}}$来引导$c_{i}$</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807164423740.png" alt="image-20220807164423740" style="zoom:80%;"><p>这种操作下的损失函数要把l的那个维度也给除掉，因为前面多了一维度求和</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807164618670.png" alt="image-20220807164618670" style="zoom:80%;"></li></ol><p><font color="red">额外注：上边这个方法是在损失项上做文章，不过在各种方式下分母都没有忽略掉h1_1和h1_2那个意思的那一项，这个里面的数学原理可能还不是太明白</font></p></li></ul><h2 id="4-SimCSE-Simple-Contrastive-Learning-of-Sentence-Embeddings"><a href="#4-SimCSE-Simple-Contrastive-Learning-of-Sentence-Embeddings" class="headerlink" title="4. SimCSE: Simple Contrastive Learning of Sentence Embeddings"></a>4. SimCSE: Simple Contrastive Learning of Sentence Embeddings</h2><h3 id="4-1-简介-amp-总结"><a href="#4-1-简介-amp-总结" class="headerlink" title="4.1 简介&amp;总结"></a>4.1 简介&amp;总结</h3><p>SimCSE是EMNLP2021年的论文，这个为后续的工作带来了非常多的经典，分为有监督学习和无监督学习两种方式，使用简单的Transformer架构中的dropout作为一句话的positive pair并与其他的生成negative pair。有监督学习在此基础上借助了NLI数据集，一个前提，和他蕴含的关系是positive pair，而和他矛盾的关系是negative pair，特别的针对这个前提的矛盾，额外加入一个权重来强化hard-negative的表现；</p><p>从alignment和uniformity两个方面还进行了一些理论分析，这里也从后续的一些论文阅读到，拉近正面的是一个alignment，而推开负面的使得表征具有各向同性的性质是一个uniformity</p><h3 id="4-2-算法实现过程"><a href="#4-2-算法实现过程" class="headerlink" title="4.2 算法实现过程"></a>4.2 算法实现过程</h3><ul><li>Unsupervised SimCSE</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807165716798.png" alt="image-20220807165716798" style="zoom:80%;"><p>这里的方法解释也比较简单，一句话输入两次encoder，通过内部的随机dropout生成两种表征，两者互为正例，且与其他采样样本生成的两种表征互为负例</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807170721955.png" alt="image-20220807170721955" style="zoom:80%;"><p>for a mini-batch ofN sentences. Note that z is just the standard dropout mask in Transformers and we do not add any additional dropout</p><ul><li>Supervised SimCSE</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807170804295.png" alt="image-20220807170804295" style="zoom:80%;"><p>额外选用了NLI（自然语言推理，Natural Language Inference）的含标注数据集作为训练集，并将$(x_i, x_{i}^{+})$这样一个扩充到$(x_i, x^{+}<em>{i},x</em>{i}^{-})$，额外引入到一个hard negative。如图中所表示的，前提被给定为“Two dogs are running”，与其具有蕴含（entailment）关系的句子是“There are animals outdoors”，与其具有矛盾（contradiction）关系的句子是“The pets are sitting on a couch”，这个矛盾的句子关系是需要推得更远的，损失函数被表示为下面这个式子：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807180551344.png" alt="image-20220807180551344" style="zoom:80%;"><p>这里因为本身就没有自己和自己（h1_1和h1_1），所以分母也没有包含这一项，但是分母同样的包含了h1_1，h1_2那一项</p><p>在ablation study章节作者给出了这个式子的加权值表示，以希望进一步引导hard-negative，其中<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807181125413.png" alt="image-20220807181125413" style="zoom:60%;">是一个指示符，只有当i&#x3D;&#x3D;j的时候等于1，也就是说当$\alpha&#x3D;1$的时候，是不是特殊hard-negative的权重都是1，而当$\alpha $大于1的时候，那么将受到指示因子的作用，只有那一项的权重将是$\alpha$其他项的系数还是1</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807180754818.png" alt="image-20220807180754818" style="zoom:80%;"><p>不过从做这个ablation实验来看，这个地方的实验现象不是很明显，但是加不加入hard-negative的现象还是很明显的</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807181629518.png" alt="image-20220807181629518" style="zoom:80%;"><h2 id="5-Raise-a-Child-in-Large-Language-Model-Towards-Effective-and-Generalizable-Fine-tuning"><a href="#5-Raise-a-Child-in-Large-Language-Model-Towards-Effective-and-Generalizable-Fine-tuning" class="headerlink" title="5. Raise a Child in Large Language Model: Towards Effective and Generalizable Fine-tuning"></a>5. Raise a Child in Large Language Model: Towards Effective and Generalizable Fine-tuning</h2><h3 id="5-1-简介-amp-总结"><a href="#5-1-简介-amp-总结" class="headerlink" title="5.1 简介&amp;总结"></a>5.1 简介&amp;总结</h3><p>这篇有点不完全属于对比学习领域的工作，更像是一种比较通用的方法能够即插即用的放置到各个任务中。主要分为一种任务无关的CHILD-TUNING_F和一种任务相关的CHILD-TUNING_D，这样做背后的motivation大概可以解释为大型预训练语言模型已经具有比较强的表征能力，那么我们在下游微调的时候其实不需要完全更新全部参数，可以每次掩码掉一部分参数是不更新的</p><ul><li>其中任务无关的就是随机一个矩阵，在反向传播的时候随机掩码掉一些梯度并且把其余部分的梯度放缩到期望与原来相同，从代码来说基本就是魔改了一下AdamW的实现；</li><li>其中任务相关的作者的实现可能和公式有些对不上，应该主要是依据梯度的大小做了一些操作；</li></ul><p>此外作者还加入了一些数学公式的推导，证明了方法的有效性。方法相对即插即用（特别是task-free那个），代码可见：<a href="https://github.com/alibaba/AliceMind/tree/main/ChildTuning">https://github.com/alibaba/AliceMind/tree/main/ChildTuning</a></p><h3 id="5-2-算法实现过程"><a href="#5-2-算法实现过程" class="headerlink" title="5.2 算法实现过程"></a>5.2 算法实现过程</h3><ul><li>overall：Figure1: The illustration of CHILD-TUNING, Left: It forwards on the whole network while backwarding on a subset of network(i.e., child network) Right: To archieve this, a task-free or task-driven mask is performed on the gradients of the non-child network, resetting them to zero (grey diagonal grids)</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807183353259.png" alt="image-20220807183353259" style="zoom:80%;"><p> CHILD-TUNING的图示，左图：在前项传播的时候保持整个网络，而在网络的一个子集上执行backward。右图：为了实现这一点，对非子网络的梯度进行task-free或者task-driven的掩码，将其重置为0（灰色对角线网格）</p><p>首先考虑optimizer更新梯度的原始公式，如式子1所示：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807183644430.png" alt="image-20220807183644430" style="zoom:80%;"><p>在CHILD-TUNING中，创建一个形状与$w_t$相同的掩码：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807183751502.png" alt="image-20220807183751502" style="zoom:80%;"><p>将其与式(1)进行点乘，这样就表明了CHILD-TUNING方法的原理，也比较好理解：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807183844431.png" alt="image-20220807183844431" style="zoom:80%;"><p>如下是一个算法流程，这个算法流程是以AdamW作为基础的optimizer更新公式，主要就是一个mask的生成过程：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807183947556.png" alt="image-20220807183947556" style="zoom:80%;"><ul><li>CHILD-TUNING_F（task-free）</li></ul><p>生成一个满足伯努利分布的mask，这里说成伯努利分布其实有点故意说的复杂了，实际上只是一个均匀分布，如果当$p_F$等于1的时候那么与vanilla的方法相等</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807184115163.png" alt="image-20220807184115163" style="zoom:80%;"><p>这里在梯度上要保持原来的期望：Note that we also en- large the reserved gradients by $1&#x2F;{p_F}$ to maintain the<br>expectation of the gradients</p><p>此外，在每个步骤的时候都随机一个mask，因为每个步骤的时候这个代价是不大的，不需要什么额外的计算过程；</p><ul><li>CHILD-TUNING_D（task-driven）</li></ul><p>通过统计fisher信息制作mask：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807184709601.png" alt="image-20220807184709601" style="zoom:67%;"></p><p>比起CHILD-TUNING_F来说，这个统计起来的时候比较复杂，所以只能在一开始的时候随机一次，并在fine-tuning的过程中保持不变：$C_0&#x3D;C_1&#x3D;···&#x3D;C_T$</p><h2 id="6-Momentum-Contrast-for-Unsupervised-Visual-Representation-Learning"><a href="#6-Momentum-Contrast-for-Unsupervised-Visual-Representation-Learning" class="headerlink" title="6. Momentum Contrast for Unsupervised Visual Representation Learning"></a>6. Momentum Contrast for Unsupervised Visual Representation Learning</h2><h3 id="6-1-简介-amp-总结"><a href="#6-1-简介-amp-总结" class="headerlink" title="6.1 简介&amp;总结"></a>6.1 简介&amp;总结</h3><p>Momentum的方式进行对比学习，优化了memory bank方法中，bank中由于参数更新导致各项表征差距过大的问题，这里momentun使得bank中已经存储的表征值每次只在之前的基础上微微改变了，这样bank中的represetation之间差异不会很大</p><p>和memory bank方法类似，解决了end-to-end方法中负样本数过少的问题</p><h3 id="6-2-算法实现过程"><a href="#6-2-算法实现过程" class="headerlink" title="6.2 算法实现过程"></a>6.2 算法实现过程</h3><ul><li>从以往的对比学习发展到MoCo</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719161407558.png" alt="image-20220719161407558"></p><ul><li>他人博客的一个对于MoCo方法的图解</li></ul><p>获取把x经过两种增强q1k1后的表征，feature q1通过一个encoder q(resnet-50)来获得，feature k1则是通过momentum encoder来获取，momentum encoder的参数更新非常缓慢，仅慢慢随着encoder q的变化而变化（初始化为encoder q）<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807190114425.png" alt="image-20220807190114425" style="zoom:33%;">，这样存入memory bank中的参数会小</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719162203974.png" alt="image-20220719162203974"></p><ul><li>作者给的Algorithm：</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807190452164.png" alt="image-20220807190452164" style="zoom:67%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807190325529.png" alt="image-20220807190325529" style="zoom:50%;"><p>把一个x经过两种aug方法后变成x_q和x_k两个，然后经过f_q和f_k层的foward变成q和k，注意这里在初始化的时候让f_k的params&#x3D;f_q的params。k.detach()代表不追踪k的梯度。</p><p>l_pos代表了q和k的相似度，也就是positive pair。l_neg代表了q和queue（长度为k）中的所有的相似度，也就是negative pair。通过式1来计算一个contrastive loss(InfoNCE），之后SGD（随机梯度下降）的方法对f_q网络层的参数进行update。</p><p>重点：每迭代loader中的一个样本x，需要更新f_k的参数，但是这里是一个momentum的更新方式，每次更新的很少。最后维护queue，把negative样本给放进去。</p><h2 id="7-TaCL-Improving-BERT-Pre-training-with-Token-aware-Contrastive-Learning"><a href="#7-TaCL-Improving-BERT-Pre-training-with-Token-aware-Contrastive-Learning" class="headerlink" title="7. TaCL: Improving BERT Pre-training with Token-aware Contrastive Learning"></a>7. TaCL: Improving BERT Pre-training with Token-aware Contrastive Learning</h2><h3 id="7-1-简介-amp-总结"><a href="#7-1-简介-amp-总结" class="headerlink" title="7.1 简介&amp;总结"></a>7.1 简介&amp;总结</h3><p>利用标记感知对比学习改进BERT预训练，首次将对比学习用于改进Transformer模型的token level表示（之前大多工作好像是句子级别的），并在token级别上盖上了各向异性这样一个问题，这背后的motivation是目前的大多未经特殊调整的Transformer对于词的一个表征大多是各向异性的，就是说表征两个词之间差距太小了，需要调整来更加分散变为各向同性的</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731002739558.png" alt="image-20220731002739558" style="zoom:67%;"><p>各向异性的缺点在于，最后学到的向量都挤在一起，彼此之间的余弦相似度很高，并不是一个很好的表示。一个好的表示应该同时满足Alignment和Uniformity，前者表示相似的向量距离应该相近，后者表示向量在空间上应该尽量均匀，最好是各向同性的</p><p><font color="red">不过从阅读论文的感觉来说，在token级别这么做是真的合理么，token级别那不是负例的实际上是更加可能的，比如两个单词他们本来在语义上就应该接近一些，以及一些指代关系的存在，会不会让这里有些问题？</font> </p><h3 id="7-2-算法实现过程"><a href="#7-2-算法实现过程" class="headerlink" title="7.2 算法实现过程"></a>7.2 算法实现过程</h3><ul><li>Figure1: An overview of TaCL. The student learns to make the representation of a masked token closer to its “reference” representation produced by the teacher (solid arrow) and away from the representations of other tokens in the same sequence (dashed arrows).</li></ul><p>TaCL的概述。学生模型学会使被掩码的token的表示更接近教师模型产生的 “reference”表示（实线箭头），并远离同一序列中其他标记的表示（虚线箭头）。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807191017715.png" alt="image-20220807191017715" style="zoom:80%;"><ol><li>学生模型Student和教师模型Teacher都是从相同的预训练BERT模型中初始化的。在训练过程中固定Teacher的参数，只优化Student的参数；</li><li>给定序列$x&#x3D;[x_1,x_2, …, x_n]$，我们使用与BERT相同程序随机掩码$x$，并将掩码后的$\hat{x}$送入到学生模型中，以产生上下文表征<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731143904381.png" alt="image-20220731143904381" style="zoom:50%;">。将未掩码的$x$送入到教师模型中获取表征<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144323169.png" alt="image-20220731144323169" style="zoom:50%;">，提出标记感知的对比性学习目标作用于两者之间，$L_{TaCL}$被定义为式1：</li></ol><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144823341.png" alt="image-20220731144823341" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144843641.png" alt="image-20220731144843641" style="zoom:50%;"><p>这里额外给出的解释是说只把mask掉的作为一个token级别的anchor</p><ol start="3"><li>截止这里的话其实方法实现就差不多了。在直觉上，学生学会了使被掩码token的表示更加接近于教师模型产生的reference表示，而远离同一序列中的其他标记。因此，Student模型学到的标记表征将对不同的标记更具辨别力，因此更能遵循各向同性的分布。</li><li>最后，作者把MLM（masked language modeling）和NSP(next sentence predicition)也加入到预训练fine-tune这个过程的目标：</li></ol><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807193905248.png" alt="image-20220807193905248" style="zoom:67%;"><ol start="5"><li>总结来说，学生的学习是无监督的，可以使用原始的训练语料库来实现。学习完成后，我们在下游任务中对学生模型进行微调。</li></ol><h2 id="8-EASE：Entity-Aware-Contrasitve-Learning-of-Sentence-Embedding"><a href="#8-EASE：Entity-Aware-Contrasitve-Learning-of-Sentence-Embedding" class="headerlink" title="8. EASE：Entity-Aware Contrasitve Learning of Sentence Embedding"></a>8. EASE：Entity-Aware Contrasitve Learning of Sentence Embedding</h2><h3 id="8-1-简介-amp-总结"><a href="#8-1-简介-amp-总结" class="headerlink" title="8.1 简介&amp;总结"></a>8.1 简介&amp;总结</h3><p>实体感知的对比学习用于句子的embedding表征，比较巧妙的应用了维基百科数据以及一些句子中存在的超链接。这个超链接和平常想象的超链接是一样的，也就是说句子中会有超链接，有点相当于一种能够额外获取到的数据了。这样自监督的构建了一些positive pair，并且由于维基百科数据收集的特点，能够在多语言语料之间完成对齐；</p><p>另外还有一些可能存疑的问题是，把一个实体和一个句子当做positive pair这样的感觉，那么如果切换了训练数据场景这个特征就会显得很奇怪，毕竟一句话中的实体还是很多的，可能这块也是利用了训练数据的特点吧。</p><h3 id="8-2-算法实现过程"><a href="#8-2-算法实现过程" class="headerlink" title="8.2 算法实现过程"></a>8.2 算法实现过程</h3><ul><li>Figure1: Illustration of the main concept behind EASE. Using a contrastive framework, sentences are embeded in the neighborhood of their hyperlink entity embeddings and kept apart from irrelevant entities. Here, we share the entity embeddings across languages for multilingual models to facilitate cross-lingual allignment of the representation</li></ul><p> EASE背后的主要概念说明。使用一个对比性框架，句子被嵌入到其超链接实体的邻近区域，并与不相关的实体分开。在这里，我们为多语言模型分享不同语言的实体嵌入，以促进表述的跨语言对齐。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807200548256.png" alt="image-20220807200548256" style="zoom:80%;"><ol><li><p>基于实体的对比学习，给出一个句子和一个语义相关的positive实体对<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801110741231.png" alt="image-20220801110741231" style="zoom:50%;">，我们训练我们的模型来预测句子实体表征$e_{i} \in R^{d_e}$，从句向量表征$s_{i} \in R^{d_s}$中。按照Chen等人SimCLR的对比学习框架，我们对N个配对的mini-batch $(s_i, e_i)$,通过下式计算训练损失：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801111124007.png" alt="image-20220801111124007" style="zoom:67%;"><p>注意这里在ei的表示前面加了一个$W \in R^{d_e×d_s}$是一个可学习的矩阵参数，否则从自己的感觉来说，一个句子的表征和一个实体的表征这样拉近推远，可能会使得噪声很大吧。</p></li><li><p>hard-negative entites：</p><ul><li>具有相同类型的实体被作为positive实体，例如“ABC工作室”和“工作室”，这是一种“instance of”的关系，如果有不止一种合适类型的实体，那么会随机选择一种（略微有一些父层级选择的感觉）；</li><li>不出现在同一维基百科页面上的实体被看做是negative的，比如“吉卜力工作室”实体的类型是“工作室”，然后“华特迪士尼动画工作室”就是不出现在同一个页面上的实体，那么把他作为一个negative，还是一个相对较难的hard-negative；（原文给出的描述是：For example, the “Studio Ghibli” entity has the type “animation studio” and one of the hard negative entity candidates is “Walt Disney Animation Studios”）</li></ul></li></ol><p>经过上面的处理后，现在有一个包含hard-negative的集合$D&#x3D;{(s_i,e_i,e^{-}<em>{i})}</em>{i&#x3D;1}^{m}$</p><p>损失函数被如下定义，注意这里分母是普通的negative加上额外的hard-negative：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808011207169.png" alt="image-20220808011207169" style="zoom:80%;"><ul><li>一些细节：</li></ul><p>实体的嵌入表征使用了开源的Wikipedia2Vec工具（EMNLP2020-demo），向量维度被设置为与基础预训练模型隐藏表征相同的768，实体嵌入矩阵的参数在训练过程中被更新；</p><p>最后把SimCSE的方法生成的损失函数给加上：有dropout噪声的self-supervised CL，它把一个句子放进去，用dropout作为噪声来预测自己，是一种以无监督方式学习句子嵌入的有效方法。我们将这个方法加入到我们的实体CL方法中，最终的损失函数被如下表示：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151455596.png" alt="image-20220801151455596" style="zoom:50%;">&#x3D;<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151545570.png" alt="image-20220801151545570" style="zoom:60%;">+<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151609615.png" alt="image-20220801151609615" style="zoom:60%;"></p><p>句子-超链接实体之间的对比损失 + 句子-句子之间的对比损失（SimCSE）</p><h2 id="9-Virtual-Augmentation-Supported-Contrastive-Learning-of-Sentence-Representations"><a href="#9-Virtual-Augmentation-Supported-Contrastive-Learning-of-Sentence-Representations" class="headerlink" title="9. Virtual Augmentation Supported Contrastive Learning of Sentence Representations"></a>9. Virtual Augmentation Supported Contrastive Learning of Sentence Representations</h2><h2 id="9-1-简介-amp-总结"><a href="#9-1-简介-amp-总结" class="headerlink" title="9.1 简介&amp;总结"></a>9.1 简介&amp;总结</h2><p>虚拟增强支持的句子表征的对比学习，有一种反向思路的感觉，通过邻域样本制造hard-negative：离自己相对较远而离邻居相对较近的一个微小扰动，但感觉不是negative这样的，就相当于创建了一个比较难（距离比较远）的positive-pair；</p><p>先在邻域内找到与$e_i$相似的K个样本$N(i)&#x3D;{k:e_k<del>has</del>the<del>top-K</del>similarity<del>with</del>e_i}$，然后来对比学习加上SimCSE的损失函数，使用中无监督的Virtual Augmentation方法，</p><h2 id="9-2-算法实现过程"><a href="#9-2-算法实现过程" class="headerlink" title="9.2 算法实现过程"></a>9.2 算法实现过程</h2><ul><li>Figure1: Illustration of VaSCL. For each instance $x_i$ In a randomly sampled batch, we optimize (i) an instance-wise contrastive loss with the dropout induced augmentation obtained by forwarding the same instance twice, i.e., x_i and x_i’，denote the same text example; and (2) a neighborhood constrained instance discrimination loss with the virtual augmentation proposed </li><li>对于随机抽样批次中的每个实例$x_i$，我们优化(i)实例对比损失，通过两次输入同一实例，即x_i和x_i’，表示同一文本实例，得到的dropout诱导增强（这是）；以及(2)邻域约束的实例歧视损失，提出的虚拟增强</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808013627207.png" alt="image-20220808013627207" style="zoom:80%;"><ol><li><p>首先构建邻域，在此基础上进行数据增强，邻域被看做是语义相似的样本，首先使得$B&#x3D;{i}_{i&#x3D;1}^{M}$代表随机采样选取的大小为M的一批数据。我们首先对于第i个实例，选择其最K近邻的邻居$N(i)$（首先将第1个实例的邻域N(i)近似为它在表示空间中的K个最近的邻居）</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801231425045.png" alt="image-20220801231425045" style="zoom:67%;"></li><li><p>定义一个实例级别的对比损失，关于第1个实例和他的邻域</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801231457038.png" alt="image-20220801231457038" style="zoom:67%;"><p>其中<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801232429140.png" alt="image-20220801232429140" style="zoom:50%;">代表perturbed representation<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801232514750.png" alt="image-20220801232514750" style="zoom:50%;">在contrastive learning head的输出表征。这里，初始扰动δi被选为各向同性的高斯噪声。方程（2）显示了将受扰动的第i个实例归类为自身而不是其邻居的负对数可能性。</p><p>即是说，当扰动和自身接近的时候loss小，而当扰动和其他邻居更加接近的时候loss大。这里是在e_i这个表征层面的操作</p></li><li><p>确定上述最佳扰动的方法如下，取最大的扰动（这个扰动的二范式，也就是自身长度大小那种感觉不能超过△，然后这个扰动使得他离K近邻的这些neighbor相对更近，而离自己较远，那么来说的话，这是一个很好的hard样例，扰动了一下但是和原句一个意思，然后又比较难）：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801233016798.png" alt="image-20220801233016798" style="zoom:67%;"></li><li><p>对比学习损失函数如下，将$N_A(i)$表示第i个实例的增强邻域，即<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801234509356.png" alt="image-20220801234509356" style="zoom:50%;">。$e_k$代表原始的第k个实例的嵌入表征，$e_k*$代表相关的增强后的表征。注意这里$e_k*$是以方程（4）中定义的同样方式获得的，关于它自己的邻域$N{(k)}$。然后，我们将第i个实例及其数据增强与它的数据增强邻域$N_A(i)$内的其他实例区分开来，如下所示：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801235339120.png" alt="image-20220801235339120" style="zoom:50%;"><p>即是：分别以第i个实例的增强，和第i个实例作为anchor：原句和其虚拟的困难样本形成positivepair相互拉近，原句和原句的虚拟样本分别于K邻域内的负样本 虚拟困难样本拉远</p></li><li><p>最后再把SimCSE的loss给拼上：对于每个有M个样本的随机抽样的mini-batch B，我们最小化如下的损失函数</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802000523521.png" alt="image-20220802000523521" style="zoom:67%;"></li></ol><p><font color="blue">加上噪声后h1和h1_比较远，h2和h1_有可能比较近；；；保留恒等性又不能太近了</font> </p><h2 id="10-Debiased-Contrastive-Learning-of-Unsupervised-Sentence-Representations"><a href="#10-Debiased-Contrastive-Learning-of-Unsupervised-Sentence-Representations" class="headerlink" title="10. Debiased Contrastive Learning of Unsupervised Sentence Representations"></a>10. Debiased Contrastive Learning of Unsupervised Sentence Representations</h2><h3 id="10-1-简介-amp-总结"><a href="#10-1-简介-amp-总结" class="headerlink" title="10.1 简介&amp;总结"></a>10.1 简介&amp;总结</h3><p>1）motivation是一个非常常见的motivation，就是说抽样得到的负例不一定很可靠，这样基于一个辅助模型搞个阈值判断，辅助模型用的SimCSE；</p><p>2）VAT的虚拟对抗训练方法扩充了一些样本，作为negative；</p><h3 id="10-2-算法实现过程"><a href="#10-2-算法实现过程" class="headerlink" title="10.2 算法实现过程"></a>10.2 算法实现过程</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807100829745.png" alt="image-20220807100829745"></p><p>自己理解：输入一句话“Two dogs are runing”，而随机采样到了两句话“Two dogs are walking”，“A kid is on a skateboard”，其中“Two dogs are walking”这句话和原来那句话明显还是有一定相似的，在推远这两个的过程中我们要把他们的权值设置成0。往下走的positive augumentation可以是SimCSE的这样一个dropout再来一次，此外还用高斯分布最大化不同生成了一些Noise-based Negatives</p><p>DCLR包含三个主要步骤。</p><p>1）我们生成基于噪声的negative来扩展batch内的negative。具体来说，我们首先使用通过随机的高斯噪音来初始化一组新的negative信息，<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023616675.png" alt="image-20220808023616675" style="zoom:50%;">。然后，我们加入了一个基于梯度的算法，通过使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023733094.png" alt="image-20220808023733094" style="zoom:50%;">使非均匀目标最大化来调整基于噪声的否定。经过几次迭代，我们可以得到与整个语义空间内的非均匀点相对应的基于噪声的否定词，并将它们与批量内的否定词混合起来，组成否定词集。</p><p>2）我们采用一个补充模型（即SimCSE）来计算原始句子和负数集的每个例子之间的语义相似度，并使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023824209.png" alt="image-20220808023824209" style="zoom:50%;">产生权重。</p><p>3）最后，我们通过dropout来增加正面的例子，并利用负面的例子和相应的权重来进行对比学习，使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023903791.png" alt="image-20220808023903791" style="zoom:50%;">。</p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl2022_debiased（消除偏置）Contrasitve Learning</title>
    <link href="/2022/08/11/research/papers/contrastive-learning/acl2022_debiased%20CL/"/>
    <url>/2022/08/11/research/papers/contrastive-learning/acl2022_debiased%20CL/</url>
    
    <content type="html"><![CDATA[<h1 id="acl2022-debiased（消除偏置）Contrasitve-Learning"><a href="#acl2022-debiased（消除偏置）Contrasitve-Learning" class="headerlink" title="acl2022_debiased（消除偏置）Contrasitve Learning"></a>acl2022_debiased（消除偏置）Contrasitve Learning</h1><p><strong>Debiased Contrastive Learning of Unsupervised Sentence Representations</strong></p><p>消除偏置的对比学习，用于无监督的句子表征</p><p>个人总结文章的亮点如下：</p><p>1）motivation是一个非常常见的motivation，就是说抽样得到的负例不一定很可靠，这样基于一个辅助模型搞个阈值判断，辅助模型用的SimCSE；</p><p>2）VAT的虚拟对抗训练方法扩充了一些样本，作为negative；</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li><font color="purple"><strong>purple</strong></font>代表待讨论的；<font color="red"><strong>red</strong></font>代表自己批注；<font color="blue"><strong>blue</strong></font>代表讨论中的记录</li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>近期，对比学习已被证明能有效的改善预训练语言模型（pretrained language models，prlm），从而获得高质量的句子表征。他的目标是拉近正面的例子以加强alignment，并推远不相关的负面例子以uniformity一整个表征空间。</p><p><font color="purple">之前还真没这么理解过，那就说明这个拉近正面的是一个alignment，推远负面的也就是之前接触到的一些各向同性可以把他说成一个uniformity</font> </p><p>然而，以前的工作大多数采用批内的作为负样本或者是从训练数据中随机抽取。这样的方式可能会造成抽样偏差，即用不适当的否定词（eg：false negatives和各向异性表征）来学习句子表征，这将损害表征空间的均匀性。</p><p><font color="purple">这个问题感觉也是之前说过很多次的，就是in-batch不一定包含比较合理的，有些本身就可能是相似的，那我们其实不能把他们看做一个negative pair，例如两张狗图片的分别AB A’ B’数据增强</font> </p><p>为了解决这个问题，我们提出DCLR框架（debiased contrastive learning of unsuperivised sentence representations，消除偏置的对比学习用于无监督的句子表征），<strong>以减轻这些不适当的负面因素的影响。</strong>在DLCR中，我们设计了一种实例加权方法来惩罚错误的否定，并生成基于噪声的否定，以保证表示空间的均匀性。</p><p><font color="purple">读到这里的话，实际上感觉和SimCSE那块那个新idea有些像？就是在loss这块权重上有一些做损失的感觉</font> </p><p>在七个语义文本相似性任务上的实验表明，我们的方法比竞争基线更有效。我们的代码和数据可通过以下链接公开获取：</p><p><a href="https://github.com/RUCAIBox/DCLR">https://github.com/RUCAIBox/DCLR</a></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>作为自然语言处理（NLP）领域的一项基本任务，无监督的句子表征学习旨在得出高质量的句子表征，以利于各种下游任务，特别是低资源领域或计算代价昂贵的任务，例如zero-shot文本语义匹配，大规模语义相似性比较，以及文档检索。</p><p>最近，预训练语言模型（BERT等）已经成为一种广泛使用的语义表示方法，在各种NLP任务上取得了显著的性能。然而，一些研究发现，PLM得出的句子原生句子表征在方向上并不是均匀分布的，而是在向量空间中占据一个狭窄的锥体，这在很大程度上限制了其表达能力。<font color="red">这里说的就是存在的各向异性问题</font> </p><p>为了解决这个问题，对比学习已经被采用来完善PLM衍生的句子表征。他将语义上接近的邻居拉到一起以提升alignment，同时将非邻居推开以提升表征空间的uniformity。</p><p><font color="red">如果为别人介绍对比学习任务的时候，可以用这段introduction，感觉这个是读到比较清楚的了，而且涵盖了很多之前的方面</font> </p><p>在学习的过程中，positive和negative的例子都涉及到和原句的对比。对于正面例子，以前的工作在原始句子上应用数据增强策略以产生高度相似的变化。而负面例子通常是从batch或训练数据中随机抽取的，由于负面例子缺乏ground truth的注释。</p><p><strong><font color="purple">这里读到motivation的时候，感觉也是相对有一些和SimCSE扩展的相似性</font></strong> </p><p>虽然这样的负向抽样方式简单方便，但是可能会造成抽样偏差（sampling bias），影响句子的表征学习。</p><ul><li><strong>首先</strong>，取样的否定句很可能是假否定句，他们在语义上与原句接近。如图1中所示的，根据SimCSE模型，在给定的输入句子中，约有一半的in-batch否定句子与原句的余弦相似度超过0.7。它很可能通过简单地推开这些取样的否定词来伤害句子表征的语义。<font color="purple">这里是不是这样的一个逻辑，就是说我确实要推远和负例之间的距离，但是说余弦相似度这么高的，那可能本来就不能算做负例了</font></li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807013958488.png" alt="image-20220807013958488" style="zoom:80%;"><p>图1：一个输入句子和255个来自常用维基百科语料库的批量内否定句之间的余弦相似度分布。它由SimCSE模型进行评估。几乎一半的否定句与输入句有很高的语义相似性。</p><ul><li><strong>其次</strong>，由于各向异性问题（Ethayarajh，2019），采样的否定词的表征来自PLMs所跨越的狭窄表征锥，不能完全反映表征空间的整体语义</li><li>因此，只依靠这些表征来学习句子表征的统一性目标是次优的。</li></ul><p><strong>为了解决上述问题，我们旨在开发一种更好的对比学习方法，采用去偏的负向抽样策略。核心思想是改进随机负向抽样策略，以缓解抽样偏差问题。</strong></p><ul><li><p><strong>首先</strong>：在我们的框架中，我们设计了一个实例加权方法，以惩罚在训练过程中抽样的虚假否定句。我们采用了一个<strong>补充模型</strong>来评估每个否定句与原句之间的相似性，然后为相似性较高的否定句分配较低的权重。通过这种方式，我们可以检测出语义上接近的假否定句，并进一步减少其影响。**<font color="purple">这里是不是真的很接近啊，新的motivation来说，就是从权重设置加权上，去掉那一项会不会本质就是个加权这样的，那比如分母不含h1_1, h1_2，就是一个较小的权值</font>** </p></li><li><p><strong>其次</strong>，我们基于<strong>随机高斯噪音</strong>随机初始化新的否定词，以模拟整个语义空间内的抽样，并<strong>设计了一种基于梯度的算法，将基于噪音的否定词向最不均匀的点优化</strong>。通过学习与非均匀的基于噪声的否定词进行对比，我们可以扩展句子表征的占用空间，并提高表征空间的均匀性。</p></li></ul><p>为此，我们提出了DCLR，一个针对无监督的句子表征的去偏对比学习通用框架：</p><ul><li>在我们的方法中，我们首先从高斯分布中初始化基于噪声的否定词，并利用基于梯度的算法，通过考虑表示空间的均匀性来更新新的否定词；</li><li>然后，我们采用互补模型来产生这些基于噪声的否定句和随机抽样的否定句的权重，其中错误的否定句将受到惩罚；</li><li>最后，我们通过dropout（SimCSE）来增加正面的例子，并将它们与上述加权的负面例子结合起来，进行对比学习；</li></ul><p>我们证明，我们的DCLR在七个语义文本相似性（STS）任务上，使用BERT和RoBERTa，优于一些竞争基准。</p><p>我们的贡献被归纳为以下几点：</p><p>（1）据我们所知，我们的方法是第一次尝试在无监督的句子表征的对比学习中减少采样偏差。</p><p>（2）我们提出了DCLR，这是一个去偏化的对比学习框架，它包含了<strong>一个实例加权方法来惩罚错误的否定</strong>，并<strong>生成基于噪声的否定</strong>来保证表示空间的统一性。</p><p>（3）七项语义文本相似性任务的实验结果显示了我们框架的有效性</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>在本节中，我们从以下三个方面回顾相关工作。</p><h3 id="2-1-Sentence-Representation-Learning"><a href="#2-1-Sentence-Representation-Learning" class="headerlink" title="2.1 Sentence Representation Learning"></a>2.1 Sentence Representation Learning</h3><p>暂时略过了</p><h3 id="2-2-Contrastive-Learning"><a href="#2-2-Contrastive-Learning" class="headerlink" title="2.2 Contrastive Learning"></a>2.2 Contrastive Learning</h3><p>暂时略过了</p><h3 id="2-3-Virtual-Adversarial-Traning"><a href="#2-3-Virtual-Adversarial-Traning" class="headerlink" title="2.3 Virtual Adversarial Traning"></a>2.3 Virtual Adversarial Traning</h3><p>虚拟对抗训练（VAT）用可学习的噪声对给定的输入进行扰动，以使模型的预测与原始标签的分歧最大化，然后利用扰动的例子来提高泛化能力。**一类虚拟对抗训练方法可以被表述为解决一个最小-最大问题，这可以通过多个投影梯度上升步骤实现(Qin et al., 2019)**。<font color="red">这篇会不会之后还可以看看，听起来像是比较通用的方法</font> </p><p><font color="purple">这个地方其实不是很看的懂，原文的表示是这样：Virtual adversarial training (VAT) perturbs a given input with learnable noises to maximize the divergence of the model’s prediction with the original label, then utilizes the perturbed examples to improve the generalization</font> </p><p>在NLP领域，一些研究在嵌入层中进行对抗性扰动，并显示其在文本分类（Miyato等人，2017）、机器翻译（Sun等人，2020）和自然语言理解（Jiang等人，2020）任务上的有效性。</p><h2 id="3-Preliminary"><a href="#3-Preliminary" class="headerlink" title="3. Preliminary"></a>3. Preliminary</h2><p><font color="red">还是很少看到这个章节的出现，作为一种预先说明的知识，不占用approach部分的篇幅？</font> </p><p>这项工作的目的是利用无标签语料库学习有效的句子表征，这些表征可以直接用于下游任务，如语义文本相似性任务。给定一组输入语句$X&#x3D;{x_1,x_2,…,x_n}$，目标是在无监督的情况下为每个$x_i$学习表征$h_i\in R^d$。为了简单起见，我们用一个参数化的函数来表示这个过程$h_i&#x3D;f(x_i)$</p><p>在这项工作中，我们主要关注使用基于BERT的PLMs来生成句子表征。按照现有的工作，我们通过我们提出的无监督学习方法在未标记的语料库上微调PLM。之后，对每个句子$x_i$，我们用微调的PLM进行编码，并将最后一层的[CLS]标记的表示作为其句子表示$h_i$</p><p><font color="red">这篇文章感觉很适合作为一个入口给别人介绍CL这个任务，他能指向很多地方</font> </p><h2 id="4-Approach"><a href="#4-Approach" class="headerlink" title="4. Approach"></a>4. Approach</h2><p>我们提出的DCLR框架侧重于减少句子表征的对比学习中采样偏差的影响。</p><p>在这个框架中，我们设计了一个基于噪声的负数生成策略，以减少各向异性PLM衍生的表征所造成的偏差，以及一个实例加权方法，以减少虚假negative造成的偏差。<font color="purple">一方面生成negative，一方面把原来的伪hard-negative拉近</font> </p><p>具体来说，我们根据高斯分布初始化基于噪声的negative，并迭代更新这些negative以达到非均匀性最大化。然后，我们利用一个<strong>互补模型</strong>为所有的negative（即随机抽样的和基于噪声的negative）产生权重。最后，我们将加权的negative和增强的positive结合起来进行对比学习。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807100829745.png" alt="image-20220807100829745"></p><p>图2自己理解：输入一句话“Two dogs are runing”，而随机采样到了两句话“Two dogs are walking”，“A kid is on a skateboard”，其中“Two dogs are walking”这句话和原来那句话明显还是有一定相似的，在推远这两个的过程中我们要把他们的权值设置成0。往下走的positive augumentation可以是SimCSE的这样一个dropout再来一次，此外还用高斯分布最大化不同生成了一些Noise-based Negatives</p><h3 id="4-1-Generating-Noise-based-Negatives"><a href="#4-1-Generating-Noise-based-Negatives" class="headerlink" title="4.1 Generating Noise-based Negatives"></a>4.1 Generating Noise-based Negatives</h3><p>生成基于噪声的negatives</p><p>我们的目标是在训练过程中，在PLM的句子表示空间之外产生新的否定词，以缓解PLM的各向异性带来的抽样偏差。</p><p>对于每个输入句子xi，我们首先从高斯分布中<strong>初始化k个噪声向量作为负向表示</strong>：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807124158286.png" alt="image-20220807124158286" style="zoom:80%;"><p>其中$\sigma$是标准差。由于这些向量是从这样的高斯分布中随机初始化的，因此他们在整个语义空间中是均匀分布的。通过学习与这些新的否定词进行对比。通过学习与这些新的否定词进行对比，有助于句子表述的统一性。<font color="purple">这个有点不明白，他随机了这些，就认为这些随机的和什么都没关系作为negative，那么随机的这些在数量量级上，会和之前是一样的吗？</font> </p><p>为了进一步提高否定词的质量，我们考虑迭代更新否定词，以捕捉整个语义空间内的非均匀性点。受到VAT（虚拟对抗训练）的启发，我们设计了一个非均匀性损失最大化的目标，以产生梯度来改善这些negative。非均匀性损失被表示为基于噪声的否定词<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807141043906.png" alt="image-20220807141043906" style="zoom:33%;">之间的对比性损失：<font color="red">（拉近正例h_i和h_i+，推远负例h_i和^h_i）</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220807141107163.png" alt="image-20220807141107163" style="zoom:80%;"><p><font color="purple">感觉对这个式子的理解还不是很到位，<strong>他这个分母看起来就像是不包含分子那一项了</strong>，那么拉近正例可能是一个拉近自己和自己另外一种dropout这样的方式，推远负例在这个式子中似乎只表示出来了推远和Noise-based Negatives的那一项，而还不涉及到和randomly sampled negatives之间的推远</font> </p><p>其中$\tau_{u}$是温度常数，sim相似度使用的是余弦相似度。在此基础上，对于每个negative<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808020550477.png" alt="image-20220808020550477" style="zoom:50%;">，我们通过t步<strong>梯度上升法</strong>对其进行优化，即：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808020645480.png" alt="image-20220808020645480" style="zoom:80%;"><p>其中$\beta$是学习率，$||·||$是二范数，$g(\hat{h}_j)$表示$\hat{h}_j$的梯度，通过最大化正反馈和基于噪声的负反馈之间的非均匀性损失来实现（by maximizing the non-uniformity loss between the positive rep- resentations and the noise-based negatives）。</p><p>这样一来，基于噪音的否定词将被优化到句子表征空间的非均匀点。通过学习与这些否定词的对比，可以进一步提高表示空间的均匀性，这对有效的句子表示至关重要。<font color="purple">最大化这个损失，然后来做梯度上升？我最开始初始化的否定词那么是一个各项同性的一个很均匀的分布，他们将被优化到句子表征空间中的非均匀点，进一步把这些用作否定词对比，怎么来提升表示空间的均匀性？</font> </p><p><font color="red">这里完全是一个Virtual adversarial training的过程，感觉自己对这个了解还不是很到位，正好顺着这里了解一下，<a href="https://zhuanlan.zhihu.com/p/549605526?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=677587051885629440&amp;utm_campaign=shareopn">https://zhuanlan.zhihu.com/p/549605526?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=677587051885629440&amp;utm_campaign=shareopn</a></font></p><h3 id="4-2-Contrastive-Learning-with-Instance-Weighting"><a href="#4-2-Contrastive-Learning-with-Instance-Weighting" class="headerlink" title="4.2 Contrastive Learning with Instance Weighting"></a>4.2 Contrastive Learning with Instance Weighting</h3><p>基于实例加权的对比学习，除了上述基于噪声的否定词，我们还遵循现有的工作），采用其他batch内表示作为否定词${\tilde{h}^{-}}$。正如前面讨论的，抽样的否定句可能包含与positive instance有相似语义的例子（举例：false negatives）</p><p><font color="purple">这个问题其实早就有所注意到，这么抽样的时候必将带来这样的问题，那么前面读过的大多数论文好像还真没有从这个方面来进行解决的，另外之前那篇token-aware的文章，这个问题如果能解决的话应该会能够更好的提升吧</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808022241671.png" alt="image-20220808022241671" style="zoom:67%;"><p>为了缓解这个问题，我们提出了一种实例加权的方法来惩罚false-negative。由于我们无法获得真实的标签或语义相似性，我们利用一个<strong>补充模型（complementary model）</strong>来产生每个负数的权重。在本文中，我们采用最先进的SimCSE作为补充模型。从${\tilde{h}^{-}}$或者${\hat{h}}$中给定一个negative表征$h^{-}$，以及原始的句向量表征$h_i$，我们利用补充模型产生的权重为：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808022623359.png" alt="image-20220808022623359" style="zoom:80%;"><p>其中$\phi$是一个实例阈值超参数，$sim_C(h_i,h^{-})$是由<strong>互补模型</strong>评估的余弦相似度得分。<strong>这样一来，与原句表征有较高语义相似性的否定句将被视为假否定句，并将被赋予0的权重进行惩罚。</strong></p><p><font color="purple">这个方法听起来还是相当合理的，不知道为什么之前的论文好像在这里操作较少，另外这个方法用在token级别上会不会很有用啊？</font> </p><p>在权重的基础上，我们用一个去中心化的交叉熵对比学习损失函数来优化句子表征，即：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023124529.png" alt="image-20220808023124529" style="zoom:80%;"><p><font color="purple">这个分母也是不包含正向的，他这个好像从各种motivation上都很像</font> </p><p>其中τ是一个温度超参数。在我们的框架中，我们遵循SimCSE的做法，即利用dropout来增加正面的例子$h_{i}^{+}$。实际上，我们可以利用各种积极的增强策略，并将在第6.1节中对其进行研究。</p><p><font color="blue">BERT的表征依赖句法层面，特别长的句子只有一个词不一样，大概率他们的Similarity是非常接近的-&gt;但也有可能是hard-negative，有可能就筛掉了一批hard-negative</font> </p><h3 id="4-3-Overview-and-Discussion"><a href="#4-3-Overview-and-Discussion" class="headerlink" title="4.3 Overview and Discussion"></a>4.3 Overview and Discussion</h3><p>在这一部分，我们介绍了我们的DCLR方法的概述和讨论</p><h4 id="4-3-1-Overview-of-DCLR"><a href="#4-3-1-Overview-of-DCLR" class="headerlink" title="4.3.1 Overview of DCLR"></a>4.3.1 Overview of DCLR</h4><p>我们的框架DCLR包含三个主要步骤。</p><p>1）我们生成基于噪声的negative来扩展batch内的negative。具体来说，我们首先使用通过随机的高斯噪音来初始化一组新的negative信息，<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023616675.png" alt="image-20220808023616675" style="zoom:50%;">。然后，我们加入了一个基于梯度的算法，通过使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023733094.png" alt="image-20220808023733094" style="zoom:50%;">使非均匀目标最大化来调整基于噪声的否定。经过几次迭代，我们可以得到与整个语义空间内的非均匀点相对应的基于噪声的否定词，并将它们与批量内的否定词混合起来，组成否定词集。</p><p>2）我们采用一个补充模型（即SimCSE）来计算原始句子和负数集的每个例子之间的语义相似度，并使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023824209.png" alt="image-20220808023824209" style="zoom:50%;">产生权重。</p><p><font color="red">这个阈值设置还是很高的，0.85 0.9这个级别</font> </p><p>3）最后，我们通过dropout来增加正面的例子，并利用负面的例子和相应的权重来进行对比学习，使用<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808023903791.png" alt="image-20220808023903791" style="zoom:50%;">。</p><h3 id="4-3-2-Discussion"><a href="#4-3-2-Discussion" class="headerlink" title="4.3.2 Discussion"></a>4.3.2 Discussion</h3><p>如上所述，我们的方法旨在减少关于negative的抽样偏差的影响，并且与各种积极的数据增强方法（例如，token cutoff和dropout）无关。<font color="red">这里会不会在说这些是能够同时作用的</font> 与传统的对比学习方法相比，我们提出的DCLR通过<strong>引入基于噪声的否定词来扩展否定词集</strong>，并<strong>增加一个权重项来惩罚虚假否定词</strong>。由于基于噪声的否定词是从高斯分布中初始化的，并不对应于真实的句子，因此它们是高度自信的否定词，可以扩大表示空间。通过学习与它们进行对比，对比性目标的学习将不会受到来自PLM的各向异性表征的限制。因此，句子表征可以跨越更广泛的语义空间，表征语义空间的统一性（uniformity）也可以得到改善。</p><p>此外，我们的实例加权方法也缓解了随机抽样策略造成的false negative问题。在补充模型的帮助下，那些与原句语义相似的false negative句子将被检测出来并受到惩罚。</p><h2 id="5-Experiments-Main-Results"><a href="#5-Experiments-Main-Results" class="headerlink" title="5. Experiments - Main Results"></a>5. Experiments - Main Results</h2><h3 id="5-1-Experiment-Setup"><a href="#5-1-Experiment-Setup" class="headerlink" title="5.1 Experiment Setup"></a>5.1 Experiment Setup</h3><p>追随之前的工作，我们在7个文本语义相似度（Semantic Textual Similarity，STS）任务上测试我们的性能。对于所有的工作，我们使用SentEval tookit用于evaluation；</p><ul><li><p><strong>Semantic Textual Similarity Task</strong>. We evaluate our approach on 7 STS tasks: STS 2012–2016, STS Benchmark and SICK-Relatedness. 这些数据集包含成对的两个句子，其相似性分数被标记为0到5。golden annotations和句子表征预测的score之间的相关性由Spearman关联度来衡量。根据以前工作的建议，我们直接计算所有STS任务的句子嵌入之间的余弦相似度。</p></li><li><p><strong>Baseline Methods</strong>: 一系列非BERT和基于BERT的方法，其中BERT那个还探讨了[CLS] mean first-last AVG的方法</p></li><li><p>implementation details: Huggingface’s transformers；</p><ul><li>BERT-base and RoBERTa-base：start from the pre-trained checkpoints of their original papers；</li><li>BERT-large and RoBERTa- large：utilize the checkpoints of SimCSE for stabilizing the convergence process</li></ul><p>Following SimCSE，我们使用从维基百科中随机抽取的1,000,000个句子作为训练语料。……</p></li></ul><h3 id="5-2-Main-Results"><a href="#5-2-Main-Results" class="headerlink" title="5.2 Main Results"></a>5.2 Main Results</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808111904230.png" alt="image-20220808111904230"></p><p><font color="red">在large的上满指标上升好像不明显</font> </p><p>为了验证我们的框架在PLM上的有效性，我们选择BERT-base和RoBERTa-base作为基础模型。表1显示不同方法七个STS任务上的结果。根据结果，我们可以发现，非BERT方法（即GloVe和USE）的表现大多优于基于PLM表示法的本地基线（i.e., CLS Mean and First-Last AVG）<font color="red">BERT这边说的是CLS直接用那种吧，直接用基本性能就直接崩了</font> 。原因是，直接利用PLM的原始表征很容易受到各向异性的影响。在非BERT方法中，USE的表现优于Glove。一个潜在的原因是USE使用Transformer模型对句子进行编码，这比简单的平均GloVe embeddings更有效。</p><p>对于其他基于PLM的方法，首先，我们可以看到flow和whiteening取得了类似的结果，并以一定的幅度超过了基于原始表征的方法。这两种方法采用特定的改进策略来完善PLM的表征。<strong>第二，基于对比学习的方法在大多数情况下优于其他基线</strong>。对比学习可以提高语义相关的positive pair之间的一致性和使用阴性样本的表示空间的统一性，从而获得更好的句子表示。<strong>此外，SimCSE在所有基线中表现最好。这表明dropout是一种比其他方法更有效的正向增强方法，因为它很少伤害到句子的语义。</strong></p><p>最后，DCLR在大多数情况下比所有的基线表现得更好，包括基于对比学习的方法。由于这些方法大多利用随机抽样的否定句（如批内否定句）来学习所有句子表征的统一性，它可能导致抽样偏差，如虚假否定句和各向异性表征。与这些方法不同的是，我们的框架采用了一种实例加权的方法来惩罚错误的否定，并采用一种基于梯度的算法来生成基于噪声的否定，向非均匀性的点倾斜。这样一来，采样偏差问题可以得到缓解，我们的模型可以更好地学习均匀性，以提高句子表征的质量。<font color="purple">又强调了一下motivation，这里感觉还是挺合理的，本来在抽样的时候就可能会有这样的问题</font> </p><h2 id="6-Experiment-Analysis-and-Extension"><a href="#6-Experiment-Analysis-and-Extension" class="headerlink" title="6. Experiment - Analysis and Extension"></a>6. Experiment - Analysis and Extension</h2><p>在本节中，我们将继续研究我们提出的DCLR的有效性。</p><h3 id="6-1-Debiased-Contrastive-Learning-on-Other-Methods"><a href="#6-1-Debiased-Contrastive-Learning-on-Other-Methods" class="headerlink" title="6.1 Debiased Contrastive Learning on Other Methods"></a>6.1 Debiased Contrastive Learning on Other Methods</h3><p>由于我们提出的DCLR是一个通用框架，主要侧重于无监督句子表征的对比学习的负向采样，它可以应用于<strong>其他依靠不同的正向数据增强</strong>策略的方法。因此，在这一部分，我们进行了实验，以检验我们的框架是否能通过以下积极的数据增强策略带来改进：</p><p>（1）Token Shuffling 随机把输入序列中的tokens shuffle；</p><p>（2）Feature&#x2F;Token&#x2F;Span Cutoff 随机删除输入中的特征&#x2F;token&#x2F;span；</p><p>（3）Dropout 类似于SimCSE，请注意，我们只修改了消极的采样策略，以实现我们的DCLR的这些变体；</p><p><font color="purple">他是一个在负例那边做文章比较多的，那么可以与其他从正向那边的工作来结合</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808114738327.png" alt="image-20220808114738327" style="zoom:80%;"><p>如图3所示，我们的DCLR可以提高所有这些增强策略的性能，它显示了我们的框架与各种增强策略的有效性。此外，在所有的变体中，Dropout策略导致了最好的性能。这表明Dropout是一种更有效的增强高质量positive的方法，<strong>也更适合于我们的方法</strong>。</p><p><font color="red">这个是一定的吧，或者说他尝试了一下与别人结合，一边positive做文章，一边negative做文章</font> </p><h3 id="6-2-Ablation-Study"><a href="#6-2-Ablation-Study" class="headerlink" title="6.2 Ablation Study"></a>6.2 Ablation Study</h3><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808115118275.png" alt="image-20220808115118275" style="zoom:80%;"><p>我们提出的DCLR结合了实例加权方法来惩罚错误的否定，还利用了基于噪音的否定来提高整个句子表示空间的统一性。为了验证它们的有效性，我们对七个STS任务中的两个组件分别进行了消减研究，并报告了Spearman相关度的平均值。如表2所示，去除每个组件都会导致性能下降。这表明实例加权法和基于噪声的否定句在我们的框架中都很重要。此外，去除实例加权方法会导致更大的性能下降。原因可能是错误的负面因素对句子表示学习有较大的影响。</p><p><font color="red">这里是不是表格还是话写错了，看起来w&#x2F;o Noise-based Negative性能下降更大一点？</font> </p><p>此外，我们还准备了三种变体供进一步比较。</p><p>（1）Random Noise：直接生成基于噪声的negative，不需要基于梯度的优化；</p><p>（2）Knowledge Distillation（知识蒸馏）：利用SimCSE作为教师模型，在培训期间将知识提炼到学生模型中。</p><p>（3）SelfInstance Weighting：采用模型本身作为补充模型来生成权重</p><p>从表2中，我们可以看到这些变化的表现不如原始的DCLR。这些结果表明第4节中提出的设计更适合我们的DCLR框架。</p><h3 id="6-3-Uniformity-Analysis"><a href="#6-3-Uniformity-Analysis" class="headerlink" title="6.3 Uniformity Analysis"></a>6.3 Uniformity Analysis</h3><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808115803724.png" alt="image-20220808115803724" style="zoom:80%;"><p>省略一些理论的部分</p><p>如图4所示，几乎在整个训练过程中，DCLR的均匀性损失要比SimCSE的低得多。此外，我们可以看到，随着训练的进行，DCLR的均匀性损失下降得更快，而SimCSE的均匀性损失则没有明显的下降趋势。这可能是因为我们的DCLR在表示空间之外对基于噪声的否定句进行了采样，这可以更好地提高句子表示的均匀性。</p><h3 id="6-4-Performance-under-Few-shot-Settings"><a href="#6-4-Performance-under-Few-shot-Settings" class="headerlink" title="6.4 Performance under Few-shot Settings"></a>6.4 Performance under Few-shot Settings</h3><p>为了验证DCLR在数据稀缺情况下的可靠性和稳健性，我们使用BERT-base作为骨干模型进行了少量实验。我们通过从100%到极小规模（即0.3%）的不同数量的可用训练数据训练我们的模型。我们报告了对STS-B和SICK-R任务的评估结果。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808120050928.png" alt="image-20220808120050928" style="zoom:80%;"><p>如图5所示，我们的方法在不同比例的训练数据下取得了 在不同比例的训练数据下取得了稳定的结果。在数据比例为0.3%的最极端情况下，我们的模型在STS-B和SICK-R上的性能分别只下降了9%和4%。这些结果揭示了我们的方法在数据稀缺的情况下的稳健性和有效性。这种特性在现实世界的应用中是很重要的。</p><h3 id="6-5-Hyper-parameters-Analysis"><a href="#6-5-Hyper-parameters-Analysis" class="headerlink" title="6.5 Hyper-parameters Analysis"></a>6.5 Hyper-parameters Analysis</h3><p>对于超参数分析，我们研究了实例加权阈值$\phi$和基于噪声的阴性体的比例k的影响。这两个超参数在我们的框架中都很重要。具体来说，我们在STS-B和SICK-R任务中使用BERT-基础模型，用不同的$\phi$和k的值来评估我们的模型。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220808120206792.png" alt="image-20220808120206792" style="zoom:80%;"><ul><li>Weighting threshold：</li></ul><p>图6(a)显示了实例加权阈值$\phi$的影响。对于STS-B任务，$\phi$对模型性能有很大影响。过大或过小的$\phi$都可能导致性能下降。原因是较大的阈值不能实现有效的惩罚，而较小的阈值可能会导致对真否定的误判。相反，SICK-R对$\phi$的变化不敏感。原因可能是在这个任务中，假阴性的问题并不严重。</p><ul><li>Negative proportion:</li></ul><p>当基于噪声的否定词的数量接近批量大小时，我们的DCLR表现得更好。在这种情况下，基于噪声的否定词更能够增强整个语义空间的统一性，而不损害对齐性，这也是DCLR表现良好的关键原因。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7. Conclusion"></a>7. Conclusion</h2><p>在本文中，我们提出了DCLR，一个用于无监督的句子表征学习的去中心化的对比学习框架。我们的核心思想是缓解由随机负向抽样策略引起的抽样偏差。为了实现这一目标，在我们的框架中，我们采用了一种实例加权的方法来惩罚训练过程中的错误否定，并产生了基于噪声的否定，以减轻各向异性的PLM衍生的代表的影响。在七个STS任务上的实验结果表明，我们的方法优于几个有竞争力的基线</p><p>在未来，我们将探索其他方法 来减少句子表征的对比性学习中的偏差（例如，debaised的预训练）。此外，我们还将考虑将我们的方法用于多语言或多模态表征学习。</p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl2021_CL-for-BERT-Sentence Representations论文阅读</title>
    <link href="/2022/08/07/research/papers/contrastive-learning/acl2021_CL-for-BERT-Sentence%20Representations%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/08/07/research/papers/contrastive-learning/acl2021_CL-for-BERT-Sentence%20Representations%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="acl2021-CL-for-BERT-Sentence-Representations论文阅读"><a href="#acl2021-CL-for-BERT-Sentence-Representations论文阅读" class="headerlink" title="acl2021_CL-for-BERT-Sentence Representations论文阅读"></a>acl2021_CL-for-BERT-Sentence Representations论文阅读</h2><p>论文全称：Self-Guided Contrastive Learning for BERT Sentence Representations</p><p>总结贡献：</p><ul><li>两个bert构造正负例：①一个参数不参与优化的Bert，对所有层的transformer隐藏层做maxpooling，即(batch,len,768)-&gt;(batch,1,768)，再取均值作为句子的输出表征；②一个参数优化的bert，直接用最后一层[CLS]作为句子表征；来自同一句话的①②表征构成正例，不同句子的①②表征作为负例。</li><li>主要用于STS语义相似度的任务，直接得到BERT表征而不依赖于数据进行fine-tune，无监督的得到初始比较好的句子representation</li><li><strong>创新点：表示学习句子的[CLS]token，可被文本语义相似STS任务直接用，而且不依赖label数据的训练？</strong></li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/qq_33161208/article/details/123631813">https://blog.csdn.net/qq_33161208/article/details/123631813</a>  # ACL2021 | 对比学习8篇论文一句话总结</p><p><a href="https://www.jianshu.com/p/c33a79603f43">https://www.jianshu.com/p/c33a79603f43</a> # NT-Xent loss</p><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>尽管BERT及其变体已经重塑了NLP的格局，<strong>但如何从这种预先训练好的Transformer中最好地推导出句子嵌入（sentence embeddings）仍然是不清楚的</strong>。在这项工作中，我们提出了一种对比性学习方法，利用self-attention来提高BERT句子表示的质量。作者提出的方法以self-supervised的方式对BERT进行微调，不依赖数据的增强，并使用通常的[CLS]token嵌入作为句子向量发挥作用。此外，作者重新设计了对比性学习目标NT-Xent，并将其应用于句子表示学习。</p><p>通过大量的实验证明，该方法在各种与句子有关的任务上比竞争baseline更有效。还证明了它在推理方面的效率和对领域转移的稳健性。</p><p><font color="red">作者似乎认为使用[CLS]这个token的方法有待商榷，然后在experiment那边STS（Semantic Textual Similarity，语义文本相似性） task是用来评估这个句子表征的</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><font color="red">自己对Introduction章节的理解是综述研究背景，综述一下别人的方法和存在的不足，最后再说一下自己的方法和主要贡献，大概就按照这几个方面总结一下Introduction章节</font> </p><h3 id="1-1-综述别人的方法和存在的不足"><a href="#1-1-综述别人的方法和存在的不足" class="headerlink" title="1.1 综述别人的方法和存在的不足"></a>1.1 综述别人的方法和存在的不足</h3><p><font color="red">这个地方研究背景作者似乎很快就带过了，不单独列为一个章节了</font> </p><p>预训练的Transformer语言模型，如BERT、RoBERTa等已经成为最近实现自然语言理解改进的重要组成部分。然而，直接将这些模型用于句子级别的任务并不简单，因为他们基本上是预先训练好的，专注于预测给定上下文的子单词标记<font color="red">（MLM？）</font> 。将这些模型转化为句子编码器的最典型方式是在下游任务的监督下对其进行微调，在这个过程中，BERT作者提出将编码器最后一层[CLS]token的嵌入看做输入序列的代表。这种简单而有效的方法是可能的，因为在监督微调期间，**[CLS]嵌入作为预训练编码器和任务特定层之间的唯一通信门**，鼓励[CLS]向量捕捉整体信息。</p><p><font color="red">TODO：待和zkh讨论，为什么通过[CLS]token的下游监督就能对整个BERT Encoder进行微调，或者说就是通过这一个，前面所有层的参数就都会跟着变了？</font> </p><p>另一方面，在标记数据集不可用的情况下，不清楚从BERT推导句子embedding的最佳策略是什么。以前的研究指出，没有任何处理的使用[CLS] token作为句子的表示，就像监督微调一样<font color="red">（这句话没有理解，从英文上好像是差不多的意思，不清楚作者想表达的是不是不进行监督微调，直接使用？）</font> 结果令人失望。目前，在没有监督的情况下构建BERT语句嵌入最常见的经验法则是在BERT的最后一层应用mean pooling。<font color="red">（这里BERT最后有个pooler，这里的mean pooling是指的那个地方吗，听起来好像不像。）</font> 然而，这种方法可能是次优的，在一个初步的实验中，作者通过采用不同的BERT层和池化方法的不同组合来构建句子embedding，并在语义文本相似性（STS）基准数据集上进行测试。<strong>以Spearman相关度（×100）来衡量</strong><font color="red">（暂时还不太了解这个指标，看起来是越高越好？）</font> ，<font color="green"><strong>作者发现，选用不同层BERT-base [CLS]token的输出，还有在不同层之间选择池化方法，都对性能很有影响，而且看起来浮动很大。</strong></font> </p><p><font color="red">作者使用了一个完全没有经过fine-tune的BERT进行训练，发现各层通过不同方法对句子的表征是有一定差异的，从而质疑BERT句子向量的做法还不够扎实，还有余地发挥BERT的更多表现力<strong>不过这里有没有一种可能，就是这个评估方法不太合理？还是对这个评估方法不太了解了</strong></font> </p><p><font color="red"><strong>或者说，作者认为无论是简单粗暴取各层的[CLS]token，还是做mean&#x2F;max pool，直接选用这些向量的做法都不好，需要把这些融合到一块来？这样作者的一个很大的亮点在于不需要数据的增强（有别于CL范式中的数据增强），而是直接用这些预训练[CLS]就可以</strong></font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713003533058.png" alt="image-20220713003533058" style="zoom:50%;"><p>注：图中SG-OPT和SG是作者的方法产生了大幅的提升，具体方法将在后面进行说明；</p><h3 id="1-2-作者提出的方法"><a href="#1-2-作者提出的方法" class="headerlink" title="1.2 作者提出的方法"></a>1.2 作者提出的方法</h3><p>在这项工作中，作者提出了一种对比性学习（CL）方法，利用新提出的self-attention机制来解决上述问题。<strong>其核心思想是将中间的BERT隐藏表征作为正样本进行回收，最终的句子嵌入应该与之接近。</strong></p><p>由于作者的方法不需要数据增强，而数据增强在最近的对比学习框架中是必不可少的，因此它比现有的方法要简单和容易使用。此外，我们定制了<strong>NT- Xent损失</strong>（Chen et al., 2020），一个广泛用于计算机视觉的对比学习目标，以更好地使用BERT进行句子表示学习。我们证明，我们的方法在各种环境下都优于为建立BERT句子向量而设计的竞争性基线。通过全面的分析，我们还表明，我们的方法在推理方面比基线更有效率，而且对领域的转变更加稳健。</p><p><font color="red">这里NT-Xent损失就是SimCLR中给出的损失函数，避免了正例自己和自己的pair计算：<a href="https://www.jianshu.com/p/c33a79603f43">https://www.jianshu.com/p/c33a79603f43</a></font></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713005132679.png" alt="image-20220713005132679"></p><p>SimCLR分母中 <img src="https://math.jianshu.com/math?formula=1_%7B%5Bk%5Cneq%20i%5D%7D" alt="1_{[k\neq i]}">排除的是样本和自身的相似度，仍然没有排除正例（正例是样本及其增广)。负样本对由样本和任意其他样本和样本变换组成，共有2N-2个负样本对。 <font color="red">当时SimCLR有个问题是一组batch里面，可能两张猫但是被当做negative pair了</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713182734788.png" alt="image-20220713182734788"></p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p><font color="red">related work章节主要感觉是分门别类的总结一下之前的方法，再引一下之前方法的不足，说一下自己方法的好处</font> </p><h3 id="2-1-Contrastive-Representation-Learning"><a href="#2-1-Contrastive-Representation-Learning" class="headerlink" title="2.1 Contrastive Representation Learning"></a>2.1 Contrastive Representation Learning</h3><p>对比性学习长期以来被认为是构建有意义的表征的有效方法。<font color="red">这里主要说的一些NLP相关的</font> </p><ul><li>Mikolov等人（2013）提出通过将目标词附近的词作为正面样本，而将其他词作为负面样本来学习词嵌入。</li><li>Logeswaran和Lee（2018）将Mikolov等人（2013）的方法推广到句子表示学习。</li><li>最近，一些研究（Fang和Xie，2020；Giorgi等人，2020；Wu等人，2020）建议利用对比学习来训练转化器模型，与作者方法类似</li></ul><p><strong>然而作者指出，这些方法一般需要数据增强技术，例如回译或训练数据的先验知识，而作者的方法不需要这一点。此外，作者专注于修改BERT以计算更好的句子嵌入，而不是从头开始训练一个语言模型。</strong></p><p>另一方面，对比性学习也受到了计算机视觉接的广泛关注，作者通过优化其学习目标来改变Chen等人的框架，以实现基于Transformer的预训练的句子表示学习。<font color="red">这里说的就是SimCLR</font> </p><h3 id="2-2-Fine-tunning-BERT-with-Supervision"><a href="#2-2-Fine-tunning-BERT-with-Supervision" class="headerlink" title="2.2 Fine-tunning BERT with Supervision"></a>2.2 Fine-tunning BERT with Supervision</h3><p>要成功的fine-tune巨大的预训练Transformer模型绝对不是简单的事情，特别是当目标领域数据的数量有限时。为了缓解这其中的稳定性问题，已有一些研究者提出了各种方法。特别的，Gunel等人（2021）提出<strong>在目标任务的监督下</strong>，在微调BERT过程中利用对比学习作为辅助训练目标。相比之下，<strong>我们处理的是在没有这种监督的情况下调整BERT的问题。</strong></p><p><font color="red">也就是说作者这个方法好像不依赖于下游任务，直接用句子的representation进行CL？这里不确定作者最终评估的目标是不是直接就是BERT的那个表征token，而不微调下游，直接应用在一些能表征STS语义文本相似性指标的数据集上</font> </p><h3 id="2-3-Sentence-Embeddings-from-BERT"><a href="#2-3-Sentence-Embeddings-from-BERT" class="headerlink" title="2.3 Sentence Embeddings from BERT"></a>2.3 Sentence Embeddings from BERT</h3><p><font color="green"><strong>由于BERT及其变体最初被设计为在每个下游任务上进行fine-tune以达到最优性能，因此如何从他们中提取一般句子的表征仍然是模糊的，这在不同的句子相关任务中广泛适用。</strong></font> </p><ul><li><p>继Conneau等人（2017）之后，Reimers和Gurevych（2019）（SBERT）提议通过在BERT的最后一层进行平均池化来计算句子嵌入，然后在自然语言推理（NLI）数据集上对池化的向量进行微调（Bowman等人，2015；Williams等人，2018）。<font color="red">sentenceBERT</font> </p></li><li><p>同时，其他一些研究集中在更有效地利用BERT中嵌入的知识来构建没有监督的句子嵌入。具体来说，Wang和Kuo（2020）提出了一种基于线性代数算法的池化方法，<strong>从BERT的中间层中抽取句子向量</strong>。Li等人（2020）建议<strong>从BERT最后两层获得的嵌入的平均值中</strong>学习一个使用流模型的球形高斯分布的映射，并利用重新分配的嵌入来代替原始BERT表示。</p></li></ul><p>作者遵循Li等人（2020）的设置，在训练期间只利用纯文本，然而，与所有其他即使在训练后也依赖某种池化方法的人不同，我们直接完善了BERT，<strong>使典型的[CLS]向量可以作为句子嵌入的功能。</strong></p><h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p>Overview&amp;some motivation</p><p>由于BERT大多需要某种类型的adaption以正确的应用于感兴趣的任务，<font color="green"><strong>因此，直接从BERT中得出句子的嵌入而不进行微调可能是不可取的。</strong></font> 虽然Reimers和Gurevych（2019）试图通过典型的监督微调来缓解这个问题，但我们限制自己以无监督的方式修改BERT，这意味着我们的方法只需要一堆原始句子来训练。<font color="red"><strong>只需要句子，不需要label，self-supervised?</strong></font> </p><p>在可能的无监督学习策略中，我们专注于对比性学习，对比性学习可以内在的促使bert意识到不同句子嵌入之间的相似性。考虑到句子向量被广泛用于计算两个句子的相似性，对比性学习所引入的归纳偏置有助于BERT在此类任务中的良好工作。问题是，句子层面的对比学习通常需要数据增强，或训练数据的先验知识，例如顺序信息以做出可信的正&#x2F;负样本。我们试图利用BERT的隐藏表征来规避这些限制<font color="red">（指的是依赖多余的数据构建等限制？）</font> ，这些表征很容易获得，作为嵌入空间中的样本。</p><h3 id="3-1-Contrastive-Learning-with-Self-Guidance"><a href="#3-1-Contrastive-Learning-with-Self-Guidance" class="headerlink" title="3.1 Contrastive Learning with Self-Guidance"></a>3.1 Contrastive Learning with Self-Guidance</h3><p>作者的目标是开发一种不受数据增强等外部程序影响的对比性学习方法。一个可能的接解决方案是在embedding空间中利用虚拟的对抗性训练，然而不能保证再加入NT-Xent随机噪声时，句子嵌入的语义会保持不变（However, there is no assurance that the semantics of a sentence embedding would remain unchanged when it is added with a NT-Xent random noise）。<font color="red">adversarial的方法自己感觉来说有一类的问题是生成的东西不够准确，或者说额外需要一个生成操作，这不像是数据增强那种感觉，所以对抗性训练的时候会有生成的额外开销和负担？</font> 作为一种替代方法，我们建议利用来自BERT中间层的隐层表征，这些表征在概念上保证能够代表相应的句子。作者称我们的方法为self-guidance的对比学习，因为作者利用BERT本身的内部信号来微调它；</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713224252841.png" alt="image-20220713224252841" style="zoom:75%;"><p>training的framework在上面这个图中被表示。首先把BERT拷贝为两份，并分别称作${\rm BERT}_F$（BERT-fixed）和${\rm BERT}_T$（BERT-tuned）。${\rm BERT}_F$  在训练期间是固定的用来提供一个训练信号${\rm BERT}_T$是微调的以构建更好的句子嵌入。将${\rm BERT}_F$和${\rmBERT} _T$分开训练的原因是，我们想预先让${\rm BERT}_F$计算的训练信号不随着训练的过程而继续退化，这也在${\rmBERT}_T&#x3D;&#x3D;{\rm BERT}_F$的时候经常发生<font color="red">这里是否可以理解为如果两个是一样的，那怎么都是一样的，肯定会越训练越差了</font> 。上述的这一设计反映了我们的理念，即我们的目标是动态的混合存储在BERT不同层的知识，以产生句子嵌入，而不是通过额外的训练引入新的信息<font color="red">（这里应该指的是传统的fine-tune方式吧）</font> 。<strong>请注意，在我们的设置中，来自${\rm BERT}_T$最后一层的[CLS]token，即${\rm c}_i$被认为是我们在微调期间&#x2F;之后，旨在优化&#x2F;利用的最终句子嵌入。</strong></p><p>step2: <font color="red">注意这个第二步是在${\rm BERT}_F$上的操作</font> 第二步，给定b个sentence作为一个mini-batch，标记为$s_1,s_2,…,s_b$，分别把每句话$s_i$输入进${\rm BERT}<em>F$中计算token-level的hidden representation$H</em>{i,k}\in R^{len(s_i)×d}$<font color="red">   P.S. 第一次看到不标注公式号码的论文。。</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713231613240.png" alt="image-20220713231613240"></p><p>这里0&lt;&#x3D;k&lt;&#x3D;l，<font color="red"> （作者对0层的解释是non-contextual layer，不知道指的是不是embedding后那个layer？）</font>，l代表BERT中隐层layer的数目，len(s_i)是这个tokenize sentence的长度，d是BERT的hidden_size。然后，在各个$H_{i,k}$之间使用一个池化操作（pooling function）$p$在所有BERT层中得出不同的句子级视图$h_{i,k}\in R^{d}$，这里$h_{i,k}&#x3D;p(H_{i,k})$，最后通过采样策略$\sigma$获取一个$h_i$</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713232745704.png" alt="image-20220713232745704"></p><p>由于我们在定义p和σ时没有具体的限制，employ max pooling as p and a uniform sampler as σ for simplicity</p><p>除非另有说明。对采样器的这种简单选择意味着每个hi,k都有相同的重要性，<strong>考虑到已知不同的BERT层专门用于捕获不同的语言概念</strong>，这是有说服力的（Jawahar等人，2019）。</p><p>step3:<font color="red">这个第三步指的是在${\rm BERT}_T$上的操作</font> ，计算$s_i$的sentence embedding $c_i$</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713233655063.png" alt="image-20220713233655063"></p><p>其中$BERT(·)_{\rm [CLS]}$代表从BERT中最后一层获取的${\rm [CLS]}$token。</p><p>step4：随后我们将计算出的向量打包一下，然后和SimCLR中一样算一个loss，c_i，h_i就可以看做SimCLR中的两种aug方法</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713235123953.png" alt="image-20220713235123953" style="zoom:50%;"><p>把所有$L_{m}^{base}$求和然后除以2b，并加入一个regularizer $L^{reg}&#x3D;||{\rm BERT}_F-{\rm BERT}_T||_2^2$，以避免两个之间“太远了”（这里作者注解了，把bert第0层也fix住，为了stable learning），这些过程和SimCLR基本是很像的，除了加上了一个regularizer以外</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713235544427.png" alt="image-20220713235544427"></p><p>额外贴一个SimCLR的</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220713235707265.png" alt="image-20220713235707265"></p><p>总而言之，我们的方法完善了BERT，使 句子嵌入ci与hi有较高的相似性，hi是句子si的另一种表示，在f投影的子空间中，与cj,j!&#x3D;i和hj,j!&#x3D;i相对不相似。<strong>训练完成后，我们删除除BERTT以外的所有成分，只用ci作为最终的句子表示。</strong></p><h3 id="3-2-Learning-Objective-Optimization"><a href="#3-2-Learning-Objective-Optimization" class="headerlink" title="3.2 Learning Objective Optimization"></a>3.2 Learning Objective Optimization</h3><p>在第3.1节中，我们依赖于一般NT-Xent损耗的简单变体，该变化由四个因素组成。</p><p>在不丧失一般性的情况下，给定句子si和sj，因子如下（图3）：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714002824057.png" alt="image-20220714002824057" style="zoom:67%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714004930539.png" alt="image-20220714004930539" style="zoom:67%;"></p><p>绿色和黄色的箭头代表吸引和排斥的力量，解释一下图里的四条边<font color="red">这个地方就是把NT-Xentloss又给画图表述了一下吧，感觉没什么创新</font> </p><p>（1）$c_i$应当与$h_i$相互接近：主要的组成部分反映了我们核心的motivation，即BERT句子向量（ci）应该与BERT的中间视图（hi）一致。</p><p>（2）$c_i$应当与$c_j$相互排斥：使得两个句子得到的这些要远离</p><p>（3）$c_i$应当与$h_j$相互排斥</p><p>（4）$h_i$应当与$h_j$相互排斥</p><p><font color="blue">传统的拉进ci cj；；</font> </p><p>尽管这四个因素都发挥了一定的作用，但有些成分可能是无用的，甚至对我们的目标造成了负面影响。一些研究工作（Chen和He（2020））指出在图像表示学习中，只有(1)是至关重要的，而其他的都是不重要的。同样地，我们对训练损失进行了三个主要的修改</p><p>第一：因为我们的目的是借助于hi来改善ci。我们重新定义我们的损失，更多地关注ci，而不是将ci和hi视为等同的实体。换句话说，”hi”的功能只是作为鼓励接近或远离的点。鼓励接近或远离，而不被认为是要优化的目标。这一修改的结果删除了（4）</p><p><font color="red">把c_i作为anchor，而不是像SimCLR那样搞个互相的？</font> 这样忽略掉h作为anchor对其他的</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714005530488.png" alt="image-20220714005530488"></p><p>此外，我们发现(2)对于提高性能也是不重要的，因此得出了</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714010111062.png" alt="image-20220714010111062"></p><p><font color="red">opt1和opt2分别去掉了hi hj之间的，ci和cj之间的，也就是(2) (4)</font> </p><p>最后，我们将(1)和(3)的信号多样化，即允许多种观点{hi,k}来指导ci。这里也就是用了多层的$h_{i,k}$</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714010334526.png" alt="image-20220714010334526"></p><p>我们期望通过这一改进，学习目标可以通过考虑提供额外的（和免费的）样本来提供更精确和富有成效的训练信号。我们的优化损失的最终形式是。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714010445957.png" alt="image-20220714010445957"></p><p><font color="red"><strong>opt1保留1，扔掉4；；opt2扔掉2；；；opt3加强3；；；这些都有一种以c_i作为anchor的感觉</strong></font> </p><p>ablation分别搞：<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714010537552.png" alt="image-20220714010537552"></p><h2 id="4-Experiment"><a href="#4-Experiment" class="headerlink" title="4. Experiment"></a>4. Experiment</h2><h3 id="4-1-General-Configurations"><a href="#4-1-General-Configurations" class="headerlink" title="4.1 General Configurations"></a>4.1 General Configurations</h3><p>在预训练的编码器方面，我们利用BERT（Devlin等人，2019）来处理英语数据集，而MBERT则是BERT的多语言变体，用于处理多语言数据集。(In terms of pre-trained encoders, we leverage BERT (Devlin et al., 2019) for English datasets and MBERT, which is a multilingual variant of BERT, for multilingual datasets.)</p><p>…</p><h3 id="4-2-Semantic-Textual-Similarity-Tasks"><a href="#4-2-Semantic-Textual-Similarity-Tasks" class="headerlink" title="4.2 Semantic Textual Similarity Tasks"></a>4.2 Semantic Textual Similarity Tasks</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714011050659.png" alt="image-20220714011050659" style="zoom:67%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220714011019848.png" alt="image-20220714011019848" style="zoom:67%;"></p><p>cosine similarity、Spearman correlation</p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cvpr2020_MoCo-MomentumCL论文阅读</title>
    <link href="/2022/08/07/research/papers/contrastive-learning/cvpr2020_MoCo-MomentumCL%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/08/07/research/papers/contrastive-learning/cvpr2020_MoCo-MomentumCL%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="cvpr2020-MoCo-MomentumCL论文阅读"><a href="#cvpr2020-MoCo-MomentumCL论文阅读" class="headerlink" title="cvpr2020_MoCo-MomentumCL论文阅读"></a>cvpr2020_MoCo-MomentumCL论文阅读</h1><p>Momentum Contrast for Unsupervised Visual Representation Learning</p><p>中文翻译为：用于无监督视觉表征学习的动量对比</p><p>个人总结贡献如下：</p><ul><li>Momentum方式进行对比学习，优化了memory bank方法中，bank中由于参数更新导致各项差距过大的问题，这里momentum使得bank中的每次只在之前的基础上微微改变，这样bank中的representation之间差异不会很大；</li><li>这种方式避免了mini-batch导致的</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>CVPR2020-MoCo-无监督对比学习论文解读：<a href="https://www.zhihu.com/search?type=content&amp;q=CVPR2020%20MoCo%EF%BC%9Bhttps://zhuanlan.zhihu.com/p/34283945">https://www.zhihu.com/search?type=content&amp;q=CVPR2020%20MoCo；https://zhuanlan.zhihu.com/p/34283945</a></li><li>Moco解读：<a href="https://zhuanlan.zhihu.com/p/382763210">https://zhuanlan.zhihu.com/p/382763210</a></li></ul><h2 id="X-对照博客1简单理解下流派的发展"><a href="#X-对照博客1简单理解下流派的发展" class="headerlink" title="X. 对照博客1简单理解下流派的发展"></a>X. 对照博客1简单理解下流派的发展</h2><p>首先学习以往无监督对比学习是如何做的</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719161407558.png" alt="image-20220719161407558"></p><h3 id="X-1-end-to-end模式"><a href="#X-1-end-to-end模式" class="headerlink" title="X.1 end-to-end模式"></a>X.1 end-to-end模式</h3><p>第一种为end-to-end模式，博客作者给了下面这样一个图</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719160848307.png" alt="image-20220719160848307"></p><p>希望拉进正样本之间的距离，推远负样本之间的距离。这样存在的一个问题是负样本的数量受到batch_size大小的限制，在没有庞大GPU集群的支持下，负样本的数量是不会特别多的。这也是很快创新改进memorybank方法的创新点之一，解决负样本数量的问题。</p><h3 id="X-2-Memory-Bank模式"><a href="#X-2-Memory-Bank模式" class="headerlink" title="X.2 Memory Bank模式"></a>X.2 Memory Bank模式</h3><p>给了这么一张图，对照博客作者的文字理解下这张图：开始时生成一个大小为k的队列，队列里面的feature都是随机初始化的，这个就是Memory Bank。然后开始训练，每迭代一次，将新生成的feature k1加入到队列中，并让队列中最老的feature出队，由于feature是已经经过编码的了，所以一次可以输入大量的负样本，解决了end-to-end方法中负样本数过少的问题。</p><p>MoCo指出来的问题是，Memory bank存在的问题是随着训练的不断进行，encoder q的参数在不断更新，这导致<strong>memory bank中的负样本feature差别过大</strong>，有的是刚更新的，有的是用很久以前参数生成的特征，这不利于对比学习。</p><p>MoCo的创新点也就在这里，通过引入momentum encoder来让memory bank中feature差异变得更小，也就是让特征更加平滑。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719161435494.png" alt="image-20220719161435494" style="zoom:50%;"><h3 id="X-3-MoCo模式"><a href="#X-3-MoCo模式" class="headerlink" title="X.3 MoCo模式"></a>X.3 MoCo模式</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719162203974.png" alt="image-20220719162203974"></p><p>feature k1的获取不是通过encoder q了，而是通过encoder q参数的历史组合得到，momentum encoder和encoder q的网络结构完全相同 ，仅是参数不一样。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719162905710.png" alt="image-20220719162905710"></p><p>这样<strong>Memory Bank中的feature区别就会变小</strong>，解决了Memory bank存在的问题。</p><p><font color="blue">维护的memory bank是针对k的，维护更大的一个memorybank？为什么要维护更大的一个memory bank，早期的研究，认为不能无限的增大batch，认为越大的负例队列，中间出现hard-negative越大，但有些研究又说hard-negative更有用的—— 做题的时候，错题本作用更大的，怎么出现hard-negative？一次batch越大hard-negative越大；；；；<strong>但伪正例的可能性也越大？</strong></font> </p><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>我们提出了Momentum Contrast(MoCo)用于无监督的视觉表征学习。从对比学习作为词典查找的角度出发，我们构建了一个带有队列和移动平均编码器的动态词典<font color="red">（这里这个词典不知道该怎么理解，英文使用的是dictionary，是指的key-value？）</font> 。这使得我们能够即时构建一个大型的、一致的字典，以促进对比性的无监督学习。MoCo在ImageNet分类的普通线性协议下提供了有竞争力的结果。更重要的是，MoCo学到的表征可以很好地转移到下游任务中。在PASCAL VOC、COCO和其他数据集的7个检测&#x2F;分割任务中，MoCo的表现优于其有监督的预训练对应物，有时甚至以较大的幅度超过它。这表明，在许多视觉任务中，无监督和有监督的表示学习之间的差距已经基本消除。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>无监督的表征学习在自然语言处理中非常成功，例如GPT和BERT。但在计算机视觉中，有监督的预训练仍然占主导地位，而无监督的方法通常落后于此。原因可能来自于它们各自信号空间的差异。语言任务有离散的信号空间（word、subword unit等），用于建立标记化的字典，无监督学习可以基于此。相比之下，计算机视觉则进一步关注字典的建立，因为原始信号是在一个连续的、高维的空间中，并不是为人类交流而构建的（例如，与单词不同）。<font color="red">怎么理解这里的dictionary，一些博客中指出原始的自监督学习方法里面这一批负样本就相当于是有个字典（dictionary），字典的key就是负样本，字典的value就是负样本通过encoder之后的内容，字典的大小就是batch_size</font></p><p>最近的几项研究提出了使用与对比性损失有关的方法进行无监督视觉表征学习的有希望的结果[29]。尽管有不同的动机，这些方法可以被认为是建立动态字典。词典中的 “键”（tokens）是从数据（如图像或斑块）中采样的，并由一个编码器网络表示。无监督学习训练编码器进行字典查询：一个编码的 “查询 “应该与它匹配的键相似，而与其他键不相似。学习被表述为最小化对比性损失</p><p><strong><font color="red"> TODO：待补充</font></strong></p><h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719163743504.png" alt="image-20220719163743504" style="zoom:80%;"><p>自己尝试解读一下这个流程，把一个x经过两种aug方法后变成x_q和x_k两个，然后经过f_q和f_k层的foward变成q和k，注意这里在初始化的时候让f_k的params&#x3D;f_q的params。k.detach()代表不追踪k的梯度。</p><p>l_pos代表了q和k的相似度，也就是positive pair。l_neg代表了q和queue（长度为k）中的所有的相似度，也就是negative pair。通过式1来计算一个contrastive loss(InfoNCE），之后SGD的方法对f_q网络层的参数进行update。</p><p>注意重点在这里：每迭代loader中的一个样本x，需要更新f_k的参数，但是这里是一个momentum的更新方式，每次更新的很少。最后维护queue，把negative样本给放进去。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719165237538.png" alt="image-20220719165237538"></p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl-findings2022_Virtual Augumentation CL论文阅读</title>
    <link href="/2022/08/02/research/papers/contrastive-learning/aclfindings2022_Virtual%20Augmentation%20CL/"/>
    <url>/2022/08/02/research/papers/contrastive-learning/aclfindings2022_Virtual%20Augmentation%20CL/</url>
    
    <content type="html"><![CDATA[<h1 id="acl-findings2022-Virtual-Augumentation-CL论文阅读"><a href="#acl-findings2022-Virtual-Augumentation-CL论文阅读" class="headerlink" title="acl-findings2022_Virtual Augumentation CL论文阅读"></a>acl-findings2022_Virtual Augumentation CL论文阅读</h1><p>Virtual Augmentation Supported Contrastive Learning of Sentence Representations</p><p>虚拟增强支持的句子表征的对比性学习</p><p>个人总结文章的亮点如下：</p><p>1）hard-negative角度，有一种反向的思路的感觉，邻域内的样本制造hard-negative：离自己相对较远而离邻居相对更近的一个微小扰动，但感觉不是negative这样的，只能说创造了一个hard的positive-pair？</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>亚马逊提出无监督虚拟增强句子表征学习框架，效果超越SimCSE：<a href="http://www.360doc.com/content/21/1217/20/7673502_1009176247.shtml">http://www.360doc.com/content/21/1217/20/7673502_1009176247.shtml</a></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li><strong><font color="purple">感觉还是之前讨论的那个问题，在这里相当于pretrain了后，那么我在下游任务的时候是怎么个微调的过程？或者说下游这些任务不需要微调？</font></strong></li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>尽管取得了巨大的成功，但对比性表征学习仍依赖于使用特定领域知识精心设计的数据增强。这一挑战在自然语言处理领域中被放大了，由于自然语言的离散性，在数据增强方面不存在一般规则。</p><p><font color="red">像图像的话因为本质上都是一样的，那么可以直接旋转、裁剪、加噪声等，但是由于自然语言不同语言特性不同，而且增强的方法可能会对语义有着本质上的改变，感觉在增强方面几乎就没有什么很通用的</font> </p><p>我们提出通过虚拟增强支持的句子表征对比学习（VaSCL，Virtual augmentation Supported Contrastive Learning）来应对这一挑战。我们从数据增强本质上构建每个训练实例的邻域的解释出发，反过来利用邻域来产生有效的数据增增强。</p><p><font color="red">论文是从hard-negative这个角度来说的，我的一个原句的hard-negative的构建，可以通过在原句子基础上添加噪声，然后让这个噪声更加接近其K近邻样本而非原句，选一个噪声和原句有一种最远感觉的（在K个sample时候loss最大），这样带噪声的就是一个额外特殊的hard-negative了。</font> </p><p><strong><font color="purple">注意hard-negative不一定指的是对立的那种contradiction样本，而是说难学习的，比如扰动后的话毕竟还是基于原句子一个很微小扰动得到的，那么他理应当和原句形成一个positive pair</font></strong> </p><p>利用对比学习的大批量训练，我们通过一个实例在表示空间中的K-nearest in-batch邻居来近似其邻域。然后，我们定义一个关于这个邻域的实例判别任务，并以对抗性训练的方式生成虚拟增强。</p><p>我们查看了VaSCL在广泛的下游任务上的表现，并为无监督的句子表示学习设定了一个最先进的方法。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>通用句子表征学习一直是自然语言处理中的一个长期问题。利用分布式单词表征作为基础特征来产生句子表征是早期阶段的一个常见策略。然而这些方法都是针对不同的目标任务而设计的，因此产生的句子表征通用性较差。</p><p>这个问题促使人们在设计通用的句子级学习目标或任务方面做出更多的研究努力。其中自然语言推理（NLI）数据集上的监督学习已经在各种下游任务上建立了基准的迁移学习性能。尽管取得了可喜的进展，但收集注释的高成本阻碍了其广泛的适用性，特别是在目标领域注释很少，但与NLI数据集有很大差别的情况。<font color="red">NLI数据集一般是给定一个假设，然后对这个假设有人工标注的蕴含、中立、矛盾类型的句子对。一些CL工作将矛盾类型特别当做hard-negative</font> </p><p>另外一方面，随着最近自监督对比学习的成功，句子表征的无监督学习又重新引起了人们的兴趣。这些方法依赖于两个主要部分：<strong>数据增强</strong>和<strong>实例级的对比性损失</strong>。流行的对比性学习目标（SimCLR那边的infoNCE）及其变体，已经在经验性上证明了它们在NLP中的有效性。然而，文本的离散性使得为有效的文本增强生成简历普遍的规则成为挑战。</p><p>人们提出了各种基于对比学习的方法来学习句子的表征，其主要区别在于如何生成增强的内容。有点令人惊讶的是，最近的一项工作（SimCSE）从经验上表明dropout（例：通过向编码器提供同一实例两次而获得的数据增强），超越了在文本上操作的普通数据增强策略， 包括删除单词或同义词替换等。在另一面，这一观察再次验证了在NLP中实现有效的数据增强的内在困难。</p><p><font color="red">这段Introduction感觉写的不错</font> </p><p>在本文中，我们通过提出一个邻域引导的虚拟增强策略来应对这一挑战，以支持对比性学习。简而言之，数据增强本质上是构建每个实例的邻域，而语义内容被保留下来。<strong>我们通过利用实例的邻域来指导扩增的生成，将这种解释引向相反的方向。</strong>受益于对比学习的大批量训练，我们通过一个实例的K-nearest in-batch neighbor对其进行近似。然后我们在这个邻域内定义一个实例判别任务，并以对抗性训练的方式生成虚拟增强。</p><p><font color="red">这里大概看到method能明白是什么意思，在abstract里面略微有写</font> </p><p>我们在广泛的下游任务上评估了我们的模型，并表明我们的模型始终以很大的优势超过了以前的最先进结果。我们进行了深入的分析，并表明我们的VaSCL模型导致了一个更分散的表征空间，不同粒度的数据语义得到了更好的捕捉。</p><p><font color="red">各向异性、各项同性相关的分析？alignment and uniformlity</font> </p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>2.1节Universal Sentence Representation Learning；2.2节Contrastive Learning；2.3节Consistency Regularization；</p><h2 id="2-1-Universal-Sentence-Representation-Learning"><a href="#2-1-Universal-Sentence-Representation-Learning" class="headerlink" title="2.1 Universal Sentence Representation Learning"></a>2.1 Universal Sentence Representation Learning</h2><p>可以说（Arguably），获得句子表征的最简单和最常见的方法是word-bag及其变体。然而，word-bag存在着数据稀少和对词的语义缺乏敏感的问题<font color="red">词袋的方法应该是一些统计特征上的利用？</font> 。在过去的20年里，分布式单词表征已经成为产生句子表征的更有效的基础特征。缺点是这些方法是针对目标任务的，因此产生的句子表征的迁移学习性能有限。</p><p>最近的努力集中在直接设计句子级别的学习目标或任务。在监督学习制度上，一些研究者证明了利用NLI任务促进通用句子表征的有效性。该任务涉及将每个句子对归入三个类别之一：蕴含（entailment）、中立（neutral）、矛盾（contradiction）。</p><p>Reimers和Gurevych（2019b）通过使用预训练的Transformer（BERT、RoBERTa）作为骨干，进一步增强了性能。另一方面，Hill等人（2016年）；Bowman等人（2015b）提议使用去噪或变分自动编码器（VAE，variational auto encoder）进行句子表示学习。Kiros等人（2015）；Hill等人（2016）将分布假设扩展到句子层面，并训练编码器-解码器为每个句子构建周围语境。或者，Logeswaran和Lee（2018）提出了一个模型，学习区分目标语境句子和所有对比句子。</p><h3 id="2-2-Contrastive-Learning"><a href="#2-2-Contrastive-Learning" class="headerlink" title="2.2 Contrastive Learning"></a>2.2 Contrastive Learning</h3><p>对比学习是近期句子表征学习成功的顶峰。Gao等人（2021）；Zhang等人（2021）通过利用NLI中的entailment句子作为positive pair来优化适当设计的对比性损失函数，大大推进了之前的最先进成果。然而，我们专注于无监督的对比学习，并通过数据增强形成positive pari，因为这种方法更具成本效益，并适用于不同领域和语言。沿着这条路线，最近提出了几种方法，其中增强是通过dropout、回译、周围环境采样或在不同语义层面进行的扰动获得。</p><p><font color="red">dropout这个方法是很有特点的，解决了数据增强不很稳定的特点</font> </p><h3 id="2-3-Consistency-Regularization"><a href="#2-3-Consistency-Regularization" class="headerlink" title="2.3 Consistency Regularization"></a>2.3 Consistency Regularization</h3><p>我们的工作也与一致性的正则化密切相关，一致性的正则化通常用于促进更好的性能，通过正则化使得模型的输出在合理的输入变化下保持不变，<strong>这些变化通常是数据增强引起的。</strong>随机的数据增强，如dropout、cropping、rotation和flipping产生有效的正则化。Berthelot等人（2019，2020）；Verma等人（2019）通过应用Mixup（Zhang等人，2017）及其在随机数据增强之上的变体来增强性能。</p><p>然而，数据扩充长期以来一直是NLP的一个挑战，因为没有有效的文本转换的一般规则。<strong>当考虑到违反一致性正则化时，一个替代方案就会出现，反过来可以用来寻找模型最敏感的扰动。</strong>在本文中，我们利用一致性正则化来促进表征空间中某一实例的信息性虚拟增强，同时利用其近似的邻域来正则化共享与原始实例相似的语义内容的增强。</p><p><font color="red">这里加粗那句话是说，如果数据增强不当就会使得模型被很敏感的扰动了，那么反过来就是说寻找使得模型最为敏感的扰动。</font> </p><h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801224053571.png" alt=" "></p><p><font color="red">这里先把method的主图贴出来：</font> </p><p><font color="blue">base：加上噪声不能影响基础的语义 </font> </p><p><font color="blue">可能认为N-1一定不存在正例，要么K近邻就会出问题；；；shifting的效果太小了？</font> </p><h3 id="3-1-Preliminaries"><a href="#3-1-Preliminaries" class="headerlink" title="3.1 Preliminaries"></a>3.1 Preliminaries</h3><p><font color="red">这里基本是复述了一下SimCLR这种比较经典的对比学习框架是怎么实现的，以及SimCSE这种比较“新奇”有代表性的方法</font> </p><p>自我监督的对比性学习通常旨在解决实例辨别任务。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801225128034.png" alt="image-20220801225128034" style="zoom:67%;"><p><font color="red">注意这里给出了“contrastive learning head”也就是zi的表述，指的是那种在hi后面再接一个线性层，用那个线性层输出作为对比学习输入的方式。</font> </p><p>直观地说，方程（1）定义了在同一批B中的所有2M-1个候选者中，将第i个实例分类为其正面的对数可能性。</p><ul><li><p><strong>Dropout based contrastive learning</strong>：正如方程1所暗示的，对比性学习的成功依赖于有效的positive pair的构建，然而，由于自然语言的离散型，在NLP中很难产生强大而有效的数据转换。这一挑战在最近的一项工作中得到了进一步的证明（SimCSE），这一工作表明，通过dropout获得的数据增强胜过常见的文本扩充策略，如裁剪、删词或同义词替换。</p><p>Dropout通过随机掩盖其输入或隐藏层节点，为数据增量提供了一种自然的方式。使用Dropout作为伪数据增强的有效性可以追溯到Bachman等人（2014）; Samuli和Timo（2017）; Tarvainen和Valpola（2017）。<strong>尽管如此，仅用Dropout的增强强度是很弱的，有改进的余地，我们在下一节进行研究。</strong></p></li></ul><h3 id="3-2-Neighborhood-Constrained-Contrastive-Learning-with-Virtual-Augmentation"><a href="#3-2-Neighborhood-Constrained-Contrastive-Learning-with-Virtual-Augmentation" class="headerlink" title="3.2 Neighborhood Constrained Contrastive Learning with Virtual Augmentation"></a>3.2 Neighborhood Constrained Contrastive Learning with Virtual Augmentation</h3><p><font color="red">邻居约束下的对比性学习与虚拟增强</font> </p><p>从本质上讲，数据增强可以被解释为在保留语义内容的前提下，构建训练中的邻域。<font color="red">这个解释还是非常直观的，就是说构建出来的应该是邻域的，那么反过来说邻域的信息可被用来进行一些构建？</font> 在本节中，我们从相反的方向进行解释，首先对一个实例的邻域进行近似，在此基础上生成数据增强。</p><p>更加具体的来说，首先使得$B&#x3D;{i}_{i&#x3D;1}^{M}$代表随机采样选取的大小为M的一批数据。我们首先对于第i个实例，选择其最K近邻的邻居$N(i)$（我们首先将第1个实例的邻域N(i)近似为它在表示空间中的K个最近的邻居）</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801231425045.png" alt="image-20220801231425045" style="zoom:67%;"><p>然后我们定义一个实例级的对比性损失 关于第1个实例和它的邻域，定义如下。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801231457038.png" alt="image-20220801231457038" style="zoom:67%;"><p>在上式中，<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801232429140.png" alt="image-20220801232429140" style="zoom:50%;">代表perturbed representation<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801232514750.png" alt="image-20220801232514750" style="zoom:50%;">在contrastive learning head的输出表征。这里，初始扰动δi被选为各向同性的高斯噪声。正如它所暗示的那样，方程（2）显示了将受扰动的第i个实例归类为自身而不是其邻居的负对数可能性。</p><p><font color="red">当扰动和自身接近的时候loss小，而当扰动和其他邻居更加接近的时候，loss大；另外这里是在ei层面上做的操作，引导ei学习表征更好，更好的表示一个句子？</font> </p><p>然后，通过确定在这个邻域内最大程度地扰乱其实例级特征的最佳扰动，保留第i个实例的增强。这就是</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801233016798.png" alt="image-20220801233016798" style="zoom:67%;"><p><font color="red">取最大的扰动（这个扰动的二范式，也就是自身长度大小那种感觉不能超过△，然后这个扰动使得他离K近邻的这些neighbor相对更近，而离自己较远，那么来说的话，这是一个很好的hard样例，扰动了一下但是和原句一个意思，然后又比较难）</font> </p><p>将$N_A(i)$表示第i个实例的增强邻域，即<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801234509356.png" alt="image-20220801234509356" style="zoom:50%;">。$e_k$代表原始的第k个实例的嵌入表征，$e_k*$代表相关的增强后的表征。注意这里$e_k*$是以方程（4）中定义的同样方式获得的，关于它自己的邻域$N{(k)}$。然后，我们将第i个实例及其数据增强与它的数据增强邻域$N_A(i)$内的其他实例区分开来，如下所示：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801235339120.png" alt="image-20220801235339120" style="zoom:50%;"><p><strong><font color="red">分别以第i个实例的增强，和第i个实例作为anchor：原句和其虚拟的困难样本形成positivepair相互拉近，原句和原句的虚拟样本分别于K邻域内的负样本 虚拟困难样本拉远</font></strong> </p><p><font color="blue">生成的hard-negative；；；一个batch中找到k，</font> </p><ul><li>Putting in all together：因此，对于每个有M个样本的随机抽样的mini-batch B，我们最小化如下的损失函数：</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802000523521.png" alt="image-20220802000523521" style="zoom:67%;"><p><font color="red">就是SimCSE的loss加上作者这个K邻居集中的loss</font> </p><p>结合起来，对每个训练实例提出了两个实例判别任务：将每个实例及其dropout引起的变化与其他批次中的实例分开；将每个实例及其虚拟增强与它的前K个最近的邻居及其虚拟增强分开。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801224053571.png" alt="image-20220801224053571"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">读到这里后来理解一下作者给的主图，<br></code></pre></td></tr></table></figure><h2 id="4-Experiment"><a href="#4-Experiment" class="headerlink" title="4. Experiment"></a>4. Experiment</h2><p><font color="red">这里着重记录一下看到里面一些比较有亮点的ablation实验等，别的简单带过一下</font> </p><p>在这一节中，我们主要针对SimCSE（Gao等人，2021）对VaSCL进行评估，SimCSE利用dropout（Srivastava等人，2014）引起的噪声作为数据增强。我们表明，VaSCL在涉及不同粒度的语义理解的各种下游任务中，一致地优于SimCSE。我们仔细研究了VaSCL的规则化效应，并从经验上证明VaSCL导致了一个更分散的代表空间，语义结构被更好地编码。<font color="red">这里就是更加各向同性？</font> </p><h3 id="4-1-Evaluation-Datasets-amp-4-2-Main-Results"><a href="#4-1-Evaluation-Datasets-amp-4-2-Main-Results" class="headerlink" title="4.1 Evaluation Datasets &amp; 4.2 Main Results"></a>4.1 Evaluation Datasets &amp; 4.2 Main Results</h3><ul><li>Table1：Semantic Textual Similarity</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802001315529.png" alt="image-20220802001315529"><font color="red">主实验结果相比SimCSE还是超越了相当程度的</font> </p><ul><li>Table2：Short Text Clustering（The clustering accuracy is computed by using the Hungarian algorithm (Munkres, 1957）</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802002029846.png" alt="image-20220802002029846" style="zoom:50%;"><ul><li>Table3：Intent Classification</li></ul><p>我们冻结Transformer，用基于softmax的交叉熵损失对线性分类层进行微调。我们合并训练集和验证集，从中为每个类别抽取K个训练和验证样本</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802002133219.png" alt="image-20220802002133219" style="zoom:80%;"><p><strong><font color="purple">这里感觉还是之前讨论的那个问题，在这里相当于pretrain了后，那么我在下游任务的时候是怎么个微调的过程？或者说下游这些任务不需要微调？</font></strong> </p><h3 id="4-3-Analysis"><a href="#4-3-Analysis" class="headerlink" title="4.3 Analysis"></a>4.3 Analysis</h3><ul><li>Neighborhood Evaluation on Categorical Data</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802002704968.png" alt="image-20220802002704968"></p><p>左边图表明，相似的样本还是足够的近，K很大了相似占比还是<strong>相对的</strong>多</p><p>右边图表明，这个特征空间在VaSCL和SimCSE的作用下拉的比较开，也就是说和K近邻的平均距离非常远！</p><ul><li>Fine-grained Semantic Understanding 细粒度的语义理解</li></ul><p><img src="2022/08/02/research/papers/contrastive-learning/aclfindings2022_Virtual%20Augmentation%20CL/curious/Desktop/image-20220802003557952.png" alt="image-20220802003557952"></p><p><font color="red">这个图有点没看懂，之后还要详细看一下</font> </p><p><font color="blue">contradiction 和 entailment就分的更开了，</font> </p><h3 id="4-4-Explict-Data-Augmentation"><a href="#4-4-Explict-Data-Augmentation" class="headerlink" title="4.4 Explict Data Augmentation"></a>4.4 Explict Data Augmentation</h3><p><font color="red">显式增强差很多？在STS和STC任务上，加上后性能都下降了，也就是说不能和传统的方法混用？但是在10-shot 的intent cls上上升了；</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220802004152333.png" alt="image-20220802004152333"></p><ul><li><p>VaSCL Outperforms SimCSE：图3a也从经验上表明，无论是否存在明确的文本增强，VaSCL都优于SimCSE。唯一的例外是当明确的增强强度过大时，即每个文本中20%的词被扰动。一个可能的解释是，对离散文本的大扰动会直接产生不希望有的噪音，这可能会违反邻域所保持的连贯性，从而使VaSCL难以产生有效的虚拟增强。</p></li><li><p>New Linguistic Patterns Are Required For A Win-Win Performance Gain：要想获得双赢的业绩，需要新的语言学模式</p><p>从图3a中得出的另一个观察结果是，SimCSE和VaSCL在与明确的文本增强相结合时，在大多数下游任务上的表现都比较差。尽管VaSCL在大多数情况下确实提高了显式扩增的性能，但这是不可取的，因为我们期望一个双赢的结果，即适度的显式扩增也能提高VaSCL的性能。我们假设，为了达到预期的性能增益，缺少新的但又有信息的语言模式。</p></li></ul><p>为了验证我们的假设，在图3b中，我们报告了每个原始训练例子与其在不同模型的表示空间上评估的增强的余弦相似度。我们的观察是双重的。首先，由RoBERTa诱导的表征和用同义词替换训练的表征（”SimCSE w&#x2F; CTxt”）在所有三种情况下都非常相似，这也解释了为什么 “SimCSE w&#x2F; WDel “在下游任务中获得了与RoBERTa类似的性能。我们将此归因于这样一个事实，即CTxt利用转化器本身来生成增量，从而携带有限的未见过的有效语言模式。其次，正如图3b中相对较小的相似度值所表明的那样，为了验证我们的假设，在图3b中，我们报告了每个原始训练例子与其在不同模型的表示空间上评估的增强的余弦相似度。我们的观察是双重的。首先，由RoBERTa诱导的表征和用同义词替换训练的表征（”SimCSE w&#x2F; CTxt”）在所有三种情况下都非常相似，这也解释了为什么 “SimCSE w&#x2F; WDel “在下游任务中获得了与RoBERTa类似的性能。我们将此归因于这样一个事实，即CTxt利用转化器本身来生成增量，从而携带有限的未见过的有效语言模式。其次，正如图3b中相对较小的相似度值所表明的那样<strong>，显式增量的加入【收紧了SimCSE和VaSCL的表达空间】，这也反过来导致下游任务的性能下降。一个可能的解释是，所有三个显式增强都是弱的和嘈杂的，这损害了实例的识别力和每个邻域的语义相关性。</strong></p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5. Conclusion"></a>5. Conclusion</h2>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>naacl2022_Entity-aware CL for sentence emb论文阅读</title>
    <link href="/2022/08/02/research/papers/contrastive-learning/naacl2022_Entity-aware%20CL%20for%20sentence%20emb/"/>
    <url>/2022/08/02/research/papers/contrastive-learning/naacl2022_Entity-aware%20CL%20for%20sentence%20emb/</url>
    
    <content type="html"><![CDATA[<h1 id="naacl2022-Entity-aware-CL-for-sentence-emb论文阅读"><a href="#naacl2022-Entity-aware-CL-for-sentence-emb论文阅读" class="headerlink" title="naacl2022_Entity-aware CL for sentence emb论文阅读"></a>naacl2022_Entity-aware CL for sentence emb论文阅读</h1><p>EASE：Entity-Aware Contrasitve Learning of Sentence Embedding</p><p>实体感知的对比学习用于句子的embedding表征</p><p>Entity-aware CL for sentence embedding，个人总结文章的亮点如下：</p><p>1）hyperlink entity这个运用的很巧妙，因为维基百科这个超链接在多语言都是一样的，<strong>相当于一种能够额外获取得到的标注了</strong>，在这种超链接的引导下构建了自监督获取的positive pair；</p><p>2）同样因为hyperlink entity和维基百科的数据特点，使得具有多语言可以对齐的语料进行数据训练；</p><p>3）做实验的数据集非常全面，分为单语&#x2F;多语，内部有STS、STC、还有许多跨语言的数据集；</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p>- </p><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li>多语言环境一般数据集指的是什么样的，是不同语言混到一块吗还是怎么样？</li><li>多语言目前了解的还有点少，有些不清楚多语言相关的是在做什么，是多语言共用一个模型吗？</li><li>待讨论：这些测试集的结果，是不是都是先完成基准的预训练后，然后再拿给下游模型做fine-tune的这样一个训练过程，或者STS那种是预训练完了后就直接评估，但是一些下游带着标签的，就是还要fine-tune一下的？</li><li>似乎一些引用的是自己复现的指标，这种在可信性上感觉会有一定问题？</li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>我们提出了EASE，一种通过<strong>句子和其相关实体之间的对比学习</strong>来学习句子嵌入的新方法。使用实体监督的好处有以下两点：（1）实体已经被证明是文本语义的一个强有力的指标，因此应该为语义嵌入提供丰富的训练信号；（2）实体的定义是独立于语言的，因此提供了有用的跨语言对齐监督；</p><p><font color="red">这里背后的motivation会不会有，一句话的实体对整个语义是更加重要的？</font> </p><p>我们对EASE与其他无监督模式在单语言和多语言环境中进行了评估。我们表明EASE在英语语义文本相似性（STS）和短文聚类</p><p>（STC）任务中表现出有竞争力或更好的性能，并在多语言环境中，它在各种任务中的表现明显优于基线方法。</p><p><font color="red">多语言环境一般数据集指的是什么样的，是不同语言混到一块吗还是怎么样？（这个问题加到todo-list里面去了）</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>目前学习句子嵌入的主流方法使用特定的的训练监督来微调通用的与训练语言模型，如BERT。监督的类型可以是自然语言推理数据，相邻的句子，或多语言模型的平行数据库。</p><p><font color="red">这里说的是一个pretraining - fine tuning的过程</font> </p><p>在本文中，我们探讨了一种监督的类型，在文献中还没有被充分探讨过的监督类型：来自维基百科的实体超链接注释（<strong>entity hyperlink annotations</strong>）。该种方式的优势有两个方面：（1）实体已经被证明是文本语义的一个有力的指标，因此应该为句子嵌入提供丰富的训练信号；（2）实体的定义是独立于语言的，因此提供了一个有用的跨语言对齐监督。维基百科广泛的多语言支持减轻了对平行资源的需求，以训练对齐的多语言句子嵌入，特别是对于低资源语言。为了证明基于实体监督的有效性，我们提出了EASE（实体感知的对比学习用于句子的embedding表征），他在单语和多语的环境下都能产生高质量的句子嵌入。</p><p><font color="red">到这里还是一个详细版的abstract，多语言这块强调的很多</font> </p><p><strong>EASE学习句子嵌入，有两类目标：（1）我们新颖的实体对比学习损失函数，在句子和他们相关的实体之间，图1；（2）自监督的对比学习损失，加入dropout的noise；</strong></p><ol><li><strong>实体CL的目标是将句子与其相关实体的嵌入拉近，同时将不相关的实体分开，该目标预计将根据实体所捕获的语义来安排句子的嵌入。为了进一步利用维基百科中的知识并改进学习到的嵌入，我们还引入了一种基于实体类型的硬性否定词挖掘方法；</strong></li><li><strong>第二个目标，即带有dropout噪声的自监督CL目标，与第一个目标相结合，使得句子嵌入能够捕获细粒度的文本语义；<font color="red">这里引用了SimCSE</font></strong></li></ol><p>我们将我们的模型与其他最先进的无监督的句子嵌入模型进行了评估，并表明EASE在语义文本相似性（STS）和短文聚类（STC）任务上表现出有竞争力或更好的性能。</p><p><font color="blue">和知识图谱结合？</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731215200544.png" alt="image-20220731215200544" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731215211165.png" alt="image-20220731215211165" style="zoom:50%;"></p><p>图1：EASE背后的主要概念说明。使用一个对比学习框架，句子的嵌入其超链接实体的临近区域，而与不相关的实体分开。在此，我们为多语言模型分享不同语言的实体嵌入，以促进表示的跨语言对齐。</p><p><strong><font color="purple">读到这里才明白，这里这个超链接实体运用的很巧妙，就是维基百科什么的一般会有那个超链接，然后把这个超链接实体的信息运用上了；相当于一种能够额外获取得到的标注了，还能在多语言之间对齐</font></strong> </p><p>我们还将EASE应用于多语言环境。为了便于评估多语言句子嵌入的高级语义，<strong>我们构建了一个多语言文本聚类数据集，MewsC-16（16种语言的多语言新闻短文聚类数据集）</strong>。多语言EASE是使用各语言共享的实体嵌入进行训练的。我们表明，鉴于来自共享实体的跨语言对齐监督，多语言EASE在多语言STS、STC、平行句子匹配和跨语言文档分类任务中明显优于基准。</p><p>我们进一步证明了多语言实体CL在低资源语言的一个更现实的场景中的有效性。利用多语言实体法，我们对一个有竞争力的多语言句子嵌入模型LaBSE（Feng等人，2020）进行了微调，并表明该调整提高了该模型所支持的低资源语言的平行句子匹配性能。</p><p>最后，我们通过研究EASE模型和句子嵌入的多语言特性来分析该模型。消减的模型和句子嵌入的多语言特性，以阐明模型改进的来源。</p><p><font color="red">多语言任务目前了解还比较少，有点不清楚是怎么做的各个操作，加入到todo那里了</font> </p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h2><p>主要从2.1 Sentence Embedding、2.2 Contrastive Learning、2.3 Multilingual Sentence embeddings三个方面来说</p><h3 id="2-1-Sentence-Embedding"><a href="#2-1-Sentence-Embedding" class="headerlink" title="2.1 Sentence Embedding"></a>2.1 Sentence Embedding</h3><p>句子嵌入，即使用稠密向量的形式表示句子的含义已经得到了积极的研究。最早的方法之一是段落向量，其中句子嵌入被训练来预测文本中的单词。随后人们探索了各种训练任务，包括重建或预测相邻的句子和解决自然语言推理（NLI）任务。</p><p>最近，随着BERT等通用预训练语言模型的出现，对预训练模型进行微调以产生高质量的句子嵌入变得越来越普遍，<strong>重新审视上述的监督信号，并使用基于对比学习（CL）的自我监督目标。在本文中，我们提出了一个基于实体监督的CL目标。我们用实体CL和带有dropout噪声的自我监督CL来训练我们的EASE模型，并表明实体CL提高了句子嵌入的质量。</strong></p><ul><li><p>Contrastive Learning：对比表示学习的基本思想是将语义相似的样本拉近，将不相似的样本分开。句子嵌入的对比学习可以根据所使用的positive pair的类型进行分类。作为代表性的例子，有几种方法在NLI数据集中使用“蕴含”对作为positive pair。</p><p>为了减轻对注释数据集的需求，自监督方法也在被积极研究。典型的自我监督方法涉及<strong>使用数据增强技术生成positive pair</strong>，包括离散操作，如单词删除、shuffle，回译，中间的BERT隐藏表示，以及transformer层内的dropout噪音（SimCSE）。</p><p>Contrastive tension (CT)-BERT将两个单独编码器对同一句子的输出视为正对。DeCLUTR使用同一文件的不同span。与这些在句子之间进行CL的方法相比，<strong>我们的方法在句子和其相关实体之间进行CL。</strong> <font color="red">换句话说，也是一种构建positive pair的方法</font> </p></li><li><p>Multilingual sentence embeddings（多语言的话语embedding）：另一个与之密切相关的研究方向是学习多语言的句子嵌入，这些句子嵌入可以捕捉到多种语言的语义。早期有竞争力的方法通常利用序列对序列的目标与平行语料库来学习多语言句子嵌入；最近微调的多语言预训练模型已经取得了最先进的性能。然而，这类方法的一个缺点是，<strong>为了对某一特定的语言对取得强有力的结果，它们需要丰富的平行或语义相关的句子对，而这不一定容易获得</strong>。在这项工作中，我们<strong>探索了维基百科实体注释的效用，这些注释是跨语言对齐的，并且已经有300多种语言。我们还表明，在多语言情况下，实体注释有效地改善了英语和低资源语言之间的句子嵌入的一致性，而现有的多语言模型并不支持这种一致性。</strong></p><p><font color="red">再次强调了一下这里在多语言上的贡献，主要是这种多语言“标注”易于获得</font></p></li></ul><h3 id="2-2-Learning-Representations-Using-Entity-based-Supervision"><a href="#2-2-Learning-Representations-Using-Entity-based-Supervision" class="headerlink" title="2.2 Learning Representations Using Entity-based Supervision"></a>2.2 Learning Representations Using Entity-based Supervision</h3><p>实体已经被习惯性地用于建立文本语义模型。最近提出的一些方法通过从实体的相关文本或实体掩码的句子中预测实体来学习基于实体的监督的文本表示。在提出的EASE模型中，现有的基于BERT的自监督CL方法被扩展，<strong>使用基于实体的监督和精心设计的硬否定句，hard-negative</strong>。此外，通过利用实体的语言无关性，它被应用于多语言环境。</p><p><font color="red">感觉总结下来是这三大贡献：超链接的引导下自监督获取这种positive pair、多语言的数据易于获取、精心设计hard-negative</font> </p><h2 id="3-Model-and-Training-Data"><a href="#3-Model-and-Training-Data" class="headerlink" title="3. Model and Training Data"></a>3. Model and Training Data</h2><p>在本节中，我们描述了我们的句子嵌入学习方法EASE的组成部分，该方法使用维基百科中的实体超链接注释进行训练；</p><h3 id="3-1-Contrastive-Learning-with-Entites"><a href="#3-1-Contrastive-Learning-with-Entites" class="headerlink" title="3.1 Contrastive Learning with Entites"></a>3.1 Contrastive Learning with Entites</h3><p>给出一个句子和一个语义相关的positive实体对<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801110741231.png" alt="image-20220801110741231" style="zoom:50%;">，我们训练我们的模型来预测句子实体表征$e_{i} \in R^{d_e}$，从句向量表征$s_{i} \in R^{d_s}$中。按照Chen等人SimCLR的对比学习框架，我们对N个配对的mini-batch $(s_i, e_i)$,通过下式计算训练损失：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801111124007.png" alt="image-20220801111124007" style="zoom:67%;"><p>其中$W \in R^{d_e×d_s}$是一个可学习的矩阵参数<font color="red">一句话的表征和其中一个实体的表征两者互为接近这个在感官上感觉不是很有道理啊，所以在这里加入了一个W来平衡这个事情？也就是说一个词经过一个学习来变成一个句子的？如果从扩展来说这里会不会可以搞成多个词的，或者做一个词义选择后来怎么搞一下</font> 。$\tau$是温度超参数，sim(·)使用的是cosine相似度<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801111602009.png" alt="image-20220801111602009" style="zoom:50%;">。</p><ul><li>Data：我们从2019年1月版本的维基百科转储中构建句子-实体配对数据集。我们使用<a href="https://polyglot.readthedocs.io/en/latest/Tokenization.html">ployglot</a>将文章中的文本拆分为句子。对于每个句子，我们提取超链接实体作为语义相关的实体[脚注：在初步实验中，我们还尝试从实体和其页面上的第一句话中构建实体-句子配对数据，结果发现目前的方法表现更好]。每个实体都构成了该句子的一个训练实例 $(s_i, e_i)$。我们把实体限制在那些在训练语料库中作为超链接出现十次以上的实体。它们被转换为维基数据实体，利用从2020年3月版本的维基数据转储中获得的语言间链接，在不同语言间共享[脚注：<a href="https://en.wikipedia.org/wiki/Help:Interlanguage_links]%E3%80%82">https://en.wikipedia.org/wiki/Help:Interlanguage_links]。</a></li></ul><h3 id="3-2-Hard-Negative-Entites"><a href="#3-2-Hard-Negative-Entites" class="headerlink" title="3.2 Hard Negative Entites"></a>3.2 Hard Negative Entites</h3><p><font color="red">自己对Hard Negative的理解是更难学一点的样本，比如在NLI那边的针对那句话的矛盾可以是一个特殊的Hard Negative，在权重的时候多分配一些</font> </p><p>根据前人的研究，引入Hard Negative（与anchor难以区分的数据<font color="red">这里是不是不太对</font> ）对改善CL模型是有效的。我们引入了一种hard negative挖掘方法，可以找到与正面实体相似但与句子无关的负面实体。**<font color="red">这里作者理解的hard negative是难区分的样本，而不是那种应当更加原理的样本</font>** </p><p>具体来说，对于每个正面实体，我们收集满足以下两个条件的硬性负面实体候选：</p><ol><li>具有相同类型的实体被作为positive的实体（entities with the same type as the positive entity）；按照Xiong等人的工作，实体类型被定义为Wiki数据上“实例instance of ”关系中的实体。如果有不止一种合适的类型，我们会随机选择一种；<font color="red">有一种父层级选择的感觉</font> </li><li>不出现在同一维基百科页面上的实体；<font color="red">不在一个界面出现，那么可能就不是很相关的感觉</font> 这里我们的假设是，同一页面上的实体与正面实体在主题上相关，因此不适合作为负面数据。最后我们随机选择其中一个候选来构建硬性的负面训练数据。</li></ol><p>例如，”吉卜力工作室 “实体的类型是 “动画工作室”，而硬性否定的实体候选者之一是 “华特迪士尼动画工作室”（For example, the “Studio Ghibli” entity has the type “animation studio” and one of the hard negative entity candidates is “Walt Disney Animation Studios”）</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801115635161.png" alt="image-20220801115635161" style="zoom:67%;"><p><font color="red">对于一个句子的表征hi，他和ei应该接近，而在分母这里要同时和所有ej-和ej远离，这里会不会也有问题，就是负负得正了，比如ej-和ei在同个wiki页面中出现了？</font> </p><h3 id="3-3-Pretrained-Entity-Embeddings"><a href="#3-3-Pretrained-Entity-Embeddings" class="headerlink" title="3.3 Pretrained Entity Embeddings"></a>3.3 Pretrained Entity Embeddings</h3><p><strong>我们使用在维基百科上预训练的英语实体嵌入来初始化实体嵌入。</strong>这些嵌入是使用开源的Wikipedia2Vec工具和2019年1月的英文维基百科转储来训练的。向量维度被设置为768，这与基础预训练模型的隐藏表征相同，其他超参数为其默认值。实体嵌入矩阵的参数<font color="red">nn.Embeddings()</font> 在训练过程中被更新。</p><p><font color="red"><strong>这里怎么还是感觉很怪，这个Wikipedia2Vec工具是EMNLP2020年demo的论文，去翻了一下感觉他表示出来的内容不一定借助了BERT，那么这篇论文里实体表征空间会不会和句子的表征空间是不一样的？只是维度一样？所以在这里作者加入了一个W来做一个线性变换，期望能学习变换到相同的空间？</strong></font> </p><p><font color="red">这里应该本质上就是一个Embedding层，用one-hot那种+词表来实现的；</font> </p><h3 id="3-4-Self-supervised-Contrastive-Learning-with-Dropout-Noise"><a href="#3-4-Self-supervised-Contrastive-Learning-with-Dropout-Noise" class="headerlink" title="3.4 Self-supervised Contrastive Learning with Dropout Noise"></a>3.4 Self-supervised Contrastive Learning with Dropout Noise</h3><p><font color="red">这里是SimCSE上提出的dropout noise，在SimCSE中，一句话输入两次在不同dropout的作用下生成两个表征，两个表征之间互为正例</font> </p><p>有dropout噪声的self-supervised CL，它把一个句子放进去，用dropout作为噪声来预测自己，是一种以无监督方式学习句子嵌入的有效方法。我们将这个方法加入到我们的实体CL方法中。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151350152.png" alt="image-20220801151350152" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151406340.png" alt="image-20220801151406340" style="zoom:50%;"><p>自己组合一个，最终的损失函数被如下表示：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151455596.png" alt="image-20220801151455596" style="zoom:50%;">&#x3D;<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151545570.png" alt="image-20220801151545570" style="zoom:50%;">+<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801151609615.png" alt="image-20220801151609615" style="zoom:50%;"></p><p>句子-实体之间的对比损失，加上句子-句子之间的对比损失（SimCSE）</p><h2 id="4-Experiment-Monolingual（单语-英语）"><a href="#4-Experiment-Monolingual（单语-英语）" class="headerlink" title="4. Experiment: Monolingual（单语-英语）"></a>4. Experiment: Monolingual（单语-英语）</h2><p>我们首先在单语环境中评估EASE，我们仅使用英语维基百科数据对单语预训练的语言模型进行微调。</p><p><font color="red">exp章节选一些比较关键内容选写在这里</font> </p><h3 id="4-1-Setup"><a href="#4-1-Setup" class="headerlink" title="4.1 Setup"></a>4.1 Setup</h3><p>选用100w的pairs的英语entity-sentence作为训练数据。在这个设置下，我们从BERT或者RoBERTa的checkpoint上训练sentence embedding，并选用[CLS]作为一句话的sentence embedding。我们只在训练的时候在output  sentence embedding后面加入一个线性层，这与SimCSE的设置相同。</p><p>我们将我们的方法与无监督的句子嵌入方法进行比较，包括GloVe的平均嵌入（Pennington等人，2014）、原始BERT或RoBERTa的平均嵌入，以及之前最先进的方法，如Sim- CSE（Gao等人，2021）、BERT-CT（Carlsson等人，2021）和DeCLUTR。</p><p>我们使用两个任务来评估句子嵌入 任务。STS（Semantic Textual Similarity）和STC（Short Text Clustering）。这些任务被认为是衡量句子嵌入的程度，以涵盖细粒度和广泛的语义结构。</p><ul><li>STS：STS是对捕捉句子分级相似性的能力的一种衡量标准</li><li>STC：句子嵌入的另一个方面是捕捉分类语义结构的能力，即把同一类别的句子紧紧地贴在一起，而把不同类别的句子远远地分开。</li></ul><h3 id="4-2-Results"><a href="#4-2-Results" class="headerlink" title="4.2 Results"></a>4.2 Results</h3><p>实验结果如下，这里作者应该只说了是部分sota，然后展现了有竞争力的性能</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801153357691.png" alt="image-20220801153357691" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801153414345.png" alt="image-20220801153414345" style="zoom:50%;"></p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801153529181.png" alt="image-20220801153529181" style="zoom:80%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801153539680.png" alt="image-20220801153539680" style="zoom:80%;"><h2 id="5-Experiment-Multilingual"><a href="#5-Experiment-Multilingual" class="headerlink" title="5. Experiment: Multilingual"></a>5. Experiment: Multilingual</h2><p>为了进一步探索实体注释作为跨语言对齐监督的优势，我们在多语言环境中测试了易用性：<strong>我们使用多种语言的维基百科数据微调多语言预训练语言模型</strong>。<font color="red">维基百科自动提供了这个，并且是相对对齐的数据</font> </p><h3 id="5-1-Setup"><a href="#5-1-Setup" class="headerlink" title="5.1 Setup"></a>5.1 Setup</h3><p>我们为每种语言抽取50000对样本，并将它们一起用作18种语言实体-句子配对数据的训练数据</p><p><font color="purple">这样综合在一起的话大概是100w这个数据级别</font> </p><p>【脚注：We chose 18 languages (ar, ca, cs, de, en, eo, es, fa, fr,it, ja, ko, nl, pl, pt, ru, sv, tr) present in both the MewsC-16 dataset (see Section 5.2) and the extended version of STS 2017】</p><p>作为我们的主要基线模型，我们使用使用与EASE相同的多语言数据（即实体-句子配对数据中的句子）训练的SimCSE模型</p><p>【脚注：<strong>我们使用在英语维基百科上训练的实体嵌入，与单语环境下的实体嵌入相同（第3节）</strong>。维基百科上训练出来的实体嵌入与单语设置中的实体嵌入相同（第3.3节）。请注意，所有语言的实体都被转换为维基数据的实体，这些实体可通过第3.1节所述的语言间链接在不同语言间共享。「They are converted into Wikidata entities, which are shared across lan- guages, using inter-language links obtained from the March 2020 version of the Wikidata dump」】</p><p>we start fine-tuning from pre-trained checkpoints of mBERT or XLM-R and take mean pooling to obtain sentence em- beddings for both training and evaluation on both EASE and SimCSE，We also tested other pooling methods, but mean pooling was the best in this experiment for both models</p><p><font color="red">这里的话，mean pooling又是best的了</font> </p><p><font color="red">mBERT - multilingual bert <a href="https://aclanthology.org/2020.acl-main.747/">https://aclanthology.org/2020.acl-main.747/</a></font> </p><h3 id="5-2-Multilingual-STS-and-STC"><a href="#5-2-Multilingual-STS-and-STC" class="headerlink" title="5.2 Multilingual STS and STC"></a>5.2 Multilingual STS and STC</h3><p>STS 2017 dataset：which contains annotated sentences for ten language pairs: EN-EN, AR-AR, ES-ES, EN-AR, EN-DE, EN-TR, EN-ES, EN-FR, EN-IT, and EN- NL</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801154641049.png" alt="image-20220801154641049"></p><p>STC上，作者新建了一个数据集MewsC-16：Multilingual Short Text Clustering Dataset for News in 16 languages</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801154838147.png" alt="image-20220801154838147"></p><h3 id="5-3-Cross-lingual-Parallel-Matching"><a href="#5-3-Cross-lingual-Parallel-Matching" class="headerlink" title="5.3 Cross-lingual Parallel Matching"></a>5.3 Cross-lingual Parallel Matching</h3><p>on the <strong>Tatoeba dataset</strong>以更直接地评估其捕捉跨语言语义的能力，这项任务是在给定一组平行句子的情况下，为每个查询句子检索出正确的目标句。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801155914145.png" alt="image-20220801155914145"></p><p>英语作为目标句子&#x2F;初始句子</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801160048664.png" alt="image-20220801160048664"></p><p>在Tatoeba全94个数据集上的验结果</p><h3 id="5-4-Cross-lingual-Zero-shot-Transfer"><a href="#5-4-Cross-lingual-Zero-shot-Transfer" class="headerlink" title="5.4 Cross-lingual Zero-shot Transfer"></a>5.4 Cross-lingual Zero-shot Transfer</h3><p>MLDoc，a cross-lingual document classification dataset that classifies news articles in eight languages into four categories</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801160537535.png" alt="image-20220801160537535"></p><h2 id="6-Case-Study-Fine-tuning-Supervised-Model-with-EASE"><a href="#6-Case-Study-Fine-tuning-Supervised-Model-with-EASE" class="headerlink" title="6. Case Study: Fine-tuning Supervised Model with EASE"></a>6. Case Study: Fine-tuning Supervised Model with EASE</h2><p>In contrast, EASE requires only the Wikipedia text corpus, which is available in more than 300 languages</p><p><font color="red">Wiki上感觉是提供了多语言的对齐数据</font> </p><h2 id="7-Analysis"><a href="#7-Analysis" class="headerlink" title="7. Analysis"></a>7. Analysis</h2><h2 id="7-1-Ablation-Study"><a href="#7-1-Ablation-Study" class="headerlink" title="7.1 Ablation Study"></a>7.1 Ablation Study</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801161429457.png" alt="image-20220801161429457"></p><p>只使用entity-CL（w&#x2F;o self-supervised CL）仍然显著提升了baseline的性能。</p><h3 id="7-2-Alignment-and-Uniformity"><a href="#7-2-Alignment-and-Uniformity" class="headerlink" title="7.2 Alignment and Uniformity"></a>7.2 Alignment and Uniformity</h3><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801162200429.png" alt="image-20220801162200429" style="zoom:80%;"><h3 id="7-3-Qualitative-Analysis※"><a href="#7-3-Qualitative-Analysis※" class="headerlink" title="7.3 Qualitative Analysis※"></a>7.3 Qualitative Analysis※</h3><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801162501883.png" alt="image-20220801162501883"></p><p><font color="red">自己理解了一下效果增加的这几个case：</font> </p><ol><li>mikey和movie在训练的时候是一个instance of 的关系，正例了</li><li>两边实体很像</li><li>两边实体很像</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220801162648744.png" alt="image-20220801162648744"></p><p>理解了一下效果降低的这几个case：</p><ol><li>idea 和 question，可能就就很像，但是忽略了句子其他非实体单词的意思</li><li>数量词</li><li>完全说的是不同的事情？</li></ol><p>作者对这两个表格的解释是：</p><p><strong>表8a显示了EASE如何改善句子嵌入的典型案例。我们发现，EASE的嵌入对同义词和语法差异更加稳健，因为它们更了解句子之间的主题相似性，从而导致更准确的分数推断。</strong></p><p>如表8b中的恶化案例所示，EASE嵌入有时<strong>对主题相似性过于敏感</strong>，使其难以捕捉整个句子的正确含义</p><h2 id="8-Discussion-and-Conclusion"><a href="#8-Discussion-and-Conclusion" class="headerlink" title="8. Discussion  and Conclusion"></a>8. Discussion  and Conclusion</h2><p>我们的实验表明，EASE中的实体监督提高了单语环境下的句子嵌入质量，特别是在多语环境下的句子嵌入质量。正如最近的研究表明，实体注释可以作为anchor来学习高质量的跨语言表征，我们的工作是对其效用的另一种证明，特别是在句子嵌入中。一个有希望的未来方向是探索如何更好地利用实体的跨语言性质。</p><p>我们的实验也证明了维基百科作为一个多语言数据库的效用。如第6节所述，维基百科的实体注释可以弥补学习跨语言表征的平行资源的不足。维基百科目前支持300多种语言，其中约有一半的语言有超过10,000篇文章。此外，维基百科还在不断增长；预计它将包括越来越多的语言。</p><p>然而，对维基百科训练数据的依赖可能会限制模型在特定领域的应用（例如，一般或百科全书领域）。为了将EASE应用于其他领域，人们可能需要对该领域的文本进行手动或自动注释。未来的工作可以研究实体CL在其他领域的有效性，并可能将其与实体链接系统相结合。</p><p><strong>最后，我们注意到EASE中的监督信号本身是有噪声的。不同的实体作为话题指标有不同的特点，而包含相同实体的句子不一定有共同的意义。未来的工作可以通过考虑一个实体在句子中的使用方式来解决这个问题，以获得更可靠的监督。</strong></p><p><font color="red">这个weakness感觉还是挺好发现的吧，在这里能不能搞出一种实体自选择的手段，比如词性？</font> </p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>naacl2022_Token-aware Contrastive Learning论文阅读</title>
    <link href="/2022/08/02/research/papers/contrastive-learning/naacl2022_Token-aware%20CL/"/>
    <url>/2022/08/02/research/papers/contrastive-learning/naacl2022_Token-aware%20CL/</url>
    
    <content type="html"><![CDATA[<h1 id="naacl2022-Token-aware-Contrastive-Learning论文阅读"><a href="#naacl2022-Token-aware-Contrastive-Learning论文阅读" class="headerlink" title="naacl2022_Token-aware Contrastive Learning论文阅读"></a>naacl2022_Token-aware Contrastive Learning论文阅读</h1><p><strong>TaCL: Improving BERT Pre-training with Token-aware Contrastive Learning</strong></p><p>TaCL：利用标记感知对比学习改进BERT预训练；</p><p>Token-aware CL，个人总结文章的亮点如下：</p><p>1）首次将对比性学习用于改进Transformer模型的token level表示（之前看到的一些好像都是句子级别的）</p><p>2）在token级别改善了各向异性这样一个问题，方法比较简单，并在GLUE这种比较广泛使用的数据集上取得了很好的效果；</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li>NLP名词解释：各向异性（Anisotropic）：<a href="https://zhuanlan.zhihu.com/p/468922604">https://zhuanlan.zhihu.com/p/468922604</a></li><li>GLUE基准数据集介绍及下载：<a href="https://zhuanlan.zhihu.com/p/135283598">https://zhuanlan.zhihu.com/p/135283598</a></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li>「MLM通常会输出token表示的各向异性分布，它占据表示空间的一个狭窄子集」这句话还不是很理解，可能需要看看作者在后面是怎么补充的。并且作者为什么说这些表征不理想，对于那些需要对不同token辨别语义的任务来说？原始方法的weakness在哪？</li></ul><p><font color="red">参照博客中的解释，「Anisotropic means word embeddings occupy a narrow cone in the vector space」，也就是说“各向异性”表示词嵌入在向量空间中占据了一个狭窄的圆锥形体（还不是很懂）</font> </p><p><font color="red">各向异性：在向量空间上的含义就是分布与方向有关系，而各项同性就是各个方向都一样，一些学者的研究发现Transformer学到的词向量在空间的分布是这个样子的：</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731002405367.png" alt="image-20220731002405367"></p><p><font color="red">各向异性的缺点在于，最后学到的向量都挤在一起，彼此之间的余弦相似度很高，并不是一个很好的表示。一个好的表示应该同时满足Alignment和Uniformity，前者表示相似的向量距离应该相近，后者表示向量在空间上应该尽量均匀，最好是各向同性的</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731002739558.png" alt="image-20220731002739558" style="zoom:67%;"><p><font color="red">左图是理想的表示，右图则有各向异性的缺点。</font> </p><p><strong><font color="red">此外补充，SimCSE的方法，作者认为通过那个简单dropout的监督，满足了更好的alignment和uniformity（下图来自SimCSE，在训练过程中keep了alignment，减小了各向异性使得更加uniform）</font></strong> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731003303038.png" alt="image-20220731003303038" style="zoom:50%;"><ul><li><p>这种token级别的任务，在下游的句子级别任务上是怎么微调的，因为很多只用CLStoken的话， 这种各向同性，各向异性的分布就在MHSA的过程中被解释过去了？<font color="red">作者没有解释好像，具体这个是怎么用的，在对比实验中也没有做比如CLStoken，还有一句话取平均这样不同方法的效果，是否需要发邮件问问？</font> </p><p><font color="blue">改善了整个bert的表征，Improving BERT … 对比学习为什么是有效的，表征空间 词转化成one-hot，映射成表征空间后，希望所有的词，几万个词在字典的分布应该是比较分散的（各向同性）-&gt; 对比学习的基本思想；；预训练模型给了一个很好的初始化，</font> </p></li><li><p>这种从token级别简单的对比学习，似乎有明显的缺点？比如一句话中存在的指代关系，还有一些同义词，貌似没有处理？<font color="red">待讨论</font></p></li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0.Abstract"></a>0.Abstract</h2><p>在过去的几年里，像BERT这样的Masked Language Modeling语言模型已经彻底改变了自然语言理解领域。然而，现有的预训练MLM通常会输出token表示的各向异性分布，它占据表示空间的一个狭窄子集。<font color="red">（这个话还不太明白，在TODO-list中解决吧）</font> 这样的标记表征并不理想，特别是对于那些需要对不同标记进行辨别语义的任务来说。<font color="red">（同样不明白，哪些任务需要对不同标记进行辨别语义，比如NER类的？但那种是序列建模的任务，和CL感觉本质上不是很像）</font> </p><p>在本文中我们提出TaCL（Token-aware Contrastive Learning，利用标记感知对比学习改进BERT预训练），一种新的持续的预训练方法，鼓励BERT学习各向同性的和有鉴别力的符号表征分布。TaCL是完全无监督的（fully unsupervised），不需要额外的数据。</p><p>我们在大量的英文和中文benchmarks上测试了我们的方法，结果表明，TaCL比原来的BERT模型带来了一致和明显的改进。此外，我们还进行了详细的分析，以揭示我们方法的优点和内部工作原理。</p><p><font color="blue">连续学习，提升bert的表征能力，学到更均匀的表达，</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>自从BERT的兴起，掩码语言模型（Masked Language Modeling，MLM）已经成为几乎所有自然语言理解任务的事实上的主干。尽管它们取得了明显的成功，但许多现有的以MLM目标预训练的语言模型都存在着各向异性的问题《How contextual are contextu- alized word representations? comparing the geome- try of bert, elmo, and GPT-2 embeddings.》。也就是说，他们的标记表示位于表示空间的一个狭窄的子集，因此在捕捉不同标记的语义差异方面，辨别力较差，功能较弱。</p><p><font color="red">通过博客还有一些其他资源的学习，如果不满足各向异性的话，可能所有token之间的意思都非常相近，那么不同token 的语义差异辨别力确实会差一些</font> </p><p>最近，通过无监督的句子级对比学习来不断训练MLM，取得了很大的进展，目的是为了创造出更有辨识度的句子级句子表征。<font color="red">（使得具有语义相似的句子靠的更近，语义不同的句子距离较远，也就是对比学习本质上的motivation，这是一个在句子级别上的motivation和实践）</font> 然而，这些表征值被评估为句子嵌入，没有证据表明他们会对其他成熟的NLU任务有益。我们表明，这些方法的对像SQuAD这样具有挑战性的任务几乎没有任何好处。<font color="red">SQuAD是机器阅读理解任务的数据集，之前类似SimCSE的评测都是在STS那种数据集上的，那种数据集有一种衡量embedding好坏的感觉，还不是太过于涉及下层任务？</font> </p><p>在本文中，我们认为，获得更具辨别力（discriminative）和可转移性（transferrable）的表征的关键在于对比学习性和同向性的token-level的特征。为此，我们提出了TaCL（利用标记感知对比学习改进BERT预训练），这是一种新的持续的预训练方法， 鼓励BERT学习更具辨别力的token表征。</p><p><strong><font color="purple">下面这块开始比较重点说方法的，大概能初步了解下方法</font></strong> </p><p>具体来说，我们的方法设计两个模型（一个学生和一个教师），它们都是由同一个预先训练好的BERT初始化的。在学习阶段，我们冻结教师的参数，并不断优化学生的模型：（1）原来BERT所具有的MLM和NSP训练目标；（2）新提出的TaCL训练目标。TaCL损失是通过对比学生对被掩码的标记的表述和教师在没有掩码输入标记的情况下产生的“参考”表述而得到的。在图1中，我们对方法进行了阐述。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731010744051.png" alt="image-20220731010744051" style="zoom:67%;"><p><font color="red">这张图一眼看过去的话是一个token level的，一个被掩码的token的表征应当更接近teacher给出的那个未被掩码词的表征，而原理其他词的表征</font></p><p><strong><font color="purple">换句话说，这里是token级别的各向异性优化？而SimCSE像是sentence级别各向异性的优化！！！</font></strong> </p><p>我们在广泛的英文和中文基准数据集上广泛地测试了我们的方法，并说明TaCL在大多数评估的数据集上带来了明显的性能改进（3.1.1节）。这些结果验证了更具辨别力和各向同性的标记能带来更好的模型性能。此外，我们还强调了与目前最先进的句子级别技术对比，在NLU任务中使用我们标记级方法的好处（3.2.1节）。我们进一步分析了TaCL的内部运作和它对标记表示空间的印象（3.2.2节）。</p><p><font color="purple">这里的3.2.1节看起来是和SimCSE作为baseline motivation十分接近的方法，使用token级别，优化句子级别，超越SimCSE？</font> </p><p>据我们所知，我们的工作是首次<strong>将对比性学习用于改进Transformer模型的token level表示</strong>。我们希望这项工作的发现能够促进对比学习和表征学习在更细粒度上的交叉方法的进一步发展。</p><h2 id="2-Token-aware-Contrastive-Learning"><a href="#2-Token-aware-Contrastive-Learning" class="headerlink" title="2. Token-aware Contrastive Learning"></a>2. Token-aware Contrastive Learning</h2><p>我们的方法包含一个学生模型S和一个教师模型T，两者都是从相同的预训练BERT模型中初始化的。在训练过程中我们固定T的参数，只优化S的参数。给定序列x&#x3D;[x1, x2, …, xn]，我们使用与BERT作者（devlin等）相同的程序随机掩码x，并将掩码后的序列x~送入到学生模型中，以产生上下文表征<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731143904381.png" alt="image-20220731143904381" style="zoom:50%;">。同时，将未掩码的序列x输入到模型T中获取<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144323169.png" alt="image-20220731144323169" style="zoom:50%;">，这一过程如figure1所示。所提出的标记感知对比性学习目标$L_{TaCL}$被定义为式1：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144823341.png" alt="image-20220731144823341" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731144843641.png" alt="image-20220731144843641" style="zoom:50%;"><p><font color="red">这里说的是只把mask掉的作为一个token级别的anchor</font> </p><p>在直觉上，学生学会了使被掩码的标记的表示更加接近于教师产生的“参考”表示，而远离同一序列中的其他标记。<font color="red">（这是对比学习这样一个任务的特性）</font> 因此，学生学到的标记表征对不同的标记更具辨别力，因此更能遵循各项同性的分布。同BERT作者一样，我们将MLM和NSP同样加入损失函数中，在持续的预训练阶段，学生模型的总体学习目标$L$被定义为：</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731145338681.png" alt="image-20220731145338681" style="zoom:50%;"><p>请注意，学生的学习是完全无监督的，可以使用原始的预训练语料库来实现。学习完成后，我们在下游任务中对学生模型进行微调。</p><h2 id="3-Experiment"><a href="#3-Experiment" class="headerlink" title="3. Experiment"></a>3. Experiment</h2><p>对于英文的基准数据集，我们使用BERT_base还有BERT-large模型。对于中文的基准数据集，我们使用BERT_base模型。超参数的设置作者描述如下：</p><p>After initializing the student and teacher, we continually pre-train the student on the same Wikipedia corpus as in Devlin et al. (2019) for 150k steps. The training samples are truncated with a maximum length of 256 and the batch size is set as 256. The temperature τ in Eq. (1) is set as 0.01. Same as Devlin et al. (2019), we optimize the model with Adam optimizer (Kingma and Ba, 2015) with weighted decay, and an initial learning rate of 1e-4 (with warm-up ratio of 10%).</p><h3 id="3-1-Evaluation-Benchmarks"><a href="#3-1-Evaluation-Benchmarks" class="headerlink" title="3.1 Evaluation Benchmarks"></a>3.1 Evaluation Benchmarks</h3><p>对于英文，作者使用了GLUE数据集，以及SQuAD1.1 2.0数据集——评估该模型在token级答案提取任务中的表现的数据集。报告了精确匹配（EM）和F1得分的dev集结果。</p><p>对于中文，作者使用了NER（named entity recognition）和CWS（chinese word segment）这两个相关的任务。</p><h3 id="个人笔记——GLUE数据集中的各个任务介绍"><a href="#个人笔记——GLUE数据集中的各个任务介绍" class="headerlink" title="个人笔记——GLUE数据集中的各个任务介绍"></a>个人笔记——GLUE数据集中的各个任务介绍</h3><p>对于英文的基线数据集，我们使用GLUE数据集，其中包含各种句子级分类任务。<font color="red">参考博客中的学习来说：为了让NLU任务发挥最大的作用，一些机构创建了一个多任务的自然语言理解基准和分析平台，就是GLUE（General Language Understanding Evaluation）。其中包括9项NLU任务，涉及到自然语言推断、文本蕴含、情感分析、语义相似等多个任务。</font> </p><p><font color="purple">作者的方法是token级别的，在这些句子级别的任务上，他是怎么应用转化过来的？下文如果看到的话会补充在TODO-list中</font> </p><img src="https://pic2.zhimg.com/80/v2-2948db2c0d3a56b2282a01c954277d15_1440w.jpg" alt="img" style="zoom:67%;"><p>CoLA：The Corpus of Linguistic Acceptability，语言可接受性语料库，单句子分类任务，每个句子被标注为是否合乎语法的单词序列。任务是一个二分类任务，标签共两个，0表示不合乎语法，1表示合乎语法；</p><p>SST-2：The Stanford Sentiment Treebank，斯坦福情感树库，单句子分类任务，包含电影评论中的句子和他们情感的人类注释。类别包括正面情感和负面情感。即针对句子级别，分为正面情感和负面情感；</p><p>MRPC：The Microsoft Research Paraphrase Corpus，微软研究院释义语料库。相似性和释义任务，是从在线新闻源中自动抽取句子对语料库，并人工注释句子对中的句子是否在语义上等效。类别不平衡，68%的正样本。标签为1代表两句话互为释义，标签为0代表两句话不互为释义；</p><p>STS-B：The Semantic Textual Similarity Benchmark，语义文本相似性基准测试，相似性和释义任务，是从新闻标题、视频标题、图像标题以及自然语言推断数据集中提取的句子对集合，每对都是由人类注释的，其相似性评分为0-5（大于等于0且小于等于5的浮点数）。任务就是预测这些相似性得分，本质上是一个回归问题，但是可以归类为句子对的5分类任务；</p><p>QQP：The Quora Question Pairs，Quora问题对数据集，任务是确定一堆问题在语义上是否等效；</p><p>MNLI：The multi-genre natural language inference corpus，是通过众包方式队进行文本蕴含标注的集合，给定前提（premise）语句和假设（hypothesis）语句，任务是预测前提语句是否包含假设（蕴含，entailment），与假设矛盾（contradiction），或者两者都不（中立，neutral）。前提语句是从数十种不同来源手机的；</p><p>QNLI：Question-Answering NLI，判断问题（question）和句子（sentence，维基百科段落中的一句）是否蕴含，蕴含和不蕴含的二分类任务；</p><p>RTE：The Recognizing Textual Entailment datasets，自然语言推断任务，将一系列挑战赛数据集整合而来，判断句子1和句子2是否互为蕴含，二分类任务；</p><p>WNLI：Winograd NLI，Winograd自然语言推断，判断句子对是否相关，蕴含和不蕴含，二分类任务；</p><p>感觉这些方法都是句子级别上的一些下游任务，也都是NLU领域上一些下游任务，任务特点和NER那类的不是很相关；</p><h3 id="个人笔记——SQuAD数据集"><a href="#个人笔记——SQuAD数据集" class="headerlink" title="个人笔记——SQuAD数据集"></a><strong>个人笔记——SQuAD数据集</strong></h3><p>机器阅读理解相关</p><h3 id="※这里记录一些Experiment章节中的重点内容"><a href="#※这里记录一些Experiment章节中的重点内容" class="headerlink" title="※这里记录一些Experiment章节中的重点内容"></a>※这里记录一些Experiment章节中的重点内容</h3><ul><li>主实验结果</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731153458674.png" alt="image-20220731153458674"></p><p>表1：BERT+MT代表BERT with more training（by continually pre-training the original BERT on Wikipedia for 150k steps3 using the original BERT pre-training objectives）；双竖线代表作者原文报告的指标，++代表复现的指标；</p><p>这些结果表明，学习各向同性的标记表示空间有利于模型的性能，特别是在以token为中心的任务上<font color="red">这里指的是作者自己补充的一些数据集？</font> 。</p><p><font color="purple">这里还是很关心，这种token级别的方法，作者是咋用到句子级的任务上的啊？</font> </p><ul><li>和其他一些sentence级别方法的对比：</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731154803399.png" alt="image-20220731154803399" style="zoom:67%;"><p>This could be attributed to the fact that such methods only focus on learning sentence-level representations while ignoring the learning of individual tokens</p><p>这可能是由于这类方法只注重学习句子层面的表征，而忽略了对单个标记的学习。这种行为对于像SQuAD这样需要信息性标记表示的任务来说是不可取的。</p><p>尽管如此，消减的模型-1表明，原始的BERT预训练目标（LMLM和LNSP）在一定程度上弥补了句子级对比方法造成的性能下降。</p><p>另一方面，消减的模型-2表明，我们的标记意识对比目标通过学习更好的标记表征，帮助模型取得更好的结果</p><ul><li>Token Representation Self-similarity，token表征的自相似性</li></ul><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731155359386.png" alt="image-20220731155359386" style="zoom:67%;"><p>其中hi和hj是由模型产生的xi和xj的标记表示。<strong>直观地说，较低的s(x)表明序列x中的标记的表征彼此之间的相似度较低，因此具有较强的辨别力。</strong>也就是说一个只该和自己的表征比较相近</p><p><strong><font color="purple">这里感觉有个很大的问题，就是说指代关系，或者it那些词的话，他们应当是互为正例的？在一句话中的指代，以及一些同义词，这个作者是否忽略掉了？</font></strong> </p><p>我们从中文和英文维基百科中抽取了5万个句子，并计算了不同层次上的表征的自相似性。图2显示了TaCLbase和BERTbase在所有句子中的平均结果。我们看到，在中间层，TaCL的自相似度比BERT的高。相反，在顶层（第12层），TaCL的自相似性明显低于BERT的自相似性，这表明TaCL的最终输出标记表示更具有辨别力</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731160842407.png" alt="image-20220731160842407"></p><p><font color="purple">最后的chinese 11-12层降幅很大啊</font> </p><ul><li>Qualitative analysis：</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731161059262.png" alt="image-20220731161059262" style="zoom:50%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220731161119303.png" alt="image-20220731161119303" style="zoom:50%;"></p><p>Figure 3: Self-similarity Matrix Visualization: (a) BERT and (b) TaCL. (best viewed in color)</p><p>我们看到，与BERT（图3(a)）相比，TaCL（图3(b)）的自相似性在对角线外的部分要低得多。这进一步突出了TaCL的单个标记表示更具有辨别力，这反过来导致了模型性能的提高，正如所证明的那样</p><p><font color="purple">还是觉得有个很大的问题，是不是某些词就应该表征更加接近的，比如a中很明显的逗号和句号</font> </p><h2 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h2><p>在这项工作中，我们提出了TaCL，一种新的方法，应用标记感知的对比学习来持续地对BERT进行预训练。我们在广泛的英文和中文基准上进行了广泛的实验。结果表明，我们的方法在所有被评估的基准上都带来了明显的性能改进。然后，我们深入研究了TaCL的内部工作，并证明我们的性能提升来自于更有鉴别力的标记代表的分布。</p><p><font color="red">证明手段似乎有些单薄</font> </p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emnlp2021_Raise a Child in Large Language Model论文阅读</title>
    <link href="/2022/07/21/research/papers/contrastive-learning/emnlp2021_Raise%20a%20Child%20in%20Large%20Language%20Model%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/07/21/research/papers/contrastive-learning/emnlp2021_Raise%20a%20Child%20in%20Large%20Language%20Model%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="emnlp2021-Raise-a-Child-in-Large-Language-Model论文阅读"><a href="#emnlp2021-Raise-a-Child-in-Large-Language-Model论文阅读" class="headerlink" title="emnlp2021_Raise a Child in Large Language Model论文阅读"></a>emnlp2021_Raise a Child in Large Language Model论文阅读</h1><p>Raise a Child in Large Language Model: Towards Effective and Generalizable Fine-tuning</p><p>中文翻译为：在大型语言模型中培养Child：实现有效且通用的fine-tune</p><p>个人总结贡献如下：</p><ul><li>一种有些即插即用感觉的fine-tune操作，称为CHILD-TUNING技术，基本原理是在back propagation的时候随机mask掉一些，这个方法与之前的其他tuning方法是正交的，如果用在一起可能可以进一步提升性能；</li><li>CHILD-TUNING_F：task-free的方法，与任务无关，伯努利分布每个W按照p_F mask掉一些；</li><li>CHILD-TUNING_D：task-driven方法，任务相关，Fisher信息来选择任务最关键的，此外只在最开始初始化一次；</li><li>和模型剪枝还是有区别的，这种保留了模型的全部前向能力，motivation是不希望大幅度改变bert那种预训练模型的表征从而导致的灾难性遗忘；</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>知乎论文解读：<a href="https://zhuanlan.zhihu.com/p/433636342">https://zhuanlan.zhihu.com/p/433636342</a></li><li>github code：<a href="https://github.com/alibaba/AliceMind/tree/main/ChildTuning%EF%BC%8C%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95">https://github.com/alibaba/AliceMind/tree/main/ChildTuning，代码结构为什么这么简单</a></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li>backward过程中，掩码掉一部分的梯度是如何被决定的？<font color="blue">作者有两种方式，CHILD-TUNING_F和CHILD-TUNING_D，分别代表task-free和task-driven的方式，</font> </li><li>从理论上或者说感官上这种方法为什么能起到作用？</li><li>读下来abstract后感觉在下游fine-tune是一个即插即用的方法？但是目标场景是什么，是所有fine-tune的任务都可以，还是说只针对少量数据微调那种gap比较大的？</li><li>作者提出来的这个mask，在实现上是怎么做的？每个nn.Linear都要配上一个mask？</li><li>CHILD-TUNING_D在代码上那个Fisher信息是怎么搞出来的？</li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>近期的预训练语言模型从数百万个参数扩展到数十亿个参数。因此，在各种下游任务中，需要使用有限的训练语料对超大预训练模型进行微调。<font color="red">2022.7 BigScience Large Open-science Open-access Multilingual Language Model（BLOOM）：<a href="https://huggingface.co/bigscience/bloom">https://huggingface.co/bigscience/bloom</a></font> </p><p>在本文中，我们提出了一种直接且有效的微调技术，CHILD-TUNING，它通过在backward process中策略性的掩码非子网络的梯度来更新大型预训练模型的参数子集（称为子网络）<font color="red">（这里指的应该是back-propagation？这个地方掩码掉一些部分是被如何决定的，从理论上或者感官上来说为什么这种方法能起到作用？）</font> 。在GLUE基准测试中的各种下游任务上的实验表明，在四种不同的预训练模型中，CHILD- TUNING始终以1.5 ∼ 8.6的平均分超越了vanilla微调，并以0.6 ∼ 1.3分超越了先前的微调技术。</p><p>此外，关于领域转移和任务转移的实证结果表明，CHILD-TUNING能够以较大的幅度获得更好的泛化性能。</p><p><font color="red">读下来abstract后感觉在下游fine-tune是一个即插即用的方法？但是目标场景是什么，是所有fine-tune的任务都可以，还是说只针对少量数据微调那种gap比较大的？一些博客中提到可以作为trick使用</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><font color="red">一般来说</font> </p><p>最近，预训练语言模型PLM对自然语言处理NLP领域产生了显著影响。预训练和微调已经成为NLP的一个范式，主导了大量的任务，</p><p>尽管它取得了巨大的成功，但如何将这种具有百万到数十亿参数的大规模预训练语言模型适应于各种场景，尤其是训练数据有限的情况下，仍然是一个挑战。由于容量极大，标注数据有限，传统的迁移学习倾向于积极的微调（aggressive fine-tuning），导致</p><ul><li><p>1）由于过拟合，测试数据的结果退化了；</p></li><li><p>2）转移到域外数据或者其他相关任务中的概括能力差；</p></li></ul><p>防止fine-tune后的模型偏离预训练的权重太多（即较少的知识遗忘）被证明是有效的，以减轻上述挑战<font color="red">（这里见过的方法是把bert那些层和后面fine-tune那些层设置不同的学习率，bert那边设小一点慢调，后面设大一点开始快调）</font> 。例如RecAdam在微调权重和预训练权重之间引入了L2距离惩罚。此外，Mixout在微调过程中使用预训练的权重随机替换了部分模型参数，他们背后的核心思想是利用预训练的权重来规范微调模型。</p><p>在本文中，我们提出从一个新的角度来缓解积极微调的问题。**<font color="green">基于在微调过程中没有必要更新大尺度模型中的所有参数这一观察</font> **，我们提出了一种有效的微调技术，CHILD-TUNING，他通过战略性的掩码掉非子网络的梯度，直接更新一个参数子集（称为子网络），如图1所示。请注意，他与模型修剪不同，因为他仍然在整个模型上进行前向传播，从而充分利用了隐藏在预训练权重中的知识。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718200422323.png" alt="image-20220718200422323" style="zoom:67%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718200434301.png" alt="image-20220718200434301" style="zoom:50%;"></p><p>Figure1：CHILD-TUNING的示意图。左图：在前向传播forward的时候在整个网络上，然而在backward反向传播的时候在网络的一个子集上（举例：child network）。右图：为了实现这一点，对非子网络的梯度进行无任务或者任务驱动的mask，将其重置为0（灰色网格）。<font color="red">（自己理解上面这个图来说的话，delta就是那个梯度，w&#x3D;w+lr*deltaw，于是把其中一些的梯度设置为0，他们的参数在反向传播的过程中则不会更新）</font> </p><p>具体来说，我们提出了两个变体，CHILD-TURNING_F和CHILD-TURNING_D，分别以无任务（<strong>task-free</strong>）和任务驱动(<strong>task-driven</strong>)的方式检测子网络。CHILD-TURNING_F在没有任务数据的情况下，通过伯努利分布选择出子网络。它为全部梯度引入了噪声，起到了正则化的作用，从而防止了对小数据集的过度拟合，导致了更好的泛化<font color="red">（更好泛化是因为一定程度上保留了pretrainmodel的能力？）</font> 。进一步的，CHILD-TUNING_D利用下游任务数据<strong>检测与任务最相关的参数作为子网络</strong>，并将非子网络的参数冻结在其预训练的权重上。它通过应用于全梯度的特定任务掩码减少了模型的假设空间，有助于有效地使大规模预训练模型适应各种任务，同时极大地保留了其原有的泛化能力。<font color="red">选择性的梯度裁剪？目前从这段文字还暂时有点不清楚这两个的区别和具体是怎么实现的</font> </p><p>我们在GLUE基准上的大量实验表明，CHILD-TUNING在微调不同的PLM方面可以更加出色，与vanilla微调相比，在CoLA&#x2F;RTE&#x2F;MRPC&#x2F;STS-B任务上平均得分提高了8.60分（将在3.3节进一步详述）。此外，它在转移到域外数据和其他相关任务中实现了更好的泛化能力（将在3.4节进一步详述）。实验结果还表明，CHILD-TUNING产生的改进始终比最先进的微调方法大。更重要的是，由于CHILD-TUNING与这些先前的方法是正交的，将CHILD-TUNING与它们整合在一起甚至可以导致进一步的改进（将在4.1节进一步详述）。总而言之，我们的贡献有以下三个方面：</p><ul><li>我们提出了CHILD-TUNING，这是一种直接而有效的微调技术，只更新子网络的参数。我们探索以无任务和任务驱动的方式检测自网络。<font color="red">从motivation解释来说，好像就是在fine-tune过程中没有必要更新所有的，选一部分子网来更新，同时也保证了泛化能力，增强fine-tune效果，并且与之前的方法是正交的</font> ；</li><li>CHILD-TUNING可以有效地使大规模训练模型适应各种下游场景，从域内到域外，以及跨任务transfer学习；</li><li>由于CHILD-TUNING与先前的微调方法是正交的，将CHILD-TUNING与它们整合在一起可以进一步提高微调性能；</li></ul><h2 id="2-Methodology"><a href="#2-Methodology" class="headerlink" title="2. Methodology"></a>2. Methodology</h2><p><font color="red">作者选择把methodology放在第二章来写了，这章公式比较多也比较硬核</font> </p><p>为了使大规模预训练的语言模型更好的适应各种下游任务，我们提出了一种简单而有效的微调技术，即CHILD-TUNING。我们首先在backward过程中引入梯度掩码，以达到更新一个参数子集的目的（i.e. child network），伴随着在前向forward过程中仍然利用整个大模型的知识（将在2.1节详述）。然后，我们探讨了两种检测CHILD-NETWORK的方法（i.e. 生成不同的梯度掩码），CHILD-TUNING_F是一种task-free的方式（将在2.2节详述），CHILD-TUNING_D是一种task-driven的方式（将在2.3节详述）。</p><h3 id="2-1-Overview-of-CHILD-TUNING"><a href="#2-1-Overview-of-CHILD-TUNING" class="headerlink" title="2.1 Overview of CHILD-TUNING"></a>2.1 Overview of CHILD-TUNING</h3><p>在介绍CHILD-TUNING的时候，我们首先给出了一个vanilla微调过程中反向传播的一般表述。我们把第t次迭代时的参数模型表示为w_t（w_0代表预训练模型的weights）。vanilla微调计算损失函数L(w_t)的梯度，然后对所有参数应用梯度下降法，可以表述为：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718211446950.png"></p><p>其中<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718211506998.png" alt="image-20220718211506998">代表模型针对参数w_t的梯度， $\eta$代表学习率。<font color="red">这里就是普通的梯度下降</font> </p><p>CHILD-TUNING也像标准微调一样，反向的计算所有可训练学习参数的梯度。然而，关键的区别在于，CHILD-TUNING在第t次迭代时确定了一个子网络C_t，并且只更新这部分参数。为了实现这一点，我们首先定义一个与w大小相同的0-1掩码，如下所示：</p><p><font color="red">这个从代码上是怎么实现的，看起来还挺好懂的，每个nn.Linear都配上一个M？</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718212223623.png" alt="image-20220718212223623"></p><p>其中$M_{t}^{(i)}$和$w_{t}^{(i)}$分别代表mask M_t的第i个元素和第t轮次训练迭代的参数w_t。<font color="red">在第t个turn时，w这个向量的第i个位置是否属于C_t，注意W是向量，比如nn.Linear()这样的一个矩阵</font> 。然后，我们通过简单地用以下等式替换等式1来正式定义CHILD-TUNING技术：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718212817411.png" alt="image-20220718212817411"></p><p>当应用于广泛使用的Adam优化器时，Algorithm1提供了CHILD-TUNING的伪代码。主要区别在于插入了第5-7行。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718214146788.png" alt="image-20220718214146788" style="zoom:80%;"><p><font color="red">这里也是说CHILD-TUNING_F是每次初始化一个新的C？每次optimizer.optimize的时候的时候初始化一个C！这样干掉一些梯度</font> </p><h3 id="2-2-Task-Free-Variant-rm-CHILD-TUNING-F"><a href="#2-2-Task-Free-Variant-rm-CHILD-TUNING-F" class="headerlink" title="2.2 Task-Free Variant: ${\rm CHILD-TUNING}_{F}$"></a>2.2 Task-Free Variant: ${\rm CHILD-TUNING}_{F}$</h3><p>在本节中，我们首先探讨不需要任何下游任务数据的子网络选择，即称为CHILD-TUNING的task-free技术。具体来说，CHILD-TUNING_F在第t次迭代时候生成一个0-1mask M_t，该mask M_t来自概率为p_F的伯努利分布<font color="red">按照下面的定义，是1的概率就是p_F，即mask掉了1-p_F的</font> 。**<font color="red">p_F是保留下来的！！！</font> **</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718220720471.png" alt="image-20220718220720471"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718214948850.png" alt="image-20220718214948850"></p><p>p_F越高，子网络规模越大，因此更新的参数也就更多。当p_F&#x3D;1时，CHILD-TUNING_F退化为vanilla的微调方法。<strong>请注意，我们还将剩余的梯度扩大了1&#x2F;p_F，其保持梯度的期望值。</strong></p><p><strong>我们<font color="red">从理论上证明了</font> CHILD-TUNING_F的有效性。我们用∆w代表每次迭代的更新量。</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718221148353.png" alt="image-20220718221148353"></p><p>直观的说，定理1表明梯度的方差是p_F的严格递减函数。因此CHILD-TUNING_F改善了梯度的方差，探索和开发之间的权衡可以通过调整p_F来控制。<font color="red">p_F扩大，梯度的方差减小，即保留下来的越多，梯度方差越小</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718221804896.png" alt="image-20220718221804896" style="zoom:50%;"><p>定理2所示，随着方差的增大，模型可以收敛到更平坦的局部最小值（定理2中的ρ较小）。受到研究表明平坦的最小值倾向于更好的泛化的启发，我们可以进一步证明CHILD-TUNINGF降低了泛化误差的界限。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718222212497.png" alt="image-20220718222212497" style="zoom:50%;"><p><strong>因此，CHILD-TUNINGF可以被看作是优化过程的一个强大的正则化。它使模型能够跳过损失景观中的鞍点，并鼓励模型收敛到一个更平坦的局部最小值。有关所述定理和证明的更多细节，请参考附录E。</strong></p><p><font color="blue">每次都是一个地方梯度最大，但是每次把那个地方都mask掉，就不收敛；；；证明了能收敛，然后能收敛到更平滑的，实现了一个无监督的剪枝？</font> </p><p><font color="blue">训练时：前向的时候走了所有的，反向的时候只把子网络的参数更新；预测推理时？</font> </p><h3 id="2-3-Task-Driven-Variant-rm-CHILD-TUNING-D"><a href="#2-3-Task-Driven-Variant-rm-CHILD-TUNING-D" class="headerlink" title="2.3 Task-Driven Variant: ${\rm CHILD-TUNING}_{D}$"></a>2.3 Task-Driven Variant: ${\rm CHILD-TUNING}_{D}$</h3><p>考虑到下游的标记数据，我们提出了CHILD-TUNING_D，它可以检测出对目标任务最重要的子网络。具体来说，我们采用Fisher信息估计法来寻找与特定下游任务高度相关的参数子集。Fisher信息是一个很好的方法，可以提供一个随机变量携带多少关于分布参数的信息的估计。对于一个预训练模型，Fisher信息可以用来衡量网络中的参数对下游任务的相对重要性。</p><p><font color="red">这里也是对其中的数学原理不太了解，</font> </p><p>形式上，模型参数w的Fisher信息矩阵（Fisher Information Matrix, FIM）定义如下：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718223445719.png" alt="image-20220718223445719"></p><p>其中x和y分别代表input和output <font color="red">这里E是期望的意思</font> 。它也可以被看作是对数似然的梯度相对于参数w的协方差。按照Kirkpatrick等人（2016）的说法，给定特定任务的训练数据数据D，我们使用经验FIM的对角线元素来点估参数的任务相关重要性。从形式上看，我们得出第i个参数的Fisher信息如下<font color="red">这里第i个参数，就是w这个向量中的第i个位置</font> ：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718223845598.png" alt="image-20220718223845598"></p><p><font color="red">自己再尝试理解下这个公式：在已知xj和w的情况下，获取yj的概率越大，那么代表wi可能有没有都无所谓了？</font> </p><p><font color="red">换句话说，当已知xj和w的时候，获取yj的概率很小，那么wi的梯度会很大，求和后平均，认为wi是很关键的？</font> </p><p><font color="red">这个CHILD-TUNING_D不知道在代码上的大概是怎么实现的</font> </p><p>我们认为，参数对目标任务越重要，它所传递的Fisher信息就越高。因此，子网络C是由信息量最大的参数组成的。子网络的比例<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718223951021.png" alt="image-20220718223951021">$\in (0, 1]$，其中<img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718224016406.png" alt="image-20220718224016406">代表non-child网络（非子网络部分)。随着pD的上升，子网络的规模也在增加，当pD&#x3D;1时，它就退化为vanilla的微调策略。</p><p><strong>由于获得任务驱动（task-driven）的子网络的开销比无任务（task-free）的子网络的开销要大，我们在微调开始时简单地得出CHILD-TUNING_D的子网络，并在微调期间保持不变。（i.e. <img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718224209488.png" alt="image-20220718224209488">)</strong> <font color="red">这里也是说CHILD-TUNING_F是每次初始化一个新的C？每次optimizer.optimize的时候的时候初始化一个C！这样干掉一些梯度</font> </p><p>通过这种方式，CHILD- TUNINGD极大地减少了大规模模型的假设空间，从而缓解了过拟合。同时，将非子网冻结在预训练的权重上，可以从根本上保持泛化能力。</p><h2 id="3-Experiments"><a href="#3-Experiments" class="headerlink" title="3.Experiments"></a>3.Experiments</h2><h3 id="3-1-Datasets"><a href="#3-1-Datasets" class="headerlink" title="3.1 Datasets"></a>3.1 Datasets</h3><p><strong>GLUE benchmark</strong>：跟随以前的研究，我们在GLUE排行榜的各种数据集上进行了实验，包括语言上的可接受性（Linguisitc Acceptability任务，CoLA数据集）、自然语言推理（Natural Language Inference任务，RTE、QNLI、MNLI数据集）、释义和相似性（Paraphrase and similarity任务，MRPC、STS-B、QQP数据集）、情感分类（Sentiment Classification任务，SST-2数据集）。</p><p>CoLA和SST-2是单句分类任务，其他任务涉及一对句子。详细可见附录A中的说明。</p><p>按照大多数以前的工作，我们在训练集上对预训练模型进行微调，并使用最后一个检查点直接报告设计集的结果，因为测试结果只能通过排行榜访问，有提交数量的限制。</p><p><strong>NLI datasets</strong>：在本文中，我们还进行了实验以探索基于几个自然语言推理任务的微调模型的概括能力。<font color="red">在阅读SimCSE论文的时候对这个数据集有一些了解，一句前提对应蕴含、中立、矛盾的多句话，但是对评价指标还没什么了解，应该是给两句推理他们之间的关系吧</font> </p><p>我们额外介绍了三个NLI数据集，即SICK（Marelli等人，2014）、SNLI（Bowman等人，2015）和SciTail（Khot等人，2018）。我们还报告了与GLUE一致的dev集的结果</p><p><font color="purple">其他章节的experiment暂时跳过，粗读着重读一下方法</font> </p><h2 id="4-Analysis-and-Discussion"><a href="#4-Analysis-and-Discussion" class="headerlink" title="4. Analysis and Discussion"></a>4. Analysis and Discussion</h2><p><font color="red">这个部分挑一些自己觉得重点的记录一下，背后有一种motivation的感觉；</font> </p><h3 id="4-1-Comparison-with-Prior-Methods"><a href="#4-1-Comparison-with-Prior-Methods" class="headerlink" title="4.1 Comparison with Prior Methods"></a>4.1 Comparison with Prior Methods</h3><p>不仅超过了vanilla fine-tune，还超过了一些专门的fine-tune方法；</p><h3 id="4-2-Result-in-Low-resource-Scenarios"><a href="#4-2-Result-in-Low-resource-Scenarios" class="headerlink" title="4.2 Result in Low-resource Scenarios"></a>4.2 Result in Low-resource Scenarios</h3><p>we explore the effect of CHILD- TUNING with only a few training examples，还是比vanilla效果好</p><p>这表明，尽管当训练数据处于极端低资源的情况下，过拟合现象相当严重，但CHILD-TUNING仍然可以有效地改善模型的性能，特别是对于CHILD-TUNINGD，因为它减少了模型的假设空间</p><p>It suggests that although overfitting is quite severe when the training data is in extreme low-resource scenarios, CHILD-TUNING can still effectively improve the model performance, especially for CHILD-TUNINGD since it decreases the hypothesis space of the model</p><h3 id="4-3-What-is-the-Difference-Between-CHILD-TUNING-and-Model-Pruning？"><a href="#4-3-What-is-the-Difference-Between-CHILD-TUNING-and-Model-Pruning？" class="headerlink" title="4.3 What is the Difference Between CHILD-TUNING and Model Pruning？"></a>4.3 What is the Difference Between CHILD-TUNING and Model Pruning？</h3><p> <font color="red">Model Pruning有一种模型剪枝，或者缩减模型大小那个感觉，这个原理上还是很不一样的</font> </p><p>CHILD-TUNINGD以任务驱动的方式检测最重要的子网络，在微调过程中只更新子网络中的这个参数，其他参数冻结。它很可能与模型修剪相混淆，后者也是检测模型中的子网络（但随后删除其他参数）。</p><p>实际上，”CHILD-TUNING “和模型修剪 在目标和方法上都是不同的。就目标而言，模型修剪的目的是提高推理效率，同时保持性能，而CHILD-TUNING的提出是为了解决过拟合问题，并在微调时提高大规模语言模型的泛化能力。根据不同的方法，模型修剪在推理过程中放弃了不重要的参数，而不属于子网络的参数在训练和推理过程中仍然保留给CHILD-TUNING。通过这种方式，隐藏在预训练权重中的非子网络的知识将得到充分的利用。<font color="red">模型裁剪可能性能就降下来了？而这里的CHILD-TUNING更像是一个regulazation方法</font> </p><p>为了更好地说明CHILD-TUNINGD与模型修剪相比的有效性。TUNINGD与模型修剪相比，我们将所有不属于子网络的参数设置为零，这在表5中被称为Prune。表中显示，一旦我们放弃了子网络中的参数，在四个任务（CoLA&#x2F;RTE&#x2F;MRPC&#x2F;STS-B）上的得分就急剧下降了33.89分，模型甚至在CoLA任务上崩溃了。这也表明，在儿童网络中的参数，非儿童网络中的参数也是必要的，因为它们可以提供在预训练中学习到的一般知识。</p><h3 id="4-4-Is-the-Task-Driven-Child-Network-Really-that-Important-to-the-Target-Task？"><a href="#4-4-Is-the-Task-Driven-Child-Network-Really-that-Important-to-the-Target-Task？" class="headerlink" title="4.4 Is the Task Driven Child Network Really that Important to the Target Task？"></a>4.4 Is the Task Driven Child Network Really that Important to the Target Task？</h3><p>CHILD-TUNINGD通过选择对下游任务数据具有最高Fisher信息的参数来检测特定任务的子网络。在本节中，我们将探讨检测到的任务驱动的子网络对任务是否真的那么重要。</p><p>为此，我们介绍了<strong>两项消融研究 为CHILD-TUNINGD：1）随机。我们随机选择一个子网络，在微调期间保持不变；2）最低信息。我们选择那些具有最低Fisher信息的参数作为子网络，与CHILD TUNINGD中采用的最高Fisher信息形成对比。</strong></p><p>如表5所示，随机选择子网络甚至可以胜过vanilla微调，平均得分提高0.18。这支持了我们的主张，即没有必要更新大型PLM的所有参数，减少假设空间可以减少过拟合的风险。然而，仍然值得寻找一个合适的子网络来进一步提高性能。如果我们选择Fisher信息最低的参数（Lowest Fisher），与选择CHILD-TUNINGD中采用的Fisher信息最高的参数相比，平均得分急剧下降6.65。因此，我们可以得出结论，CHILD-TUNINGD检测到的Child net对下游任务确实很重要。</p><h3 id="4-5-What-is-the-Relationship-among-Child-Networks-for-Different-Tasks？"><a href="#4-5-What-is-the-Relationship-among-Child-Networks-for-Different-Tasks？" class="headerlink" title="4.5 What is the Relationship among Child Networks for Different Tasks？"></a>4.5 What is the Relationship among Child Networks for Different Tasks？</h3><p>如我们所料，类似的任务往往有较高的子网络重叠率。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719110533227.png" alt="image-20220719110533227"></p><p>GLUE任务中任务驱动的子网络之间的重叠率。</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>为了缓解过拟合问题并提高微调大规模PLM的通用性，我们提出了一种简单而有效的微调技术–CHILD-TUNING，它在微调过程中只通过战略性地掩盖非子网络的梯度来更新子网络。引入了两个变体：CHILD-TUNING_F和CHILD-TUNING_D，它们分别以无任务和任务驱动的方式检测子网络。在各种下游任务上的大量实验表明，在四种不同的预训练语言模型中，这两种方法都能以较大的收益超过vanilla微调和先前的工作，同时在很大程度上提高了微调模型的泛化能力。由于CHILD-TUNING与大多数先前的微调技术是正交的，因此将CHILD-TUNING与它们结合起来可以进一步提高性能。</p><h2 id="代码学习"><a href="#代码学习" class="headerlink" title="代码学习"></a>代码学习</h2><p>对于CHILD-TUNRING_F应该在optimizer那块简单换一下就可以直接用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># =================== HACK BEGIN =======================         </span><br><span class="hljs-keyword">if</span> self.mode <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-keyword">if</span> self.mode == <span class="hljs-string">&#x27;ChildTuning-D&#x27;</span>:<br>        <span class="hljs-keyword">if</span> p <span class="hljs-keyword">in</span> self.gradient_mask:<br>            grad *= self.gradient_mask[p]<br>    <span class="hljs-keyword">else</span>: <br>        <span class="hljs-comment"># ChildTuning-F</span><br>        grad_mask = Bernoulli(grad.new_full(size=grad.size(), fill_value=self.reserve_p))<br>        grad *= grad_mask.sample() / self.reserve_p<br><span class="hljs-comment"># =================== HACK END =======================</span><br></code></pre></td></tr></table></figure><p>可以和如下的对比，但这里感觉有些不一样的，作者把一个functional中的for i, params in enumerate(params):合并到一块写了的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW  <span class="hljs-comment"># 和 AdamW对比，感觉还是有一些不一样的</span><br></code></pre></td></tr></table></figure><p><a href="https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamw.html#AdamW">https://pytorch.org/docs/1.8.0/_modules/torch/optim/adamw.html#AdamW</a></p><p><font color="blue">每次只更新固定的参数，因为CHILD在一开始固定住了</font> </p><p><font color="blue">taskfree的时候，为什么这样做就能让更好？task-driven的时候还可以用bert学习率要小一些那套理论来解释</font> </p><p><font color="blue">取出来12个CLS，接一个映射层 &#x2F;&#x2F;&#x2F; 模型蒸馏，12层-&gt;6层，fast-BERT，横着剪枝；；drop纵着减</font> </p><p>对于CHILD-TUNING_D，看起来像是在开始的时候跑了一遍，然后给到了一个gradient_mask</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_fisher</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    Calculate Fisher Information for different parameters</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    gradient_mask = <span class="hljs-built_in">dict</span>()<br>    model = self.model<br>    model.train()<br><br>    <span class="hljs-keyword">for</span> name, params <span class="hljs-keyword">in</span> model.named_parameters():<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;layer&#x27;</span> <span class="hljs-keyword">in</span> name:<br>            gradient_mask[params] = params.new_zeros(params.size())<br><br>    <span class="hljs-comment"># Now begin</span><br>    train_dataloader = DataLoader(<br>        self.train_dataset,<br>        batch_size=self.args.per_device_train_batch_size,<br>        shuffle=<span class="hljs-literal">True</span>,<br>        collate_fn=self.data_collator,<br>        drop_last=self.args.dataloader_drop_last,<br>        num_workers=self.args.dataloader_num_workers,<br>        pin_memory=self.args.dataloader_pin_memory,<br>    )<br>    <br>    N = <span class="hljs-built_in">len</span>(train_dataloader)<br><br>    <span class="hljs-keyword">for</span> inputs <span class="hljs-keyword">in</span> tqdm(train_dataloader):<br>        inputs.pop(<span class="hljs-string">&#x27;idx&#x27;</span>)<br>        inputs = self._prepare_inputs(inputs)<br>        outputs = model(**inputs)<br>        loss = outputs[<span class="hljs-string">&quot;loss&quot;</span>] <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(outputs, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">else</span> outputs[<span class="hljs-number">0</span>]<br>        loss.backward()<br><br>        <span class="hljs-keyword">for</span> name, params <span class="hljs-keyword">in</span> model.named_parameters():<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;layer&#x27;</span> <span class="hljs-keyword">in</span> name:<br>                torch.nn.utils.clip_grad_norm_(params, self.args.max_grad_norm)<br>                gradient_mask[params] += (params.grad ** <span class="hljs-number">2</span>) / N<br>        model.zero_grad()<br><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Calculate Fisher Information&#x27;</span>)<br><br>    <span class="hljs-comment"># Numpy</span><br>    r = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> gradient_mask.items():<br>        v = v.view(-<span class="hljs-number">1</span>).cpu().numpy()<br>        <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            r = v<br>        <span class="hljs-keyword">else</span>:<br>            r = np.append(r, v)<br>    polar = np.percentile(r, (<span class="hljs-number">1</span>-self.reserve_p)*<span class="hljs-number">100</span>)  <span class="hljs-comment"># r是一个多维数组，后面是一个几分位，比如50%那个50</span><br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> gradient_mask:<br>        gradient_mask[k] = gradient_mask[k] &gt;= polar  <span class="hljs-comment"># 对下游任务比较重要的参数给保留下来</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Polar =&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(polar))<br><br>    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> pytorch: torch.kthvalue</span><br>    <br>    <span class="hljs-keyword">return</span> gradient_mask<br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220719152140654.png" alt="image-20220719152140654"></p><p>整体感觉上应该还是相对比较即插即用的</p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>emnlp2021_SimCSE论文阅读</title>
    <link href="/2022/07/21/research/papers/contrastive-learning/emnlp2021_SimCSE%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/07/21/research/papers/contrastive-learning/emnlp2021_SimCSE%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="emnlp2021-SimCSE论文阅读"><a href="#emnlp2021-SimCSE论文阅读" class="headerlink" title="emnlp2021_SimCSE论文阅读"></a>emnlp2021_SimCSE论文阅读</h1><p>**SimCSE: Simple Contrastive Learning of Sentence Embeddings **普林斯顿&amp;清华大学</p><p>SimCSE，个人总结文章的亮点如下：</p><p>1）一种无监督的方法，只简单使用BERT中的dropout，一句话过同一个bert两次，生成的两种representation之间构成positive pair；</p><p>2）一种有监督的方法，使用NLI数据集内部包含的一个前提，以及前提对应的蕴含文本、中立文本、矛盾文本，其中和蕴含文本构成positive pair，和矛盾文本构成negative pair，还可以通过权重额外增强negative pair；</p><p>3）提出了从理论分析的角度，alignment和uniformity证明这种简单dropout有效的；</p><p>4）进行了多项ablation实验，寻求细节处的最有设置</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/462763973">https://zhuanlan.zhihu.com/p/462763973</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/476429545">https://zhuanlan.zhihu.com/p/476429545</a></p></li><li><p>文本语义相似度：<a href="https://www.zhihu.com/question/22004262/answer/2565474940">https://www.zhihu.com/question/22004262/answer/2565474940</a></p></li><li><p>文本语义相似度：<a href="https://zhuanlan.zhihu.com/p/539418586">https://zhuanlan.zhihu.com/p/539418586</a></p></li><li><p>github 代码：<a href="https://github.com/princeton-nlp/SimCSE">https://github.com/princeton-nlp/SimCSE</a></p></li></ul><h2 id="TODO-list"><a href="#TODO-list" class="headerlink" title="TODO-list"></a>TODO-list</h2><ul><li>公式（1）中positive pair是否包含在分母中？个人感觉应该是包含的吧，没有写j!&#x3D;i；<font color="blue">包含</font> </li><li>对 Aligenment and uniformity的理解还不是很到位，可能需要去看下ICML2020那篇Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere，不过有些过于数学了；</li><li>还是有些不理解使用一个而不是两个Encoder的motivation是什么，如果使用两个那么后面是要丢弃掉一个吗？除了从实验效果上来说，两个编码器的为什么相较于共用一个表现不好？；</li><li>因为是修改[CLS]token这种感觉，CL大多数的任务都是专注于句子级别的？比如句子分类还有句子情感分析相似度计算等，但是对于NER那类的任务会不会就不适用了？</li><li>[CLS]token这块的含义：</li></ul><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>本文介绍了SimCSE（simple contrastive learning framework for sentence embedding ），一个简单的对比性学习框架，大大推进了最先进的句子嵌入技术。</p><p>我们首先描述了一种<strong>无监督的方法</strong>，它接受一个输入句子并在对比性目标中预测其本身，仅使用标准的dropout作为噪声。这种简单的方法出奇的好，与以前的有监督方法相当。我们发现，dropout作为最小的数据扩充，删除它会导致representation崩溃。</p><p>然后我们提出了一种有<strong>监督学习方法</strong>，将来自自然语言推理数据集的注释对合并到我们的对比表示学习框架中，使用“entailment（蕴含，这里翻译成<strong>相近</strong>比较好）”对代表positive并使用“contradiction（<strong>矛盾</strong>）”对代表negative。</p><p>我们在标准语义文本相似性（STS）任务上评估了SimCSE，我们使用BERT-base的无监督和有监督模型分别实现了76.3和81.6%的Spearman相关性，与之前的最佳结果相比，分别提高了4.2%和2.2%。我们还从理论和经验上证明，对比学习目标将预训练嵌入的各向异性空间正则化为更单一的形式，并且当有监督信号可用时，它可以更好地对齐正对。</p><p><font color="red">在这里翻了下后面的ablation，似乎没有对比发表在ACL2021上的那篇韩国团队用BERT-CLS搞的，看起来实验结果比那篇好一些，然后也比较广泛流传，而且对比来说那一篇从可信性和换数据集的脆弱性上也不一定</font> </p><p><font color="red">这个作者说的“将预训练embedding的各向异性空间正则化为更单一的形式，并且当有监督信号可用时，它可以更好地对齐正对”不理解，这里可能有一些数学原理在里面</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>学习通用的句子嵌入是自然语言过程中的一个基本问题，在一些文献中已经得到了广泛的研究。在这项工作中，我们提出了最先进的句子嵌入方法，并证明了对比目标与预训练的语言模型如BERT和RoBERTa相结合可以非常有效。我们提出了一个简单的对比句子嵌入框架SimCSE，它可以从未标记或标记的数据中生成更好的句子嵌入。</p><ul><li>我们的<strong>无监督SimCSE</strong>简单的预测输入句子本身，只将dropout作为噪声（Figure1-a），换句话说我们将<strong>同一个句子</strong>传递给预训练的编码器两次，通过应用两次的dropout，我们可以获得两个不同的embedding作为positive pair。<font color="red">这个还是真的很巧妙，中间多层dropout确实提供了同一个句子不同embedding表示相对的不同差异？</font> 然后我们在同一个mini-batch中选择其他句子作为negative sample， and the model predicts the positive one among negatives.<font color="red">这句英文有点没看懂</font> ；；虽然他可能看起来非常简单，但这种方法大大优于训练目标，例如预测下一个句子和离散数据增强（例如单词删除和替换），甚至与以前的有监督方法相媲美。*<em>通过仔细分析，我们发现dropout作为隐藏表示的最小数据增强，而删除他会导致表示崩溃。</em></li><li>我们的有监督SimCSE在最近成功使用自然语言推理（Natural Language Inference, NLI）的基础上，并将带注释句子对纳入对比学习中（Figure1-b，图中<font color="green">entailment意思是蕴含，Two dogs are running和There are animals outdoors两句话是一种蕴含关系？</font> ，<font color="red">contradiction的意思是矛盾，Two dogs are running和The pets are sitting on a couch是矛盾的关系</font> ）。与之前将其转化为三向分类任务（蕴含、中立和矛盾）的工作不同，我们利用了蕴含对可以自然地用作positive pairs的事实。我们还发现，添加对应的矛盾对作为hard negative进一步提高了性能。与以前使用相同数据集的方法相比，这种简单使用NLI数据集的方法实现了实质性的改进。我们还与其他标记句子对数据集进行了比较，发现NLI数据集对于学习句子嵌入特别有效。</li></ul><p>为了更好地理解SimCSE强大的性能，我们借用他人的分析工具，该工具采用语义相关正对之间的对齐和整个representation空间的一致性来衡量学习embedding的质量。通过实证分析，我们发现我们的无监督SimCSE从本质上提高了一致性，同时通过dropout噪声避免了退化对齐，从而提高了表示的表达能力。同样的分析还表明，NLI训练信号可以进一步改善positive pair之间的对齐并产生更好的句子嵌入，我们还与最近的研究结果联系起来，即预训练的词嵌入存在各向异性，并通过光谱的角度证明了对比学习目标“压平”了奇异值分布 句子嵌入空间，从而提高一致性。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220715004056053.png" alt="image-20220715004056053"></p><p>我们对七个标准语义文本相似性 (STS) 任务和七个transfer task进行测试。在STS任务上，我们的无监督和有监督模型使用BERT-base分别实现了76.3和81.6的平均spearman相关性，与之前的最佳结果相比提高了4.2%和2.2%。我们还在transfer任务上取得了有竞争力的表现。最后，我们在文献中确定了一个不连贯的评估问题，并整合了不同设置的结果，以用于评估未来的句子嵌入评估工作。</p><h2 id="2-Background-Contrastive-Learning"><a href="#2-Background-Contrastive-Learning" class="headerlink" title="2. Background: Contrastive Learning"></a>2. Background: Contrastive Learning</h2><p><font color="red">这里主要介绍的是CL方面的相关工作，和其他一些paper有可能还介绍一些fine-tuneBERT、sentence embedding什么的还不太一样 </font> </p><p>对比学习旨在通过将语义上相近的邻域聚在一起并将非邻域分开来学习有效的表征。它设置了一组成对的示例 $D &#x3D; {(x_i, x_{i}^{+})}<em>{i&#x3D;1}^{m}$，其中$x_i$与$x</em>{i}^{+}$具有语义相关的性质。我们遵循Chen等人提出的contrastive framework <font color="red">（SimCLR）</font>，并使用cross-entropy损失函数作为训练目标with in-batch negatives <font color="red">后面这个with in-batch negatives有点没理解，下面这个公式来说像是softmax的感觉又好像不包含positive pair在式子中。</font> $h_i$和$h_{i}^{+}$代表$x_i$与$x_{i}^{+}$的representation，一个训练的mini-batch中有N对$(x_i, x_{i}^{+})$组合，公式如下：</p><p><font color="red"><strong>自己理解这个公式来说，positive pair应该还是包含在分母中的吧，要不怎么来像是softmax衡量那个感觉？另外没有写j!&#x3D;i</strong>，另注这个公式是针对每单个样本的！对于所有样本一般先求和后再平均</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220716223355098.png" alt="image-20220716223355098"></p><p>$\tau$代表一个温度超参数<font color="red">（个人理解有点像MHSA那块除一个根号dk，这样来放缩softmax的指数大小）</font> ，${\rm sim(h_1,h_2)}$用来衡量相似性，作者这里使用的是cosine similarity $\frac{h_{1}^{Τ}h_{2}}{\left| h_{1} \right| \cdot \left| h_{2} \right|}$<font color="red">向量点乘除以模长乘在一起，这个应该就是$cos \theta$吧，这个数值是1代表两个向量十分接近，即完全能投影在另外一个向量上，夹角为0度；而如果是0则代表两个向量正交90°</font> 。在这项工作中，我们使用预训练的语言模型（如BERT或RoBERTa）对输入句子进行编码：h&#x3D;fθ(x)，然后使用对比学习目标（式1）。</p><h3 id="2-1-positive-instances-正实例"><a href="#2-1-positive-instances-正实例" class="headerlink" title="2.1 positive instances 正实例"></a>2.1 positive instances 正实例</h3><p>对比学习中的一个关键问题是如何构建$(x_i, x_{i}^{+})$对（positive pair）。在视觉表示中，一个有效的解决方案是对同一图像进行两次随机变换（例如，裁剪、翻转、失真和旋转）来获取$x_i$与$x_{i}^{+}$。最近在语言表示中采用了类似的数据增强技术（如单词删除、重新排序和替换）。然而由于其离散性，非线性规划中的数据扩充本质上是困难的。在第3节中我们将看到，在中间层的表征中使用标准的dropout优于这些离散的算子。<font color="red">离散算子discrete operators大概指的就是这些传统数据增强操作。</font> </p><p>在自然语言处理中，人们在不同的语境中探索了相似的对比学习目标。在这些情况下，$x_i$与$x_{i}^{+}$是从有监督数据集例如question-passage pair中获取的。由于$x_i$与$x_{i}^{+}$的不同性质，这些方法总是使用双编码器框架，例如为$(x_i, x_{i}^{+})$使用两个独立的encoder$f_{\theta_1}$和$f_{\theta_2}$。对于句子embedding，Logeswaran和Lee（2018）也使用了双编码器方法的对比学习，将当前句子和下一个句子形成为$(x_i, x_{i}^{+})$。</p><h3 id="2-2-Aligenment-and-uniformity-同向性和均匀性"><a href="#2-2-Aligenment-and-uniformity-同向性和均匀性" class="headerlink" title="2.2 Aligenment and uniformity 同向性和均匀性"></a>2.2 Aligenment and uniformity 同向性和均匀性</h3><p>最近，Wang和Isola（[ICML2020](Understanding Contrastive Representation Learning through Alignment and Uniformity on the Hypersphere)）确定了对比学习两个重要的属性，<strong>alignment（对齐、结盟） and uniformity（均匀性、单调）</strong>，并建议使用它们来衡量表征的质量。给定positive pair的distribution$p_{pos}$，alignment计算成对实例embedding之间的预期距离（假设representation已经过规范化）：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220716234655559.png" alt="image-20220716234655559"></p><p>从另一方面来说，uniformity衡量嵌入表征的均匀分布如何：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220716234735352.png" alt="image-20220716234735352"></p><p>其中$p_{data}$代表data distribution。这两个指标与对比学习的目标很好的一致：positive实例应该保持紧密，随机实例的embedding应分散在hypersphere。在以下部分中，我们还将使用这两个指标证明我们方法的内部工作。</p><p><font color="red">关于这块数学的推导还没有研究太深，还需要之后深入研究一下</font> </p><h2 id="3-Unsupervised-SimCSE"><a href="#3-Unsupervised-SimCSE" class="headerlink" title="3. Unsupervised SimCSE"></a>3. Unsupervised SimCSE</h2><p>无监督SimCSE的思想非常简单：我们收集了一些句子${x_{i}}<em>{i&#x3D;1}^{m}$并且使用$x</em>{i}^{+}&#x3D;x_{i}$。对于本项工作的关键因素是通过完全相同的获取方法获取positive pair，通过对于$x_i$和$x_{i}^{+}$独立的使用采样dropout mask。在Transformer的标准训练过程中，在fully-connected layers和attention probabilities层中使用了dropout mask（默认的p&#x3D;0.1）。</p><p>我们表示$h_{i}^{z}&#x3D;f_{\theta}(x_i,z)$，其中$z$是一个dropout的random mask。我们只需要将相同的输入送入编码器两次，就能得到两个具有不同dropout mask $z，z’$的embedding嵌入表征。而SimCSE的训练目标变成了：</p><p><font color="red">这个公式就是上面式1那个感觉，同样和上面的一样，这单个公式是对于单个样本的！然后因为分母那边没有写j!&#x3D;i，所以positive pair也是包含在分母中的</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220717230453790.png" alt="image-20220717230453790"></p><p>对于一个包含N句话的mini-batch。注意$z$只是一个标准的包含在Transformer中的dropout mask，我们没有添加其他的dropout。</p><h3 id="3-1-Dropout-noise-as-data-augmentation"><a href="#3-1-Dropout-noise-as-data-augmentation" class="headerlink" title="3.1 Dropout noise as data augmentation"></a>3.1 Dropout noise as data augmentation</h3><p><font color="red">这种论文写作的方法是不是不太常见？感觉还在method章节就把实验拿进来了，也可能是因为这个章节方法太简单了没什么说的，就要多写一些实验分析相关的？</font> </p><p>我们把dropout看做一种最小形式的数据增强：positive pairs采用完全相同的句子，它们的嵌入只在dropout mask上有所不同。我们将这种方法与STS-B development set上的其他训练目标进行比较[角标注释2：我们从Englist Wikipedia中随机采样了10^6的句子，并且使用lr&#x3D;3e-5 N&#x3D;64的参数来进行BERT-base的fine-tune，没有STS 的training sets被使用]。表1将我们的方法与常见的数据增强技术进行了比较，如裁剪、单词删除和替换，这些技术可以被视为$h&#x3D;f_\theta(g(x),z)$，其中$g$是一个作用于$x$的随机离散运算符<font color="red">（理解为数据增强法）</font> 。我们注意到，即使是删除<strong>一个词one word</strong>也会损害性能，而且没有一个离散的数据增强方法能超过dropout噪声。<font color="red">是不是如果使用其他方法的话，如果不是作者这种简单的dropout方法，那么其他方法的dropout是固定住的吗？</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220717231336252.png" alt="image-20220717231336252" style="zoom:75%;"><p>Table1：不同数据增强方法在STS-B develoment set上的比较（Spearman’s correlation）。Crop k%代表保留了100-k%的长度；word deletion k%代表删除掉k%的词；Synonym replacement同义词替换使用了nlpaug（Ma2019）来随机替换同义词；MLM k%代表使用BERT_base替换k%的words。</p><p>我们还将这个self-prediction的自我训练目标与Logeswaran和Lee使用的下一句话目标进行比较，采取一个编码器或两个独立的编码器。我们发现SimCSE的表现比next-sentence目标好得多（在STS-B上为82.5vs67.4），使用一个编码器而不是两个编码器使我们的方法有了很大的不同。<font color="red">对于使用两个编码器做dropout的话，那么最终是丢弃一个？</font> </p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220717233524850.png" alt="image-20220717233524850" style="zoom:75%;"><p>Table2：不同无监督学习目标的比较（STS-B development set，Spearman’s correlation）。两列标识了我们使用同一个encoder还是两个独立的encoder。Next 3 sentences：随机从下面3句话中采样一句话；delete one word：随机从句子中删除一个词。</p><h3 id="3-2-Why-does-it-work？"><a href="#3-2-Why-does-it-work？" class="headerlink" title="3.2 Why does it work？"></a>3.2 Why does it work？</h3><p>为了进一步了解dropout在无监督SimCSE中发挥的作用，我们在表3中尝试了不同的dropout rate，发现所有的变体都低于Transformer中默认设置的p&#x3D;0.1。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220717235551898.png" alt="image-20220717235551898" style="zoom:75%;"><p>我们发现两个极端case特别有趣：“no dropout”(p&#x3D;0)和“fixed 0.1”(使用默认的dropout p&#x3D;0.1但是在一对中使用同样的mask)。在这两个case中，所产生的pair的embedding完全相同，这导致了性能的急剧下降。在训练过程中，我们每个10个step对这些模型取checkpoint，并在Figure2中展示了alignment和uniformity指标，以及一个简单的数据增强模型“delete one word”。**[角标注释3：我们将STS-B指标score大于4的pair作为$p_{pos}$，并把所有STS-B中的sentences作为$p_{data}$]**</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718001916184.png" alt="image-20220718001916184" style="zoom:75%;"><p>如图所示，从预训练的checkpoint开始，所有模型都大大改善了uniformity。然而，两个特殊变体的alignment也急剧下降，而我们的无监督SimCSE则保持了稳定的aligment，这主要归功于dropout噪声的使用。这也表明，从预先训练好的checkpoint开始是至关重要的，因为它提供了良好的初始aligment。最后，“delete one word”提供了良好的初始aligment，但在uniformilty指标上取得了较小的收益，并最终低于无监督SimCSE的表现。</p><h2 id="4-Supervised-SimCSE"><a href="#4-Supervised-SimCSE" class="headerlink" title="4. Supervised SimCSE"></a>4. Supervised SimCSE</h2><p>我们已经证明，添加dropout噪声能够使得positive pair保持良好的aligment $(x, x^+)～p_{pos}$。在本节中，我们研究是否可以利用监督数据集来提供更好的训练信号，以优化我们方法的alignment一致性。前人的研究工作已经证明，有监督的自然语言推理（Natural Language Inference, NLI）数据集对于学习句子embedding是有效的，它可以预测两个句子之间的关系是相近的（entailment）、中性的（neutral）、还是矛盾（contradiction）关系。</p><p>在我们的对比性学习框架中，我们直接把从有监督数据集中拿到的$(x_{i}^{+},x_{i})$对，然后用他们优化公式1。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718003428911.png" alt="image-20220718003428911"></p><h3 id="4-1-Choices-of-labeled-data"><a href="#4-1-Choices-of-labeled-data" class="headerlink" title="4.1 Choices of labeled data"></a>4.1 Choices of labeled data</h3><p>我们首先探究哪些监督数据集特别适合构建positive pair$(x_{i}^{+},x_{i})$。我们在一些带有句对示例的数据集进行实验，包括</p><ul><li>QQP：Quora questions pairs；</li><li>Flickr30k：每张图片都有5个人工撰写的标题，我们认为同一张图片的任何两个标题都是正面的一对；</li><li>ParaNMT：一个大规模的back-translation的dataset；</li><li>NLI：SNLI和MNLI；</li></ul><p>我们在不同的数据集通过公式1训练对比学习模型，并在table4中比较结果。为了进行公平的比较，我们还用相同的#训练对进行训练。在所有的选项中，使用NLI（SNLI+MNLI）数据集的表现最好。我们认为这是合理的，因为NLI数据集包括高质量的、来自crowd-sourced pairs。另外，人类注释者要根据前提手动写出假设，而且两个句子的词汇重叠度往往较低。例如，我们发现entailment（相关）对的词汇重叠度（两个word bag之间的F1）为39%，而QQP和ParaNMT的词汇重叠率为60%和55%。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718004244885.png" alt="image-20220718004244885" style="zoom:67%;"><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718004254481.png" alt="image-20220718004254481" style="zoom:67%;"></p><h3 id="4-2-Contradiction-as-hard-negatives-对于hard-negatives的矛盾"><a href="#4-2-Contradiction-as-hard-negatives-对于hard-negatives的矛盾" class="headerlink" title="4.2 Contradiction as hard negatives 对于hard-negatives的矛盾"></a>4.2 Contradiction as hard negatives 对于hard-negatives的矛盾</h3><p>最后，我们进一步利用NLI数据集的优势，将其矛盾（contradiction）对作为硬性否定句。在NLI数据集中，给定一个前提，注视着需要首先出一个绝对真实的句子（entailment），一个可能是真实的句子（neutral），以及一个绝对错误的句子（contradiction）。因此，对于每个前提和它的entailment假设，都有一个伴随的contradiction假设。[脚注7：事实上，一个前提可以有多个矛盾的假设。在我们的实施中，我们<strong>只抽出一个作为硬性否定</strong>，我们没有发现使用更多的会带来区别]</p><p><font color="red">再次把这个图给贴过来，一个前提对应的entailment和contradiction</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718005843191.png" alt="image-20220718005843191"></p><p>形式上，我们将$(x_{i}^{+},x_{i})$扩展为$(x_{i}, x_{i}^{+}, x_{i}^{-})$,分别代表前提（premise）蕴含（entailment）和矛盾（contradiction）。训练目标被表示为如下的：</p><p><font color="red">这个式5和其他地方还是不太一样的，我们希望hi和hi+尽量接近，分母那边意会上也是说，hi不仅需要与hj+相远离、也需要与hj-相远离，<strong>这里j可以等于i</strong></font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718011359827.png" alt="image-20220718011359827"></p><p>如table4所示，添加hard negatives可以进一步提高性能（84.2-&gt;86.2），这就是我们最终有监督的SimCSE。我们还试图加入ANLI数据集或将其与我们的无监督SimCSE方法相结合，但没有发现有意义的改进。我们还考虑在有监督的SimCSE中采用双编码器框架，但它损害了性能（86.2-&gt;84.2）。</p><p><font color="red">为什么两个encoder就会有问题，这个地方背后获取存在着什么解释吗？</font> </p><h2 id="5-Connection-to-Anisotropy-与各向异性的联系"><a href="#5-Connection-to-Anisotropy-与各向异性的联系" class="headerlink" title="5. Connection to Anisotropy 与各向异性的联系"></a>5. Connection to Anisotropy 与各向异性的联系</h2><p>这个章节相对数学内容比较多，暂时跳过，如果需要看的话可能还要再理解一下ICML2020那篇</p><h2 id="6-Experiment"><a href="#6-Experiment" class="headerlink" title="6. Experiment"></a>6. Experiment</h2><p><font color="red">这里记录一些Experiment中比较关键的内容，也为之后看代码积累下</font> </p><h3 id="6-1-Evaluation-Setup"><a href="#6-1-Evaluation-Setup" class="headerlink" title="6.1 Evaluation Setup"></a>6.1 Evaluation Setup</h3><p>我们对7项语义文本相似性（Semantic Textual Similarity）任务进行了实验。请注意，我们所有的STS实验都是无监督的，没有使用STS的训练集。即使是有监督的SimCSE，我们也只是意味着我们采取额外的标记数据集进行训练，遵循以前的工作。我们还评估了7个Transfer学习任务，并在附录E中提供了详细的结果。我们与Reimers和Gurevych（2019）有类似的看法，即句子嵌入的主要目标是将语义相似的句子聚在一起，因此将STS作为主要结果。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718114930149.png" alt="image-20220718114930149"></p><h4 id="6-1-1-Semantic-textual-similarity-tasks"><a href="#6-1-1-Semantic-textual-similarity-tasks" class="headerlink" title="6.1.1 Semantic textual similarity tasks"></a>6.1.1 Semantic textual similarity tasks</h4><p>We evaluate on 7 STS tasks: STS 2012–2016、STS Benchmark（STS-B）、SICK- Relatedness（SICK-R）</p><p>这里还说了一些和别人公平比较的设置：</p><p>(a) whether to use an additional regressor -&gt; 选择no additional regressor </p><p>(b) Spearman’s vs Pearson’s correlation -&gt; 选择Spearman corrleation</p><p>(c) how the results are aggregated -&gt; “all” aggregation</p><h4 id="6-1-2-Training-details"><a href="#6-1-2-Training-details" class="headerlink" title="6.1.2 Training details"></a>6.1.2 Training details</h4><p>我们从BERT(uncased)或者RoBERTa(cased)的checkpoint开始训练<font color="red">（作者之前在method中的实验也提到了：It also demonstrates that starting from a pre-trained checkpoint is crucial, for it provides good initial alignment）</font> ，并将[CLS]表示法作为句子嵌入的方法（后续实验中有提到不同pooling method的对比）。我们在英语维基百科中随机抽样的10^6个句子上训练无监督的SimCSE <font color="red">这里的10^6就是1M，前面有个表格写到了</font> 。并在MNLI和SNLI数据集的组合上（314k）训练有监督的SimCSE。**[脚注9：在BERT原版的实现中[CLS]token后有MLP layer，我们保持并将保持随机初始化]**</p><p>Appendix A：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718144746875.png" alt="image-20220718144746875"></p><p>这里除了表格里写的实验设置之外，还说了下面这段话：我们再引入一个可选的变体，它增加了一个Mask Language Modeling目标作为辅助损失添加到式1中，$\ell + \lambda·\ell^{mlm}$。这有助于SImCSE避免对token级别的知识的灾难性遗忘。正如我们在表D.2这种显示的，我们发现增加这个词可以帮助提高transfer任务的性能（而不是句子级sts任务）。</p><p><font color="red">因为是修改[CLS]token这种感觉，CL大多数的任务都是专注于句子级别的？比如句子分类还有句子情感分析相似度计算等，但是对于NER那类的任务会不会就不适用了？</font> </p><h3 id="6-2-Main-Results"><a href="#6-2-Main-Results" class="headerlink" title="6.2 Main Results"></a>6.2 Main Results</h3><p>主要介绍和哪些前人的工作进行了对比和Main Results</p><h3 id="6-3-Abalation-Studies-※"><a href="#6-3-Abalation-Studies-※" class="headerlink" title="6.3 Abalation Studies ※"></a>6.3 Abalation Studies ※</h3><p>我们研究了不同的pooling方法和hard negative的影响。本节中所有报告的结果都是基于STS-B development集合。我们在附录D中提供了更多的消融研究（normalization、temperature、MLM objectives）。</p><h4 id="6-3-1-Pooling-methods"><a href="#6-3-1-Pooling-methods" class="headerlink" title="6.3.1 Pooling methods"></a>6.3.1 Pooling methods</h4><p>一些研究者表明采取预训练模型的平均embedding（特别是来自第一层和最后一层的embedding）会导致比[CLS]更好的性能。<font color="red">（这里一方面自己想记录一下[CLS]token的理解，我觉得[CLS]token就是一个指定上的内容，我们希望这个token学习到整个句子的特征表示，在self-attention中聚合了来自其他token的表示。另外来说这里好像写的不是很清楚，取的是第一层和最后一层的[CLS]？）</font> Table6显示了再无监督和有监督的SimCSE中不同集合方法的比较。对于[CLS]的表示，原始的BERT实现在其之上采取了一个额外的MLP层。</p><p>在此，我们考虑了[CLS]的三种不同设置</p><ul><li>保持MLP层</li><li>没有MLP层</li><li>在训练时候保留MLP，在测试时删除它</li></ul><p>我们发现，对于无监督的SimCSE，在训练过程中只用MLP的[CLS]表征效果最好（上述设置3）。对于有监督的SimCSE，不同的pooling方法并不重要。默认的情况下，对于无监督的SimCSE我们使用[CLS]+MLP（train），对于有监督的SimCSE使用[CLS]+MLP。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718151624346.png" alt="image-20220718151624346" style="zoom:75%;"><h4 id="6-3-2-Hard-negatives"><a href="#6-3-2-Hard-negatives" class="headerlink" title="6.3.2 Hard negatives"></a>6.3.2 Hard negatives</h4><p>直观的说，将hard negatives与其他in-batch的negatives区分开来可能是有益的<font color="red">（这里背后的motivation是x x+ x-三个组成一组的时候，那么xi和xi-是最应该原理的，而且应当比xi和xj+ xi和xj-都更远）</font> 。因此，我们扩展了公式5中定义的训练目标，以纳入不同的负面因素的权重。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718152452658.png" alt="image-20220718152452658"></p><p>其中$1_{i}^{j}$是一个指示器，只有当i&#x3D;j的时候会是1。<font color="red">其他情况是0，那么$\alpha$的0次方永远都是1，和alpha就没什么关系了，而只有对hard-negatives才会有关系</font> </p><p>我们用不同的α值训练SimCSE，并在STS-B的开发集上评估训练好的模型。我们还考虑将中性假设作为硬性否定。如表7所示，α&#x3D;1的表现最好，中性假设不会带来进一步的收益。</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718152715348.png" alt="image-20220718152715348" style="zoom:75%;"><p><font color="red">这里有个问题，这么微小的波动，实验是真的会训练多次然后取平均吗，如果seed不一样就很容易造成这样的误差吧</font> </p><h4 id="6-3-3-different-temperatures（Appendix-D）"><a href="#6-3-3-different-temperatures（Appendix-D）" class="headerlink" title="6.3.3 different temperatures（Appendix D）"></a>6.3.3 different temperatures（Appendix D）</h4><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718153034975.png" alt="image-20220718153034975" style="zoom:75%;"><h4 id="6-3-4-MLM-training-objective"><a href="#6-3-4-MLM-training-objective" class="headerlink" title="6.3.4 MLM training objective"></a>6.3.4 MLM training objective</h4><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220718153131888.png" alt="image-20220718153131888" style="zoom:75%;"><p>在Transfer任务上使用MLM会好一点点</p><p><font color="blue">这个paper，写的introduction，前导理论，还有一些实验什么的写的比较到位。学一下人家提出来一个想法的时候，一步步引出来这个问题，再加上ablation</font> </p><p><font color="blue">方法比较简单但是细节比较多：dropout起到了作用，同一条数据进模型两次，但是用不同的dropoutmask的，用了dropout后一种子网络的感觉，用了两个完整网络的不同子网络，同一条文本数据的embedding</font> </p><p><font color="blue">为什么dropout取两个子网络，就好？ 另外一种方法比如取1357层、2468层，效果不如这个好？用dropout就相对于剪枝了一些的，随机mask，0.1 0.2 ；；；一条数据经过dropout一定是一样的？—— dropout为什么起作用hinton：dropout在训练的时候起作用，原来神经元10个，现在0.1随机mask掉一个9个，训练过程的时候<strong>任意</strong>9个神经元完成一个任务，强制的使得模型对特征的表达更好，但即使这样还是随机的，剪枝是一个有向的希望剪枝前后尽可能相近的；；；worddropout？；；；，</font> </p><p>dropout-随机化的剪枝 有偏的，说不定把最重要的mask掉了，无向</p><p>正常的剪枝：梯度比较小了，不重要了，就剪枝掉；；希望剪枝前后尽可能相近的，剪枝后略有精度损失；；</p><p><font color="red">是不是可以用剪枝的思路也实现一下，从剪枝的角度梳理了一下思路；；BERT-base-12层，12层的特征，比如取出来每一层的[CLS]，每一层提到了不同的特征，底层句法特征，上层语义特征，12个CLS赋权重，textCNN网络，每个CLS给个权重，映射层后面加dropout，映射层参数小于encoder，大大降低参数量，不同层不同权重 dropout加在encoder层&#x2F;dropout加在后面层</font> </p><p><font color="blue">※用CLS作为默认的，但是其他有很多思路认为用CLS不一定是效果最好；；；[CLS] token的理解，用CLS做sentence embedding只是一个经验主义，但是可解释性不强；；；sift hog；；；<strong>token embedding</strong>加起来做平均&#x2F;第一层和最后一层加起来更好&#x2F;…</font> </p><p>调整embedding space，使得sentence embedding更好，<strong>sentence representation</strong></p><p><font color="blue">加一些思考，有没有什么可改进的；</font> </p><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a>9. Conclusion</h2><p>在这项工作中，我们提出了SImCSE，一个简单的对比学习框架，它大大改善了最先进的句子嵌入的语义文本相似性任务。</p><p>我们提出了一种无监督的方法，该方法预测输入的句子本身有dropout噪声。还有一种有监督的方法，利用NLI数据集。</p><p>我们通过分析SimCSE与其他baseline模型的一致性和统一性，进一步证明了我们方法的内部工作原理。</p><p>我们相信，我们的对比目标，特别是无监督的目标，在NLP中可能有更广泛的应用。它为文本输入的数据扩充提供了一个新的视角，并且可以扩展到其他的连续representations，并整合到语言模型的预训练中。</p><h2 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h2><p>模型的主要代码在这个相对路径下， SimCSE-main&#x2F;simcse&#x2F;models.py</p><p><a href="https://github.com/princeton-nlp/SimCSE/blob/main/simcse/models.py">https://github.com/princeton-nlp/SimCSE/blob/main/simcse/models.py</a></p><p><a href="https://github.com/princeton-nlp/SimCSE/blob/00cfc7a3c496e46c132dfc0d0d79e926af03947b/simcse/models.py#L156">https://github.com/princeton-nlp/SimCSE/blob/00cfc7a3c496e46c132dfc0d0d79e926af03947b/simcse/models.py#L156</a></p><p>156行经过pooler后，得到一个[batchsize, num_sentence, hidden]长度的tensor，[0] [1]之间是一个positive pair，[2]是在有监督学习场景下给进去的hard-negative（意思可能最为离谱相反的）</p><p><a href="https://github.com/princeton-nlp/SimCSE/blob/00cfc7a3c496e46c132dfc0d0d79e926af03947b/simcse/models.py#L168%E8%BF%99%E9%87%8C%E6%8B%86%E6%88%90z1">https://github.com/princeton-nlp/SimCSE/blob/00cfc7a3c496e46c132dfc0d0d79e926af03947b/simcse/models.py#L168这里拆成z1</a> z2 z3</p><p><font color="blue">代码结构，看到主要模块在什么地方，什么地方怎么改：比如负例的权重，实现原始结果：可能google drive；；；数据规模缩小一点</font> </p><h3 id="有个中文版的对于unsupervised写了一版，看起来比较好理解些？"><a href="#有个中文版的对于unsupervised写了一版，看起来比较好理解些？" class="headerlink" title="有个中文版的对于unsupervised写了一版，看起来比较好理解些？"></a>有个中文版的对于unsupervised写了一版，看起来比较好理解些？</h3><p><a href="https://github.com/KwangKa/SIMCSE_unsup/blob/6d4b20b2f02640a62ea6241a4fbb8133dd7711b4/CSECollator.py#L19">https://github.com/KwangKa/SIMCSE_unsup/blob/6d4b20b2f02640a62ea6241a4fbb8133dd7711b4/CSECollator.py#L19</a></p><p>这里每句话重复了两次，构建一句话输入进去两次bert，然后在这里算损失函数</p><p><a href="https://github.com/KwangKa/SIMCSE_unsup/blob/6d4b20b2f02640a62ea6241a4fbb8133dd7711b4/train_unsup.py#L52">https://github.com/KwangKa/SIMCSE_unsup/blob/6d4b20b2f02640a62ea6241a4fbb8133dd7711b4/train_unsup.py#L52</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_loss</span>(<span class="hljs-params">y_pred, tao=<span class="hljs-number">0.05</span>, device=<span class="hljs-string">&quot;cuda&quot;</span></span>):<br>    idxs = torch.arange(<span class="hljs-number">0</span>, y_pred.shape[<span class="hljs-number">0</span>], device=device)  <span class="hljs-comment"># </span><br>    y_true = idxs + <span class="hljs-number">1</span> - idxs % <span class="hljs-number">2</span> * <span class="hljs-number">2</span>  <span class="hljs-comment"># tensor([1, 0, 3, 2, 5])，这样构建pair还是比较巧妙</span><br>    similarities = F.cosine_similarity(y_pred.unsqueeze(<span class="hljs-number">1</span>), y_pred.unsqueeze(<span class="hljs-number">0</span>), dim=<span class="hljs-number">2</span>)<br>    similarities = similarities - torch.eye(y_pred.shape[<span class="hljs-number">0</span>], device=device) * <span class="hljs-number">1e12</span><br>    similarities = similarities / tao<br>    loss = F.cross_entropy(similarities, y_true)<br>    <span class="hljs-keyword">return</span> torch.mean(loss)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl2021_CLINE论文阅读</title>
    <link href="/2022/07/15/research/papers/contrastive-learning/acl2021_CLINE%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <url>/2022/07/15/research/papers/contrastive-learning/acl2021_CLINE%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="acl2021-CLINE论文阅读"><a href="#acl2021-CLINE论文阅读" class="headerlink" title="acl2021_CLINE论文阅读"></a>acl2021_CLINE论文阅读</h2><p>总结贡献：</p><ul><li>用同&#x2F;反义词构造正负例，三个损失：①MLM；②预测每个token是否被替换，0&#x2F;1二分类；③对比损失，即正例拉近，反例远离</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://blog.csdn.net/qq_33161208/article/details/123631813">https://blog.csdn.net/qq_33161208/article/details/123631813</a>  # ACL2021 | 对比学习8篇论文一句话总结</p><h2 id="0-Abstract"><a href="#0-Abstract" class="headerlink" title="0. Abstract"></a>0. Abstract</h2><p>尽管预训练的语言模型已被证明有助于学习高质量的语义表征，但这些模型仍然容易受到简单的扰动。</p><p><font color="red">这个受到简单的扰动该怎么理解：从作者在Introduction章节给出一个图的例子中解释来说，进行简单的同义词替换模型预测可能会相反，而进行简单的反义词替换模型可能还会保持原来的预测，反映出模型在与语义鲁棒性上的不足</font> </p><p>近期旨在提高预训练模型鲁棒性的工作，主要集中在从具有类似语义的扰动实例中进行对抗性训练，而忽略了对不同甚至相反语义的利用。与图像处理领域不同的是，文本信息是离散的，几个字的替换就能引起重大的语义变化；</p><p>为了研究由小的扰动引起的语义变化的影响，我们进行了一系列的试点实验，并令人惊讶的发现对抗性训练（adversarial training）对于模型检测这些语义变化是无用的，甚至是有害的；</p><p>为了解决这个问题，我们提出使用语义负例进行对比学习（Contrastive Learning with semantIc Negative Examples, CLINE），它在无监督的情况下构建语义负例，以提高在语义对抗性攻击下的稳健性；</p><p><font color="red">这个语义对抗性攻击也可以理解为，我只是简单替换一些同义词模型可能预测结果就变了，我可能替换了一些反义词模型结果还是不变</font> </p><p>通过在相似和相反的语义例子之间进行比较，该模型可以有效地感知由小的扰动引起的语义变化。实证结果表明，作者的方法在一系列的情感分析、推理和阅读理解任务中产生了实质性的改善。而且，CLINE还确保了同一语义下的紧凑性和句子级不同语义的可分离性。</p><p><font color="red">TODO 还要看看这个语义紧凑性、句子级不同语义的可分离性作者是怎么解释的</font> </p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p><font color="red">自己对Introduction章节的理解是综述研究背景，综述一下别人的方法和存在的不足，最后再说一下自己的方法和主要贡献，大概就按照这几个方面总结一下Introduction章节</font> </p><h3 id="1-1-研究背景"><a href="#1-1-研究背景" class="headerlink" title="1.1 研究背景"></a>1.1 研究背景</h3><p>预训练语言模型，例如BERT和RoBERTa的出现可以有效各项自然语言处理任务的表现。然而近期的研究发现BERT模型在遇到对抗性的例子时鲁棒性很差。作者举例如下“creepy but ultimately unsatisfying thriller（令人毛骨悚然但最终不尽人意的惊悚片）”这句本意的话，label被标注为Negative的，预测也是Negative的，从人类角度应该可以看出这句话的核心集中在“unsatisfying”上，但是只是简单替换“ultimately”-&gt;“lastly”（<strong>同义词替换</strong>）就使得bert这个模型预测错了，同样的完全 <strong>反义词替换</strong> “unsatisfying”-&gt;“satisfying”模型也预测错了，作者给出的表述是“the BERT model can be <strong>fooled</strong> easily just by replacing ultimately with a similar word lastly.”</p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712151230610.png" alt="image-20220712151230610" style="zoom:50%;"><h3 id="1-2-已有的研究工作和存在的不足"><a href="#1-2-已有的研究工作和存在的不足" class="headerlink" title="1.2 已有的研究工作和存在的不足"></a>1.2 已有的研究工作和存在的不足</h3><p>为了提高PLM的稳健性，一些研究工作试图在PLM上进行对抗性的训练，即在训练的过程中对词嵌入进行基于梯度的扰动，或者在训练阶段增加高质量的对抗文本实例。这些对抗性的方法主要目标是在输入发生微小变化时保持标签不变，通过构建高质量的扰动实例并产生对抗机制，产生了有希望的性能；</p><p><font color="red">对这两块工作还是有点不太了解，这里特别强调了一个高质量可能是为了引出CL方法self-supervised的不需要手工构筑大量标签的意思？</font> </p><p><font color="red">或者说这里想说的也有点生成对抗那个地方的感觉？生成对抗那边目前理解和CL比较大的区别是多出来一个生成步骤，generator需要生成一个例子那种感觉，然后discriminator来辨别这个示例，多引入的生成就多出了很多的问题，包括生成可靠性等？</font> </p><p>然而，由于自然语言的离散性，在许多情况下，小的扰动就会引起句子语义的重大变化，就像上面那个例子展示的，只是改变了<strong>一个词</strong>，模型就将gt为Negative的预测为Positive了。一些近期的研究工作创建了对比集合（Contrastive sets），以小而有意义的方式<strong>手动</strong>扰动测试实例，从而改变了gt label。<strong>在本文中，作者把没有改变语义的扰动实例表示为对抗性例子，把改变了语义的例子表示为对比性的例子，motivation也考虑到大多数PLM鲁棒性的研究工作主要把方法集中在对抗性例子的研究中，而较少有考虑到语义负面的例子。</strong></p><p><font color="red">这里结合作者说的abstract也能想到简单的“数据增强”或者被称作“数据扩充”方法，执行同义词替换就可以简单的收集到很多的对抗性例子，执行反义词替换就可以简单的收集到很多对比性的例子，之前SimCLR中的aug1 aug2那种感觉</font> </p><p>现有研究现象（较多考虑到对抗性例子，而较少考虑到对比性的例子）让作者开始想要探究，能否通过使用对抗性和对比性的例子来训练一个既能够抵御对抗性攻击，又能通过使用对抗性例子和对比性例子对语义变化敏感的BERT。为了解决这个问题，需要评估目前的vanilla模型（可以翻译为香草模型，也可以翻译为稳健模型）是否同时具有语义敏感性。<strong>在进行的几组对比vanilla PrLM 和 经过对抗性训练的PrLM中发现，虽然对抗性训练提高了PLM应对对抗性攻击的能力，但其在对比性的例子上表现却下降了</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712155656060.png" alt="image-20220712155656060"></p><p><font color="red">这里IMDB是一个影评数据集从文章里给的这个例子来看，蓝色那些地方应该是换了一些对比性（也就是反义)的词汇？</font> </p><p><font color="red">对抗性的例子：执行一些同义词扰动替换，但是不改变原来句子的含义</font> </p><p><font color="red">对比性的例子：执行一些反义词的扰动替换，同时改变了橘子的含义</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712160234997.png" alt="image-20220712160234997"></p><h3 id="1-3-作者自己方法的简述"><a href="#1-3-作者自己方法的简述" class="headerlink" title="1.3 作者自己方法的简述"></a>1.3 作者自己方法的简述</h3><p>为了训练一个具有语义健壮性的PLM，提出基于语义反义示例的对比学习方法（Contrastive Learning with semantIc Negative Examples，CLINE）。这是一种简单有效的方法可以产生对抗性和对比性的例子，并从两个例子中进行对比性的学习。</p><p>许多工作证明了对比性的学习已经在学习句子表征方面取得了有效性的研究进展，然而这些研究忽略了负面实例的生成。在CLINE中，作者引入了WordNet的外部语义知识，通过<strong>无监督地</strong>替换少数有代表性的标记来产生对抗性和对比性的例子。通过替换标记检测和对比性目标，作者的方法收集了具有可理解语义的相似性句子，和具有不同甚至相反语义的分散句子，该方法通过替换标记检测和对比目标，收集具有语义相似的句子，分散具有不同甚至相反语义的句子，同时提高了PLMs的鲁棒性和语义敏感性。</p><p><font color="red">负面实例的生成，这里替换标记检测和对比目标应该是指loss那边，替换标记检测指的是判断每个token是否是被替换的，而对比性目标就是CL相关的loss</font> </p><p><font color="red">如果作者这么描述的话，有个问题是真的能检测出来token是被替换的吗，因为只是换了相同或者相反词性的词，也可能这样就会对语义连贯性一些造成影响？</font> </p><p>实验证明，在几个对比性测试集上取得改善，在几个对抗性测试集上也取得改善，也就是说<strong>CLINE同时获得了对抗性攻击的鲁棒性，和语义变化的敏感性</strong></p><p><font color="red">以往的方法只能获得对抗性攻击的鲁棒性，但是对语义变化的敏感性就有所不足</font> </p><h2 id="2-Pilot-Experiment-and-Analysis"><a href="#2-Pilot-Experiment-and-Analysis" class="headerlink" title="2. Pilot Experiment and Analysis"></a>2. Pilot Experiment and Analysis</h2><p><font color="red">这个章节在之前很少见，预实验及分析，可能未来一些内容可以参考下这个写法</font> </p><p>为了研究对抗性训练方法在对抗性集合和对比性集合上的表现，我们首先进行试点实验（Pilot Experiment）并在本节中进行详细分析。</p><h3 id="2-1-Model-and-Datasets"><a href="#2-1-Model-and-Datasets" class="headerlink" title="2.1 Model and Datasets"></a>2.1 Model and Datasets</h3><p>其中我们选择了一种流行的方法，TextFooler（Jin等，2020），作为词级的对抗性攻击模型来构建对抗性例子。</p><p>选择之前研究者构建的IMDB、SNLI作为对比集</p><p>我们选择了一种对抗性训练方法FreeLB（Zhu等，2020）作为我们的试点实验。我们对vanilla的BERT（Devlin等，2019）和RoBERTa（Liu等，2019）以及FreeLB版本在对抗性集合和对比性集合上进行了评估。</p><h3 id="2-2-Result-analysis"><a href="#2-2-Result-analysis" class="headerlink" title="2.2 Result analysis"></a>2.2 Result analysis</h3><p>与vanilla版本相比，对抗性训练方法FreeLB在对抗性测试集上取得了更高的准确率，但在对比性测试集上却有相当大的性能下降，特别是对于BERT。这些结果与第1节中的直觉一致，同时也证明了对抗性训练不适合于对比性集合，甚至会带来负面的影响。</p><p><strong>直观地说，对抗性训练倾向于保持标签不变，而对比性集合倾向于进行小的但改变标签的修改。对抗性训练和对比性例子似乎构成了一个天然的矛盾，揭示了需要在训练阶段应用额外的策略来检测语义的细微变化</strong></p><h3 id="2-3-Case-Study"><a href="#2-3-Case-Study" class="headerlink" title="2.3 Case Study"></a>2.3 Case Study</h3><p>上面table3那个例子进一步分析（被BERT的vanilla版本预测正确，但被FreeLB版本预测错误）</p><p>对于标签3中的例子，我们可以观察到，许多部分在句子中表达了积极的情绪（红色部分），而少数部分则表达了消极的情绪（蓝色部分）。总的来说，这个例子表达的是负面情绪，而vanilla BERT可以准确地捕捉到整个文档的负面情绪。<strong>然而，FreeLB版本的BERT可能会将负面情绪的特征作为噪音，并将整个文档预测为正面情绪。</strong>这一结果表明，经过对抗性训练的BERT可以以与传统对抗性训练相反的方式被愚弄。<font color="red">这里的理论性不是很强吧，一个这样的例子说明不太了什么？</font> </p><p>从这个案例研究中，我们可以看到，对抗性训练方法可能不适合这些语义改变的对抗性例子，而且就我们所知，目前还没有针对这种对抗性攻击的防御方法。因此，探索适当的方法来从语义负面的例子中学习变化的语义是至关重要的。</p><h2 id="3-Method"><a href="#3-Method" class="headerlink" title="3. Method"></a>3. Method</h2><p>CLINE，一种简单而有效的方法来生成对抗性和对比性的例子，并从它们中学习。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712165811156.png" alt="image-20220712165811156"></p><h3 id="3-1-对抗性（Adversarial）与对比性（Contrastive）实例的生成"><a href="#3-1-对抗性（Adversarial）与对比性（Contrastive）实例的生成" class="headerlink" title="3.1 对抗性（Adversarial）与对比性（Contrastive）实例的生成"></a>3.1 对抗性（Adversarial）与对比性（Contrastive）实例的生成</h3><p>希望通过对比具有相同和不同语义的句子，对语义变化更加敏感。采用了对比学习的思想，拉进positive pair之间的学习表征而推开negative pair之间的学习表征，因此定义如何配对是非常重要的。在本文中将具有相同语义的句子视为正向对，将具有相反语义的句子视为负向对。</p><p><strong>一些研究试图利用数据增强（如同义词替换、回译等）来生成正面实例，但很少有作品关注负面实例。而且，要获得文本实例的相反语义立场是很困难的。直觉上，当我们用反义词替换句子中的代表词时，句子的语义很容易与原始句子无关甚至相反。如图1所示，假设句子“Batman is an fictional super- hero written by”，我们可以用反义词“real-life”替换“fictional”，然后我们得到一个反事实的句子“Batman is an real-life super-hero written by”。后者与前者相矛盾，并与之形成负对。</strong></p><p>如图所示的，$ x^{syn} $是对抗的例子，$ x^{ant} $ 是对比的例子，我们从原始input $ x^{ori} $生成这两个语义大不相同，但是词汇却没有几个不同的句子，其中对抗的例子$ x^{syn} $在语义上与$ x^{ori} $接近，而对比的例子$ x^{ant} $的语义与$ x^{ori} $大大相反。具体来说，作者使用了spaCy这个工具对原始句子进行分割和词性（POS）提取<strong>动词、名词、形容词和副词</strong>。$ x^{syn} $是通过用同义词、超义词和形态变化替换提取的词而产生的，$ x^{ant} $是通过用反义词和随机词替换它们产生的。对于$ x^{syn} $大约有40%的标记被替换。对于$ x^{ant} $，大约20%的标记被替换。</p><p><font color="red">具体怎么制作对抗和对比的实例操作在上面这个地方，这个应该就是self-supervised的那个感觉了，自己能够构建出标签来</font> </p><p><font color="red">这个地方听起来还是挺硬性的</font> </p><h3 id="3-2-Training-Objectives"><a href="#3-2-Training-Objectives" class="headerlink" title="3.2 Training Objectives"></a>3.2 Training Objectives</h3><p>CLINE的目标是训练neural text encoder（deep transformers）$ E_{\phi} $,其中$\phi$代表网络的参数；类似于BERT那种感觉，对于输入$x &#x3D; [x_{1},…,x_{T}]$来输出一个$h &#x3D; [h_{1},…,h_{T}]$，其中每个$h_{i} \in \R^{d}$，d代表hidden_size的维度；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712191919771.png" alt="image-20220712191919771"></p><h4 id="3-2-1-Masked-Language-Modeling-Objective"><a href="#3-2-1-Masked-Language-Modeling-Objective" class="headerlink" title="3.2.1 Masked Language Modeling Objective"></a>3.2.1 Masked Language Modeling Objective</h4><p>作者也使用到了BERT那个MLM，随机将一些token用[MASK]替换掉，然后对这些token进行预测，表示为$\ L_{MLM}$</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712192517490.png" alt="image-20220712192517490"></p><h4 id="3-2-2-Replaced-Token-Detection-Objective"><a href="#3-2-2-Replaced-Token-Detection-Objective" class="headerlink" title="3.2.2 Replaced Token Detection Objective"></a>3.2.2 Replaced Token Detection Objective</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712193520638.png" alt="image-20220712193520638"></p><p>把h过线性层后，再过sigmoid激活函数（这里因为是多分类问题，所以是sigmoid激活函数而不是softmax激活函数那个感觉），过完sigmoid后实际上是对每个位置得到了一个logit（或者说score），然后通过类似交叉熵损失函数度量 $\ L_{RTD}$</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712193721230.png" alt="image-20220712193721230"></p><h4 id="3-2-3-Contrastive-Objective（与对比学习更加相关？）"><a href="#3-2-3-Contrastive-Objective（与对比学习更加相关？）" class="headerlink" title="3.2.3 Contrastive Objective（与对比学习更加相关？）"></a>3.2.3 Contrastive Objective（与对比学习更加相关？）</h4><p>CLINE的直觉是准确地预测当原始句子被修改时，语义是否发生了变化，从距离度量上来说，要使得 $ h^{ori} $和 $ h^{syn} $尽量接近，而使得$ h^{ori} $和 $ h^{ant} $尽量远离。于是在对比学习的操作上，把$(x^{ori}, x^{syn})$看做positive pair，把$(x^{ori}, x^{ant})$看做negative pair，使用[CLS]那个token $ h_{c}$于是通过下面这个函数计算相似度</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712201633618.png" alt="image-20220712201633618"></p><p><font color="red">这里有个问题是为什么这样能通过两个向量点积计算相似度，同样也是BERT中Q·K^T的那个地方的疑问：两个向量点乘就是用来计算相似度的，u·v如果u和v是向量的话，那么点乘起来就是|u||v|cosθ，反应一个向量在另一个向量上的投影，如果越大代表两个向量越相似</font> </p><p>然后通过下面这个InfoNCE loss来度量，注意因为这里是一对一对的，分母那里就没有求和了，作者的解释是：<strong>请注意，与一些通常随机抽取多个反面例子的对比策略不同，我们只利用一个反面例子作为训练的对象。这是因为我们预训练的主要目标是提高语义对抗下的鲁棒性。而且，我们只关注为我们的目标而产生的负面样本（即xant），而不是任意地从预训练语料库中抽取其他句子作为负面样本。</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712201737847.png" alt="image-20220712201737847"></p><h4 id="3-2-4-最终的损失函数"><a href="#3-2-4-最终的损失函数" class="headerlink" title="3.2.4 最终的损失函数"></a>3.2.4 最终的损失函数</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220712201832237.png" alt="image-20220712201832237"></p><p><font color="red">大概能明白这个损失函数的意思，但是每个损失函数具体怎么得到还需要再整理下</font> </p><h2 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4. Experiments"></a>4. Experiments</h2><p>这个地方implement details比较重要，不知道他这里说的32块32G显卡指的是他还是之前的pretrain</p><p>To better acquire the knowledge from the existing pre-trained model, we did not train from scratch but the official RoBERTa-base model.</p><p>The model is pre-trained on 32 NVIDIA Tesla V100 32GB GPUs. Our model is pre-trained on a combination of BookCorpus (Zhu et al., 2015) and English Wikipedia datasets, the data BERT used for pre-training.</p><p><font color="blue">前面预测token有没有被替换这个任务的时候，bert encoder的参数是不是被更新了？<strong>是不是共用的bert encoder？</strong></font> </p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Contrastive Learning 初步调研&amp;了解</title>
    <link href="/2022/07/05/research/papers/contrastive-learning/Contrastive%20Learning%20%E5%88%9D%E6%AD%A5%E8%B0%83%E7%A0%94&amp;%E4%BA%86%E8%A7%A3/"/>
    <url>/2022/07/05/research/papers/contrastive-learning/Contrastive%20Learning%20%E5%88%9D%E6%AD%A5%E8%B0%83%E7%A0%94&amp;%E4%BA%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Contrastive-Learning-初步调研-amp-了解"><a href="#Contrastive-Learning-初步调研-amp-了解" class="headerlink" title="Contrastive Learning 初步调研&amp;了解"></a>Contrastive Learning 初步调研&amp;了解</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">备注：<br>中文名为：对比表示学习，或者说叫做对比表征学习？<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.zhihu.com/zvideo/1296467630460039168">https://www.zhihu.com/zvideo/1296467630460039168</a></p><p><a href="https://zhuanlan.zhihu.com/p/450561239">https://zhuanlan.zhihu.com/p/450561239</a></p><p><a href="https://zhuanlan.zhihu.com/p/471018370">https://zhuanlan.zhihu.com/p/471018370</a></p><p>Ashish Jaiswal, Ashwin Ramesh Babu, et.al, A Survey on Contrastive Self-Supervised Learning.<br>Ting Chen, Simon Kornblith, Mohammad Norouzi, and Geoffrey Hinton. A simple framework for contrastive learning of visual representations.<br>Tian Li , Xiang Chen, et.al. CROSS-DOMAIN SENTIMENT CLASSIFICATION WITH CONTRASTIVE LEARNING AND MUTUAL INFORMATION MAXIMIZATIO.<br>Daniela N. Rim, DongNyeong Heo, Heeyoul Choi, Adversarial Training with Contrastive Learning in NLP.</p><h2 id="1-基础概念Overview"><a href="#1-基础概念Overview" class="headerlink" title="1. 基础概念Overview"></a>1. 基础概念Overview</h2><p>直觉非常符合人类，在分辨多种东西的时候不需要记住每个细节，需要记住最少的东西把这几个东西分开就可以了；</p><h3 id="1-1-Motivation-and-Intuition"><a href="#1-1-Motivation-and-Intuition" class="headerlink" title="1.1 Motivation and Intuition"></a>1.1 Motivation and Intuition</h3><p>目标是在Unsupervised Learning（无监督学习即无标签）场景下的，把每个instance当成一个class。比如说有一根笔，还有另一根笔， 在分类的时候这两个是应该分类到一类的，在CL里面就是把每一个instance都分开。</p><p>为什么研究这个问题，在Supervised Learning（监督学习）中有很多问题：1）数据是非常高维的他是很难学的；2）另外拿到label是有cost的，生活中有很多数据但是label却没有那么多；3）有task specific solution，训练了一个猫狗分类器，现在又来了一个兔子就没法分开了，如果是Unsupervised，学到某个class的feature，这些feature是可重复利用的， 可能能用到很多种不同的task里面去；</p><p>主要可以分为两大类的方法，第一类是Generative（Predictive）生成的，第二类是Contrasitive（Discriminative）鉴别的。Generative主要是干比如VAE，reconstract sample，输入图片然后重构这个图片【之前看到关系抽取领域的Gaussian Graph Generator】，对于Contrasitive和Generative不一样的是不需要reconstract，而只是需要把不同的instance分开就可以了，好处是实际上不需要学的很细节，比如pixel level的可能就可以省去一些计算资源，另外pixel之间不应该是单独考虑的，应该学习到一些correlation的global的内容</p><h3 id="1-2-Introduction"><a href="#1-2-Introduction" class="headerlink" title="1.2 Introduction"></a>1.2 Introduction</h3><p><strong>Notation</strong>：Anchor、Positive sample、Negative sample，拿一个纸盒子举例的话， 一个纸盒子两个不同角度拍两张照片，一个竖着一个横着，那么这个pair是属于同一个物体的，就一个当做anchor一个当做positive sample。然后给另外一个纸盒子拍照片，另外这个纸盒子就是一个negative sample。总结来说，是同一个类型的就可以是一个positive pair，不同类型的就是negative pair。这里背后隐含着 $ {score}(f(x),f(x^{+})) &gt;&gt; {score}(f(x),f(x^{-}))$</p><p><strong>NCE Loss</strong>优化上来说类似于softmax的原理，对于一个anchor，softmax使得相关性越大的，在这种整体衡量上loss更小，使得anchor与所有positive sample之间的score更大？</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705164214577.png" alt="image-20220705164214577"></p><p> 为什么可以work，可以被解耦成两部分，positive sample和anchor尽量靠近，然后negative作为一个regularizer term分布更均匀</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705164353942.png" alt="image-20220705164353942"></p><h3 id="1-3-Contrastive-Learning-in-NLP"><a href="#1-3-Contrastive-Learning-in-NLP" class="headerlink" title="1.3 Contrastive Learning in NLP"></a>1.3 Contrastive Learning in NLP</h3><p>有监督的学习需要大量的样本，面临着泛化能力差的问题。自监督学习（Self-supervised Learning）可以在大量无标签的数据上通过虚标的label去学习数据的通用表征方式，这种通用的表征方式可以作为特征提取器应用于各种下游任务。有了特征提取器后，在具体任务上使用较少的样本做fine-tune就能取得很好的效果，节约了标注成本。而且由于self-supervised或者说unsupervised任务的数据不需要标注特点，特征提取器可以在大量的样本上学习得到也增强了鲁棒性，提升模型泛化能力。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">备注：<br>·有一种需要针对特定任务设计或者finetune的感觉，因为是下游任务？<br>·类似于BERT中的MLM，NSP？这里还看到过一些用一些基础模型预测出来一些<span class="hljs-selector-tag">label</span>，然后把这些<span class="hljs-selector-tag">label</span>和原来混到一块训练的（ACL2022 ASSIST-DST），不过这种看起来是noise <span class="hljs-selector-tag">label</span>更接近一些；<br></code></pre></td></tr></table></figure><p>自监督学习中，GAN这类的生成式模型获得了广泛应用，但是可能训练困难。更加敏捷的CL逐渐成为主流。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">备注：<br>·GAN对抗生成网络，之前在CV领域了解过一些，分generator和descriminator<br><br>·这里说的训练困难，可能有一个问题是他需要generator的生成？而实际上对比学习<span class="hljs-built_in">anchor</span>和positive pairs那种感觉是比较轻量化的<br></code></pre></td></tr></table></figure><h4 id="1-3-1-Contrastive-Learning定义"><a href="#1-3-1-Contrastive-Learning定义" class="headerlink" title="1.3.1 Contrastive Learning定义"></a>1.3.1 Contrastive Learning定义</h4><p>对比学习CL属于表征学习，本质是学习一种样本的表征方法，学习的目标是让样本与其对应的增强版本表征或者Embedding相距较近，不同样本的表征或者Embedding之间相距较远。给了一个例子是猴子图片和经过数据增强的猴子图片表征距离较近，而猴子图片和老虎图片的表征距离较远，被称作<strong>Pretext Task</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705203317372.png" alt="image-20220705203317372"></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">备注：<br>·从NLP角度来说，如果通过<span class="hljs-keyword">CL</span>的这种方法，让我在fine-tune前，两段相似的文本具有相类似的表征，那么后续的fine-tune是不是只需要少量的数据就可以达到相对更好的效果，但是这种<span class="hljs-keyword">CL</span>的方法是怎么通过无标注得到的，比如BERT那种MLM和NSP？但是图像这边呢，比如图像分类，这些数据是否也能搞一个图像的MLM？或者就是通过数据增强得到？<br><br>·迁移能力如何而来，或者和预训练的区别是什么？<br></code></pre></td></tr></table></figure><p>从训练范式上来说，就很像BERT那种预训练语言模型。梳理下流程感觉是data aug后首先输入Encoder得到一个初始embedding（对于图像可能是直接像素，对于NLP可能是一个初始的embedding），然后无标注的在data aug的作用下进行训练，通过contrasive学习来进行损失函数反向传播引导encoder参数更新&#x2F;&#x2F;&#x2F;&#x2F;在迁移知识的时候，encoder直接进行编码就能编码到一个与类别相似的embedding，这样fine-tune就简单了很多，可能少量数据就可以；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705203620875.png" alt="image-20220705203620875"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">备注：<br>·似乎还是有点没理解到contrastive learning的优势之处，总结下来大概能稍微理解了一些最开始看到的：<br>    在Supervised Learning（监督学习）中有很多问题：<span class="hljs-number">1</span>）数据是非常高维的他是很难学的；<span class="hljs-number">2</span>）另外拿到label是有cost的，生活中有很多数据但是label却没有那么多；<span class="hljs-number">3</span>）有task specific solution，训练了一个猫狗分类器，现在又来了一个兔子就没法分开了，如果是Unsupervised，学到某个<span class="hljs-keyword">class</span>的<span class="hljs-symbol">feature</span>，这些<span class="hljs-symbol">feature</span>是可重复利用的， 可能能用到很多种不同的<span class="hljs-symbol">task</span>里面去；<br><br>·第三点可能还有些疑问，现在这种范式下，认为这个训练得到的<span class="hljs-symbol">encoder</span>是可以重复利用的吗，或者说在一开始就搞很多任务训练到一起，或者说具备了一个最基本的表征能力（往<span class="hljs-symbol">BERT</span>那个方面想的话）<br></code></pre></td></tr></table></figure><h4 id="1-3-2-Pretext-Task-in-NLP"><a href="#1-3-2-Pretext-Task-in-NLP" class="headerlink" title="1.3.2 Pretext Task in NLP"></a>1.3.2 Pretext Task in NLP</h4><p>自监督学习（self-supervised learning）中经常采用一种被称为Pretext Task自监督任务来训练模型，<strong>根据数据的特点构造虚标样本的技术。</strong>在NLP领域常用的用于构造Pretext Task的增强方法有：</p><ul><li>Center and Neighbor Word Prediction：典型代表就是训练Word2Vec的Skip-gram和CBOW <font color="red">这个还不是很了解</font></li><li>Next and Neighbor Sentence Prediction：句子级别的上下文预测，典型就是BERT中的NSP <font color="red">MLM没有写在这里，但是也算是一种？</font></li><li>Autoregressive Language Modeling：单向的语言模型建模，代表作是GPT。<font color="red">暂时不太了解</font></li><li>Sentence Permutation：在GAPT中被使用，将一定长度的文本中的句子打乱，然后预测句子的先后次序。<font color="red">这个听起来有点像NSP，但好像有个排序在里面？</font></li></ul><p><font color="blue">Pretext self-supervised</font> </p><h4 id="1-3-4-架构"><a href="#1-3-4-架构" class="headerlink" title="1.3.4 架构"></a>1.3.4 架构</h4><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706013341299.png" alt="image-20220706013341299"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706013410011.png" alt="image-20220706013410011"></p><p><font color="blue">一个batch里面的负例太少了，从之前的一些batch拿过来；；；momentum （以batch为单位进行更新），第一个epoch中10个batch，到第9个batch的时候是用什么时候的参数，一直用epoch开始的参数，参数的波动太大了；；随机梯度下降，Momentum-SGD，借助于上一次更新的“速度”</font> </p><ul><li>第一种架构：端到端（End2End），只将batch内的不同样本组成的样本对作为负例，典型的代表就是SimCLR（A Simple Framework for Contrastive Learning of Visual Representations，下文2.1章节），这种方法需要强大的batch才能保证效果</li></ul><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705211549766.png" alt="image-20220705211549766"></p><p><font color="blue">batch越大，2N-2越大，越可能在剩下的2N-2场景下出现实际上是正例的内容</font> </p><ul><li>第二种架构：TODO</li></ul><p><font color="red">看到这个架构后有点想到BBN那种把长尾数据做采样后分成两路输入的，但是这个是一对数据，那个是采样后的两张数据，分成两路训练然后融合；</font> </p><h4 id="1-3-5-Training-Method"><a href="#1-3-5-Training-Method" class="headerlink" title="1.3.5 Training Method"></a>1.3.5 Training Method</h4><p>CL的中心思想是拉进相似的样本的表征，推开不相似的样本的表征，一般用余弦相似度来度量表征向量的距离或者相似度<br>$$<br>{\rm cos_sim}(A, B) &#x3D; \frac{A \cdot B}{\left| A \right|\left| B \right|}<br>$$<br>CL一般使用NCE Loss来聚焦于对比正负样本对之间的距离或者相似度差异</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705213650253.png" alt="image-20220705213650253"></p><p>如果负样本较多则采用NCE的一个变体InfoNCE</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705213703141.png" alt="image-20220705213703141"></p><p><font color="red">这里的$ \tau $ 有一种那个根号下dk的感觉？因为sim这个值域不是很确定或者做一个放缩来保证梯度？</font></p><p> <font color="red">这个形式上就很像softmax？</font> </p><h2 id="2-论文阅读"><a href="#2-论文阅读" class="headerlink" title="2. 论文阅读"></a>2. 论文阅读</h2><h3 id="2-1-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations"><a href="#2-1-A-Simple-Framework-for-Contrastive-Learning-of-Visual-Representations" class="headerlink" title="2.1 A Simple Framework for Contrastive Learning of Visual Representations"></a>2.1 A Simple Framework for Contrastive Learning of Visual Representations</h3><h4 id="2-1-1-abstract"><a href="#2-1-1-abstract" class="headerlink" title="2.1.1 abstract"></a>2.1.1 abstract</h4><p>SimCLR一个用于视觉对比表示学习的简单框架。简化了近期提出的对比自监督学习算法，而不需要专门的架构或存储库。为了了解是什么使得对比预测任务能够学习有用的表示，系统的研究了框架的组成部分：</p><p>1）数据增强的composition在定义有效的预测任务中起到关键作用；</p><p>2）在【表示】和【对比损失】之间引入【可学习的非线性变换】大大提高了学习表示的质量；</p><p>3）与监督学习相比，对比学习受益于更大的batchsize和训练步数；<font color="red">无监督的优势？</font></p><p>通过结合这些发现，我们能够大大优于以前在 ImageNet 上进行自我监督和半监督学习的方法。</p><h4 id="2-1-2-结合博客论文对这篇文章的总结学习"><a href="#2-1-2-结合博客论文对这篇文章的总结学习" class="headerlink" title="2.1.2 结合博客论文对这篇文章的总结学习"></a>2.1.2 结合博客论文对这篇文章的总结学习</h4><p><a href="https://zhuanlan.zhihu.com/p/389064413">https://zhuanlan.zhihu.com/p/389064413</a></p><p>SimCLR是一个比较“标准”的对比学习模型：</p><p>1）相较于之前的self-supervised模型效果有所提升；</p><p>2）采用对称结构，结构相对清晰；</p><p>3）奠定的结构，已经成为其他对比学习模型的标准构成部分；</p><h5 id="如何构造正负例"><a href="#如何构造正负例" class="headerlink" title="如何构造正负例"></a>如何构造正负例</h5><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705235252477.png" alt="image-20220705235252477"></p><p>对于某张图片，从可能的增强操作集合T中，随机抽取 t1<del>T 与 t2</del>T 两种，将其作用在原始图像上，形成 $ &lt;x_1, x_2&gt; $，两者互为正例，训练时Batch内任意其他的图像，都可以作为x1或者x2的负例</p><p><font color="red">这个batch上是怎么个训练方法，用来测试的数据集上是什么数据？如果这样batch的话，只有两个正例，而负例可能有很多，会不会涉及到一些样本类别不均衡的问题？</font> </p><p>对比表示学习希望学习到某个表示模型，能够将图片映射到某个投影空间<font color="red">（这里指的是一种embedding或者representation表示？）</font> ，并在这个空间内拉近正例的距离，推远负例的距离。也就是说，迫使表示模型能够忽略表面因素，学习图像内在的一致结构信息，即学会某些类型的不变性（遮挡不变性、旋转不变性、颜色不变性等）；；；SimCLR给出的图像增强方法难度提升，十分有效</p><p><font color="blue">在原始数据上的数据增强，后续可能有一些方法在数据表征层面做的一些数据增强</font> </p><h5 id="构造表示学习系统"><a href="#构造表示学习系统" class="headerlink" title="构造表示学习系统"></a>构造表示学习系统</h5><p>指导原则：通过这个系统，将训练数据投影到某个表示空间内，采取某种方式使得正例距离比较近，负例距离比较远；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706000430506.png" alt="image-20220706000430506"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220705235035619.png" alt="image-20220705235035619"></p><p>具体流程综合理解为如下，从文字描述来看有些难理解，还是看一下算法流程图：</p><p>对于batchsize为N的一个集合，对于每个元素，执行aug1和aug2，并分别过两次f和g得到h和z的representation</p><p>这样有aug1集合有N张，aug2集合有N张，两者相对应的，比如1和2是一个源数据得到的两种增强（3和4是下一个源数据得到的两种增强），这样的话除去这两张图片，剩下的2N-2是负样本；；在这2N样本中两两计算相似度，以备损失函数度量过程中使用；；；在损失函数度量上，使用的好像就是上文提到的L_infoNCE，在正样本对之间进行度量，假设1作为anchor的时候，就是1和2这个sim 比上 1和2N（除了自己）的sim这样的；；；交换anchor后，得到两种加在一起的；；；</p><p>为什么用z来进行sim度量，好像是一种经验性的做法，然后h是得到的representation，经过这样的Contrastive Learning后，得到f用于表征</p><p><font color="red">作者给了很大的batch size，那么这种感觉会不会让这个类似的softmax的式子有某种变化？比如说更加难以优化，但是泛化性更强？</font> </p><p><font color="blue">原始方法提出的效果只有在大batch_size的时候效果才好；；BERT就是一个典型的自监督方式，通过预训练得到的一个模型；；；大部分把自监督看做无监督，或者说虽然不需要人工标注数据，其实是自己给自己构建了label自动化的方法；</font> </p><h1 id="2022-7-12-补充这里loss的一些细节：https-www-jianshu-com-p-c33a79603f43"><a href="#2022-7-12-补充这里loss的一些细节：https-www-jianshu-com-p-c33a79603f43" class="headerlink" title="2022.7.12_补充这里loss的一些细节：https://www.jianshu.com/p/c33a79603f43"></a>2022.7.12_补充这里loss的一些细节：<a href="https://www.jianshu.com/p/c33a79603f43">https://www.jianshu.com/p/c33a79603f43</a></h1><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706012230880.png" alt="image-20220706012230880"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706010205402.png" alt="image-20220706010205402"></p><p><font color="blue">向量层面的数据增强，representation，近三年（2020）的ACL EMNLP，找几个引用比较多的，现在主要是用作表征的，先看通用一些的；；；看BERT&#x2F;Transformer的实现-形成一个，代码层面定位到训练参数；；；；BERT&#x2F;Transformer的论文仔细读一下，Attention is all you need，positional embedding相对绝对？哪些点是有助于模型这些效果</font> </p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/image-20220706164929885.png" alt="image-20220706164929885"></p><p>d_model 是什么然后根号下</p><p><font color="blue">到8月写实习生考勤表的时候，细化到每周做了什么，</font> </p>]]></content>
    
    
    <categories>
      
      <category>research</category>
      
      <category>contrastive learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>contrastive learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>295场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1299)+t2(1577)；</p><p>这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧；</p><p>第一题：简单字典计数；</p><p>第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>第三题：咕咕QAQ；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2287-重排字符形成目标字符串【难度：1299】"><a href="#第一题：2287-重排字符形成目标字符串【难度：1299】" class="headerlink" title="第一题：2287.重排字符形成目标字符串【难度：1299】"></a>第一题：2287.重排字符形成目标字符串【难度：1299】</h1><p><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p><p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p><p>示例1：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;ilovecodingonleetcode&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;code&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">1</span> 个副本，选取下标为 <span class="hljs-number">4</span> 、<span class="hljs-number">5</span> 、<span class="hljs-number">6</span> 和 <span class="hljs-number">7</span> 的字符。<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">2</span> 个副本，选取下标为 <span class="hljs-number">17</span> 、<span class="hljs-number">18</span> 、<span class="hljs-number">19</span> 和 <span class="hljs-number">20</span> 的字符。<br>形成的字符串分别是 <span class="hljs-string">&quot;ecod&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> ，都可以重排为 <span class="hljs-string">&quot;code&quot;</span> 。<br>可以形成最多 <span class="hljs-number">2</span> 个 <span class="hljs-string">&quot;code&quot;</span> 的副本，所以返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>示例2</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;abcba&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>选取下标为 <span class="hljs-number">0</span> 、<span class="hljs-number">1</span> 和 <span class="hljs-number">2</span> 的字符，可以形成 <span class="hljs-string">&quot;abc&quot;</span> 的 <span class="hljs-number">1</span> 个副本。 <br>可以形成最多 <span class="hljs-number">1</span> 个 <span class="hljs-string">&quot;abc&quot;</span> 的副本，所以返回 <span class="hljs-number">1</span> 。<br>注意，尽管下标 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 分别有额外的 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> ，但不能重用下标 <span class="hljs-number">2</span> 处的 <span class="hljs-string">&#x27;c&#x27;</span> ，所以无法形成 <span class="hljs-string">&quot;abc&quot;</span> 的第 <span class="hljs-number">2</span> 个副本。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;abbaccaddaeea&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;aaaaa&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>选取下标为 <span class="hljs-number">0</span> 、<span class="hljs-number">3</span> 、<span class="hljs-number">6</span> 、<span class="hljs-number">9</span> 和 <span class="hljs-number">12</span> 的字符，可以形成 <span class="hljs-string">&quot;aaaaa&quot;</span> 的 <span class="hljs-number">1</span> 个副本。<br>可以形成最多 <span class="hljs-number">1</span> 个 <span class="hljs-string">&quot;aaaaa&quot;</span> 的副本，所以返回 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= target.length &lt;= 10</code></li><li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>简单字典计数；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rearrangeCharacters</span>(<span class="hljs-params">self, s, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type target: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt_s = Counter(s)<br>        cnt_target = Counter(target)<br>        <br>        res = <span class="hljs-number">1e9</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt_target.items():<br>            res = <span class="hljs-built_in">min</span>(res, cnt_s[key]//value)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2288-价格减免【难度：1577】"><a href="#第二题：2288-价格减免【难度：1577】" class="headerlink" title="第二题：2288.价格减免【难度：1577】"></a>第二题：2288.价格减免【难度：1577】</h1><p><a href="https://leetcode.cn/problems/apply-discount-to-prices/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>&#39;$&#39;</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。</p><ul><li>例如 <code>&quot;$100&quot;</code>、<code>&quot;$23&quot;</code> 和 <code>&quot;$6.75&quot;</code> 表示价格，而 <code>&quot;100&quot;</code>、<code>&quot;$&quot;</code> 和 <code>&quot;2$3&quot;</code> 不是。</li></ul><p><strong>注意</strong>：本题输入中的价格均为整数。</p><p>给你一个字符串 <code>sentence</code>  和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p><p>返回表示修改后句子的字符串。</p><p>示例1：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">输入：sentence = <span class="hljs-string">&quot;there are <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> and 5<span class="hljs-variable">$</span> candies in the shop&quot;</span>, discount = <span class="hljs-number">50</span><br>输出：<span class="hljs-string">&quot;there are <span class="hljs-variable">$0</span>.50 <span class="hljs-variable">$1</span>.00 and 5<span class="hljs-variable">$</span> candies in the shop&quot;</span><br>解释：<br>表示价格的单词是 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 和 <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> 。 <br>- <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 减免 <span class="hljs-number">50</span>% 为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.50&quot;</span> ，所以 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.50&quot;</span> 。<br>- <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> 减免 <span class="hljs-number">50</span>% 为 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ，所以 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>.00&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">输入：sentence = <span class="hljs-string">&quot;1 2 <span class="hljs-variable">$3</span> 4 <span class="hljs-variable">$5</span> <span class="hljs-variable">$6</span> 7 8<span class="hljs-variable">$</span> <span class="hljs-variable">$9</span> <span class="hljs-variable">$10</span><span class="hljs-variable">$</span>&quot;</span>, discount = <span class="hljs-number">100</span><br>输出：<span class="hljs-string">&quot;1 2 <span class="hljs-variable">$0</span>.00 4 <span class="hljs-variable">$0</span>.00 <span class="hljs-variable">$0</span>.00 7 8<span class="hljs-variable">$</span> <span class="hljs-variable">$0</span>.00 <span class="hljs-variable">$10</span><span class="hljs-variable">$</span>&quot;</span><br>解释：<br>任何价格减免 <span class="hljs-number">100</span>% 都会得到 <span class="hljs-number">0</span> 。<br>表示价格的单词分别是 <span class="hljs-string">&quot;<span class="hljs-variable">$3</span>&quot;</span>、<span class="hljs-string">&quot;<span class="hljs-variable">$5</span>&quot;</span>、<span class="hljs-string">&quot;<span class="hljs-variable">$6</span>&quot;</span> 和 <span class="hljs-string">&quot;<span class="hljs-variable">$9</span>&quot;</span>。<br>每个单词都替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.00&quot;</span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 10^5</code></li><li><code>sentence</code> 由小写英文字母、数字、<code>&#39; &#39;</code> 和 <code>&#39;$&#39;</code> 组成</li><li><code>sentence</code> 不含前导和尾随空格</li><li><code>sentence</code> 的所有单词都用单个空格分隔</li><li>所有价格都是 <strong>正</strong> 整数且不含前导零</li><li>所有价格 <strong>最多</strong> 为  <code>10</code> 位数字</li><li><code>0 &lt;= discount &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>P.S. 借这个题想说好讨厌这种描述又长，又带着小数的题啊，感觉不像是正路的题目；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">discountPrices</span>(<span class="hljs-params">self, sentence, discount</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type sentence: str</span><br><span class="hljs-string">        :type discount: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        tmp_list = sentence.split()<br>        res_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br><br>            <span class="hljs-keyword">if</span> tmp_list[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;$&#x27;</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    tmp = <span class="hljs-built_in">int</span>(tmp_list[i][<span class="hljs-number">1</span>:])<br>                    tmp = tmp - (tmp * discount * <span class="hljs-number">1.0</span> /<span class="hljs-number">100</span>)<br>                    tmp = <span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tmp)<br>                    tmp = <span class="hljs-string">&#x27;$&#x27;</span> + tmp<br>                    res_list.append(tmp)<br>                <span class="hljs-keyword">except</span>:<br>                    res_list.append(tmp_list[i])<br>            <span class="hljs-keyword">else</span>:<br>                res_list.append(tmp_list[i])<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(res_list)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>296场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1241)+t2(1416)+t3(1445)；</p><p>难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟&#x2F;贪心就可以完成了；</p><p>第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><p>第二题：排序后贪心，维护一个组内的最大最小值；</p><p>第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2293-极大极小游戏【难度：1241】"><a href="#第一题：2293-极大极小游戏【难度：1241】" class="headerlink" title="第一题：2293.极大极小游戏【难度：1241】"></a>第一题：2293.极大极小游戏【难度：1241】</h1><p><a href="https://leetcode.cn/problems/min-max-game/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p><p>对 <code>nums</code> 执行下述算法：</p><ol><li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>用 <code>newNums</code> 替换 <code>nums</code> 。</li><li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li></ol><p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-06-19-17-05-41.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,2,4,8,2,2]</span><br>输出：1<br>解释：重复执行算法会得到下述数组。<br>第一轮：nums = <span class="hljs-comment">[1,5,4,2]</span><br>第二轮：nums = <span class="hljs-comment">[1,4]</span><br>第三轮：nums = <span class="hljs-comment">[1]</span><br>1 是最后剩下的那个数字，返回 1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 就是最后剩下的数字，返回 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1024</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums.length</code> 是 <code>2</code> 的幂</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMaxGame</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            tmp = []<br>            idx = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                    tmp.append(<span class="hljs-built_in">min</span>(nums[i], nums[i+<span class="hljs-number">1</span>]))<br>                    idx += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    tmp.append(<span class="hljs-built_in">max</span>(nums[i], nums[i+<span class="hljs-number">1</span>]))<br>                    idx += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(tmp)</span><br>            nums = copy.deepcopy(tmp)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>        <span class="hljs-comment"># print(tmp)</span><br>        <span class="hljs-keyword">return</span> tmp[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="第二题：2294-划分数组使最大差为-K【难度：1416】"><a href="#第二题：2294-划分数组使最大差为-K【难度：1416】" class="headerlink" title="第二题：2294.划分数组使最大差为 K【难度：1416】"></a>第二题：2294.划分数组使最大差为 K【难度：1416】</h1><p><a href="https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p><p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p><p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,6,1,2,5], k = 2<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 2 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 1 </span>。<br>由于创建了两个子序列，返回<span class="hljs-number"> 2 </span>。可以证明需要划分的最少子序列数目就是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3], k = 1<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [1,2] 和 [3] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 1 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 0 </span>。<br>由于创建了两个子序列，返回<span class="hljs-number"> 2 </span>。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,4,5], k = 0<br>输出：3<br>解释：<br>可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 0 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 0 </span>。<br>第三个子序列中最大值和最小值的差值是<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 0 </span>。<br>由于创建了三个子序列，返回<span class="hljs-number"> 3 </span>。可以证明需要划分的最少子序列数目就是<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>排序后贪心，维护一个组内的最大最小值；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionArray</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums.sort()<br>        res = []<br> <br>        now_min = nums[<span class="hljs-number">0</span>]<br>        now_max = nums[<span class="hljs-number">0</span>]<br>        tmp = [nums[<span class="hljs-number">0</span>]]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            now_min = <span class="hljs-built_in">min</span>(now_min, nums[i])<br>            now_max = <span class="hljs-built_in">max</span>(now_max, nums[i])<br>            chazhi = <span class="hljs-built_in">abs</span>(now_max-now_min)<br>            <br>            <span class="hljs-keyword">if</span> chazhi &lt;= k:<br>                tmp.append(nums[i])<br>            <span class="hljs-keyword">else</span>:<br>                res.append(tmp)<br>                tmp = [nums[i]]<br>                now_min = nums[i]<br>                now_max = nums[i]<br>        <br>        res.append(tmp)<br>        <span class="hljs-comment"># print(res)</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第三题：2295-替换数组中的元素【难度：1445】"><a href="#第三题：2295-替换数组中的元素【难度：1445】" class="headerlink" title="第三题：2295.替换数组中的元素【难度：1445】"></a>第三题：2295.替换数组中的元素【难度：1445】</h1><p><a href="https://leetcode.cn/problems/replace-elements-in-an-array/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，它包含 <code>n</code> 个 <strong>互不相同</strong> 的正整数。请你对这个数组执行 <code>m</code> 个操作，在第 <code>i</code> 个操作中，你需要将数字 <code>operations[i][0]</code> 替换成 <code>operations[i][1]</code> 。</p><p>题目保证在第 <code>i</code> 个操作中：</p><ul><li><code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li><code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><p>请你返回执行完所有操作后的数组。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,4,6]</span>, operations = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[6,1]</span>]</span><br>输出：<span class="hljs-comment">[3,2,7,1]</span><br>解释：我们对 nums 执行以下操作：<br>- 将数字 1 替换为 3 。nums 变为 <span class="hljs-comment">[3,2,4,6]</span> 。<br>- 将数字 4 替换为 7 。nums 变为 <span class="hljs-comment">[3,2,7,6]</span> 。<br>- 将数字 6 替换为 1 。nums 变为 <span class="hljs-comment">[3,2,7,1]</span> 。<br>返回最终数组 <span class="hljs-comment">[3,2,7,1]</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2]</span>, operations = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[3,2]</span>]</span><br>输出：<span class="hljs-comment">[2,1]</span><br>解释：我们对 nums 执行以下操作：<br>- 将数字 1 替换为 3 。nums 变为 <span class="hljs-comment">[3,2]</span> 。<br>- 将数字 2 替换为 1 。nums 变为 <span class="hljs-comment">[3,1]</span> 。<br>- 将数字 3 替换为 2 。nums 变为 <span class="hljs-comment">[2,1]</span> 。<br>返回最终数组 <span class="hljs-comment">[2,1]</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == operations.length</code></li><li><code>1 &lt;= n, m &lt;= 10^5</code></li><li><code>nums</code> 中所有数字 <strong>互不相同</strong> 。</li><li><code>operations[i].length == 2</code></li><li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10^6</code></li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrayChange</span>(<span class="hljs-params">self, nums, operations</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type operations: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        d = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            d[nums[i]] = [nums[i], nums[i], i]<br>        <br>        <span class="hljs-comment"># print(d)</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(operations)):<br>            old, new = operations[i][<span class="hljs-number">0</span>], operations[i][<span class="hljs-number">1</span>]<br>            tmp_list = d[old]<br>            <br>            d[old] = [new, tmp_list[<span class="hljs-number">1</span>], tmp_list[<span class="hljs-number">2</span>]]<br>            d[new] = d[old]<br>            <span class="hljs-keyword">del</span> d[old]<br>        <br>        tmp_res = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>            tmp_res.append([value[<span class="hljs-number">0</span>], value[<span class="hljs-number">2</span>]])<br>        tmp_res.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>        <span class="hljs-comment"># print(tmp_res)</span><br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_res)):<br>            res.append(tmp_res[i][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1283)+t2(1658)+t3(1886)；</p><p>这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧；</p><p>第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><p>第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><p>第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2303-计算应缴税款总额【难度：1283】"><a href="#第一题：2303-计算应缴税款总额【难度：1283】" class="headerlink" title="第一题：2303.计算应缴税款总额【难度：1283】"></a>第一题：2303.计算应缴税款总额【难度：1283】</h1><p><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10^-5</code> 的结果将被视作正确答案。</p><p>示例1：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：brackets = [[<span class="hljs-number">3</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">25</span>]], income = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">2.65000</span><br>解释：<br>前 $3 的税率为 <span class="hljs-number">50</span>% 。需要支付税款 $3 * <span class="hljs-number">50</span>% = $1<span class="hljs-number">.50</span> 。<br>接下来 $7 - $3 = $4 的税率为 <span class="hljs-number">10</span>% 。需要支付税款 $4 * <span class="hljs-number">10</span>% = $0<span class="hljs-number">.40</span> 。<br>最后 $10 - $7 = $3 的税率为 <span class="hljs-number">25</span>% 。需要支付税款 $3 * <span class="hljs-number">25</span>% = $0<span class="hljs-number">.75</span> 。<br>需要支付的税款总计 $1<span class="hljs-number">.50</span> + $0<span class="hljs-number">.40</span> + $0<span class="hljs-number">.75</span> = $2<span class="hljs-number">.65</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：brackets = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">25</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">50</span>]], income = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.25000</span><br>解释：<br>前 $1 的税率为 <span class="hljs-number">0</span>% 。需要支付税款 $1 * <span class="hljs-number">0</span>% = $0 。<br>剩下 $1 的税率为 <span class="hljs-number">25</span>% 。需要支付税款 $1 * <span class="hljs-number">25</span>% = $0<span class="hljs-number">.25</span> 。<br>需要支付的税款总计 $0 + $0<span class="hljs-number">.25</span> = $0<span class="hljs-number">.25</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：brackets = <span class="hljs-string">[[2,50]]</span>, income = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0.00000</span><br>解释：<br>没有收入，无需纳税，需要支付的税款总计 $<span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= brackets.length &lt;= 100</code></li><li><code>1 &lt;= upperi &lt;= 1000</code></li><li><code>0 &lt;= percenti &lt;= 100</code></li><li><code>0 &lt;= income &lt;= 1000</code></li><li><code>upperi</code> 按递增顺序排列</li><li><code>upperi</code> 中的所有值 互不相同</li><li>最后一个税级的上限大于等于 <code>income</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculateTax</span>(<span class="hljs-params">self, brackets, income</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type brackets: List[List[int]]</span><br><span class="hljs-string">        :type income: int</span><br><span class="hljs-string">        :rtype: float</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brackets)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            brackets[i][<span class="hljs-number">0</span>] = brackets[i][<span class="hljs-number">0</span>] - brackets[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>    <br>        <span class="hljs-comment"># print(brackets)</span><br>        res = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brackets)):<br>            <span class="hljs-keyword">if</span> income &gt;= brackets[i][<span class="hljs-number">0</span>]:<br>                res +=  ((brackets[i][<span class="hljs-number">0</span>] * brackets[i][<span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span>) / <span class="hljs-number">100</span>)<br>                income -= brackets[i][<span class="hljs-number">0</span>]<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <br>                res +=  ((income * brackets[i][<span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span>) / <span class="hljs-number">100</span>)<br>                i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2304-网格中的最小路径代价【难度：1658】"><a href="#第二题：2304-网格中的最小路径代价【难度：1658】" class="headerlink" title="第二题：2304.网格中的最小路径代价【难度：1658】"></a>第二题：2304.网格中的最小路径代价【难度：1658】</h1><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意</strong>： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-06-19-16-46-14.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]<br>输出：17<br>解释：最小代价的路径是<span class="hljs-number"> 5 </span>-&gt;<span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 1 </span>。<br>- 路径途经单元格值之和<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br>- 从<span class="hljs-number"> 5 </span>移动到<span class="hljs-number"> 0 </span>的代价为<span class="hljs-number"> 3 </span>。<br>- 从<span class="hljs-number"> 0 </span>移动到<span class="hljs-number"> 1 </span>的代价为<span class="hljs-number"> 8 </span>。<br>路径总代价为<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 17 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]<br>输出：6<br>解释：<br>最小代价的路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 3 </span>。 <br>- 路径途经单元格值之和<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>。 <br>- 从<span class="hljs-number"> 2 </span>移动到<span class="hljs-number"> 3 </span>的代价为<span class="hljs-number"> 1 </span>。 <br>路径总代价为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li><li><code>moveCost.length == m * n</code></li><li><code>moveCost[i].length == n</code></li><li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid, moveCost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type moveCost: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        base = grid[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):  <span class="hljs-comment"># 遍历m行</span><br>            new_base = [<span class="hljs-number">1e99</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># n个</span><br>            <span class="hljs-comment"># 下面是一个从当前n个状态（base，用j代表）到下n个状态（用k表示）的转移，从上一行的n个转移到下一行的n个，每个地方取最优的dp</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    new_base[k] = <span class="hljs-built_in">min</span>(new_base[k], base[j]+grid[i][k]+moveCost[grid[i-<span class="hljs-number">1</span>][j]][k])  <span class="hljs-comment"># 选一个所有状态转移里最小的</span><br>            <br>            base = new_base<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(base)<br></code></pre></td></tr></table></figure><h1 id="第三题：2305-公平分发饼干【难度：1886】"><a href="#第三题：2305-公平分发饼干【难度：1886】" class="headerlink" title="第三题：2305.公平分发饼干【难度：1886】"></a>第三题：2305.公平分发饼干【难度：1886】</h1><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cookies = [8,15,10,20,8], k = 2<br>输出：31<br>解释：一种最优方案是 [8,15,8] 和 [10,20] 。<br>- 第<span class="hljs-number"> 1 </span>个孩子分到 [8,15,8] ，总计<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 31 </span>块饼干。<br>- 第<span class="hljs-number"> 2 </span>个孩子分到 [10,20] ，总计<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 20 </span>=<span class="hljs-number"> 30 </span>块饼干。<br>分发的不公平程度为 max(31,30) =<span class="hljs-number"> 31 </span>。<br>可以证明不存在不公平程度小于<span class="hljs-number"> 31 </span>的分发方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cookies = [6,1,3,2,2,4,1,2], k = 3<br>输出：7<br>解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。<br>- 第<span class="hljs-number"> 1 </span>个孩子分到 [6,1] ，总计<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>块饼干。 <br>- 第<span class="hljs-number"> 2 </span>个孩子分到 [3,2,2] ，总计<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 7 </span>块饼干。<br>- 第<span class="hljs-number"> 3 </span>个孩子分到 [4,1,2] ，总计<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 7 </span>块饼干。<br>分发的不公平程度为 max(7,7,7) =<span class="hljs-number"> 7 </span>。<br>可以证明不存在不公平程度小于<span class="hljs-number"> 7 </span>的分发方案。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= cookies.length &lt;= 8</code></li><li><code>1 &lt;= cookies[i] &lt;= 10^5</code></li><li><code>2 &lt;= k &lt;= cookies.length</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超时解法27/36</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCookies</span>(<span class="hljs-params">self, cookies, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cookies: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">1e99</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">n, x, padding_len</span>):<br>            <span class="hljs-comment">#n为待转换的十进制数，x为机制，取值为2-16</span><br>            a=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>]<br>            b=[]<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                s=n//x  <span class="hljs-comment"># 商</span><br>                y=n%x  <span class="hljs-comment"># 余数</span><br>                b=b+[y]<br>                <span class="hljs-keyword">if</span> s==<span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">break</span><br>                n=s<br>            b.reverse()<br>            tmp = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b:<br>                tmp.append(a[i])<br>            <span class="hljs-keyword">return</span> tmp + [<span class="hljs-number">0</span>] * (padding_len - <span class="hljs-built_in">len</span>(tmp))<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k**<span class="hljs-built_in">len</span>(cookies)):<br>            tmp = f(i, k, <span class="hljs-built_in">len</span>(cookies))<br>            d = defaultdict(<span class="hljs-built_in">int</span>)<br>            tmp_max = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp)):<br>                d[tmp[i]] += cookies[i]<br>            <br>            <span class="hljs-comment"># print(d)</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(d) != k:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                tmp_max = <span class="hljs-built_in">max</span>([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> d.values()])<br><br>            res = <span class="hljs-built_in">min</span>(res, tmp_max)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
      <tag>矩阵</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>298场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1427)+t2(1646)+t3(1871)；</p><p>近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧；</p><p>第一题：小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><p>第二题：思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><p>第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：5242-兼具大小写的最好英文字母【难度：1427】"><a href="#第一题：5242-兼具大小写的最好英文字母【难度：1427】" class="headerlink" title="第一题：5242.兼具大小写的最好英文字母【难度：1427】"></a>第一题：5242.兼具大小写的最好英文字母【难度：1427】</h1><p><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> 更好 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 后 出现。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;lEeTcOdE&quot;</span><br>输出：<span class="hljs-string">&quot;E&quot;</span><br>解释：<br>字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;arRAzFif&quot;</span><br>输出：<span class="hljs-string">&quot;R&quot;</span><br>解释：<br>字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。<br>注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AbCdEfGhIjK&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<br>不存在大写和小写形式都出现的字母。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写和大写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">greatestLetter</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        res = []<br>        d = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            d[s[i]] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>            <span class="hljs-keyword">if</span> d.get(key.upper()) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> d.get(key.lower()) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                res += key.upper()<br>        <br>        res.sort()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res):<br>            <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第二题：5218-个位数字为-K-的整数之和【难度：1646】"><a href="#第二题：5218-个位数字为-K-的整数之和【难度：1646】" class="headerlink" title="第二题：5218.个位数字为 K 的整数之和【难度：1646】"></a>第二题：5218.个位数字为 K 的整数之和【难度：1646】</h1><p><a href="https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p><ul><li>每个整数个位数字都是 <code>k</code> 。</li><li>所有整数之和是 <code>num</code> 。</li></ul><p>返回该多重集的最小大小，如果不存在这样的多重集，返回 <code>-1</code> 。</p><p>注意：</p><ul><li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。</li><li><code>个位数字</code> 是数字最右边的数位。</li></ul><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 58, k = 9<br>输出：2<br>解释：<br>多重集 [9,49] 满足题目条件，和为<span class="hljs-number"> 58 </span>且每个整数的个位数字是<span class="hljs-number"> 9 </span>。<br>另一个满足条件的多重集是 [19,39] 。<br>可以证明<span class="hljs-number"> 2 </span>是满足题目条件的多重集的最小长度。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 37, k = 2<br>输出：-1<br>解释：个位数字为<span class="hljs-number"> 2 </span>的整数无法相加得到<span class="hljs-number"> 37 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>, k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">0</span><br>解释：空多重集的和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= num &lt;= 3000</code></li><li><code>0 &lt;= k &lt;= 9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumNumbers</span>(<span class="hljs-params">self, num, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <br>        <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span>:<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                cnt = -<span class="hljs-number">1</span><br>                <br>            res = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">break</span><br>                num -= k<br>                res += <span class="hljs-number">1</span><br>                <br>            <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <br>            <span class="hljs-keyword">return</span> res<br>        <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】"><a href="#第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】" class="headerlink" title="第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】"></a>第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】</h1><p><a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p><p>请你返回 <code>s</code> 的 <strong>最长</strong> 子序列，且该子序列对应的 <strong>二进制</strong> 数字小于等于 <code>k</code> 。</p><p>注意：</p><ul><li>子序列可以有 <strong>前导 0</strong> 。</li><li>空字符串视为 <code>0</code> 。</li><li><code>子序列</code> 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li></ul><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;1001010&quot;, k = 5<br>输出：5<br>解释：s 中小于等于<span class="hljs-number"> 5 </span>的最长子序列是 &quot;00010&quot; ，对应的十进制数字是<span class="hljs-number"> 2 </span>。<br>注意 &quot;00100&quot; 和 &quot;00101&quot; 也是可行的最长子序列，十进制分别对应<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 5 </span>。<br>最长子序列的长度为<span class="hljs-number"> 5 </span>，所以返回<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;00101001&quot;, k = 1<br>输出：6<br>解释：&quot;000001&quot; 是 s 中小于等于<span class="hljs-number"> 1 </span>的最长子序列，对应的十进制数字是<span class="hljs-number"> 1 </span>。<br>最长子序列的长度为<span class="hljs-number"> 6 </span>，所以返回<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">self, s, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        summ = <span class="hljs-number">0</span><br>        remove = <span class="hljs-number">0</span><br>        s = s[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">if</span> summ &gt;= k:<br>                    remove += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> summ + (<span class="hljs-number">1</span> &lt;&lt; i) &gt; k:<br>                        remove += <span class="hljs-number">1</span><br>                    summ += (<span class="hljs-number">1</span> &lt;&lt; i)  <span class="hljs-comment"># 左移i位置，优先加小位置的</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) - remove<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>294场LeetCode周赛</title>
    <link href="/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 <code>from decimal import Decimal</code>，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG；</p><p>第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><p>第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><p>第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2278-字母在字符串中的百分比"><a href="#第一题：2278-字母在字符串中的百分比" class="headerlink" title="第一题：2278.字母在字符串中的百分比"></a>第一题：2278.字母在字符串中的百分比</h1><p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;foobar&quot;</span>, letter = <span class="hljs-string">&quot;o&quot;</span><br>输出：<span class="hljs-number">33</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;o&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">2</span> / <span class="hljs-number">6</span> * <span class="hljs-number">100</span><span class="hljs-meta">%</span> = <span class="hljs-number">33</span><span class="hljs-meta">%</span> ，向下取整，所以返回 <span class="hljs-number">33</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">输入：s = <span class="hljs-string">&quot;jjjj&quot;</span>, letter = <span class="hljs-string">&quot;k&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;k&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">0</span><span class="hljs-comment">% ，所以返回 0 。</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">percentageLetter</span>(<span class="hljs-params">self, s, letter</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type letter: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == letter:<br>                cnt += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt * <span class="hljs-number">100</span> // <span class="hljs-built_in">len</span>(s)<br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        res = (cnt * 1.0 / len(s) ) * 100</span><br><span class="hljs-string">        r = int(str(res).split(&#x27;.&#x27;)[0])</span><br><span class="hljs-string">        return r</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2279-装满石头的背包的最大数量"><a href="#第二题：2279-装满石头的背包的最大数量" class="headerlink" title="第二题：2279.装满石头的背包的最大数量"></a>第二题：2279.装满石头的背包的最大数量</h1><p><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 <strong>任意</strong> 背包中放置。</p><p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大</strong> 数量。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2<br>输出：3<br>解释：<br>1 块石头放入背包<span class="hljs-number"> 0 </span>，1 块石头放入背包<span class="hljs-number"> 1 </span>。<br>每个背包中的石头总数是 [2,3,4,4] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和 背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，可能存在其他放置石头的方案同样能够得到<span class="hljs-number"> 3 </span>这个结果。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100<br>输出：3<br>解释：<br>8 块石头放入背包<span class="hljs-number"> 0 </span>，2 块石头放入背包<span class="hljs-number"> 2 </span>。<br>每个背包中的石头总数是 [10,2,2] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，不必用完所有的额外石头。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == capacity.length == rocks.length</code></li><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li><li><code>1 &lt;= capacity[i] &lt;= 10^9</code></li><li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li><li><code>1 &lt;= additionalRocks &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumBags</span>(<span class="hljs-params">self, capacity, rocks, additionalRocks</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type capacity: List[int]</span><br><span class="hljs-string">        :type rocks: List[int]</span><br><span class="hljs-string">        :type additionalRocks: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cha = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(capacity)):<br>            cha.append(capacity[i]-rocks[i])<br>        <br>        cha.sort()<br><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cha)):<br>            <span class="hljs-keyword">if</span> cha[i] &lt;= additionalRocks:<br>                cnt += <span class="hljs-number">1</span><br>                additionalRocks -= cha[i]<br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：2280-表示一个折线图的最少线段数"><a href="#第三题：2280-表示一个折线图的最少线段数" class="headerlink" title="第三题：2280.表示一个折线图的最少线段数"></a>第三题：2280.表示一个折线图的最少线段数</h1><p><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [day_i, price_i]</code> 表示股票在 <code>day_i</code> 的价格为 <code>price_i</code> 。<strong>折线图</strong> 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-25-00-57-12.png"></p><p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong> 。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-25-00-58-50.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：stockPrices = [[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：<br>上图为输入对应的图，横坐标表示日期，纵坐标表示价格。<br>以下 <span class="hljs-number">3</span> 个线段可以表示折线图：<br>- 线段 1 （红色）从 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 2 （蓝色）从 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 3 （绿色）从 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> 。<br>可以证明，无法用少于 3 条线段表示这个折线图。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-25-00-59-13.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stockPrices = <span class="hljs-comment">[<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[7,8]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：1<br>解释：<br>如上图所示，折线图可以用一条线段表示。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= stockPrices.length &lt;= 10^5</code></li><li><code>stockPrices[i].length == 2</code></li><li><code>1 &lt;= day_i, price_i &lt;= 10^9</code></li><li>所有 <code>day_i</code> 互不相同 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumLines</span>(<span class="hljs-params">self, stockPrices: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stockPrices) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        stockPrices.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <span class="hljs-comment"># print(stockPrices)</span><br>        k = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(stockPrices)):<br>            tmp = Decimal(stockPrices[i][<span class="hljs-number">1</span>] - stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) / Decimal((stockPrices[i][<span class="hljs-number">0</span>] - stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            prev = Decimal(stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - stockPrices[i-<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])/ Decimal(stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - stockPrices[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])<br><br>            <span class="hljs-keyword">if</span> prev == tmp:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                res += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
      <tag>几何</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>293场LeetCode周赛</title>
    <link href="/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh</p><p>第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><p>第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><p>第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p>第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了；</p><span id="more"></span><h1 id="第一题：5234-移除字母异位词后的结果数组"><a href="#第一题：5234-移除字母异位词后的结果数组" class="headerlink" title="第一题：5234.移除字母异位词后的结果数组"></a>第一题：5234.移除字母异位词后的结果数组</h1><p><a href="https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p><p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 <strong>删除</strong> <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p><ol><li><code>0 &lt; i &lt; words.length</code></li><li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li></ol><p>只要可以选出满足条件的下标，就一直执行这个操作。</p><p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>&quot;dacb&quot;</code> 是 <code>&quot;abdc&quot;</code> 的一个字母异位词。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;baba&quot;</span>,<span class="hljs-string">&quot;bbaa&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]<br>输出：[<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]<br>解释：<br>获取结果数组的方法之一是执行下述步骤：<br>- 由于 words[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;bbaa&quot;</span> 和 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;baba&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">2</span> 并删除 words[<span class="hljs-number">2</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;baba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>- 由于 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;baba&quot;</span> 和 words[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;abba&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">1</span> 并删除 words[<span class="hljs-number">1</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>- 由于 words[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;cd&quot;</span> 和 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;cd&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">2</span> 并删除 words[<span class="hljs-number">2</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>无法再执行任何操作，所以 [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 是最终答案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>]<br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>]<br>解释：<br><span class="hljs-built_in">words</span> 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeAnagrams</span>(<span class="hljs-params">self, words</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type words: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        i = <span class="hljs-number">1</span><br>        res = []<br>        init_cnt = Counter(words[<span class="hljs-number">0</span>])<br>        res.append(words[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(words):<br>            <span class="hljs-keyword">if</span> Counter(words[i]) == init_cnt:<br>                i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                init_cnt = Counter(words[i])<br>                res.append(words[i])<br>                i += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：6064-不含特殊楼层的最大连续楼层数"><a href="#第二题：6064-不含特殊楼层的最大连续楼层数" class="headerlink" title="第二题：6064.不含特殊楼层的最大连续楼层数"></a>第二题：6064.不含特殊楼层的最大连续楼层数</h1><p><a href="https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p><p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示  Alice 指定用于放松的特殊楼层。</p><p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bottom = 2, top = 9, special = [4,6]<br>输出：3<br>解释：下面列出的是不含特殊楼层的连续楼层范围：<br>- (2, 3) ，楼层数为<span class="hljs-number"> 2 </span>。<br>- (5, 5) ，楼层数为<span class="hljs-number"> 1 </span>。<br>- (7, 9) ，楼层数为<span class="hljs-number"> 3 </span>。<br>因此，返回最大连续楼层数<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：<span class="hljs-built_in">bottom</span> = <span class="hljs-number">6</span>, <span class="hljs-built_in">top</span> = <span class="hljs-number">8</span>, special = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-number">0</span><br>解释：每层楼都被规划为特殊楼层，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示</p><ul><li><code>1 &lt;= special.length &lt;= 10^5</code></li><li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10^9</code></li><li><code>special</code> 中的所有值 互不相同</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxConsecutive</span>(<span class="hljs-params">self, bottom, top, special</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bottom: int</span><br><span class="hljs-string">        :type top: int</span><br><span class="hljs-string">        :type special: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        special.append(bottom-<span class="hljs-number">1</span>)<br>        special.append(top+<span class="hljs-number">1</span>)<br>        special.sort()<br>        <br>        <span class="hljs-built_in">print</span>(special)<br>        res = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(special)):<br>            res = <span class="hljs-built_in">max</span>(res, special[i]-special[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6065-按位与结果大于零的最长组合"><a href="#第三题：6065-按位与结果大于零的最长组合" class="headerlink" title="第三题：6065.按位与结果大于零的最长组合"></a>第三题：6065.按位与结果大于零的最长组合</h1><p><a href="https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>对数组 <code>nums</code> 执行 <strong>按位与</strong> 相当于对数组 <code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p><ul><li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li><li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li></ul><p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p><p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [16,17,71,62,12,24,14]<br>输出：4<br>解释：组合 [16,17,62,24] 的按位与结果是<span class="hljs-number"> 16 </span>&amp;<span class="hljs-number"> 17 </span>&amp;<span class="hljs-number"> 62 </span>&amp;<span class="hljs-number"> 24 </span>=<span class="hljs-number"> 16 </span>&gt;<span class="hljs-number"> 0 </span>。<br>组合长度是<span class="hljs-number"> 4 </span>。<br>可以证明不存在按位与结果大于<span class="hljs-number"> 0 </span>且长度大于<span class="hljs-number"> 4 </span>的组合。<br>注意，符合长度最大的组合可能不止一种。<br>例如，组合 [62,12,24,14] 的按位与结果是<span class="hljs-number"> 62 </span>&amp;<span class="hljs-number"> 12 </span>&amp;<span class="hljs-number"> 24 </span>&amp;<span class="hljs-number"> 14 </span>=<span class="hljs-number"> 8 </span>&gt;<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [8,8]<br>输出：2<br>解释：最长组合是 [8,8] ，按位与结果<span class="hljs-number"> 8 </span>&amp;<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 8 </span>&gt;<span class="hljs-number"> 0 </span>。<br>组合长度是<span class="hljs-number"> 2 </span>，所以返回<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= candidates.length &lt;= 10^5</code></li><li><code>1 &lt;= candidates[i] &lt;= 10^7</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-16-10-17-08.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestCombination</span>(<span class="hljs-params">self, candidates</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        candidates.sort()<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_bin</span>(<span class="hljs-params">num, pad=<span class="hljs-number">31</span></span>):<br>            tmp_list = []<br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                tmp_list.append(num&amp;<span class="hljs-number">1</span>)<br>                num &gt;&gt;= <span class="hljs-number">1</span><br>            <br>            tmp_list.reverse()<br>            tmp_list = [<span class="hljs-number">0</span>] * (pad-<span class="hljs-built_in">len</span>(tmp_list)) + tmp_list<br>            <br>            <span class="hljs-keyword">return</span> tmp_list<br>        <br>        a = []<br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidates)):<br>            a.append(convert_to_bin(candidates[i]))<br>            <span class="hljs-comment"># print(candidates[i], convert_to_bin(candidates[i]))</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a[<span class="hljs-number">0</span>])):<br>            tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>                <span class="hljs-keyword">if</span> a[i][j] == <span class="hljs-number">1</span>:<br>                    tmp += <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, tmp)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>HARD</tag>
      
      <tag>位运算</tag>
      
      <tag>哈希表</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>292场LeetCode周赛</title>
    <link href="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 <code>22222</code> 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 <code>@lru_cache(1000*1000)</code> 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg</p><p>第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p>第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a>，<strong>注意这个题的优化剪枝！</strong></p><span id="more"></span><h1 id="第一题：6056-字符串中最大的-3-位相同数字"><a href="#第一题：6056-字符串中最大的-3-位相同数字" class="headerlink" title="第一题：6056.字符串中最大的 3 位相同数字"></a>第一题：6056.字符串中最大的 3 位相同数字</h1><p><a href="https://leetcode.cn/problems/largest-3-same-digit-number-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p><ul><li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li><li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li></ul><p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li><strong>子字符串</strong> 是字符串中的一个连续字符序列。</li><li><code>num</code> 或优质整数中可能存在 <strong>前导零</strong> 。</li></ul><p>示例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;6777133339&quot;</span><br>输出：<span class="hljs-string">&quot;777&quot;</span><br>解释：<span class="hljs-built_in">num</span> 中存在两个优质整数：<span class="hljs-string">&quot;777&quot;</span> 和 <span class="hljs-string">&quot;333&quot;</span> 。<br><span class="hljs-string">&quot;777&quot;</span> 是最大的那个，所以返回 <span class="hljs-string">&quot;777&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：num <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2300019&quot;</span><br>输出：<span class="hljs-string">&quot;000&quot;</span><br>解释：<span class="hljs-string">&quot;000&quot;</span> 是唯一一个优质整数。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：num <span class="hljs-operator">=</span> <span class="hljs-string">&quot;42352338&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：不存在长度为 <span class="hljs-number">3</span> 且仅由一个唯一数字组成的整数。因此，不存在优质整数。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= num.length &lt;= 1000</code></li><li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>另外来说的话，三个数是一样的，水仙花数hh！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestGoodInteger</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num)-<span class="hljs-number">2</span>):<br>            tmp = num[i:i+<span class="hljs-number">3</span>]<br>            <span class="hljs-keyword">if</span> tmp[<span class="hljs-number">0</span>] == tmp[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> tmp[<span class="hljs-number">1</span>] == tmp[<span class="hljs-number">2</span>]:<br>                res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">int</span>(tmp), res)<br>        <br>        <span class="hljs-keyword">if</span> res == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">3</span> - <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(res))) * <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-built_in">str</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：6057-统计值等于子树平均值的节点数"><a href="#第二题：6057-统计值等于子树平均值的节点数" class="headerlink" title="第二题：6057.统计值等于子树平均值的节点数"></a>第二题：6057.统计值等于子树平均值的节点数</h1><p><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵二叉树的根节点 <code>root</code> ，找出并返回满足要求的节点数，要求节点的值等于其 <strong>子树</strong> 中值的 <strong>平均值</strong> 。</p><p>注意：</p><ul><li><code>n</code> 个元素的平均值可以由 <code>n</code> 个元素 <strong>求和</strong> 然后再除以 <code>n</code> ，并 <strong>向下舍入</strong> 到最近的整数。</li><li><code>root</code> 的 <strong>子树</strong> 由 <code>root</code> 和它的所有后代组成。</li></ul><p>示例 1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-27-52.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [4,8,5,0,1,null,6]<br>输出：5<br>解释：<br>对值为<span class="hljs-number"> 4 </span>的节点：子树的平均值 (4 +<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+ 6) /<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 24 </span>/<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 4 </span>。<br>对值为<span class="hljs-number"> 5 </span>的节点：子树的平均值 (5 + 6) /<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 11 </span>/<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>。<br>对值为<span class="hljs-number"> 0 </span>的节点：子树的平均值<span class="hljs-number"> 0 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 0 </span>。<br>对值为<span class="hljs-number"> 1 </span>的节点：子树的平均值<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 1 </span>。<br>对值为<span class="hljs-number"> 6 </span>的节点：子树的平均值<span class="hljs-number"> 6 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-28-58.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1]<br>输出：1<br>解释：对值为<span class="hljs-number"> 1 </span>的节点：子树的平均值<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>写一个函数是 <code>count_mean</code> 然后再在dfs中把这个套进去！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.cnt = <span class="hljs-number">0</span><br>        self.val_sum = <span class="hljs-number">0</span><br>        self.res = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfSubtree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_mean</span>(<span class="hljs-params">root</span>):  <span class="hljs-comment"># 统计一个子树的均值</span><br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            self.val_sum += root.val<br>            self.cnt += <span class="hljs-number">1</span><br>            count_mean(root.left)<br>            count_mean(root.right)<br>        <br>        <br>        <span class="hljs-comment"># 外面再套一层dfs？</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            self.val_sum = <span class="hljs-number">0</span><br>            self.cnt = <span class="hljs-number">0</span><br>            count_mean(root)<br>            <span class="hljs-keyword">if</span> self.val_sum/self.cnt == root.val:<br>                self.res += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(self.cnt)</span><br>            <span class="hljs-comment"># print(self.val_sum)</span><br>            dfs(root.left)<br>            dfs(root.right)<br>        <br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.res<br></code></pre></td></tr></table></figure><h1 id="第三题：6058-统计打字方案数"><a href="#第三题：6058-统计打字方案数" class="headerlink" title="第三题：6058.统计打字方案数"></a>第三题：6058.统计打字方案数</h1><p><a href="https://leetcode.cn/problems/count-number-of-texts/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 在给 Bob 用手机打字。数字到字母的 <strong>对应</strong> 如下图所示。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-36-14.png"></p><p>为了 <strong>打出</strong> 一个字母，Alice 需要 <strong>按</strong> 对应字母 <code>i</code> 次，<code>i</code> 是该字母在这个按键上所处的位置。</p><ul><li>比方说，为了按出字母 <code>&#39;s&#39;</code> ，Alice 需要按 <code>&#39;7&#39;</code> 四次。类似的， Alice 需要按 <code>&#39;5&#39;</code> 两次得到字母  <code>&#39;k&#39;</code> 。</li><li>注意，数字 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 不映射到任何字母，所以 Alice <strong>不</strong> 使用它们。</li></ul><p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 <strong>按键的字符串信息</strong> 。</p><ul><li>比方说，Alice 发出的信息为 <code>&quot;bob&quot;</code> ，Bob 将收到字符串 <code>&quot;2266622&quot;</code> 。</li></ul><p>给你一个字符串 <code>pressedKeys</code> ，表示 Bob 收到的字符串，请你返回 Alice <strong>总共可能发出多少种文字信息</strong> 。</p><p>由于答案可能很大，将它对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">pressedKeys</span> = <span class="hljs-string">&quot;22233&quot;</span><br>输出：<span class="hljs-number">8</span><br>解释：<br>Alice 可能发出的文字信息包括：<br><span class="hljs-string">&quot;aaadd&quot;</span>, <span class="hljs-string">&quot;abdd&quot;</span>, <span class="hljs-string">&quot;badd&quot;</span>, <span class="hljs-string">&quot;cdd&quot;</span>, <span class="hljs-string">&quot;aaae&quot;</span>, <span class="hljs-string">&quot;abe&quot;</span>, <span class="hljs-string">&quot;bae&quot;</span> 和 <span class="hljs-string">&quot;ce&quot;</span> 。<br>由于总共有 <span class="hljs-number">8</span> 种可能的信息，所以我们返回 <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;<br>输出：82876089<br>解释：<br>总共有<span class="hljs-number"> 2082876103 </span>种 Alice 可能发出的文字信息。<br>由于我们需要将答案对<span class="hljs-number"> 109 </span>+<span class="hljs-number"> 7 </span>取余，所以我们返回<span class="hljs-number"> 2082876103 </span>% (109 + 7) =<span class="hljs-number"> 82876089 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= pressedKeys.length &lt;= 10^5</code></li><li><code>pressedKeys</code> 只包含数字 <code>&#39;2&#39;</code> 到 <code>&#39;9&#39;</code> 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-43-04.png"></p><p>另外在代码实现上，发现直接初始化所有的这种类似于离线的操作可能会超时，所以来说的话还是写了一版动态的思路，参照之前的经验，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countTexts</span>(<span class="hljs-params">self, pressedKeys</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type pressedKeys: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">        # 写法1，方法应该没问题，但是初始化的时候太耗时了，可能就被边界卡了</span><br><span class="hljs-string">        if len(pressedKeys) == 0:</span><br><span class="hljs-string">            return 0</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        max_len = len(pressedKeys) + 5</span><br><span class="hljs-string">        MOD = 10**9 + 7</span><br><span class="hljs-string"></span><br><span class="hljs-string">        # 这个过程有点太耗时了，这里可能要换一种动态的写法，因为太多位置是没用的了？</span><br><span class="hljs-string">        # 非7，9的递推方程</span><br><span class="hljs-string">        f_1 = [0] * max_len  # 写不写成for好像没区别</span><br><span class="hljs-string">        f_1[1], f_1[2], f_1[3] = 1, 2, 4</span><br><span class="hljs-string">        # 7，9的递推方程</span><br><span class="hljs-string">        f_2 = [0] * max_len</span><br><span class="hljs-string">        f_2[1], f_2[2], f_2[3], f_2[4] = 1, 2, 4, 8</span><br><span class="hljs-string">        # 简化为一个循环</span><br><span class="hljs-string">        for i in range(4, max_len):</span><br><span class="hljs-string">            f_1[i] = f_1[i-1] + f_1[i-2] + f_1[i-3]</span><br><span class="hljs-string">            if i != 4:</span><br><span class="hljs-string">                f_2[i] = f_2[i-1] + f_2[i-2] + f_2[i-3] + f_2[i-4]</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        # 开始分组统计</span><br><span class="hljs-string">        res = 1</span><br><span class="hljs-string">        pressedKeys += &#x27;#&#x27;  # 哨兵</span><br><span class="hljs-string">        now_str = pressedKeys[0]</span><br><span class="hljs-string">        cnt = 1</span><br><span class="hljs-string">        i = 1</span><br><span class="hljs-string">        while i &lt; len(pressedKeys):</span><br><span class="hljs-string">            if pressedKeys[i] == now_str:</span><br><span class="hljs-string">                cnt += 1</span><br><span class="hljs-string">            else:</span><br><span class="hljs-string">                if now_str == &#x27;7&#x27; or now_str == &#x27;9&#x27;:</span><br><span class="hljs-string">                    res *= f_2[cnt] % MOD</span><br><span class="hljs-string">                else:</span><br><span class="hljs-string">                    res *= f_1[cnt] % MOD</span><br><span class="hljs-string">                cnt = 1</span><br><span class="hljs-string">                now_str = pressedKeys[i]</span><br><span class="hljs-string">            i += 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">        return res % MOD</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 写法2，把写法1的方法转成动态的，或者相对更加记忆化一点</span><br>        f_1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]  <span class="hljs-comment"># 角标直接对应上</span><br>        f_2 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]<br>        i = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">1</span><br>        pressedKeys += <span class="hljs-string">&#x27;#&#x27;</span><br>        now_str = pressedKeys[<span class="hljs-number">0</span>]<br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(pressedKeys):<br>            <span class="hljs-keyword">if</span> pressedKeys[i] == now_str:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> now_str == <span class="hljs-string">&#x27;7&#x27;</span> <span class="hljs-keyword">or</span> now_str == <span class="hljs-string">&#x27;9&#x27;</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        res *= f_2[cnt]<br>                    <span class="hljs-keyword">except</span>:<br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(f_2), cnt+<span class="hljs-number">1</span>):<br>                            <span class="hljs-comment"># 注，这里实际上不推荐append的写法，最好是初始化一个很长的，往里填</span><br>                            f_2.append(f_2[j-<span class="hljs-number">1</span>] + f_2[j-<span class="hljs-number">2</span>] + f_2[j-<span class="hljs-number">3</span>] + f_2[j-<span class="hljs-number">4</span>])<br>                        res *= f_2[cnt]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        res *= f_1[cnt]<br>                    <span class="hljs-keyword">except</span>:<br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(f_1), cnt+<span class="hljs-number">1</span>):<br>                            f_1.append(f_1[j-<span class="hljs-number">1</span>] + f_1[j-<span class="hljs-number">2</span>] + f_1[j-<span class="hljs-number">3</span>])<br>                        res *= f_1[cnt]<br>                cnt = <span class="hljs-number">1</span><br>                now_str = pressedKeys[i]<br>            i += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res % (<span class="hljs-number">10</span>**<span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="第四题：6059-检查是否有合法括号字符串路径"><a href="#第四题：6059-检查是否有合法括号字符串路径" class="headerlink" title="第四题：6059.检查是否有合法括号字符串路径"></a>第四题：6059.检查是否有合法括号字符串路径</h1><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p><ul><li>字符串是 <code>()</code> 。</li><li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li><li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li></ul><p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p><ul><li>路径开始于左上角格子 <code>(0, 0)</code> 。</li><li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li><li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li><li>路径经过的格子组成的括号字符串是 <strong>合法</strong> 的。</li></ul><p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-49-28.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>],[<span class="hljs-string">&quot;)&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>],[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>],[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>]]<br>输出：true<br>解释：上图展示了两条路径，它们都是合法括号字符串路径。<br>第一条路径得到的合法字符串是 <span class="hljs-string">&quot;()(())&quot;</span> 。<br>第二条路径得到的合法字符串是 <span class="hljs-string">&quot;((()))&quot;</span> 。<br>注意可能有其他的合法括号字符串路径。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-50-00.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：两条可行路径分别得到 <span class="hljs-string">&quot;))(&quot;</span> 和 <span class="hljs-string">&quot;)((&quot;</span> 。由于它们都不是合法括号字符串，我们返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>grid[i][j]</code> 要么是 <code>&#39;(&#39;</code> ，要么是 <code>&#39;)&#39;</code> 。</li></ul><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a></p><p>在优化剪枝上，一种是 <code>@lru_cache(1000*1000)</code> 靠着编译器来优化，另外一种是记录visited数组，类似于下面图里写的意思，还有就是说匹配上的括号长度一定是 <strong>偶数</strong> 的：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-08-21-56-39.png"></p><p>这个题还遇到很多玄学问题，就是说两个优化都加上就过不了，但是只留其中一个优化就可以。。。dfs结构还是比较简单的！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.flag = <span class="hljs-literal">False</span><br>        self.already_true = &#123;&#125;<br>        self.grid = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasValidPath</span>(<span class="hljs-params">self, grid:<span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[str]]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 只能往下，或者往右移动</span><br>        dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        self.grid = grid  <span class="hljs-comment"># n,m实际上也可以搞到self.里去</span><br><br>        <span class="hljs-keyword">if</span> (n+m) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-meta">        @lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, y:<span class="hljs-built_in">int</span>, left_kh_cnt:<span class="hljs-built_in">int</span>, n:<span class="hljs-built_in">int</span>, m:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> left_kh_cnt &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <br><br>            <span class="hljs-comment"># 剪枝条件是，路径上某个位置，在相同left_kh_cnt条件下，是否出现过了</span><br>            <span class="hljs-comment"># 这里原理上的解释是</span><br>            <span class="hljs-keyword">if</span> self.already_true.get((x,y,left_kh_cnt)) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self.already_true[(x,y,left_kh_cnt)] = <span class="hljs-literal">True</span><br>                <span class="hljs-comment"># print(&quot;self.already_true: &quot;, self.already_true)</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <br><br>            <span class="hljs-keyword">if</span> x == n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == m-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> left_kh_cnt == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 恰好匹配</span><br>                self.flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <br>            <br><br>            <span class="hljs-comment"># 1. 先写dfs逻辑，剩下逻辑随之适配</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; n <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; m: <br>                    <span class="hljs-keyword">if</span> self.grid[nx][ny] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                        dfs(nx, ny, left_kh_cnt+<span class="hljs-number">1</span>, n, m)<br>                    <span class="hljs-keyword">else</span>:<br>                        dfs(nx, ny, left_kh_cnt-<span class="hljs-number">1</span>, n, m)<br><br>        <span class="hljs-keyword">if</span> self.grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> self.grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;(&#x27;</span>:<br>            dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n, m)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.flag<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
      <tag>哈希表</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~</p><p>另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~</p><p><a href="https://c.runoob.com/front-end/854/">菜鸟工具在线正则表达式验证工具</a></p><span id="more"></span><p>菜鸟工具在线正则表达式验证工具:<a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><h1 id="正则总结"><a href="#正则总结" class="headerlink" title="正则总结"></a>正则总结</h1><h2 id="匹配数字相关"><a href="#匹配数字相关" class="headerlink" title="匹配数字相关"></a>匹配数字相关</h2><p><code>\d</code> 是匹配一个数字（0到9），在程序实现上一般需要再用 <code>\</code> 转义一下，即 <code>\\d</code></p><p>如果要匹配多个数字的话，就使用 <code>\\d+</code>，这里 <code>+</code> 代表一个或者多个</p><p>如果要匹配小数，中间带着小数点 <code>.</code> 的话，就是 <code>\\d+.\\d+</code>，注意这里还没有加入正负号的匹配</p><h2 id="加号-与乘号"><a href="#加号-与乘号" class="headerlink" title="加号 + 与乘号 *"></a>加号 <code>+</code> 与乘号 <code>*</code></h2><p><code>*</code> 表示匹配前面的字符0个或多个</p><p><code>+</code> 表示前面的字符1个或多个</p><h2 id="问号"><a href="#问号" class="headerlink" title="问号 ?"></a>问号 <code>?</code></h2><p>直接跟在表达式后面，表示匹配前面的一次或者零次，类似于{0, 1}的用法，<code>[+-]&#123;0,1&#125;\\d+.\\d+</code> 和  <code>[+-]?\\d+.\\d+</code> 应该是等价的意思，匹配前面有没有+-这些符号</p><h2 id="指数符-和-dollar符"><a href="#指数符-和-dollar符" class="headerlink" title="指数符^ 和 dollar符 $"></a>指数符<code>^</code> 和 dollar符 <code>$</code></h2><p><code>^</code> 用来匹配起始位置，<code>$</code> 用来匹配结束位置，配合使用一般用作检验，比如检验一段文本是否只包含数字 <code>^[0-9]*$</code></p><p>如果 <code>^</code> 使用在中括号中，则有一种not的感觉</p><h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号 ()"></a>小括号 <code>()</code></h2><p>小括号起到了一种组的概念，首先可以按照顺序使用 <code>\\1</code>，<code>\\2</code> 进行访问匹配，例如在html&#x2F;xml标签的匹配中，可以用 <code>&lt;(div)&gt;[^&lt;]*&lt;/\\1&gt;</code> 来进行匹配div标签，这样中间 <code>[^&lt;]*</code> 的意思就是匹配不是 <code>&lt;</code> 的任意字符，后边的 <code>&lt;/\\1&gt;</code> 能够自动对应到尾部标签去；注意这样的可能存在的嵌套关系匹配替换，可以每次循环迭代把内层的不断替换成一些特殊字符或者空，直到匹配不到为止；</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-06-15-11-31.png"></p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf">text: <span class="hljs-attribute">&lt;div&gt;</span><span class="hljs-attribute">&lt;font color=&#x27;red&#x27;&gt;</span>hello, world<span class="hljs-attribute">&lt;/font&gt;</span><span class="hljs-attribute">&lt;div&gt;</span>tmp2<span class="hljs-attribute">&lt;/div&gt;</span><span class="hljs-attribute">&lt;/div&gt;</span><br><br>re: <span class="hljs-attribute">&lt;(div)&gt;</span>[^<span class="hljs-attribute">&lt;]*&lt;/\1&gt;</span><br><br>result: <span class="hljs-attribute">&lt;div&gt;</span>tmp2<span class="hljs-attribute">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><h2 id="中括号-与竖线"><a href="#中括号-与竖线" class="headerlink" title="中括号 [] 与竖线 |"></a>中括号 <code>[]</code> 与竖线 <code>|</code></h2><p>中括号用来匹配单个字符，是否属于中括号中的一个字符 <code>[0-9]</code> <code>[A-Z]</code> 这样都也是可以的，注意如果待正则匹配的内容中已经具有中括号（其他括号也是同理），需要用 <code>\[</code> 把其他待匹配的做一个转义的感觉</p><p>竖线 <code>|</code> 就是一个或的意思，虽然不知道为什么要和中括号写在一个类别hhh，感觉使用场景上来说还是很灵活的</p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号 {}"></a>大括号 <code>&#123;&#125;</code></h2><p>匹配出现几次那种感觉，例如 <code>\\d&#123;1,3&#125;</code> 就是匹配出现一段文本中1次到3次的数字，这里还可以补充一下问号 <code>?</code> 的作用，有一种最小匹配的感觉</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-06-15-33-31.png"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-06-15-33-47.png"></p><p><font color="red">好了，1+1&#x3D;2学会（废）了！开始搞题！</font></p><h1 id="BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断"><a href="#BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断" class="headerlink" title="BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断"></a>BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断</h1><p><a href="http://bjutacm.openjudge.cn/lianxi/lq17I/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>于是由于各种各样的原因, 出现了一个叹号。</p><p>我们都已经看到了工具下载及比赛规则的地址是 <a href="http://172.21.17.211/">http://172.21.17.211/</a></p><p>下面你就来判断一下一个网址是否符合 <a href="http://a.b.c.d/">http://a.b.c.d/</a> 的格式吧。 (a, b, c, d 均为长度在 [1, 5] 且由数字 0-9 构成的字符串)</p><p>输入<br>一行字符串。 长度小于50。</p><p>输出<br>如果输入符合要求。 输出 “Yes”。<br>否则输出 “No” 。</p><p>(输出不含引号)</p><p>样例输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">172.21</span>.<span class="hljs-number">17.211</span>/<br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Yes</span><br></code></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题对自己影响是真的大，当年蓝桥预选赛靠着这个题在大一上从毫无基础的小白就到学校预选赛的前30名，用C语言一条规则一条规则的适配，AC的那一刻真是最难忘的会议之一~</p><p>现在再来做这个题的话，过了这么多年了，发现用非常简单的正则就能写出来，也就把题总结在这里了~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;http://[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;/&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    input_str = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>())<br>    tmp_str = re.sub(pattern, <span class="hljs-string">&#x27;&#x27;</span>, input_str)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp_str) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65.有效数字"></a>65.有效数字</h1><p><a href="https://leetcode.cn/problems/valid-number/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></p><p>部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题要分两部分考虑，首先考虑单独表示一个整数或者小数，然后再考虑科学计数法的内容，科学计数法就是 <code>e-5</code> 或者 <code>e10</code> 这样的</p><p>单独考虑整数： <code>[+-]&#123;0,1&#125;\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代）， <code>&#123;0,1&#125;</code>，<code>\\d+</code> 匹配整数；</p><p>考虑小数，情况1： <code>[+-]&#123;0,1&#125;\\d+\\.\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代），后面是 <code>x.x</code> 形式的小数；</p><p>考虑小数，情况2： <code>[+-]&#123;0,1&#125;\\d+\\.</code><br>解释：后面是 <code>x.</code> 形式的小数；</p><p>考虑小数，情况3： <code>[+-]&#123;0,1&#125;\\.\\d+</code><br>解释：后面是 <code>.x</code> 形式的小数；</p><p>然后考虑科学计数法，即 <strong>从e开始后面的位置</strong> ，情况有： </p><p><code>[eE][+-]?×</code> -&gt; 不能带小数点，因为不能是e2.5次方这样的，所以正则的写法为 <code>([eE][+-]?\\d+)?</code> ，这里只能匹配一次，所以要把整体的带上括号</p><p><font color="red">※</font>合并上述内容，前边的必须有，科学计数法不一定要有：</p><p><code>(([+-]?\\d+)|([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>这里还有个坑的内容，例如对于 <code>3.</code> 这种case，如果把整数的匹配写在前面，那么只会优先匹配到 <code>3</code> 了，所以要把小数写在前面，整数写在后面</p><p><code>(([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+)|([+-]?\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>补充还有个坑的地方，就是说 <code>1+3</code> 这种case，在后面的话小数部分应该写成 <code>([eE][+-]?\\d+)?</code> ，而不能写成多一个问号 <code>([eE]?[+-]?\\d+)?</code> 只有出现了e或者E，才能让+-出现0或1次</p><p>非转义的final写法： <code>(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?</code></p><p>代码如下所示，这里的注意点是</p><ol><li><code>re.compile(ur&#39;&#39;)</code> 就可以不用转义各个字符了，转义还是个考虑的重点问题；</li><li>替换成一个特殊字符 <code>#</code> ，最后可以用这个特殊字符做一些判断，避免单个 <code>e</code> 一类的问题；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isNumber</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">import</span> re<br>        <br>        pattern = re.<span class="hljs-built_in">compile</span>(u<span class="hljs-string">r&#x27;(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?&#x27;</span>)  <span class="hljs-comment"># 这里不用转义了</span><br>        tmp_s = re.sub(pattern, <span class="hljs-string">&quot;#&quot;</span>, s)<br>        <br>        <span class="hljs-keyword">if</span> tmp_s != <span class="hljs-string">&#x27;#&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="591-标签验证器"><a href="#591-标签验证器" class="headerlink" title="591.标签验证器"></a>591.标签验证器</h1><p><a href="https://leetcode.cn/problems/tag-validator/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p><ol><li>代码必须被 <strong>合法的闭合标签包围</strong> 。否则，代码是无效的。</li><li><strong>闭合标签</strong> （不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code> 。其中，<code>&lt;TAG_NAME&gt;</code> 是起始标签，<code>&lt;/TAG_NAME&gt;</code> 是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是 <strong>合法的</strong> 。</li><li><strong>合法的</strong> <code>TAG_NAME</code> <strong>仅含有大写字母</strong>，长度在范围 [1,9] 之间。否则，该 <code>TAG_NAME</code> 是不合法的。</li><li><strong>合法的</strong> <code>TAG_CONTENT</code> 可以包含其他 <strong>合法的闭合标签</strong> ，<strong>cdata</strong> （请参考规则7）和任意字符（注意参考规则1）除了不匹配的 <code>&lt;</code> 、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code> <strong>是不合法的</strong> 。</li><li>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li><li>一个 <code>&lt;</code> ，如果你找不到一个后续的 <code>&gt;</code> 与之匹配，是不合法的。并且当你找到一个 <code>&lt;</code> 或 <code>&lt;/</code> 时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。</li><li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。CDATA_CONTENT 的范围被定义成 <code>&lt;![CDATA[</code> <strong>和后续的第一个</strong> <code>]]&gt;</code> 之间的字符。</li><li><code>CDATA_CONTENT</code> 可以包含 <strong>任意字符</strong> 。cdata 的功能是阻止验证器解析 <code>CDATA_CONTENT</code> ，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为 <strong>常规字符</strong> 。</li></ol><p>合法代码的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml">输入: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>输出: True<br><br>解释: <br><br>代码被包含在了闭合的标签内： <span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span> 和 <span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span> 。<br><br>TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 <br><br>即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。<br><br>所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。<br><br><br>输入: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>输出: True<br><br>解释:<br><br>我们首先将代码分割为： start_tag|tag_content|end_tag 。<br><br>start_tag -&gt; &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>end_tag -&gt; &quot;<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>tag_content 也可被分割为： text1|cdata|text2 。<br><br>text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;<br><br>cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>]&gt;&quot;<br><br>text2 -&gt; &quot;]]&gt;&gt;]&quot;<br><br><br>start_tag 不是 &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&gt;&gt;&quot; 的原因参照规则 6 。<br>cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。<br></code></pre></td></tr></table></figure><p>不合法代码的例子：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bnf">输入: &quot;<span class="hljs-attribute">&lt;A&gt;</span>  <span class="hljs-attribute">&lt;B&gt;</span> <span class="hljs-attribute">&lt;/A&gt;</span>   <span class="hljs-attribute">&lt;/B&gt;</span>&quot;<br>输出: False<br>解释: 不合法。如果 &quot;<span class="hljs-attribute">&lt;A&gt;</span>&quot; 是闭合的，那么 &quot;<span class="hljs-attribute">&lt;B&gt;</span>&quot; 一定是不匹配的，反之亦然。<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  div tag is not closed  <span class="hljs-attribute">&lt;DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  unmatched <span class="hljs-attribute">&lt;  &lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span> closed tags with invalid tag name  <span class="hljs-attribute">&lt;b&gt;</span>123<span class="hljs-attribute">&lt;/b&gt;</span> <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span> unmatched tags with invalid tag name  <span class="hljs-attribute">&lt;/1234567890&gt;</span> and <span class="hljs-attribute">&lt;CDATA[[]]&gt;</span>  <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  unmatched start tag <span class="hljs-attribute">&lt;B&gt;</span>  and unmatched end tag <span class="hljs-attribute">&lt;/C&gt;</span>  <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>为简明起见，你可以假设输入的代码（包括提到的 <strong>任意字符</strong> ）只包含 <code>数字</code>, <code>字母</code>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题还是挺难的，也是一种正则表达式的练习吧，总之对正则表达式又熟了一分，想法和题解就写在代码的注释里了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, code</span>):<br><br>        <span class="hljs-comment"># 使用正则表达式偷鸡了，正好作为一个正则表达式题目的练习了</span><br>        <span class="hljs-keyword">import</span> re<br><br>        <span class="hljs-comment"># 去掉CDATA字段变化为空，注意由于&#x27;[&#x27;括号字符在正则表达式中具有特殊的含义，所以要&#x27;\&#x27;字符完成转义</span><br>        <span class="hljs-comment"># 【badcase4】CDATA必须被标签包含</span><br>        <span class="hljs-comment"># 【badcase5】.*?和.*的区别？</span><br>        code_remove_cdata = re.sub(<span class="hljs-string">r&quot;&lt;!\[CDATA\[.*?\]\]&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code)<br>        <br>        <span class="hljs-comment"># 【badcase2】如果全是CDATA匹配到的就返回False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(code_remove_cdata) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span><br>        <span class="hljs-comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span><br>        prev = code_remove_cdata<br>        code_remove_cdata_tag = re.sub(<span class="hljs-string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code_remove_cdata)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata: &quot;</span>, code_remove_cdata)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)<br><br>        <span class="hljs-comment"># 一直正则替换</span><br>        <span class="hljs-keyword">while</span> prev != code_remove_cdata_tag:  <br>            prev = code_remove_cdata_tag<br>            <span class="hljs-comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span><br>            <span class="hljs-comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span><br>            code_remove_cdata_tag = re.sub(<span class="hljs-string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code_remove_cdata_tag)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)<br>        <br>        <span class="hljs-keyword">if</span> code_remove_cdata_tag == <span class="hljs-string">&quot;#&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-comment"># if __name__ == &#x27;__main__&#x27;:</span><br><br><span class="hljs-comment">#     s = Solution()</span><br><span class="hljs-comment">#     code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span><br><br><span class="hljs-comment">#     # badcase1</span><br><span class="hljs-comment">#     # &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;  -&gt;  [^&lt;]*的问题，要求中甲不能匹配&lt;</span><br><br><span class="hljs-comment">#     # badcase2</span><br><span class="hljs-comment">#     # &quot;&lt;![CDATA[wahaha]]]&gt;&lt;![CDATA[]&gt; wahaha]]&gt;&quot; -&gt; 如果经过第一步处理后就空了，那就要返回False</span><br><br><span class="hljs-comment">#     # badcase3</span><br><span class="hljs-comment">#     # &quot;&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt;&quot; 要输出False</span><br><br><span class="hljs-comment">#     # badcase4</span><br><span class="hljs-comment">#     # &quot;&lt;![CDATA[ABC]]&gt;&lt;TAG&gt;sometext&lt;/TAG&gt;&quot;  CDATA必须被标签包含</span><br><br><span class="hljs-comment">#     # badcase5，.*和.*?还是有区别的，</span><br><span class="hljs-comment">#     # &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span><br><span class="hljs-comment">#     # 如果是.*匹配（贪婪匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span><br><span class="hljs-comment">#     # 如果是.*?匹配（最小匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;DIV&gt; &lt;A&gt;  #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span><br><br><br><span class="hljs-comment">#     print(&quot;output res: &quot;, s.isValid(code))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>273-283场LeetCode周赛总结</title>
    <link href="/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>273-283场LeetCode周赛综述&amp;总结：</p><p>LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢；</p><p>温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~</p><p>另外这里相对整理一下需要数据结构&#x2F;特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容；</p><p>总结来看主要有这些操作：</p><p>【前后缀和】【数学&amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;构造】【链表】【二分】【字符串】【水题】</p><span id="more"></span><h1 id="前后缀和"><a href="#前后缀和" class="headerlink" title="前后缀和"></a>前后缀和</h1><blockquote><p>前后缀和大概是因为每次都要统计相同的位置，那么就是每次在基础上做累加的操作来避免每次对于相同位置的统计；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><h1 id="数学-amp-找规律"><a href="#数学-amp-找规律" class="headerlink" title="数学&amp;找规律"></a>数学&amp;找规律</h1><blockquote><p>数学和找规律的题一般都要现场推，自己动手模拟下看看，也没什么太多复盘的思路，每次遇到的感觉都不会太一样；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><strong>283场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">2195.向数组中追加 K 个整数</a>，暴力哈希的思路还是比较好像，但实际上不能这样，还要往后补的思路，总结数学题来说就是每次现场推就行了，复盘的时候不用想的太明白；</p><h1 id="哈希表mapping"><a href="#哈希表mapping" class="headerlink" title="哈希表mapping"></a>哈希表mapping</h1><blockquote><p>哈希表是个简化时间复杂度的好东西，万物皆可哈希hhhh；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>275场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/">2135.统计追加字母可以获得的单词数</a>，这个题主要就是哈希表的思想，一方面来说 <strong>重排</strong> 这个事情可以在最开始的时候把大家都重排了这样一种预处理得到，另一方面来说set起到判重的作用，差一个字符上就是截断的拼接问题 <code>word[:i] + word[i+1:]</code> 这样可以把第i位的字符忽略掉，还是很难的这个题，这么看来说275场周赛的三个题都好难啊；</p><p><strong>277场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">2150.找出数组中的所有孤独数字</a>，这个题哈希表也太明显了，甚至有些情况够不上平常周赛第一题，第二题的难度，包装的也比较简单，其实可以算在水题里了；</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><blockquote><p>贪心的事情，不用想的那么明白哈哈哈哈；</p></blockquote><p><strong>274场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/destroying-asteroids/">2126.摧毁小行星</a>，这个题算是很简单的第三题啊，274场周赛没有实时做，不然来说的话应该是一个靠前三题能rank前1000内的比赛，就是直接暴力贪心就可以了，中间带一个简单的排序，名言之贪心的事情不用搞那么明白！；</p><p><strong>276场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">2139.得到目标值的最少行动次数</a>，从大往小贪心就可以了，如果是偶数就除，如果是奇数就减就行了；</p><p><strong>279场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">2165.重排数字的最小值</a>，这个题分正数负数贪心就可以了，前导0还是个约束条件；</p><p><strong>280场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">2170.使数组变成交替数组的最少操作数</a>，第二题还是不能想太复杂了，奇数偶数位，选出分别两边出现最多的，但是 <strong>不能相等的</strong>，当时把自己坑惨了啊，还是要仔细读题，读歪了那可真是掉沟里了；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><p><font color="red">※</font><strong>281场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/construct-string-with-repeat-limit/">2182.构造限制重复的字符串</a>，这个题真的难，不是特殊情况下一定不要往原地交换的思路想，要想往新构造的思路想，剩下就是贪心和随缘的面向答案编程了；</p><h1 id="Counter计数"><a href="#Counter计数" class="headerlink" title="Counter计数"></a>Counter计数</h1><blockquote><p>Counter是个很常用的数据结构，任何涉及到统计的的题目都可能会用到这个，不知道在其他语言Counter的对应是什么；</p></blockquote><p><font color="red">※</font><strong>275场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/">2133.检查是否每一行每一列都包含全部整数</a>，是个比较难的第一题，甚至感觉很多情况下难度超过了第二题，一方面是对一行&#x2F;一列取Counter计数的时候，应该是 <code>第i行：Counter(matrix[i])</code> 和 <code>第i列：Counter([matrix[x][i] for x in range(n)])</code>，另一方面来说Counter是可以加减，还有相比较的，这个是个很方便的特性不知道在其他语言里怎么使用这个内容，这个题的特色点在于只要遍历一次主对角线做Counter，就可以涵盖所有情况了；</p><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p>282场周赛第2题 <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/">2186.使两字符串互为字母异位词的最少步骤数</a>，经典Counter加减，莽过去！；</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>主要看题目是否本身暗含了一种窗口的思想在里面；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><blockquote><p>主要是简化实现上的操作，比如把环变成数组，还有就是针对起始位置还有终点位置的特殊处理；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p><strong>276场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">2138.将字符串拆分为若干长度为 k 的组</a>，也是水题但是可以通过哨兵补齐的思想，这样最后切分起来就很容易了，看了下当时的代码，不知道为什么当时能写那么复杂。。。；</p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><blockquote><p>一般按照题目来，跟着题目操作就可以；</p></blockquote><p><strong>273场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120.执行所有后缀指令</a>，使用 <code>[1:]</code> 不断截断，然后按照操作要求来模拟就行，这种题感觉也是不能着急，争取能在5分钟内完成第二题和第一题，要爆一下手速，第二题一般不会太难，不要太考虑时间复杂度的事情，想到方法基本就差不多了；</p><p><strong>274场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">2125.银行中的激光束数量</a>，感觉是题目理解相对比较长的第二题，第二题可能存在题面复杂类的问题，但是通过这个题来看不能着急读题，读完题最好一遍能理解题意，尽快做出来；</p><p><strong>280场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-operations-to-obtain-zero/">2169. 得到 0 的操作数</a>，两边来回减，按照题目的要求模拟就可以了；</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>还是要多刷，包括普通dp，区间dp等等，跟一波wls了；</p></blockquote><p><font color="red">※</font><strong>276场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">2140.解决智力问题</a>，这个题dp还是相对能看出来的？每个位置是选和不选两种状态，但是这个题只能让自己觉得自己智力有问题，dp第三题还是难，看来276和275场周赛是把自己给虐了，这个题要存 <strong>截止到当前位置的状态值！</strong></p><h1 id="状态压缩（2-n那种类型的题目）"><a href="#状态压缩（2-n那种类型的题目）" class="headerlink" title="状态压缩（2^n那种类型的题目）"></a>状态压缩（2^n那种类型的题目）</h1><blockquote><p>看数据范围有可能可以看出来是不是这类型的题目，特点就是每个状态下验证合理性的感觉吧；</p></blockquote><p><font color="red">※</font><strong>277场周赛第4题</strong> <a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">2151.基于陈述统计最多好人数</a>，还是比较难的，首先看数据范围如果是8，15这样比较小的数，那可能就要想能不能往2^n这种方向上做一做，这个题的关键思路还是当时室友给的，就是说：只需要判断假定所有说真话的人是否和条件有冲突就可以了，这种2^n很多情况都是判断每种情况是否合理的;</p><h1 id="设计-amp-构造"><a href="#设计-amp-构造" class="headerlink" title="设计&amp;构造"></a>设计&amp;构造</h1><blockquote><p>设计构造题目比较思路型，可能也是面试常考的题目，包括LRU也是设计类题目；</p></blockquote><p><strong>279场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/design-bitset/">2166.设计位集</a>，依照时间复杂度把一些能简化时间复杂度的操作转化为全局的，在 <code>__init__</code> 的时候设计全局变量，然后后边依照这个全局变量简化时间复杂度即可，设计的时候来说边设计应该就是能想到的；</p><p><font color="red">※</font><strong>283场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">2196.根据描述创建二叉树</a>，这种设计的题，要把每个节点做成一个哈希，然后用哈希再往里插入就可以了，构造的题目好像要用这种哈希是比较普遍的思路；</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表题还没在周赛见过太多，这个题是比较水的链表题；</p></blockquote><p><strong>281场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/">2181.合并零之间的节点</a>，链表模拟操作，操作过去就行了；</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><blockquote><p>二分边界情况判断，最后是left还是right是真的难，二分也可以做在每个情况下，O(n)的合理性验证吧；</p></blockquote><p><font color="red">※</font><strong>282场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">2187.完成旅途的最少时间</a>，自己想的时候没有看出来哪里可以二分，在大佬的提醒下二分验证每个时刻，O(n)判断judge是否合理，实际上有点像2^n那种题的验证思路了；</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote><p>字符串题目还是很多的，一方面要会a-z A-Z这种ord chr的转化，另外一方面也要自己多练习一些正则的题目；</p></blockquote><p><font color="red">※</font><strong>283场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">2194.Excel 表中某个范围内的单元格</a>，本来是个简单的二维遍历问题，但是居然不知道python怎么遍历字符。。。查了下是 <code>ord()</code> 把字符转数字, <code>chr()</code> 把数字转字符，这个还是要记住的，特别是一些a-z，A-Z的遍历题目；</p><h1 id="水题"><a href="#水题" class="headerlink" title="水题"></a>水题</h1><p><strong>273场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">2119.反转两次的数字</a>，稍微操作一下就可以完成这个模拟操作了，第一题千万注意的就是不要急躁，耐下心来一遍把题读完，然后2分钟之内刷出来；</p><p><strong>274场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">2124.检查是否所有 A 都在 B 之前</a>，标准水题，这种题感觉要半分钟读题，一分半内手速搞定暴力出来；</p><p><strong>277场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">2148.元素计数</a>，能看出来是和最大最小比就很容易了，读题还是要细心呀；</p><p><strong>277场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">2149.按符号重排数组</a>，甚至比很多第一题还简单，是相对比较简单的第二题了，直接拆成两个，不做原地操作就还是很简单的；</p><p><strong>279场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">2164.对奇偶下标分别排序</a>，这个题虽然是水题，但是可以学习python奇数偶数 <strong>下标位置</strong> 取值方法，<code>nums[::2]</code>取偶数，<code>nums[1:;2]</code>取奇数；</p><p><strong>281场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/">2180.统计各位数字之和为偶数的整数个数</a>，水题，写个judge函数搞过去就可以了；</p><p><strong>282场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/">2185.统计包含给定前缀的字符串</a>，python有 <code>str.startswith()</code> 函数，用这个就可以了；</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>291场LeetCode周赛</title>
    <link href="/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题；</p><p>感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙</p><p>第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><p>第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了；</p><p>第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了；</p><span id="more"></span><p>希望下次前1000名来得快一点，这次确实是题简单了</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-02-09-13-42.png"></p><h1 id="第一题：6047-移除指定数字得到的最大结果"><a href="#第一题：6047-移除指定数字得到的最大结果" class="headerlink" title="第一题：6047.移除指定数字得到的最大结果"></a>第一题：6047.移除指定数字得到的最大结果</h1><p><a href="https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个表示某个正整数的字符串 <code>number</code> 和一个字符 <code>digit</code> 。</p><p>从 <code>number</code> 中 <strong>恰好</strong> 移除 <strong>一个</strong> 等于 <code>digit</code> 的字符后，找出并返回按 <strong>十进制</strong> 表示 <strong>最大</strong> 的结果字符串。生成的测试用例满足 <code>digit</code> 在 <code>number</code> 中出现至少一次。</p><p>示例1：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;123&quot;</span>, digit = <span class="hljs-string">&quot;3&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br>解释：<span class="hljs-string">&quot;123&quot;</span> 中只有一个 <span class="hljs-string">&#x27;3&#x27;</span> ，在移除 <span class="hljs-string">&#x27;3&#x27;</span> 之后，结果为 <span class="hljs-string">&quot;12&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;1231&quot;</span>, digit = <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-string">&quot;231&quot;</span><br>解释：可以移除第一个 <span class="hljs-string">&#x27;1&#x27;</span> 得到 <span class="hljs-string">&quot;231&quot;</span> 或者移除第二个 <span class="hljs-string">&#x27;1&#x27;</span> 得到 <span class="hljs-string">&quot;123&quot;</span> 。<br>由于 <span class="hljs-number">231</span> &gt; <span class="hljs-number">123</span> ，返回 <span class="hljs-string">&quot;231&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;551&quot;</span>, digit = <span class="hljs-string">&quot;5&quot;</span><br>输出：<span class="hljs-string">&quot;51&quot;</span><br>解释：可以从 <span class="hljs-string">&quot;551&quot;</span> 中移除第一个或者第二个 <span class="hljs-string">&#x27;5&#x27;</span> 。<br>两种方案的结果都是 <span class="hljs-string">&quot;51&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= number.length &lt;= 100</code></li><li><code>number</code> 由数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 组成</li><li><code>digit</code> 是 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 中的一个数字</li><li><code>digit</code> 在 <code>number</code> 中出现至少一次</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDigit</span>(<span class="hljs-params">self, number, digit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type number: str</span><br><span class="hljs-string">        :type digit: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(number)):<br>            <span class="hljs-keyword">if</span> number[i] == digit:<br>                tmp_list = <span class="hljs-string">&#x27;&#x27;</span>.join(number[:i] + number[i+<span class="hljs-number">1</span>:])<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">int</span>(tmp_list))<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：6048-必须拿起的最小连续卡牌数"><a href="#第二题：6048-必须拿起的最小连续卡牌数" class="headerlink" title="第二题：6048.必须拿起的最小连续卡牌数"></a>第二题：6048.必须拿起的最小连续卡牌数</h1><p><a href="https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p><p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cards = [<span class="hljs-number">3,4,2,3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">4</span><br>解释：拿起卡牌 [<span class="hljs-number">3,4,2,3</span>] 将会包含一对值为 <span class="hljs-number">3</span> 的匹配卡牌。注意，拿起 [<span class="hljs-number">4,2,3,4</span>] 也是最优方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cards = [<span class="hljs-number">1,0,5,3</span>]<br>输出：-<span class="hljs-number">1</span><br>解释：无法找出含一对匹配卡牌的一组连续卡牌。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= cards.length &lt;= 10^5</code></li><li><code>0 &lt;= cards[i] &lt;= 10^6</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了，还是比较好想到这个思路的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCardPickup</span>(<span class="hljs-params">self, cards</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cards: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>        tmp_dict = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cards)):<br>            tmp_dict[cards[i]].append(i)<br>        <br>        <span class="hljs-comment"># print(tmp_dict)</span><br>        res = <span class="hljs-number">1e9</span><br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> tmp_dict.values():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(value) &lt; <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(value)-<span class="hljs-number">1</span>):<br>                res = <span class="hljs-built_in">min</span>(res, value[j+<span class="hljs-number">1</span>]-value[j])<br>        <br>        <span class="hljs-keyword">if</span> res != <span class="hljs-number">1e9</span>:<br>            <span class="hljs-keyword">return</span> res+ <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="第三题：6049-含最多-K-个可整除元素的子数组"><a href="#第三题：6049-含最多-K-个可整除元素的子数组" class="headerlink" title="第三题：6049.含最多 K 个可整除元素的子数组"></a>第三题：6049.含最多 K 个可整除元素的子数组</h1><p><a href="https://leetcode.cn/problems/k-divisible-elements-subarrays/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>p</code> ，找出并返回满足要求的不同的子数组数，要求子数组中最多 <code>k</code> 个可被 <code>p</code> 整除的元素。</p><p>如果满足下述条件之一，则认为数组 <code>nums1</code> 和 <code>nums2</code> 是 <strong>不同</strong> 数组：</p><ul><li>两数组长度 <strong>不同</strong> ，或者</li><li>存在 <strong>至少</strong> 一个下标 <code>i</code> 满足 <code>nums1[i] != nums2[i]</code> 。</li></ul><p><strong>子数组</strong> 定义为：数组中的连续元素组成的一个 <strong>非空</strong> 序列。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,3,3,2,2]</span>, k = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">11</span><br>解释：<br>位于下标 <span class="hljs-number">0</span>、<span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 的元素都可以被 <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span> 整除。<br>共计 <span class="hljs-number">11</span> 个不同子数组都满足最多含 k = <span class="hljs-number">2</span> 个可以被 <span class="hljs-number">2</span> 整除的元素：<br><span class="hljs-selector-attr">[2]</span>、<span class="hljs-selector-attr">[2,3]</span>、<span class="hljs-selector-attr">[2,3,3]</span>、<span class="hljs-selector-attr">[2,3,3,2]</span>、<span class="hljs-selector-attr">[3]</span>、<span class="hljs-selector-attr">[3,3]</span>、<span class="hljs-selector-attr">[3,3,2]</span>、<span class="hljs-selector-attr">[3,3,2,2]</span>、<span class="hljs-selector-attr">[3,2]</span>、<span class="hljs-selector-attr">[3,2,2]</span> 和 <span class="hljs-selector-attr">[2,2]</span> 。<br>注意，尽管子数组 <span class="hljs-selector-attr">[2]</span> 和 <span class="hljs-selector-attr">[3]</span> 在 nums 中出现不止一次，但统计时只计数一次。<br>子数组 <span class="hljs-selector-attr">[2,3,3,2,2]</span> 不满足条件，因为其中有 <span class="hljs-number">3</span> 个元素可以被 <span class="hljs-number">2</span> 整除。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,4], k = 4, p = 1<br>输出：10<br>解释：<br>nums 中的所有元素都可以被 p =<span class="hljs-number"> 1 </span>整除。<br>此外，nums 中的每个子数组都满足最多<span class="hljs-number"> 4 </span>个元素可以被<span class="hljs-number"> 1 </span>整除。<br>因为所有子数组互不相同，因此满足所有限制条件的子数组总数为<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li><li>1 &lt;&#x3D; nums[i], p &lt;&#x3D; 200</li><li>1 &lt;&#x3D; k &lt;&#x3D; nums.length</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>另外还想说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j&#x3D;i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countDistinct</span>(<span class="hljs-params">self, nums, k, p</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type p: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># preprocess</span><br>        cnt_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] % p == <span class="hljs-number">0</span>:<br>                cnt_list.append(<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                cnt_list.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># print(&quot;cnt_list: &quot;, cnt_list)</span><br>            <br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># from collections import defaultdict</span><br>        hash_set = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(nums)):<br>                tmp_list = nums[i:j+<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> hash_set.get(<span class="hljs-built_in">tuple</span>(tmp_list)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">continue</span><br>                hash_set[<span class="hljs-built_in">tuple</span>(tmp_list)] = <span class="hljs-number">1</span><br>                tmp = <span class="hljs-built_in">sum</span>(cnt_list[i:j+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">if</span> tmp &lt;= k:<br>                    res += <span class="hljs-number">1</span><br>                <br>                <br>                <br>                <span class="hljs-comment"># print(tmp_list)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第四题：6050-字符串的总引力"><a href="#第四题：6050-字符串的总引力" class="headerlink" title="第四题：6050.字符串的总引力"></a>第四题：6050.字符串的总引力</h1><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p><ul><li>例如，<code>&quot;abbca&quot;</code> 的引力为 <code>3</code> ，因为其中有 3 个不同字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 。</li></ul><p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> 。</p><p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，自己举的例子是下边这个图这样，这样能按照每个字符，来统计每个字符的贡献度：</p><p>非重复情况：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-02-10-28-47.png"></p><p>重复情况：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-05-02-10-29-13.png"></p><p>另外还想再次说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j&#x3D;i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><p>正确解答方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appealSum</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 一种每个字符贡献度的思想，还是很有特点的</span><br>        res = <span class="hljs-number">0</span><br>        char_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> char_dict.get(s[i]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                res += (i + <span class="hljs-number">1</span>) * (<span class="hljs-built_in">len</span>(s)-i)<br>            <span class="hljs-keyword">else</span>:<br>                res += (i - char_dict[s[i]]) * (<span class="hljs-built_in">len</span>(s) - i)<br>            char_dict[s[i]] = i<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这里也额外把自己当时写的暴力方法附上，一位缩减了时间复杂度，实际上像个小丑哈哈哈哈哈哈哈哈，dp了但没完全dp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appealSum</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        d1 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            d1[i] = &#123;s[i]: <span class="hljs-number">1</span>&#125;<br>            res += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init: &quot;</span>, d1)<br>        <br>        <br>        res_d = &#123;&#125;<br>        <br>        <span class="hljs-comment"># 这里感觉是一个base基础上的dp，每次要取几位，有点不像平常的遍历思路1</span><br>        <span class="hljs-comment"># 现在要开始每次取两位</span><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-l+<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># base</span><br>                base = s[i:i+l-<span class="hljs-number">1</span>]<br>                <span class="hljs-comment"># print(&quot;base: &quot;, base)</span><br>                <br>                <span class="hljs-comment"># now（要不要给他加一个标识？）</span><br>                tmp_s = s[i:i+l]<br>                <span class="hljs-comment"># print(&quot;tmp_s: &quot;, tmp_s)</span><br>                <br>                <span class="hljs-comment"># 增量</span><br>                upper = tmp_s[<span class="hljs-built_in">len</span>(base):]<br>                <span class="hljs-comment"># print(&quot;upper: &quot;, upper)</span><br>                <br>                <span class="hljs-comment"># 查看upper在不在</span><br>                <span class="hljs-keyword">if</span> d1[i].get(upper) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 不在，这样是一种累加的</span><br>                    d1[i][tmp_s] = d1[i][base] + <span class="hljs-number">1</span><br>                    d1[i][upper] = <span class="hljs-number">1</span><br>                    res += d1[i][tmp_s]<br>                <span class="hljs-keyword">else</span>:<br>                    d1[i][tmp_s] = d1[i][base]<br>                    res += d1[i][tmp_s]<br>                    <br>                    <span class="hljs-comment"># continue</span><br>                    <span class="hljs-comment"># res += d1[i][upper]</span><br>                    <span class="hljs-comment"># d1[i][upper] = d1[i][upper] + 1</span><br>                    <span class="hljs-comment"># continue</span><br>                <br>        <span class="hljs-comment"># print(d1)</span><br>        <br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
      <tag>字典树</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>枚举</tag>
      
      <tag>哈希函数</tag>
      
      <tag>滚动哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>687.最长同值路径-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>687.最长同值路径（中等）</p><p>题目大意：</p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">题目链接</a></p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-30-10-51-58.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[5,4,5,1,1,5]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-30-10-52-12.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[1,4,5,4,4,5]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>比较经典能看出来是 <code>树中子结构dfs/dp的题目</code>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>对于这个题目来说，子结构下的返回值可能会有none的情况，另外也需要全局比较，总结来说和124题目比较像，如果再做到这题的话不知道能不能做出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    典型树中子结构搜索的题目</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_res = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestUnivaluePath</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 1. 先写dfs递归函数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            <span class="hljs-comment"># 3. 子结构搜索任务要用后序遍历，这里写递归两次</span><br>            left = dfs(root.left)<br>            right = dfs(root.right)<br><br>            <span class="hljs-comment"># 4. 写全局的那个逻辑，全局结构要把左右都考虑上</span><br>            tmp_res = <span class="hljs-number">0</span>  <span class="hljs-comment"># 路径长度，所以这里是0开始</span><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val:<br>                tmp_res += left<br>            <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val:<br>                tmp_res += right<br>            self.max_res = <span class="hljs-built_in">max</span>(self.max_res, tmp_res)<br><br>            <span class="hljs-comment"># 2. 对于树中的子结构搜索任务，写返回值，看看不同种情况下子结构该怎么返回</span><br>            <span class="hljs-keyword">if</span> (root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val) <span class="hljs-keyword">and</span> (root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val):<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val:<br>                <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val:<br>                <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 为什么是return1，只能暂时理解为每个的base都是1了</span><br>        <br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543.二叉树的直径-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>543.二叉树的直径（简单）</p><p>题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目链接</a></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例：<br>给定二叉树</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>     <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <br><br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>，它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>题目中给出了一个提示，就是说 <strong>这条路径可能穿过也可能不穿过根节点</strong>，那么换句话说，每个节点都有可能是 <strong>路径的根节点</strong>，这样应该可以判断出是经典的 <strong>树形子结构dfs&#x2F;dp题目</strong>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>这个题目来说，坑点在于不是节点数目，而是边数目的表示，最后需要加减个1一般通过调试就可以完成了，然后路径上的话一般子结构返回值就是 <code>1+xxx</code> 这样的；另外想说的是这个题居然是简单题，和124本质上没有什么区别啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_len = -<span class="hljs-number">1e9</span>  <span class="hljs-comment"># 这里要新定义一个？</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameterOfBinaryTree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            max_left_len = dfs(root.left)<br>            max_right_len = dfs(root.right)<br><br>            self.max_len = <span class="hljs-built_in">max</span>(self.max_len, <span class="hljs-number">1</span> + max_left_len + max_right_len)<br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(max_left_len, max_right_len)  <span class="hljs-comment"># 子结构的加上根</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_len - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>124.二叉树中的最大路径和-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>124.二叉树中的最大路径和（困难）</p><p>题目大意：<strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">题目链接</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-30-10-00-18.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-30-10-00-43.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>树中节点数目范围是 [1, 3 * 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>经典的树形子结构dp题目，这个题带了一个最大路径和，这块是要有一个全局的变量，每个子结构的值要和这个全局的值来比取最大值；</p><p>树里的子结构，一般思路就是<strong>后序遍历</strong>的思想，把每个节点当做根节点，然后求出这个点左右和这个点的值加起来，和全局的来比；而其中比较关键的是在此之前，每个地方的递归出口，也就是后序遍历的出口要把子结构的值给返回回去，而这种路径的话，子结构实际上只能往左边或者右边，也就是<code>root.val + max(left_val, right_val)</code>，其中两边的val需要通过递归来完成返回</p><p>总结来说，一般的套路是如下几个步骤：</p><ol><li>写 <code>from function tools import lru_cache</code> ，在dfs函数前加上 <code>@lru_cache(1000*1000)</code> 的修饰，这样可以一定程度上减小时间占用（在笔试题目中可能会有奇效hh）；</li><li>写入口，入口一般有两种情况，像是笔试题目的话可能是 <code>def dfs(left, right)</code> 这样的，像是leetcode题目的话，可能就是 <code>def dfs(root)</code>；</li><li>写出口返回值，一般来说就是子结构的值，如果是像这个题一样树中路径的话，就是当前节点加上左边或者右边的；</li><li>写后续遍历的递归部分，将两边的子结构传入dfs函数中，来进一步往深度优先寻找；</li><li>写全局比较，这个步骤不一定存在，但是如果把每个节点像这个题一样当做“中转节点”的话，那就要和全局的值比较一下；</li><li>写递归出口条件，一般来说就是 <code>root is None</code> 或者 <code>left &gt;= right</code>这类的条件；</li></ol><p>这个模式感觉还挺套路的，几乎子结构或者带着树中路径的题目都可以这么做，也算是积累到一种做法吧，相似题目包括：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a><br><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://www.nowcoder.com/test/28665343/summary">001场笔试练习 第四题.最优二叉树</a></p><p>通过上边的总结来说，这个题目基本已经可以做出来了，需要注意的是这个题目中可能有负数存在，路径上带上负数还不如不带这条路径，子结构返回的时候需要注意一下</p><p>补充：</p><p>543.二叉树直径 easy: <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><p>124.二叉树中的最大路径和 hard: <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><p>这两个题感觉是很像的，但是不太像树形dp，就像是在树里的dfs一样，感觉最主要的思路就是子结构</p><ul><li><p>在写dfs函数的时候，先写返回值，返回值是左右两个子结构中最大的一个加上当前节点的值；；这里说是子结构是因为他的父节点如果选了左边的就不能选右边的（题目特性决定）；；代表这个根作为子结构的条件下最大值</p></li><li><p>然后写结束条件，一般就是root is None的时候</p></li><li><p>然后写递归的两边，基本就是把root.left和root.right传进去</p></li><li><p>然后写全局的，全局的就是 当前+左子结构+右子结构，然后和现有比取最大的；；；代表按这个根作为真实根的情况下条件的最大值</p></li></ul><p>最后return回全局的这个最大的</p><p>树里子结构的dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_res = -<span class="hljs-number">1e9</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            left_max_val = dfs(root.left) <span class="hljs-comment"># 往左子树走，以左子树为根的最大子结构</span><br>            right_max_val = dfs(root.right)  <span class="hljs-comment"># 往右子树走，右子树的最大子结构</span><br><br>            tmp_value = root.val + left_max_val + right_max_val  <span class="hljs-comment"># 以root为根的最大子结构</span><br>            self.max_res = <span class="hljs-built_in">max</span>(self.max_res, tmp_value)<br>            <br>            <span class="hljs-comment"># 这个return是单一子结构的return，子结构下不能同时往左又往右走，只能选择一边，子结构的！！！</span><br>            <span class="hljs-keyword">if</span> root.val + <span class="hljs-built_in">max</span>([<span class="hljs-number">0</span>, left_max_val, right_max_val]) &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> root.val + <span class="hljs-built_in">max</span>([<span class="hljs-number">0</span>, left_max_val, right_max_val]) <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001场笔试练习</title>
    <link href="/2022/04/26/algorithms/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/04/26/algorithms/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz；</p><p>笔试题目选择：<a href="https://www.nowcoder.com/test/28665343/summary">美团2021校招笔试-编程题(通用编程试题,第10场)</a></p><p>笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题&#x2F;面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6&#x2F;10，还加上了一个@lru_cache(1000*1000)；</p><span id="more"></span><h1 id="第一题：淘汰分数"><a href="#第一题：淘汰分数" class="headerlink" title="第一题：淘汰分数"></a>第一题：淘汰分数</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。</p><p>但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。</p><p>显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。</p><p>数据范围：1 ≤ n ≤ 50000，1 ≤ x ≤ y ≤ n<br>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第一行仅包含三个正整数<span class="hljs-built_in">n</span>,x,y，分别表示参赛的人数和晋级淘汰人数区间。(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">50000</span>,<span class="hljs-number">1</span>&lt;=x,y&lt;=<span class="hljs-built_in">n</span>)<br>输入第二行包含<span class="hljs-built_in">n</span>个整数，中间用空格隔开，表示从<span class="hljs-number">1</span>号选手到<span class="hljs-built_in">n</span>号选手的成绩。(<span class="hljs-number">1</span>&lt;=|a_i|&lt;=<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输出仅包含一个整数，如果不存在这样的m，则输出<span class="hljs-string">-1</span>，否则输出符合条件的最小的值。<br></code></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题好像出的case比较弱，做的时候直接用前后缀偷鸡了，实际上可能需要考虑同分数的情况，所以自己的前后缀做法实际上是有问题的，不过既然偷过了，就先不管了哈哈哈，就当他是笔试题和leetcode的不同了；</p><p>笔试题模板就用类似这样的，写成leetcode的写法，也会相对比较熟练了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, x, y, scores</span>):<br>        scores.sort()<br>        pre = <span class="hljs-number">0</span><br>        last = <span class="hljs-built_in">len</span>(scores)<br><br>        m = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(scores)):  <span class="hljs-comment"># 二分优化</span><br>            pre += <span class="hljs-number">1</span><br>            last -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> pre &gt;= x <span class="hljs-keyword">and</span> pre &lt;= y <span class="hljs-keyword">and</span> last &gt;= x <span class="hljs-keyword">and</span> last &lt;= y:<br>                m = scores[i]<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">return</span> m<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n, x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>))<br>    scores = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># mock区域</span><br>    <span class="hljs-comment"># n = 6</span><br>    <span class="hljs-comment"># x = 2</span><br>    <span class="hljs-comment"># y = 3</span><br>    <span class="hljs-comment"># scores = [1, 2, 3, 4, 5, 6]</span><br>    <br><br>    res = s.func(n, x, y, scores)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：正则序列"><a href="#第二题：正则序列" class="headerlink" title="第二题：正则序列"></a>第二题：正则序列</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><font color="red">我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序</font></p><p>有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。</p><p>请问他最少用多少次操作可以把这个序列变成正则序列？</p><p>数据范围： 1 ≤ n ≤ 20000，0 ≤ abs(s_i) ≤ 10000<br>进阶：时间复杂度O(n)，空间复杂度O(n)  <strong>注：这里实际上是不是写错了，时间复杂度没法做到O(n)吧</strong></p><p>输入例子1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">5<br>-1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 10 </span>100<br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">103<br></code></pre></td></tr></table></figure><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题也太简单了，感觉甚至不如平常周赛第一题的包装后的难度，排个序然后对位相减就可以，O(nlogn)的解法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, nums</span>):<br>        nums.sort()<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            res += <span class="hljs-built_in">abs</span>(nums[i] - (i+<span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>))<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># mock区域</span><br>    <span class="hljs-comment"># n = 5</span><br>    <span class="hljs-comment"># nums = [-1, 2, 3, 10, 100]</span><br>    <br>    res = s.func(n, nums)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第三题：公司食堂"><a href="#第三题：公司食堂" class="headerlink" title="第三题：公司食堂"></a>第三题：公司食堂</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；</p><p><font color="red">当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；</font></p><p>无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。</p><p>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">第一行输入一个整数T（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>T&lt;<span class="hljs-operator">=</span><span class="hljs-number">10</span>），表示数据组数。<br><br>每组数据占四行，第一行输入一个整数N（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>N&lt;<span class="hljs-operator">=</span><span class="hljs-number">500000</span>）；<br><br>第二行输入一个长度为N且仅包含数字<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；<br><br>第三行输入一个整数M（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>M&lt;<span class="hljs-operator">=</span><span class="hljs-number">2</span>N且保证排队的每个人进入食堂时都有可供选择的餐桌）；<br><br>第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">每组数据输出占M行，第i行输出一个整数j（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>j&lt;<span class="hljs-operator">=</span>N），表示排在第i的人将选择左起第j张餐桌用餐。<br></code></pre></td></tr></table></figure><p>输入示例1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>5<br>01102<br>6<br>MFMMFF<br></code></pre></td></tr></table></figure><p>输入示例2：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>1<br>3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>感觉是个模拟题，本来以为笔试会经常出这种模拟题的，但是从今年来看好像不是这样啊。<strong>当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐</strong> 这感觉是一个提示，提示使用优先队列做模拟；</p><p>现在来看这个题好像一下想过去也不是能秒做的题目，但是感觉那天状态比较好吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, sitdown_peoples, m, gender</span>):<br>        res_list = []<br>        have_zero_count = <span class="hljs-number">0</span><br>        have_one_count = <span class="hljs-number">0</span><br>        have_two_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">import</span> heapq<br>        mapping = &#123;<span class="hljs-number">0</span>: [], <span class="hljs-number">1</span>: [], <span class="hljs-number">2</span>: []&#125;  <span class="hljs-comment"># 每个list是priority queue（heapq）</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sitdown_peoples)):<br>            mapping[sitdown_peoples[i]].append(i)<br>        <span class="hljs-comment"># heapify一下，优先队列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            heapq.heapify(mapping[i])<br><br>        <span class="hljs-comment"># print(&quot;after mapping: &quot;, mapping)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gender)):<br>            <span class="hljs-keyword">if</span> gender[i] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>                <span class="hljs-comment"># 男员工会优先选择有一个人的地方坐，如果都有了就去坐两个空的</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping[<span class="hljs-number">1</span>]) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 优先选择有一个人的地方坐</span><br>                    <span class="hljs-comment"># 坐在这里</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">1</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">2</span>], tmp_idx)<br><br>                <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 去坐两个空的</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">0</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">1</span>], tmp_idx)<br><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 女员工会优先选择都空的地方坐，如果没有了才会和别人拼桌</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping[<span class="hljs-number">0</span>]) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 优先选择没有人的地方</span><br>                    <span class="hljs-comment"># 坐在这里</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">0</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">1</span>], tmp_idx)<br><br>                <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 去坐有人的</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">1</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">2</span>], tmp_idx)<br><br>        <span class="hljs-keyword">return</span> res_list<br><br>        <br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>        sitdown_peoples = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>()))<br>        sitdown_peoples = [<span class="hljs-built_in">int</span>(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> sitdown_peoples]<br>        m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>        gender = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>()))<br><br><br>        <span class="hljs-comment"># print(&quot;n: &quot;, n)</span><br>        <span class="hljs-comment"># print(&quot;sitdown_peoples: &quot;, sitdown_peoples)</span><br>        <span class="hljs-comment"># print(&quot;m: &quot;, m)</span><br>        <span class="hljs-comment"># print(&quot;gender: &quot;, gender)</span><br><br>        res_list = s.func(n, sitdown_peoples, m, gender)<br>        <span class="hljs-comment"># print(&quot;res_list: &quot;, res_list)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res_list)):<br>            <span class="hljs-built_in">print</span>(res_list[i]+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="第四题：最优二叉树II"><a href="#第四题：最优二叉树II" class="headerlink" title="第四题：最优二叉树II"></a>第四题：最优二叉树II</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。</p><p>输入描述：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">第一行输入一个整数<span class="hljs-built_in">N</span>（<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">N</span>&lt;=<span class="hljs-number">300</span>），表示二叉树的节点数。<br>第二行输入<span class="hljs-built_in">N</span>个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过<span class="hljs-number">1000</span>的正整数。<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出一个整数，表示最优二叉树的总开销。<br></code></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">45<br></code></pre></td></tr></table></figure><p>例子说明1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-29-00-25-01.png"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">最优二叉树如图所示，总开销为7<span class="hljs-number">*1</span>+6<span class="hljs-number">*5</span>+5<span class="hljs-number">*1</span>+1<span class="hljs-number">*3</span>=45。<br></code></pre></td></tr></table></figure><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题后来看了答案，好像是要区间dp的做法，但是区间dp感觉就是完全未知的领域了，树上的操作感觉实在是太多了，包括还有线段树一类的，说到这里也什么时候找个线段树的模板，以备之后套用吧</p><p>这个题也可以用树形dp直接暴力，而且这里学到一个lru_cache，对于笔试题感觉是一种偷鸡的操作，让本来只能过2&#x2F;10的测试用例瞬间变到过6&#x2F;10 ~ 7&#x2F;10了，感觉就是dfs中的一个笔试偷鸡操作？应该所有dfs都可以用吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functiontools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-meta">@lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>():<br>    <span class="hljs-comment"># do sth</span><br></code></pre></td></tr></table></figure><p>这个题暂时只学习了下dfs暴力的方法了，和子结构树形dp很像，但是和leetcode那边的区别是这里的输入是一个数组，所以dfs的区间是 <code>(0, n)</code> 这种感觉，然后dfs的含义感觉就是把 <code>i</code> 作为<strong>子结构</strong>的根节点，然后i这个位置乘父亲的，再加上左边和右边的，就完成了一次内部的递归，此外，在内部递归中要遍历每个 <code>i</code> 位置，即每次（包括dfs下去的子层）都要把这个地方当做根节点试一下，最后记录一个局部子结构的ret最优作为返回值，而 <code>(0, n)</code> 这个子结构实际上就是父结构了，另外每次要把 <code>parent_value</code> 往下传下去；</p><p>子结构dp，LeetCode相似题目：</p><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a></p><p>如下代码可以通过6&#x2F;10 ~ 7&#x2F;10组测试用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, values</span>):<br>        <span class="hljs-comment"># 输出的values是一个global的数组，这里lru_cache大幅优化效率</span><br><span class="hljs-meta">        @lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">left, right, parent_val</span>):<br><br>            <span class="hljs-comment"># 3. 写出口，这里等于的话，就0</span><br>            <span class="hljs-keyword">if</span> left &gt;= right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            <span class="hljs-comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span><br>            res = <span class="hljs-number">1e9</span><br><br>            <span class="hljs-comment"># 2. 递归这个left,right区间下的最优子结构</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right):<br>                left_val = dfs(left, i, values[i])<br>                right_val = dfs(i+<span class="hljs-number">1</span>, right, values[i])<br>                res = <span class="hljs-built_in">min</span>(res, values[i] * parent_val + left_val + right_val)<br><br><br>            <span class="hljs-comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span><br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>    <span class="hljs-keyword">global</span> values<br>    values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># print(&quot;n: &quot;, n)</span><br>    <span class="hljs-comment"># print(&quot;values: &quot;, values)</span><br>    <br><br>    <span class="hljs-comment"># 调用以及output</span><br>    res = s.func(n, values)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2022春季战队赛</title>
    <link href="/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/"/>
    <url>/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>比赛综述&amp;总结：</p><p>这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了，</p><p>另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的</p><span id="more"></span><h1 id="第一题：LCP-55-采集果实"><a href="#第一题：LCP-55-采集果实" class="headerlink" title="第一题：LCP 55.采集果实"></a>第一题：LCP 55.采集果实</h1><p><a href="https://leetcode-cn.com/problems/PTXy4P/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。</p><p>在新手村中，各位勇者需要采集一些果实来制作药剂。<code>time[i]</code> 表示勇者每次采集 <code>1～limit</code> 颗第 <code>i</code> 种类型的果实需要的时间（即每次最多可以采集 <code>limit</code> 颗果实）。</p><p>当前勇者需要完成「采集若干批果实」的任务， <code>fruits[j] = [type, num]</code> 表示第 <code>j</code> 批需要采集 <code>num</code> 颗 <code>type</code> 类型的果实。采集规则如下：</p><ul><li>按 <code>fruits</code> 给定的顺序<strong>依次</strong>采集每一批次</li><li>采集完当前批次的果实才能开始采集下一批次</li><li>勇者完成当前批次的采集后将<strong>清空背包</strong>（即多余的果实将清空）</li></ul><p>请计算并返回勇者完成采集任务最少需要的时间。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3<br><br>输出：10<br><br>解释：<br>由于单次最多采集<span class="hljs-number"> 3 </span>颗<br>第<span class="hljs-number"> 0 </span>批需要采集<span class="hljs-number"> 2 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 1 </span>次，耗时为 2*1=2<br>第<span class="hljs-number"> 1 </span>批需要采集<span class="hljs-number"> 4 </span>颗第<span class="hljs-number"> 1 </span>类型果实，需要采集<span class="hljs-number"> 2 </span>次，耗时为 3*2=6<br>第<span class="hljs-number"> 2 </span>批需要采集<span class="hljs-number"> 1 </span>颗第<span class="hljs-number"> 2 </span>类型果实，需要采集<span class="hljs-number"> 1 </span>次，耗时为 2*1=2<br>返回总耗时 2+6+2=10<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [1], fruits = [[0,3],[0,5]], limit = 2<br><br>输出：5<br><br>解释：<br>由于单次最多采集<span class="hljs-number"> 2 </span>颗<br>第<span class="hljs-number"> 0 </span>批需要采集<span class="hljs-number"> 3 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 2 </span>次，耗时为 1*2=2<br>第<span class="hljs-number"> 1 </span>批需要采集<span class="hljs-number"> 5 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 3 </span>次，耗时为 1*3=3<br>需按照顺序依次采集，返回 2+3=5<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; time.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; time[i] &lt;&#x3D; 100</li><li>1 &lt;&#x3D; fruits.length &lt;&#x3D; 10^3</li><li>0 &lt;&#x3D; fruits[i][0] &lt; time.length</li><li>1 &lt;&#x3D; fruits[i][1] &lt; 10^3</li><li>1 &lt;&#x3D; limit &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题一上来就让人读题困难了，简单概括来说就是一个套角标，然后看看是否能整除，除完了向上取整吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumTime</span>(<span class="hljs-params">self, time, fruits, limit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type time: List[int]</span><br><span class="hljs-string">        :type fruits: List[List[int]]</span><br><span class="hljs-string">        :type limit: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fruits)):<br>            <span class="hljs-keyword">if</span> fruits[i][<span class="hljs-number">1</span>] % limit != <span class="hljs-number">0</span>:<br>                res += ((fruits[i][<span class="hljs-number">1</span>]//limit) + <span class="hljs-number">1</span>) * time[fruits[i][<span class="hljs-number">0</span>]]<br>            <span class="hljs-keyword">else</span>:<br>                 res += (fruits[i][<span class="hljs-number">1</span>]//limit) * time[fruits[i][<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：LCP-56-信物传送"><a href="#第二题：LCP-56-信物传送" class="headerlink" title="第二题：LCP 56.信物传送"></a>第二题：LCP 56.信物传送</h1><p><a href="https://leetcode-cn.com/problems/6UEx57/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。</p><p>本次试炼场地设有若干传送带，<code>matrix[i][j]</code> 表示第 <code>i</code> 行 <code>j</code> 列的传送带运作方向，<code>&quot;^&quot;,&quot;v&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;</code> 这四种符号分别表示 <strong>上</strong>、<strong>下</strong>、<strong>左</strong>、<strong>右</strong> 四个方向。信物会随传送带的方向移动。勇者<strong>每一次</strong>施法操作，可<strong>临时</strong>变更一处传送带的方向，在物品经过后传送带恢复原方向。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-23-20-10-49.png"></p><p>通关信物初始位于坐标 <code>start</code> 处，勇者需要将其移动到坐标 <code>end</code> 处，请返回勇者施法操作的最少次数。</p><p>注意：</p><ul><li><code>start</code> 和 <code>end</code> 的格式均为 <code>[i,j]</code></li></ul><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;v^&lt;&quot;</span>,<span class="hljs-string">&quot;&lt;&gt;&lt;&quot;</span>], start = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], end = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br><br>输出：<span class="hljs-number">1</span><br><br>解释：<br>如上图所示<br>当信物移动到 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 时，勇者施法一次将 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 的传送方向 ^ 从变更为 &lt;<br>从而信物移动到 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]，后续到达 end 位置<br>因此勇者最少需要施法操作 <span class="hljs-number">1</span> 次<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：matrix = [<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;^&lt;&lt;&quot;</span>], <span class="hljs-built_in">start</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-keyword">end</span> = [<span class="hljs-title">1</span>,<span class="hljs-title">1</span>]</span><br><br>输出：<span class="hljs-number">0</span><br><br>解释：勇者无需施法，信物将自动传送至 <span class="hljs-function"><span class="hljs-keyword">end</span> 位置</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [<span class="hljs-string">&quot;&gt;^^&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;^v&gt;&quot;</span>,<span class="hljs-string">&quot;^v^&lt;&quot;</span>], start = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], end = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>matrix</code> 中仅包含 <code>&#39;^&#39;、&#39;v&#39;、&#39;&lt;&#39;、&#39;&gt;&#39;</code></li><li><code>0 &lt; matrix.length &lt;= 100</code></li><li><code>0 &lt; matrix[i].length &lt;= 100</code></li><li><code>0 &lt;= start[0],end[0] &lt; matrix.length</code></li><li><code>0 &lt;= start[1],end[1] &lt; matrix[i].length</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉有平常周赛里相对难一点第三题的感觉，比赛的时候没有想到太好的做法就直接超级暴力了，赛后看只过了2&#x2F;32个测试用例，这也是这个比赛没法面向答案编程的难度吧hhhh</p><p>实际上要用bfs+dp的做法来做，当时能想到bfs，但是还是忽略和dp结合到一起了</p><p>这个题不需要记录vis了，就是说只把更小的入队，也好像不能纯优先队列，因为有些地方有好几个方向能走到，另外不用优先队列也可以做，但是用优先队列好像耗时会快一些</p><p>优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span><br>dp = [[<span class="hljs-number">1e9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br><br><span class="hljs-comment"># 状态初始化</span><br>sx, sy = start<br><span class="hljs-keyword">import</span> heapq<br>pq = []<br>heapq.heappush(pq, (<span class="hljs-number">0</span>, [sx, sy]))  <span class="hljs-comment"># 优先队列</span><br>dp[sx][sy] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) != <span class="hljs-number">0</span>:<br>tmp = heapq.heappop(pq)<br>x, y = tmp[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nx = x + dx[i]<br>ny = y + dy[i]<br><span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 这里不用设置visited数组是关键</span><br><span class="hljs-keyword">if</span> (matrix[x][y] == <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;v&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&gt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dp[x][y] &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y]<br>heapq.heappush(pq, (tmp[<span class="hljs-number">0</span>], [nx, ny]))<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">if</span> dp[x][y] + <span class="hljs-number">1</span> &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y] + <span class="hljs-number">1</span><br>heapq.heappush(pq, (tmp[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, [nx, ny]))<br><br><span class="hljs-keyword">return</span> dp[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>非优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span><br>dp = [[<span class="hljs-number">1e9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br><br><span class="hljs-comment"># 状态初始化</span><br>sx, sy = start<br>queue = [[sx, sy]]<br>dp[sx][sy] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>x, y = queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nx = x + dx[i]<br>ny = y + dy[i]<br><span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 这里不用设置visited数组是关键</span><br><span class="hljs-keyword">if</span> (matrix[x][y] == <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;v&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&gt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dp[x][y] &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y]<br>queue.append([nx, ny])<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">if</span> dp[x][y] + <span class="hljs-number">1</span> &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y] + <span class="hljs-number">1</span><br>queue.append([nx, ny])<br><br><span class="hljs-keyword">return</span> dp[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>比赛时候的超时做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br>record = [[[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br>visited = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br>total_vis = <span class="hljs-number">0</span><br>target_vis = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) * <span class="hljs-built_in">len</span>(matrix)<br><br><span class="hljs-comment"># 第一次从start开始走，把所有能走到的位置都标记上，如果走到了end则跳出并且输出0</span><br><span class="hljs-comment"># x纵向，y横向</span><br>sx, sy = start<br>nx, ny = sx, sy<br><br><span class="hljs-keyword">while</span> visited[nx][ny] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 如果走到了end则跳出，并且输出0</span><br><span class="hljs-keyword">if</span> nx == end[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> ny == end[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 标记访问过的</span><br>visited[nx][ny] = <span class="hljs-number">1</span><br>total_vis += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修改状态</span><br>record[nx][ny][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>record[nx][ny][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 按照当前的格子走</span><br><span class="hljs-keyword">if</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>ny = ny + <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>ny = ny - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;^&#x27;</span>:<br>nx = nx - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;v&#x27;</span>:<br>nx = nx + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># print(&quot;total_vis: &quot;, total_vis)</span><br><span class="hljs-comment"># print(&quot;target_vis: &quot;, target_vis)</span><br><span class="hljs-comment"># print(&quot;record: &quot;, record)</span><br><br><span class="hljs-comment"># 暴力走</span><br>now_status = <span class="hljs-number">0</span><br>jilu_i = <span class="hljs-number">0</span><br>jilu_j = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> total_vis != target_vis:<br><span class="hljs-comment"># 找到一个与now_status相邻的位置</span><br>break_flag = <span class="hljs-literal">False</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(jilu_i, <span class="hljs-built_in">len</span>(matrix)):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(jilu_j, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>can_flag = <span class="hljs-literal">False</span><br><span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果还没有访问过</span><br><span class="hljs-comment"># 如果临近的可达状态有上一个now_status的</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nnx = i + dx[k]<br>nny = j + dy[k]<br><span class="hljs-keyword">if</span> nnx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nnx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> nny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> record[nnx][nny][<span class="hljs-number">0</span>] == now_status:  <span class="hljs-comment"># </span><br>can_flag = <span class="hljs-literal">True</span><br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> can_flag:<br>break_flag = <span class="hljs-literal">True</span><br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">if</span> break_flag:<br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> break_flag:  <span class="hljs-comment"># 还能找到</span><br><br>jilu_i = i<br>jilu_j = j<br><br>nx, ny = i, j<br><span class="hljs-keyword">while</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> visited[nx][ny] == <span class="hljs-number">0</span>:<br><span class="hljs-comment"># 修改状态</span><br>record[nx][ny][<span class="hljs-number">0</span>] = now_status + <span class="hljs-number">1</span><br>record[nx][ny][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 增加</span><br>visited[i][j] = <span class="hljs-number">1</span><br>total_vis += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 按照当前的格子走</span><br><span class="hljs-keyword">if</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>ny = ny + <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>ny = ny - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;^&#x27;</span>:<br>nx = nx - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;v&#x27;</span>:<br>nx = nx + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># print(record)</span><br><span class="hljs-comment"># print(&quot;=============&quot;)</span><br><br><br><br><span class="hljs-keyword">else</span>:<br>now_status += <span class="hljs-number">1</span>  <span class="hljs-comment"># 再多一跳才能跳到的</span><br><br><span class="hljs-keyword">return</span> record[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>289场LeetCode周赛</title>
    <link href="/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了；</p><p>第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… <a href="http://bjutacm.openjudge.cn/lianxi/193E/">吃饭时的怪癖</a></p><p>好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh</p><p>第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><p>第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2&#x2F;3也都是medium但是难很多；</p><p>第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6070-计算字符串的数字和"><a href="#第一题：6070-计算字符串的数字和" class="headerlink" title="第一题：6070.计算字符串的数字和"></a>第一题：6070.计算字符串的数字和</h1><p><a href="https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p><p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p><ol><li>将 <code>s</code> <strong>拆分</strong> 成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li><li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>&quot;346&quot;</code> 会替换为 <code>&quot;13&quot;</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li><li>合并 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li></ol><p>返回在完成所有轮操作后的 <code>s</code> 。</p><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;11111222223&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;135&quot;</span><br>解释：<br>- 第一轮，将 s 分成：<span class="hljs-string">&quot;111&quot;</span>、<span class="hljs-string">&quot;112&quot;</span>、<span class="hljs-string">&quot;222&quot;</span> 和 <span class="hljs-string">&quot;23&quot;</span> 。<br>  接着，计算每一组的数字和：<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>、<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span>、<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">6</span> 和 <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> 。 <br>  这样，s 在第一轮之后变成 <span class="hljs-string">&quot;3&quot;</span> + <span class="hljs-string">&quot;4&quot;</span> + <span class="hljs-string">&quot;6&quot;</span> + <span class="hljs-string">&quot;5&quot;</span> = <span class="hljs-string">&quot;3465&quot;</span> 。<br>- 第二轮，将 s 分成：<span class="hljs-string">&quot;346&quot;</span> 和 <span class="hljs-string">&quot;5&quot;</span> 。<br>  接着，计算每一组的数字和：<span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span> 、<span class="hljs-number">5</span> = <span class="hljs-number">5</span> 。<br>  这样，s 在第二轮之后变成 <span class="hljs-string">&quot;13&quot;</span> + <span class="hljs-string">&quot;5&quot;</span> = <span class="hljs-string">&quot;135&quot;</span> 。 <br>现在，s.<span class="hljs-built_in">length</span> &lt;= k ，所以返回 <span class="hljs-string">&quot;135&quot;</span> 作为答案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：s = <span class="hljs-string">&quot;00000000&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;000&quot;</span><br>解释：<br>将 <span class="hljs-string">&quot;000&quot;</span>, <span class="hljs-string">&quot;000&quot;</span>, <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;00&quot;</span>.<br>接着，计算每一组的数字和：<span class="hljs-number">0</span> + <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 、<span class="hljs-number">0</span> + <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 和 <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 。 <br>s 变为 <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> = <span class="hljs-string">&quot;000&quot;</span> ，其长度等于 k ，所以返回 <span class="hljs-string">&quot;000&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li><li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">digitSum</span>(<span class="hljs-params">self, s, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(s) &gt; k:<br>            tmp_list = []<br>            ttmp_list = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                ttmp_list.append(s[i])<br>                <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>:<br>                    tmp_list.append(ttmp_list)<br>                    ttmp_list = []<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ttmp_list):<br>                tmp_list.append(ttmp_list)<br>            <span class="hljs-comment"># print(tmp_list)</span><br>            tttmp_list = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br>                tsum = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list[i])):<br>                    tsum += <span class="hljs-built_in">int</span>(tmp_list[i][j])<br>                tttmp_list.append(<span class="hljs-built_in">str</span>(tsum))<br>            s = <span class="hljs-string">&#x27;&#x27;</span>.join(tttmp_list)<br>        <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><h1 id="第二题：6071-完成所有任务需要的最少轮数"><a href="#第二题：6071-完成所有任务需要的最少轮数" class="headerlink" title="第二题：6071.完成所有任务需要的最少轮数"></a>第二题：6071.完成所有任务需要的最少轮数</h1><p><a href="https://leetcode-cn.com/problems/minimum-rounds-to-complete-all-tasks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p><p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回 <code>-1</code></p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：tasks = [2,2,3,3,2,4,4,4,4,4]<br>输出：4<br>解释：要想完成所有任务，一个可能的计划是：<br>- 第一轮，完成难度级别为<span class="hljs-number"> 2 </span>的<span class="hljs-number"> 3 </span>个任务。 <br>- 第二轮，完成难度级别为<span class="hljs-number"> 3 </span>的<span class="hljs-number"> 2 </span>个任务。 <br>- 第三轮，完成难度级别为<span class="hljs-number"> 4 </span>的<span class="hljs-number"> 3 </span>个任务。 <br>- 第四轮，完成难度级别为<span class="hljs-number"> 4 </span>的<span class="hljs-number"> 2 </span>个任务。 <br>可以证明，无法在少于<span class="hljs-number"> 4 </span>轮的情况下完成所有任务，所以答案为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：tasks = [2,3,3]<br>输出：-1<br>解释：难度级别为<span class="hljs-number"> 2 </span>的任务只有<span class="hljs-number"> 1 </span>个，但每一轮执行中，只能选择完成<span class="hljs-number"> 2 </span>个或者<span class="hljs-number"> 3 </span>个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= tasks.length &lt;= 10^5</code></li><li><code>1 &lt;= tasks[i] &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2&#x2F;3也都是medium但是难很多；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumRounds</span>(<span class="hljs-params">self, tasks</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tasks: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>        cnt_tasks = Counter(tasks)<br>        <span class="hljs-built_in">print</span>(cnt_tasks)  <span class="hljs-comment"># Counter(&#123;4: 5, 2: 3, 3: 2&#125;)</span><br><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt_tasks.items():<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 中间跳出</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>            t_value = value<br>            cnt_nums = t_value // <span class="hljs-number">3</span><br>            t_value -= cnt_nums * <span class="hljs-number">3</span><br>            <br>            <span class="hljs-keyword">if</span> t_value == <span class="hljs-number">1</span>:<br>                cnt_nums = cnt_nums - <span class="hljs-number">1</span> + <span class="hljs-number">2</span>  <span class="hljs-comment"># 去掉一次搞3，然后搞两次2</span><br>            <span class="hljs-keyword">elif</span> t_value == <span class="hljs-number">2</span>:<br>                cnt_nums += <span class="hljs-number">1</span><br>                t_value -= <span class="hljs-number">2</span><br>            <span class="hljs-comment"># print(t_value)</span><br>            res += cnt_nums<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6072-转角路径的乘积中最多能有几个尾随零"><a href="#第三题：6072-转角路径的乘积中最多能有几个尾随零" class="headerlink" title="第三题：6072.转角路径的乘积中最多能有几个尾随零"></a>第三题：6072.转角路径的乘积中最多能有几个尾随零</h1><p><a href="https://leetcode-cn.com/problems/maximum-trailing-zeros-in-a-cornered-path/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p><p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p><p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p><p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p><p>注意：</p><ul><li><strong>水平</strong> 移动是指向左或右移动。</li><li><strong>竖直</strong> 移动是指向上或下移动。</li></ul><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-18-18-31-09.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]<br>输出：3<br>解释：左侧的图展示了一条有效的转角路径。<br>其乘积为<span class="hljs-number"> 15 </span>*<span class="hljs-number"> 20 </span>*<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 18000 </span>，共计<span class="hljs-number"> 3 </span>个尾随零。<br>可以证明在这条转角路径的乘积中尾随零数目最多。<br><br>中间的图不是一条有效的转角路径，因为它有不止一个弯。<br>右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-04-18-18-31-15.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[4,3,2],[7,6,1],[8,8,8]]</span><br>输出：<span class="hljs-number">0</span><br>解释：网格如上图所示。<br>不存在乘积含尾随零的转角路径。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10^5</code></li><li><code>1 &lt;= m * n &lt;= 10^5</code></li><li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxTrailingZeros</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_five</span>(<span class="hljs-params">num</span>):<br>            cnt = <span class="hljs-number">0</span> <br>            <span class="hljs-keyword">while</span> num%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                num /= <span class="hljs-number">5</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> cnt<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_two</span>(<span class="hljs-params">num</span>):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                num /= <span class="hljs-number">2</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> cnt<br><br>        <span class="hljs-comment"># 从上到下的前缀矩阵，从下到上的前缀矩阵</span><br>        grid_up_to_down_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        grid_down_to_up_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 第一行</span><br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] = get_num_two(grid[i][j])<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] = get_num_five(grid[i][j])<br><br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] = get_num_two(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j])<br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] = get_num_five(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j])<br><br>                <span class="hljs-keyword">else</span>:<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] = grid_up_to_down_prefix[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] + get_num_two(grid[i][j])<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] = grid_up_to_down_prefix[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + get_num_five(grid[i][j])<br><br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-i][j][<span class="hljs-number">0</span>] + get_num_two(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j])<br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-i][j][<span class="hljs-number">1</span>] + get_num_five(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j])<br><br>        <span class="hljs-comment"># 从左到右的前缀矩阵，从右到左的前缀矩阵</span><br>        grid_left_to_right_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        grid_right_to_left_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 第一列</span><br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>] = get_num_two(grid[i][j])<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>] = get_num_five(grid[i][j])<br><br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = get_num_two(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>])<br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = get_num_five(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>])<br><br>                <span class="hljs-keyword">else</span>:<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>] = grid_left_to_right_prefix[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + get_num_two(grid[i][j])<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>] = grid_left_to_right_prefix[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + get_num_five(grid[i][j])<br><br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j][<span class="hljs-number">0</span>] = grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-j][<span class="hljs-number">0</span>] + get_num_two(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j])<br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j][<span class="hljs-number">1</span>] = grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-j][<span class="hljs-number">1</span>] + get_num_five(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j])<br><br>        <span class="hljs-comment"># for i in range(len(grid)):</span><br>        <span class="hljs-comment">#     for j in range(len(grid[0])):</span><br>        <span class="hljs-comment">#         print(grid_right_to_left_prefix[i][j])</span><br>        <span class="hljs-comment">#     print(&quot;\n&quot;)</span><br><br><br>        <span class="hljs-comment"># 从上往下走，从下往上走同时</span><br>        max_zero_last = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br><br>                <span class="hljs-comment"># 上往下，然后往右看</span><br>                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] + grid_left_to_right_prefix[i][-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] + grid_left_to_right_prefix[i][-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br><br>                <span class="hljs-comment"># 下往上，然后往右看</span><br>                cnt_num_2 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] + grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] + grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br>                <br>                <span class="hljs-comment"># 上往下，然后往左看</span><br>                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] + grid_right_to_left_prefix[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - grid_right_to_left_prefix[i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] + grid_right_to_left_prefix[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - grid_right_to_left_prefix[i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br><br>                <span class="hljs-comment"># 下往上，然后往左看</span><br>                cnt_num_2 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] + grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] + grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br>        <br>        <span class="hljs-keyword">return</span> max_zero_last<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
      <tag>前缀和</tag>
      
      <tag>矩阵</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>288场LeetCode周赛</title>
    <link href="/2022/04/11/algorithms/leetcode-weekly-contest/288%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/04/11/algorithms/leetcode-weekly-contest/288%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>上一周清明节扫墓鸽了一周，这周又回来了~ 周中尝试做了一个笔试题找了下思路的手感，然后发现leetcode说不定隔一阵做一次手感会更好哈哈哈。这次的前三个题感觉都是很快就有思路的，然后感觉自己做的顺手程度和代码的变量命名关系很大，如果变量命名的很顺利，那说明这次周赛可能就会很顺利了；</p><p>另外来说的话周赛确实要总结下数据结构，感觉前三题都是各种数据结构几乎差不多就能做出来了，而且要熟悉各个数据结构的时间复杂度，像这次的第三题实际上堆的想法是在脑子里一闪而过的，但是没有深思考下去就放弃了，有点可惜；</p><p>这次还积累到一个很坑的地方，就是除【1e9+7】和除【1000000007还有除10**9+7】可能是有精度问题的！！！最后比赛结束后才因为精度问题把这个题改过了做出来，实在是太坑了，或者说可能要用int把1e9+7转一下吧</p><p>第一题：比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的；</p><p>第二题：加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧；</p><p>第三题：根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：2231-按奇偶性交换后的最大数字"><a href="#第一题：2231-按奇偶性交换后的最大数字" class="headerlink" title="第一题：2231.按奇偶性交换后的最大数字"></a>第一题：2231.按奇偶性交换后的最大数字</h1><p><a href="https://leetcode-cn.com/problems/largest-number-after-digit-swaps-by-parity/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p><p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 1234<br>输出：3412<br>解释：交换数字<span class="hljs-number"> 3 </span>和数字<span class="hljs-number"> 1 </span>，结果得到<span class="hljs-number"> 3214 </span>。<br>交换数字<span class="hljs-number"> 2 </span>和数字<span class="hljs-number"> 4 </span>，结果得到<span class="hljs-number"> 3412 </span>。<br>注意，可能存在其他交换序列，但是可以证明<span class="hljs-number"> 3412 </span>是最大可能值。<br>注意，不能交换数字<span class="hljs-number"> 4 </span>和数字<span class="hljs-number"> 1 </span>，因为它们奇偶性不同。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 65875<br>输出：87655<br>解释：交换数字<span class="hljs-number"> 8 </span>和数字<span class="hljs-number"> 6 </span>，结果得到<span class="hljs-number"> 85675 </span>。<br>交换数字<span class="hljs-number"> 5 </span>和数字<span class="hljs-number"> 7 </span>，结果得到<span class="hljs-number"> 87655 </span>。<br>注意，可能存在其他交换序列，但是可以证明<span class="hljs-number"> 87655 </span>是最大可能值。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestInteger</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(num))<br>        <br>        tmp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]  <span class="hljs-comment"># 记录角标奇偶性</span><br>        oushu = []<br>        jishu = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(nums[i]) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                tmp[i] = <span class="hljs-number">0</span><br>                oushu.append(<span class="hljs-built_in">int</span>(nums[i]))<br>            <span class="hljs-keyword">else</span>:<br>                tmp[i] = <span class="hljs-number">1</span><br>                jishu.append(<span class="hljs-built_in">int</span>(nums[i]))<br>        <br>        <br>        <span class="hljs-comment"># 贪心</span><br>        k = <span class="hljs-number">0</span><br>        jishu.sort(reverse=<span class="hljs-literal">True</span>)<br>        <br>        j = <span class="hljs-number">0</span><br>        oushu.sort(reverse=<span class="hljs-literal">True</span>)<br>        <br>        <br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> tmp[i] == <span class="hljs-number">0</span>:<br>                res.append(oushu[j])<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(jishu[k])<br>                k += <span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">str</span>(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(res))<br></code></pre></td></tr></table></figure><h1 id="第二题：2232-向表达式添加括号后的最小结果"><a href="#第二题：2232-向表达式添加括号后的最小结果" class="headerlink" title="第二题：2232.向表达式添加括号后的最小结果"></a>第二题：2232.向表达式添加括号后的最小结果</h1><p><a href="https://leetcode-cn.com/problems/minimize-result-by-adding-parentheses-to-expression/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>&quot;&lt;num1&gt;+&lt;num2&gt;&quot;</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p><p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>&#39;+&#39;</code> 的左侧，而右括号必须添加在 <code>&#39;+&#39;</code> 的右侧。</p><p>返回添加一对括号后形成的表达式 <code>expression</code> ，且满足 <code>expression</code> 计算得到 <strong>最小</strong> 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。</p><p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p><p>示例1：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;247+38&quot;</span><br>输出：<span class="hljs-string">&quot;2(47+38)&quot;</span><br>解释：表达式计算得到 <span class="hljs-number">2</span> * (<span class="hljs-number">47</span> + <span class="hljs-number">38</span>) = <span class="hljs-number">2</span> * <span class="hljs-number">85</span> = <span class="hljs-number">170</span> 。<br>注意 <span class="hljs-string">&quot;2(4)7+38&quot;</span> 不是有效的结果，因为右括号必须添加在 <span class="hljs-string">&#x27;+&#x27;</span> 的右侧。<br>可以证明 <span class="hljs-number">170</span> 是最小可能值。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：expression = &quot;12+34&quot;<br>输出：&quot;1(2+3)4&quot;<br>解释：表达式计算得到<span class="hljs-number"> 1 </span>* (2 + 3) *<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 5 </span>*<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 20 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;999+999&quot;</span><br>输出：<span class="hljs-string">&quot;(999+999)&quot;</span><br>解释：表达式计算得到 <span class="hljs-number">999</span> + <span class="hljs-number">999</span> = <span class="hljs-number">1998</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= expression.length &lt;= 10</code></li><li><code>expression</code> 仅由数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 和 <code>&#39;+&#39;</code> 组成</li><li><code>expression</code> 由数字开始和结束</li><li><code>expression</code> 恰好仅含有一个 <code>&#39;+&#39;</code>.</li><li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimizeResult</span>(<span class="hljs-params">self, expression</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type expression: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 遍历每个可添加位置，然后找一个最小的</span><br>        <br>        <br>        expression_list = expression.split(<span class="hljs-string">&#x27;+&#x27;</span>)<br>        left_list = <span class="hljs-built_in">list</span>(expression_list[<span class="hljs-number">0</span>])<br>        right_list = <span class="hljs-built_in">list</span>(expression_list[<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># print(left_list)</span><br>        <span class="hljs-comment"># print(right_list)</span><br>        <br>        <br>        tmp_res = -<span class="hljs-number">1</span><br>        min_res = <span class="hljs-number">1e9</span><br>        <br>        <br>        <span class="hljs-comment"># left</span><br>        <span class="hljs-comment"># 哨兵</span><br>        left_res = <span class="hljs-number">0</span><br>        right_res = <span class="hljs-built_in">len</span>(right_list)-<span class="hljs-number">1</span><br>        min_res = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list)) + <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list))<br>        <br>        <br>        <br>        <span class="hljs-comment"># min_res = min(min_res, int(&#x27;&#x27;.join(left_list[:1])) * (int(&#x27;&#x27;.join(left_list[1:])) + int(&#x27;&#x27;.join(right_list))))</span><br>        <span class="hljs-comment"># min_res = min(min_res, (int(&#x27;&#x27;.join(left_list)) + int(&#x27;&#x27;.join(right_list[:len(right_list)-1]))) * int(&#x27;&#x27;.join(right_list[len(right_list)-1:])))</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(left_list)):  <span class="hljs-comment"># i代表插在前边</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(right_list)):  <span class="hljs-comment"># j代表插在后边</span><br>                <span class="hljs-comment"># if i != 0 and j != len(right_list) - 1:</span><br>                    <br>                pre = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[:i])) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[:i])) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>                inter = (<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[i:])) + <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[:j+<span class="hljs-number">1</span>])))<br>                last = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[j+<span class="hljs-number">1</span>:])) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[j+<span class="hljs-number">1</span>:])) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br><br><br>                tmp_res = pre * inter * last<br><br>                <span class="hljs-keyword">if</span> tmp_res &lt; min_res:<br>                    min_res = tmp_res<br>                    left_res = i<br>                    right_res = j<br>                    <br>                        <br>                    <span class="hljs-comment"># min_res = min(min_res, tmp_res)</span><br>                  <br>                    <br>                    <span class="hljs-comment"># print(left_list[:i])</span><br>                    <span class="hljs-comment"># print(left_list[i:])</span><br>                    <span class="hljs-comment"># print(right_list[:j+1])</span><br>                    <span class="hljs-comment"># print(right_list[j+1:])</span><br>                    <span class="hljs-comment"># assert False</span><br>        <span class="hljs-comment"># print(left_res, right_res)</span><br>        <br>        left_list.insert(left_res, <span class="hljs-string">&#x27;(&#x27;</span>)<br>        right_list.insert(right_res+<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;)&#x27;</span>)<br>        res_list = left_list + [<span class="hljs-string">&#x27;+&#x27;</span>] + right_list<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res_list)    <br></code></pre></td></tr></table></figure><h1 id="第三题：2233-K-次增加后的最大乘积"><a href="#第三题：2233-K-次增加后的最大乘积" class="headerlink" title="第三题：2233.K 次增加后的最大乘积"></a>第三题：2233.K 次增加后的最大乘积</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>k</code> 。每次操作，你可以选择 <code>nums</code> 中 <strong>任一</strong> 元素并将它 <strong>增加</strong> <code>1</code> 。</p><p>请你返回 <strong>至多</strong> <code>k</code> 次操作后，能得到的 <code>nums</code> 的 <strong>最大乘积</strong> 。由于答案可能很大，请你将答案对 <code>10^9 + 7</code> 取余后返回。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,4], k = 5<br>输出：20<br>解释：将第一个数增加<span class="hljs-number"> 5 </span>次。<br>得到 nums = [5, 4] ，乘积为<span class="hljs-number"> 5 </span>*<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 20 </span>。<br>可以证明<span class="hljs-number"> 20 </span>是能得到的最大乘积，所以我们返回<span class="hljs-number"> 20 </span>。<br>存在其他增加 nums 的方法，也能得到最大乘积。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,3,3,2], k = 2<br>输出：216<br>解释：将第二个数增加<span class="hljs-number"> 1 </span>次，将第四个数增加<span class="hljs-number"> 1 </span>次。<br>得到 nums = [6, 4, 3, 3] ，乘积为<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 3 </span>*<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 216 </span>。<br>可以证明<span class="hljs-number"> 216 </span>是能得到的最大乘积，所以我们返回<span class="hljs-number"> 216 </span>。<br>存在其他增加 nums 的方法，也能得到最大乘积。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length, k &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧；</p><p>自己的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># test = [43, 57, 60, 70, 72, 84, 86, 92]</span><br>        <span class="hljs-comment"># ttt_1 = 1</span><br>        <span class="hljs-comment"># for i in range(len(test)):</span><br>        <span class="hljs-comment">#     ttt_1 *= (test[i] % (1e9+7))</span><br>        <span class="hljs-comment"># print(&quot;ttt_1: &quot;, ttt_1%(1e9+7))</span><br>        <br>        c = <span class="hljs-number">1000000007</span> <span class="hljs-comment"># 这里换成1e9 + 7就过不了</span><br>        <br>        <span class="hljs-comment"># 平均了乘积最大，好像有前缀和那感觉</span><br>        nums.sort()  <span class="hljs-comment"># 从小到大排序</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums: &quot;</span>, nums)<br>        tmp_idx = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &lt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 这里还是有问题？</span><br>                <span class="hljs-comment"># print(&quot;k: &quot;, k)</span><br>                <span class="hljs-comment"># print(&quot;(nums[i+1] - nums[i]) * i: &quot;, (nums[i+1] - nums[i]) * (i+1))</span><br>                <span class="hljs-keyword">if</span> k &gt; (nums[i+<span class="hljs-number">1</span>] - nums[i]) * (i+<span class="hljs-number">1</span>):<br>                    k -= (nums[i+<span class="hljs-number">1</span>] - nums[i]) * (i+<span class="hljs-number">1</span>)<br>                    nums[i] = nums[i+<span class="hljs-number">1</span>]<br>                    <br>                <span class="hljs-keyword">else</span>:<br>                    tmp_idx = i<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(&quot;first nums: &quot;, nums)</span><br>        <span class="hljs-comment"># print(&quot;tmp_idx: &quot;, tmp_idx)</span><br>        <span class="hljs-comment"># print(&quot;k:&quot;, k)</span><br>        <br>        <span class="hljs-keyword">if</span> tmp_idx == -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 把剩余的k均匀展开到各个地方</span><br>            bias = k // <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 每个能增加几</span><br>            k -= bias * <span class="hljs-built_in">len</span>(nums)<br>            <span class="hljs-comment"># print((nums[0] + bias + 1)**k)</span><br>            <span class="hljs-comment"># print((nums[0] + bias)**(len(nums) - k))</span><br>            <br>            <span class="hljs-comment"># res = ((nums[-1] + bias + 1)**k)  *  ((nums[-1] + bias)**(len(nums) - k))</span><br>            <span class="hljs-comment"># 下边两行替代</span><br>            res = <span class="hljs-number">1</span><br>            a1 = (nums[-<span class="hljs-number">1</span>] + bias + <span class="hljs-number">1</span>)<br>            a2 = (nums[-<span class="hljs-number">1</span>] + bias)<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                res  = ((res % c) * (a1 % c)) % c<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - k):<br>                res  = ((res % c) * (a2 % c)) % c<br>            <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># print(&quot;nums: &quot;, nums)</span><br>            <span class="hljs-comment"># print(&quot;nums[tmp_idx+1:]: &quot;, nums[tmp_idx+1:])</span><br>            res = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tmp_idx+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                res = ((res%c) * (nums[i]%c)) % c<br>            <br>            t_nums = copy.deepcopy(nums[:tmp_idx+<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># print(&quot;t_nums: &quot;, t_nums)</span><br>            <br>            bias = k // <span class="hljs-built_in">len</span>(t_nums)  <span class="hljs-comment"># 每个能增加几</span><br>            k -= bias * <span class="hljs-built_in">len</span>(t_nums)<br>            <br>            t_res =  <span class="hljs-number">1</span><br>            a1 = (t_nums[-<span class="hljs-number">1</span>] + bias + <span class="hljs-number">1</span>)<br>            a2 = (t_nums[-<span class="hljs-number">1</span>] + bias)<br>            <span class="hljs-comment"># t_res = ((t_nums[-1] + bias + 1)**k)  *  ((t_nums[-1] + bias)**(len(t_nums) - k))</span><br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                t_res  = ((t_res % c) * (a1 % c)) % c<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t_nums) - k):<br>                t_res  = ((t_res % c) * (a2 % c)) % c<br>            <br>            res = ((res%c) * (t_res%c)) % c<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res)<br></code></pre></td></tr></table></figure><p>抄大佬的堆的思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        c = <span class="hljs-number">1000000007</span> <span class="hljs-comment"># 这里换成1e9 + 7就过不了</span><br>        <span class="hljs-keyword">import</span> heapq<br>        heapq.heapify(nums)<br>        <br>        <span class="hljs-comment"># 直接暴力模拟，k &lt; 10^5</span><br>        <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span>:<br>            tmp = heapq.heappop(nums)<br>            heapq.heappush(nums, tmp+<span class="hljs-number">1</span>)<br>            k -= <span class="hljs-number">1</span><br>        <br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            res = ((res%c) * (nums[i]%c)) % c<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>286场LeetCode周赛</title>
    <link href="/2022/03/27/algorithms/leetcode-weekly-contest/286%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/27/algorithms/leetcode-weekly-contest/286%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周周赛久违的在常规时间里做出三题了，感觉还是要先仔细读题然后多想一想常用的数据结构和思路吧，像这次的第二题就很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加；另外这次周赛感觉又在面向答案编程了，自己的思考总是不太全面就开始做题，中间各种边界情况和极端情况就会忽略，笔试比较好用但是面试就不好说了，还是要加强下自己的一次AC准确率！</p><p>第一题：比较简单，但是又忘记了 <code>set</code> 是可以直接相减的了，还用了个 <code>Counter</code> 搞来搞去整了半天，有点过于耗费时间了；</p><p>第二题：看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！</p><p>第三题：数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 <code>10 11 12 13</code> ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 <code>9*</code>次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：5268-找出两数组的不同"><a href="#第一题：5268-找出两数组的不同" class="headerlink" title="第一题：5268.找出两数组的不同"></a>第一题：5268.找出两数组的不同</h1><p><a href="https://leetcode-cn.com/problems/find-the-difference-of-two-arrays/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p><ul><li><code>answer[0]</code> 是 <code>nums1</code> 中所有 <strong>不</strong> 存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li><li><code>answer[1]</code> 是 <code>nums2</code> 中所有 <strong>不</strong> 存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li></ul><p><strong>注意</strong>：列表中的整数可以按 <strong>任意</strong> 顺序返回。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3]</span>, nums2 = <span class="hljs-comment">[2,4,6]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[4,6]</span>]</span><br>解释：<br>对于 nums1 ，nums1<span class="hljs-comment">[1]</span> = 2 出现在 nums2 中下标 0 处，然而 nums1<span class="hljs-comment">[0]</span> = 1 和 nums1<span class="hljs-comment">[2]</span> = 3 没有出现在 nums2 中。因此，answer<span class="hljs-comment">[0]</span> = <span class="hljs-comment">[1,3]</span>。<br>对于 nums2 ，nums2<span class="hljs-comment">[0]</span> = 2 出现在 nums1 中下标 1 处，然而 nums2<span class="hljs-comment">[1]</span> = 4 和 nums2<span class="hljs-comment">[2]</span> = 6 没有出现在 nums2 中。因此，answer<span class="hljs-comment">[1]</span> = <span class="hljs-comment">[4,6]</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,3]</span>, nums2 = <span class="hljs-comment">[1,1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[]</span>]</span><br>解释：<br>对于 nums1 ，nums1<span class="hljs-comment">[2]</span> 和 nums1<span class="hljs-comment">[3]</span> 没有出现在 nums2 中。由于 nums1<span class="hljs-comment">[2]</span> == nums1<span class="hljs-comment">[3]</span> ，二者的值只需要在 answer<span class="hljs-comment">[0]</span> 中出现一次，故 answer<span class="hljs-comment">[0]</span> = <span class="hljs-comment">[3]</span>。<br>nums2 中的每个整数都在 nums1 中出现，因此，answer<span class="hljs-comment">[1]</span> = <span class="hljs-comment">[]</span> 。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单，但是又忘记了 <code>set</code> 是可以直接相减的了，还用了个 <code>Counter</code> 搞来搞去整了半天，有点过于耗费时间了；</p><p>方法1（比赛时方法，现在看起来有点蠢hhh）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDifference</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1))<br>        nums2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums2))<br>        <br>        cnt1 = Counter(nums1) - Counter(nums2)<br>        cnt2 = Counter(nums2) - Counter(nums1)<br>        <br>        <span class="hljs-built_in">print</span>(cnt1)<br>        <span class="hljs-built_in">print</span>(cnt2)<br>        <br>        res = []<br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt1.items():<br>            tmp.append(key)<br>        res.append(tmp)<br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt2.items():<br>            tmp.append(key)<br>        res.append(tmp)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>方法2（set方法，只需一行233333）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDifference</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1) - <span class="hljs-built_in">set</span>(nums2)), <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums2) - <span class="hljs-built_in">set</span>(nums1))]<br></code></pre></td></tr></table></figure><h1 id="第二题：5236-美化数组的最少删除数"><a href="#第二题：5236-美化数组的最少删除数" class="headerlink" title="第二题：5236.美化数组的最少删除数"></a>第二题：5236.美化数组的最少删除数</h1><p><a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-array-beautiful/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p><ul><li><code>nums.length</code> 为偶数</li><li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li></ul><p>注意，空数组同样认为是美丽数组。</p><p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p><p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2,3,5]</span><br>输出：1<br>解释：可以删除 nums<span class="hljs-comment">[0]</span> 或 nums<span class="hljs-comment">[1]</span> ，这样得到的 nums = <span class="hljs-comment">[1,2,3,5]</span> 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2,2,3,3]</span><br>输出：2<br>解释：可以删除 nums<span class="hljs-comment">[0]</span> 和 nums<span class="hljs-comment">[5]</span> ，这样得到的 nums = <span class="hljs-comment">[1,2,2,3]</span> 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDeletion</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        res = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        idx_res = <span class="hljs-number">0</span><br>        idx_nums = <span class="hljs-number">0</span><br>        <br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> idx_res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-string">&quot;&quot;&quot; 如果是偶数位了，就直接贪心选 &quot;&quot;&quot;</span><br>                res[idx_res] = nums[i]<br>                idx_res += <span class="hljs-number">1</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> idx_res % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-string">&quot;&quot;&quot; 如果是奇数位，选一个离得比较远的 &quot;&quot;&quot;</span><br>                <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums):<br>                    <span class="hljs-keyword">if</span> nums[i] != res[idx_res-<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">break</span><br>                    i += <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-comment"># print(nums[i], res[idx_res-1])</span><br>                <span class="hljs-keyword">try</span>:<br>                    res[idx_res] = nums[i]<br>                    idx_res += <span class="hljs-number">1</span><br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-comment"># print(&quot;out: &quot;, i)</span><br>                <br><br>        <span class="hljs-keyword">if</span> idx_res % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            idx_res -= <span class="hljs-number">1</span><br>            <br>            <br>        <span class="hljs-comment"># print(res[:idx_res])</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) - idx_res<br></code></pre></td></tr></table></figure><h1 id="第三题：5253-找到指定长度的回文数"><a href="#第三题：5253-找到指定长度的回文数" class="headerlink" title="第三题：5253.找到指定长度的回文数"></a>第三题：5253.找到指定长度的回文数</h1><p><a href="https://leetcode-cn.com/problems/find-palindrome-with-fixed-length/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>queries</code> 和一个 <strong>正</strong> 整数 <code>intLength</code> ，请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是长度为 <code>intLength</code> 的 <strong>正回文数</strong> 中第 <code>queries[i]</code> 小的数字，如果不存在这样的回文数，则为 <code>-1</code>。</p><p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：queries = [1,2,3,4,5,90], intLength = 3<br>输出：[101,111,121,131,141,999]<br>解释：<br>长度为<span class="hljs-number"> 3 </span>的最小回文数依次是：<br>101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...<br>第<span class="hljs-number"> 90 </span>个长度为<span class="hljs-number"> 3 </span>的回文数是<span class="hljs-number"> 999 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：queries</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<span class="hljs-string">,</span> <span class="hljs-string">intLength</span> <span class="hljs-string">=</span> <span class="hljs-number">4</span><br><span class="hljs-string">输出：[1111,1331,1551]</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">长度为</span> <span class="hljs-number">4</span> <span class="hljs-string">的前</span> <span class="hljs-number">6</span> <span class="hljs-string">个回文数是：</span><br><span class="hljs-number">1001</span><span class="hljs-string">,</span> <span class="hljs-number">1111</span><span class="hljs-string">,</span> <span class="hljs-number">1221</span><span class="hljs-string">,</span> <span class="hljs-number">1331</span><span class="hljs-string">,</span> <span class="hljs-number">1441</span> <span class="hljs-string">和</span> <span class="hljs-number">1551</span> <span class="hljs-string">。</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= queries.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= queries[i] &lt;= 10^9</code></li><li><code>1 &lt;= intLength &lt;= 15</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 <code>10 11 12 13</code> ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 <code>9*</code>次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthPalindrome</span>(<span class="hljs-params">self, queries, intLength</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type queries: List[int]</span><br><span class="hljs-string">        :type intLength: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        <span class="hljs-keyword">if</span> intLength == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                res.append(queries[i])<br>            <span class="hljs-comment"># print(res)</span><br>            <span class="hljs-comment"># return res</span><br>        <span class="hljs-keyword">elif</span> intLength == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                tmp = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(queries[i]) + <span class="hljs-built_in">str</span>(queries[i]))<br>                res.append(tmp)<br>            <span class="hljs-comment"># print(res)</span><br>            <span class="hljs-comment"># return res</span><br>        <br>        <span class="hljs-comment"># elif intLength == 3:</span><br>        <span class="hljs-comment">#     for i in range(len(queries)):</span><br>        <span class="hljs-comment">#         a = queries[i] // 10 + 1</span><br>        <span class="hljs-comment">#         b = queries[i] % 10 - 1</span><br>        <span class="hljs-comment">#         if b == -1:</span><br>        <span class="hljs-comment">#             b = 9</span><br>        <span class="hljs-comment">#         if a == 10:</span><br>        <span class="hljs-comment">#             a = 9</span><br>        <span class="hljs-comment">#         tmp = int(str(a) + str(b) + str(a))   </span><br>        <span class="hljs-comment">#         res.append(tmp)</span><br>        <span class="hljs-comment">#     # print(res)</span><br>        <span class="hljs-comment">#     # return res</span><br>        <span class="hljs-keyword">else</span>:      <br>            ttmp = intLength // <span class="hljs-number">2</span>  <span class="hljs-comment"># 整除2</span><br>            <span class="hljs-keyword">if</span> intLength % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 要求偶数位，那就是第i个ttmp位数</span><br>                base_idx = <span class="hljs-number">10</span> ** (ttmp - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                    half = <span class="hljs-built_in">str</span>(base_idx + queries[i])<br>                    res.append(<span class="hljs-built_in">int</span>(half + half[::-<span class="hljs-number">1</span>]))<br>                <span class="hljs-comment"># return res</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 奇数位的，先确定中间的</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                    mid = <span class="hljs-built_in">str</span>((queries[i] - <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>)<br>                    <span class="hljs-comment"># print(mid)</span><br>                    base_idx = <span class="hljs-number">10</span> ** (ttmp - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 多少位数在前边</span><br>                    <br>                    <span class="hljs-keyword">if</span> queries[i] % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>:<br>                        offset = (queries[i] // <span class="hljs-number">10</span>) + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        offset = (queries[i] // <span class="hljs-number">10</span>)<br>                    <br>                    <br>                    <br>                    half = <span class="hljs-built_in">str</span>(base_idx + offset)<br>                    <span class="hljs-comment"># print(half)</span><br>                    res.append(<span class="hljs-built_in">int</span>(half+mid+half[::-<span class="hljs-number">1</span>]))<br>            <br>                <span class="hljs-comment"># return res</span><br>        <br>        max_tmp = (<span class="hljs-number">10</span> ** intLength) - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):<br>            <span class="hljs-keyword">if</span> res[i] &gt; max_tmp:<br>                res[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录服务器conda虚拟环境导出</title>
    <link href="/2022/03/23/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BA/"/>
    <url>/2022/03/23/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>某些场景下需要进行虚拟环境迁移，或者使用其他人的虚拟环境，这种时候如果能够完整导出别人的虚拟环境，在自己的环境下直接下载同步就很方便。</p><span id="more"></span><p>Reference:</p><blockquote><p><a href="https://blog.csdn.net/shunaoxi2313/article/details/92003710">https://blog.csdn.net/shunaoxi2313/article/details/92003710</a></p></blockquote><h1 id="原机器A的导出准备"><a href="#原机器A的导出准备" class="headerlink" title="原机器A的导出准备"></a>原机器A的导出准备</h1><p>通过如下命令，可以查看当前conda的可用环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda info --envs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">conda environments:</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">base                  *  /home/abc/miniconda3</span><br></code></pre></td></tr></table></figure><p>导出当前的conda环境（注意，这样导出貌似只会导出使用conda命令安装的内容，如果需要导出pip则还需要其他步骤），这里直接在base环境下（如果要导出别的，就conda activate venv1这类的之后再导出就可以）。导出后会在目录下生成一个py36.yaml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda env export &gt; py36.yaml<br></code></pre></td></tr></table></figure><p><strong>注意</strong>如果导出base环境的话，在目标机器上可能会提示已存在base环境（而且base环境无法删除）。所以如果导出base环境最好先复制一下，再导出base环境的复制品，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda create -n h1_abc_base --clone base<br>Source:      /home/abc/miniconda3<br>Destination: /home/abc/miniconda3/envs/h1_abc_base<br>The following packages cannot be cloned out of the root environment:<br> - defaults/linux-64::conda-4.9.2-py36h06a4308_0<br>Packages: 84<br>Files: 35464<br><br>Preparing transaction: done<br>Verifying transaction: done<br>Executing transaction: / Enabling nb_conda_kernels...<br>Status: enabled<br>done<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># To activate this environment, use</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">#     $ conda activate h1_abc_base</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># To deactivate an active environment, use</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">#     $ conda deactivate</span></span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda activate h1_abc_base<br>(h1_abc_base) abc@h1:~$ conda env export &gt; h1_abc_base.yaml<br></code></pre></td></tr></table></figure><p>完成上述步骤后，查看了一下h1_abc_base.yaml文件，其中已经包含了pip安装的一些内容，不过为了以防万一还是也把pip的内容导出一遍，如下所示，会生成requirements.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(h1_abc_base) abc@h1:~$ pip freeze &gt; h1_abc_base_requirements.txt<br></code></pre></td></tr></table></figure><h1 id="目标机器B的迁移"><a href="#目标机器B的迁移" class="headerlink" title="目标机器B的迁移"></a>目标机器B的迁移</h1><p>下载目标机器A最终生成的 <code>h1_abc_base.yaml</code> 与 <code>h1_abc_base_requirements.txt</code>，复制到目标机器的个人conda&#x2F;miniconda目录下 <code>/data/sdb1/lyx/</code></p><p>首先执行如下操作，导入conda环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:/data/sdb1/lyx$ conda env create -f h1_abc_base.yaml<br><br>...<br><br>Successfully built docopt jieba pyrouge sklearn termcolor textrank4zh<br>Installing collected packages: jmespath, numpy, cached-property, botocore, werkzeug, threadpoolctl, scipy, s3transfer, protobuf, markdown, joblib, h5py, grpcio, yarg, torch, termcolor, tensorboard, scikit-learn, regex, pytz, networkx, keras-preprocessing, keras-applications, jieba, gast, docopt, dill, boto3, astor, absl-py, textrank4zh, tensorflow, tensorboardx, sklearn, rouge, pytorch-pretrained-bert, pyrouge, pipreqs, pandas, multiprocess, emoji<br>Successfully installed absl-py-0.11.0 astor-0.8.1 boto3-1.17.68 botocore-1.20.69 cached-property-1.5.2 dill-0.3.3 docopt-0.6.2 emoji-1.2.0 gast-0.4.0 grpcio-1.33.2 h5py-3.1.0 jieba-0.42.1 jmespath-0.10.0 joblib-0.17.0 keras-applications-1.0.8 keras-preprocessing-1.1.2 markdown-3.3.3 multiprocess-0.70.11.1 networkx-2.5.1 numpy-1.16.0 pandas-1.1.4 pipreqs-0.4.10 protobuf-3.14.0 pyrouge-0.1.3 pytorch-pretrained-bert-0.6.2 pytz-2020.4 regex-2021.4.4 rouge-1.0.0 s3transfer-0.4.2 scikit-learn-0.23.2 scipy-1.5.4 sklearn-0.0 tensorboard-1.12.2 tensorboardx-2.1 tensorflow-1.12.0 termcolor-1.1.0 textrank4zh-0.3 threadpoolctl-2.1.0 torch-1.1.0 werkzeug-1.0.1 yarg-0.1.9<br></code></pre></td></tr></table></figure><p>其次执行如下操作，安装pip的包的版本（不一定要做）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:/data/sdb1/lyx$ conda activate h1_abc_base<br>(h1_abc_base) lyx@h5:/data/sdb1/lyx$ pip install -r h1_abc_base_requirements.txt <br></code></pre></td></tr></table></figure><p><strong>注意目前的安装操作还是需要在线环境才能安装的，离线安装的时候可能需要在导出环境配置文件的同时把下载环境的那些文件也都一起导出来，未来如果有需求的时候再进一步研究了！</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">(h1_abc_base) lyx<span class="hljs-variable">@h5</span><span class="hljs-symbol">:/data/sdb1/lyx</span><span class="hljs-variable">$ </span>python<br><span class="hljs-title class_">Python</span> <span class="hljs-number">3.6</span>.<span class="hljs-number">12</span> |<span class="hljs-title class_">Anaconda</span>, <span class="hljs-title class_">Inc</span>.| (default, <span class="hljs-title class_">Sep</span>  <span class="hljs-number">8</span> <span class="hljs-number">2020</span>, <span class="hljs-number">23</span><span class="hljs-symbol">:</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">56</span>) <br>[<span class="hljs-title class_">GCC</span> <span class="hljs-number">7.3</span>.<span class="hljs-number">0</span>] on linux<br><span class="hljs-title class_">Type</span> <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; <span class="hljs-keyword">import</span> torch<br>&gt;&gt;&gt; torch.cuda.is_available()<br><span class="hljs-title class_">True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-ACM模式的输入输出</title>
    <link href="/2022/03/23/algorithms/python-ACM%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/23/algorithms/python-ACM%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>在笔试环节做题的时候，题目大多数情况会是以ACM模式的输入输出构造，</p><span id="more"></span><p>Reference: <a href="https://blog.csdn.net/mmmmonkeyfei/article/details/118863773">https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</a></p><h1 id="各种类型情况总结"><a href="#各种类型情况总结" class="headerlink" title="各种类型情况总结"></a>各种类型情况总结</h1><p>TODO</p><h1 id="PTA的平台可以用python交，POJ用python交不了"><a href="#PTA的平台可以用python交，POJ用python交不了" class="headerlink" title="PTA的平台可以用python交，POJ用python交不了"></a>PTA的平台可以用python交，POJ用python交不了</h1><h2 id="example1-POJ2524：并查集题目"><a href="#example1-POJ2524：并查集题目" class="headerlink" title="example1: POJ2524：并查集题目"></a>example1: POJ2524：并查集题目</h2><p><a href="http://poj.org/problem?id=2524">题目链接</a></p><p>除了数据输入输出的提醒以外，也还提醒了以前很多在C语言算法题的时候，用的数组都可以用哈希表替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这里是哈希表</span><br>par = &#123;&#125;<br>vis = &#123;&#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_root</span>(<span class="hljs-params">a</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">找根（找部落）</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> par[a] != a:<br>par[a] = get_root(par[a])<br><span class="hljs-keyword">return</span> par[a]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">把p2往p1聚类</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p1 = get_root(a)<br>p2 = get_root(b)<br><span class="hljs-keyword">if</span> p1 != p2:<br>par[p2] = p1<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>js = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 这里重置了</span><br>vis = &#123;&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>par[i] = i<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>))<br>merge(a, b)<br><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> vis.get(get_root(i)) == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">else</span>:<br>count += <span class="hljs-number">1</span><br>vis[get_root(i)] = <span class="hljs-number">1</span><br><br>js += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Case %d: %d\n&quot;</span>  % (js, count), end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="example2-尝试输入输出字符串，GPLT轮着输出几次"><a href="#example2-尝试输入输出字符串，GPLT轮着输出几次" class="headerlink" title="example2-尝试输入输出字符串，GPLT轮着输出几次"></a>example2-尝试输入输出字符串，GPLT轮着输出几次</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805113036587008">题目链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">output_gplt</span>(<span class="hljs-params">self, s</span>):<br>        cnt_dict = Counter(s)<br>        return_list = []<br>        cnt_g = cnt_dict.get(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_p = cnt_dict.get(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_l = cnt_dict.get(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_t = cnt_dict.get(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-number">0</span>)<br><br><br>        <span class="hljs-keyword">while</span> cnt_g != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_p != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_l != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_t != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> cnt_g != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;G&#x27;</span>)<br>                cnt_g -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_p != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;P&#x27;</span>)<br>                cnt_p -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_l != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;L&#x27;</span>)<br>                cnt_l -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_t != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;T&#x27;</span>)<br>                cnt_t -= <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(return_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>())<br>    res = Solution().output_gplt(s)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h2 id="example3"><a href="#example3" class="headerlink" title="example3-"></a>example3-</h2>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode-python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>285场LeetCode周赛</title>
    <link href="/2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>被周末临时开会打断的一次周赛，有点烦hhh。总结来说这次周赛给的教训第一个应该就是好好读题？好好读题理解题意后再开始做，反而会比一上来突然来个想法就做顺利很多，在每个想法开始前要有个大概的实现难度预估和通过可能性预估，一般来说周赛前三个题仔细思考下，合理性分析下，感觉还都是可以做出来的，思路其实绕来绕去大部分还是那些，比较需要构思好再写吧！</p><p>第一题：比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序；</p><p>第二题：这个题自己想到的是一种模拟的思想，但是模拟过去后 <code>RRRRS</code> 这种情况，自己的操作后会变成 <code>RRRSS</code> ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 <code>LLLL</code> ，后缀去掉 <code>RRRR</code> ，最后中间的不是 <code>S</code> 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法；</p><p>第三题：原来 <code>2^n</code> 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 <code>20-32</code> 以内，就可以暴力遍历 <code>2^20~30</code> 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6027-统计数组中峰和谷的数量"><a href="#第一题：6027-统计数组中峰和谷的数量" class="headerlink" title="第一题：6027.统计数组中峰和谷的数量"></a>第一题：6027.统计数组中峰和谷的数量</h1><p><a href="https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标 <code>i</code> 和 <code>j</code> ，如果 <code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p><p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p><p>返回 <code>nums</code> 中峰和谷的数量。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,4,1,1,6,5]<br>输出：3<br>解释：<br>在下标<span class="hljs-number"> 0 </span>：由于<span class="hljs-number"> 2 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 0 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 1 </span>：4 的最近不相等邻居是<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 1 </span>。由于<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 2 </span>且<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 1 </span>，下标<span class="hljs-number"> 1 </span>是一个峰。<br>在下标<span class="hljs-number"> 2 </span>：1 的最近不相等邻居是<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>。由于<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 4 </span>且<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 6 </span>，下标<span class="hljs-number"> 2 </span>是一个谷。<br>在下标<span class="hljs-number"> 3 </span>：1 的最近不相等邻居是<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>。由于<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 4 </span>且<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 6 </span>，下标<span class="hljs-number"> 3 </span>符合谷的定义，但需要注意它和下标<span class="hljs-number"> 2 </span>是同一个谷的一部分。<br>在下标<span class="hljs-number"> 4 </span>：6 的最近不相等邻居是<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 5 </span>。由于<span class="hljs-number"> 6 </span>&gt;<span class="hljs-number"> 1 </span>且<span class="hljs-number"> 6 </span>&gt;<span class="hljs-number"> 5 </span>，下标<span class="hljs-number"> 4 </span>是一个峰。<br>在下标<span class="hljs-number"> 5 </span>：由于<span class="hljs-number"> 5 </span>的右侧不存在不相等邻居，所以下标<span class="hljs-number"> 5 </span>既不是峰也不是谷。<br>共有<span class="hljs-number"> 3 </span>个峰和谷，所以返回<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,6,5,5,4,1]<br>输出：0<br>解释：<br>在下标<span class="hljs-number"> 0 </span>：由于<span class="hljs-number"> 6 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 0 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 1 </span>：由于<span class="hljs-number"> 6 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 1 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 2 </span>：5 的最近不相等邻居是<span class="hljs-number"> 6 </span>和<span class="hljs-number"> 4 </span>。由于<span class="hljs-number"> 5 </span>&lt;<span class="hljs-number"> 6 </span>且<span class="hljs-number"> 5 </span>&gt;<span class="hljs-number"> 4 </span>，下标<span class="hljs-number"> 2 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 3 </span>：5 的最近不相等邻居是<span class="hljs-number"> 6 </span>和<span class="hljs-number"> 4 </span>。由于<span class="hljs-number"> 5 </span>&lt;<span class="hljs-number"> 6 </span>且<span class="hljs-number"> 5 </span>&gt;<span class="hljs-number"> 4 </span>，下标<span class="hljs-number"> 3 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 4 </span>：4 的最近不相等邻居是<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 1 </span>。由于<span class="hljs-number"> 4 </span>&lt;<span class="hljs-number"> 5 </span>且<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 1 </span>，下标<span class="hljs-number"> 4 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 5 </span>：由于<span class="hljs-number"> 1 </span>的右侧不存在不相等邻居，所以下标<span class="hljs-number"> 5 </span>既不是峰也不是谷。<br>共有<span class="hljs-number"> 0 </span>个峰和谷，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序；</p><p>下边这个代码实际上冗余了很多；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countHillValley</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        tmp_nums = []<br>        tmp = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> tmp == -<span class="hljs-number">1</span>:<br>                tmp = nums[i]<br>                tmp_nums.append(nums[i])<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> nums[i] == tmp:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">else</span>:<br>                    tmp = nums[i]<br>                    tmp_nums.append(nums[i])<br>        <br>        <span class="hljs-built_in">print</span>(tmp_nums)<br>        <br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(tmp_nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 找到左边不相等的</span><br>            <br>            t1 = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> tmp_nums[j] != tmp_nums[i]:<br>                    t1 = tmp_nums[j]<br>                    <span class="hljs-keyword">break</span><br>                    <br>            t2 = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(tmp_nums)):<br>                <span class="hljs-keyword">if</span> tmp_nums[j] != tmp_nums[i]:<br>                    t2 = tmp_nums[j]<br>                    <span class="hljs-keyword">break</span><br>                    <br>            <span class="hljs-built_in">print</span>(tmp_nums[i], t1, t2)<br>            <br>            <span class="hljs-keyword">if</span> (tmp_nums[i] &gt; t1 <span class="hljs-keyword">and</span> tmp_nums[i] &gt; t2 <span class="hljs-keyword">and</span> t1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t2 != -<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> (tmp_nums[i] &lt; t1 <span class="hljs-keyword">and</span> tmp_nums[i] &lt; t2 <span class="hljs-keyword">and</span> t1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t2 != -<span class="hljs-number">1</span>):<br>                cnt +=<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：6028-统计道路上的碰撞次数"><a href="#第二题：6028-统计道路上的碰撞次数" class="headerlink" title="第二题：6028.统计道路上的碰撞次数"></a>第二题：6028.统计道路上的碰撞次数</h1><p><a href="https://leetcode-cn.com/problems/count-collisions-on-a-road/submissions/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>&#39;L&#39;</code> 、 <code>&#39;R&#39;</code> 或 <code>&#39;S&#39;</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p><p>碰撞次数可以按下述方式计算：</p><ul><li>当两辆移动方向 相反 的车相撞时，碰撞次数加 <code>2</code> 。</li><li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li></ul><p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p><p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：directions = &quot;RLRSLL&quot;<br>输出：5<br>解释：<br>将会在道路上发生的碰撞列出如下：<br>- 车<span class="hljs-number"> 0 </span>和车<span class="hljs-number"> 1 </span>会互相碰撞。由于它们按相反方向移动，碰撞数量变为<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 2 </span>。<br>- 车<span class="hljs-number"> 2 </span>和车<span class="hljs-number"> 3 </span>会互相碰撞。由于<span class="hljs-number"> 3 </span>是静止的，碰撞数量变为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 3 </span>。<br>- 车<span class="hljs-number"> 3 </span>和车<span class="hljs-number"> 4 </span>会互相碰撞。由于<span class="hljs-number"> 3 </span>是静止的，碰撞数量变为<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>- 车<span class="hljs-number"> 4 </span>和车<span class="hljs-number"> 5 </span>会互相碰撞。在车<span class="hljs-number"> 4 </span>和车<span class="hljs-number"> 3 </span>碰撞之后，车<span class="hljs-number"> 4 </span>会待在碰撞位置，接着和车<span class="hljs-number"> 5 </span>碰撞。碰撞数量变为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 5 </span>。<br>因此，将会在道路上发生的碰撞总次数是<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：directions <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLRR&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= directions.length &lt;= 10^5</code></li><li><code>directions[i]</code> 的值为 <code>&#39;L&#39;</code> 、<code>&#39;R&#39;</code> 或 <code>&#39;S&#39;</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题自己想到的是一种模拟的思想，但是模拟过去后 <code>RRRRS</code> 这种情况，自己的操作后会变成 <code>RRRSS</code> ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 <code>LLLL</code> ，后缀去掉 <code>RRRR</code> ，最后中间的不是 <code>S</code> 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countCollisions</span>(<span class="hljs-params">self, directions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type directions: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># directions += &#x27;R&#x27;  # 哨兵</span><br>        <br>        init_status = [[i, i, <span class="hljs-string">&#x27;S&#x27;</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(directions))]  <span class="hljs-comment"># 第几个车，第几个车移动后，这个车的移动方向是</span><br>        <br>        new_status = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(init_status)):<br>            <span class="hljs-keyword">if</span> directions[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                new_status.append([init_status[i][<span class="hljs-number">0</span>], init_status[i][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>])<br>            <span class="hljs-keyword">elif</span> directions[i] == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                new_status.append([init_status[i][<span class="hljs-number">0</span>], init_status[i][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;R&#x27;</span>])<br>            <span class="hljs-keyword">elif</span> directions[i] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                new_status.append(init_status[i])<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_status)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">1</span>] &gt;= new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 这两个会撞上，判断两个状态</span><br>                <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;S&#x27;</span> <span class="hljs-keyword">and</span> new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;S&#x27;</span> <span class="hljs-keyword">and</span> new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] != new_status[i][<span class="hljs-number">2</span>]:<br>                    <span class="hljs-comment"># print(&quot;2: &quot;, new_status[i], new_status[i+1])</span><br>                    res += <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># print(&quot;1: &quot;, new_status[i], new_status[i+1])</span><br>                    res += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 汇总成之前的，不应该是之前的</span><br>                new_status[i] = init_status[i]<br>                new_status[i][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>                new_status[i+<span class="hljs-number">1</span>] = init_status[i+<span class="hljs-number">1</span>]<br>                new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>                <span class="hljs-comment"># print(&quot;i, new_status: &quot;, i, new_status)</span><br>                <br><span class="hljs-comment">#         # 还需要再过一遍</span><br><span class="hljs-comment">#         # 正着过</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(new_status)):<br>            <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-keyword">and</span> new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                res += <span class="hljs-number">1</span><br>                new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_status)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;R&#x27;</span> <span class="hljs-keyword">and</span> new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                res += <span class="hljs-number">1</span><br>                new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>  <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6029-射箭比赛中的最大得分"><a href="#第三题：6029-射箭比赛中的最大得分" class="headerlink" title="第三题：6029.射箭比赛中的最大得分"></a>第三题：6029.射箭比赛中的最大得分</h1><p><a href="https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p><ol><li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li><li>分数按下述规则计算：<ol><li>箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。</li><li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code> 区域射中 <code>ak</code> 和 <code>bk</code> 支箭。如果 <code>ak &gt;= bk</code> ，那么 Alice 得 <code>k</code> 分。如果 <code>ak &lt; bk</code> ，则 Bob 得 <code>k</code> 分</li><li>如果 <code>ak == bk == 0</code> ，那么无人得到 <code>k</code> 分。</li></ol></li></ol><ul><li>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得 <code>11</code> 分。</li></ul><p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中 <code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p><p>返回数组 <code>bobArrows</code> ，该数组表示 Bob 射中 <code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p><p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-20-23-45-26.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]<br>输出：[0,0,0,0,1,1,0,0,1,2,3,1]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 11 </span>=<span class="hljs-number"> 47 </span>。<br>可以证明 Bob 无法获得比<span class="hljs-number"> 47 </span>更高的分数。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-03-20-23-45-58.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：numArrows = <span class="hljs-number">3</span>, aliceArrows = [<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,2</span>]<br>输出：[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,1,1,0</span>]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分 <span class="hljs-number">8</span> + <span class="hljs-number">9</span> + <span class="hljs-number">10</span> = <span class="hljs-number">27</span> 。<br>可以证明 Bob 无法获得比 <span class="hljs-number">27</span> 更高的分数。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= numArrows &lt;= 10^5</code></li><li><code>aliceArrows.length == bobArrows.length == 12</code></li><li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li><li><code>sum(aliceArrows[i]) == numArrows</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>原来 <code>2^n</code> 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 <code>20-32</code> 以内，就可以暴力遍历 <code>2^20~30</code> 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumBobPoints</span>(<span class="hljs-params">self, numArrows, aliceArrows</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type numArrows: int</span><br><span class="hljs-string">        :type aliceArrows: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_score = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 直接暴力枚举，11种二进制转状态，判断在哪些状态能得分（是合理的）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(aliceArrows)):<br>            tmp_bin = []<br>            tmp = i<br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                tmp_bin.append(tmp&amp;<span class="hljs-number">1</span>)<br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>            tmp_bin += [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aliceArrows)-<span class="hljs-built_in">len</span>(tmp_bin))]<br>            <br>            <span class="hljs-comment"># 1代表要在这些位置上击败alice，然后做合理性判断就行了</span><br>            flag = <span class="hljs-literal">True</span><br>            cnt = <span class="hljs-number">0</span><br>            tmp_score = <span class="hljs-number">0</span><br>            tmp_list = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aliceArrows)):<br>                <span class="hljs-keyword">if</span> tmp_bin[j] == <span class="hljs-number">1</span>:<br>                    cnt += aliceArrows[j] + <span class="hljs-number">1</span><br>                    tmp_score += j<br>                    tmp_list.append(aliceArrows[j] + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    tmp_list.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 这里判断合理性</span><br>            <span class="hljs-keyword">if</span> cnt &lt;= numArrows:<br>                <span class="hljs-keyword">if</span> tmp_score &gt; max_score:<br>                    max_score= tmp_score<br>                    res = tmp_list<br>                    res[<span class="hljs-number">0</span>] = numArrows - <span class="hljs-built_in">sum</span>(res)<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>栈</tag>
      
      <tag>枚举</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2044.统计按位或能得到最大值的子集数目-python</title>
    <link href="/2022/03/15/algorithms/leetcode-python/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE-python/"/>
    <url>/2022/03/15/algorithms/leetcode-python/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE-python/</url>
    
    <content type="html"><![CDATA[<p>2044.统计按位或能得到最大值的子集数目（中等）</p><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p><p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">题目链接</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p><p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,1]</span><br>输出：2<br>解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：<br>- <span class="hljs-comment">[3]</span><br>- <span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,2]<br>输出：7<br>解释：[2,2,2] 的所有非空子集的按位或都可以得到<span class="hljs-number"> 2 </span>。总共有<span class="hljs-number"> 23 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>个子集。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,5]</span><br>输出：6<br>解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：<br>- <span class="hljs-comment">[3,5]</span><br>- <span class="hljs-comment">[3,1,5]</span><br>- <span class="hljs-comment">[3,2,5]</span><br>- <span class="hljs-comment">[3,2,1,5]</span><br>- <span class="hljs-comment">[2,5]</span><br>- <span class="hljs-comment">[2,1,5]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 16</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>典型的 <code>2^n</code> 暴力遍历题目，题目里给的提示 <code>16</code> 也代表了这个意思， <code>2^16 = 65536</code>；</p><p>如果是每日一题的话就先不用回溯搞了，回溯好像是dfs分为取和不取的两个分支往下dfs，写起来稍微有点麻烦；</p><p>大佬的提醒下不用做什么哈希表了，在迭代判断的过程中直接记录 <code>max</code> ，然后出现新的更大的 <code>refresh</code> 掉那个 <code>cnt</code> 、没出现新的然后等于 <code>max</code> 的直接 <code>cnt+=1</code> 这样就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countMaxOrSubsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_or = <span class="hljs-number">0</span><br>        max_or_count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(nums)):<br>            tmp = i<br>            tmp_list = []<br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                tmp_list.append(tmp&amp;<span class="hljs-number">1</span>)<br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>            tmp_list += [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-built_in">len</span>(tmp_list))]<br>            <span class="hljs-comment"># print(tmp_list)  # 1是选择，0是不选择</span><br><br>            tmp_or = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br>                <span class="hljs-keyword">if</span> tmp_list[j] == <span class="hljs-number">1</span>:<br>                    tmp_or |= nums[j]  <span class="hljs-comment"># 按位或简单写法</span><br>            <span class="hljs-keyword">if</span> tmp_or &gt; max_or:<br>                max_or = tmp_or<br>                max_or_count = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> tmp_or == max_or:<br>                max_or_count += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> max_or_count<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>589.N叉树的前序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>589.N叉树的前序遍历（简单）</p><p>题目大意：</p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">题目链接</a></p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-13-50.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-14-19.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>节点总数在范围 <code>[0, 10^4]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^4</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>这个题要是用递归的话那是绝对的简单题，N叉树就感觉把所有children走一遍就行了，和二叉树的前序遍历递归完全是一个模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_preorder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            res.append(root.val)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> root.children:<br>                dfs_preorder(ch)     <br>        dfs_preorder(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h2><p>N叉树的前序遍历和后序遍历的迭代法本质就是栈的应用，前序遍历是每次弹出来就加，而后序遍历要在每次加的基础上最后reverse一下</p><p>在自己设定好栈顶和栈底的基础上，按照操作来就可以了，手写模拟下很快就能找到规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历用栈实现非递归</span><br>        res = []<br>        stack = []<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(root)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack):<br>            tmp = stack[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 左边是栈顶，右边是栈底</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            res.append(tmp.val)<br>            <span class="hljs-comment"># tmp.children是一个list，倒序入栈，这个还是相对好像的吧</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp.children)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> tmp.children[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    stack.insert(<span class="hljs-number">0</span>, tmp.children[i])  <span class="hljs-comment"># 在位置0insert</span><br>                    <span class="hljs-comment"># print([a.val for a in stack])</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>590.N叉树的后序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>590.N叉树的后序遍历（简单）</p><p>题目大意：</p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>后序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">题目链接</a></p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>后序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-13-50.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-14-19.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>节点总数在范围 <code>[0, 10^4]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^4</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>这个题写完内部的dfs函数居然忘了调用了哈哈哈，很简单和二叉树的一样就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_postorder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> root.children:<br>                dfs_postorder(ch)<br>            res.append(root.val)<br>        dfs_postorder(root)  <span class="hljs-comment"># 居然是因为忘写了这句话</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h2><p>使用了前序遍历迭代的思想，自己写一写模拟就好，最后需要reverse过来，也就是 <code>t_list = t_list[::-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 迭代，这里可以借助前序遍历</span><br>        res = []<br>        stack = []<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(root)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack):<br>            tmp = stack[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 左边栈顶，右边栈底</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            res.append(tmp.val)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> tmp.children:<br>                <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    stack.insert(<span class="hljs-number">0</span>, ch)<br>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>429.N叉树的层序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>429.N叉树的层序遍历（中等）</p><p>题目大意：</p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">题目链接</a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-02-01.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,3,2,4,null,5,6]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[3,2,4]</span>,<span class="hljs-comment">[5,6]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-14-21-02-42.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>],[<span class="hljs-number">14</span>]]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>层序遍历本质上是广度优先，广度优先本质上就是bfs（？好像在说废话hhh）</p><p>这个题需要特别注意下把层序遍历 <code>append</code> 成这个嵌套的样子 <code>[[], [], []] </code> ，这里的思路是每次记录下当前层的数目，然后在 <code>pop-appendtail</code> 的时候只把当前层这么多个的给 <code>pop</code> 出来，使用一个中间的 <code>tmp_ans</code> 来存储每层，然后一层一层的 <code>append</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        queue = []  <span class="hljs-comment"># 左出，右进</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            queue.append(root)<br><br>        <span class="hljs-comment"># 层序遍历代码写成一体化的，因为层序遍历还要兼顾层级的输出</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue):<br>            <span class="hljs-comment"># 每次都把当前这一层走完，然后append</span><br>            tmp_ans = []<br>            now_level_len = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(now_level_len):  <span class="hljs-comment"># 只是为了执行这么多次</span><br>                tmp_q = queue[<span class="hljs-number">0</span>]<br>                queue = queue[<span class="hljs-number">1</span>:]<br>                tmp_ans.append(tmp_q.val)<br>                <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> tmp_q.children:<br>                    queue.append(ch)<br>            res.append(tmp_ans)<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.合并K个升序链表-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>23.合并K个升序链表（困难）</p><p>题目大意：</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目链接</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例1：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length 的总和不超过 10^4</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉实际真的明白了什么是优先队列，什么是堆的思想。python这个 <code>heapq</code> 是真的神，如果用正数就是小根堆，如果是用负数就可以转化为大根堆了！</p><p>只要先用 <code>heapq</code> 存储成一个堆，然后不断 <code>heappop()</code>就可以了，这里推荐堆的命名可以直接用 <code>heap</code>；</p><p>另注，这个题实际上有很多做法，但这个做法是最为简单的了，其他还需要进一步探究；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type lists: List[ListNode]</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">import</span> heapq  <span class="hljs-comment"># 优先队列</span><br>        heap = []<br>        <span class="hljs-keyword">for</span> i, t_list <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lists):<br>            head = t_list<br>            <span class="hljs-keyword">while</span> head <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                heapq.heappush(heap, head.val)<br>                head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 尾插法</span><br>        return_head = ListNode(val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>)<br>        p = return_head<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(heap) != <span class="hljs-number">0</span>:<br>            tmp = heapq.heappop(heap)<br>            p.<span class="hljs-built_in">next</span> = ListNode(val=tmp)<br>            p = p.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> return_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>HARD</tag>
      
      <tag>链表</tag>
      
      <tag>分治</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>284场LeetCode周赛</title>
    <link href="/2022/03/13/algorithms/leetcode-weekly-contest/284%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/13/algorithms/leetcode-weekly-contest/284%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周三个题还是相对友善一点点的：第一题读题有些困难hhh读好了一些角标标记的操作就可以了；第二题感觉一下想过去就是个哈希表记录，感觉也是状态好才能现场写出来吧；第三题需要考虑很多种case是个比较细节的题，感觉还是模拟为主。总结来说这周还都属于是一下想过去有思路的题，希望未来能进一步保持啊啊啊啊啊；</p><p>第一题：角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 <code>abs</code> 就可以了；</p><p>第二题：一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）；</p><p>第三题：这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 <code>nums</code> 的长度是 <code>10^5</code> 的时候就感觉可以模拟了，然后 <code>k</code> 比这个大就说明可能会有一部分相对特殊的case；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6031-找出数组中的所有-K-近邻下标"><a href="#第一题：6031-找出数组中的所有-K-近邻下标" class="headerlink" title="第一题：6031.找出数组中的所有 K 近邻下标"></a>第一题：6031.找出数组中的所有 K 近邻下标</h1><p><a href="https://leetcode-cn.com/problems/find-all-k-distant-indices-in-an-array/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和两个整数 <code>key</code> 和 <code>k</code> 。<strong>K 近邻下标</strong> 是 <code>nums</code> 中的一个下标 <code>i</code> ，并满足至少存在一个下标 <code>j</code> 使得 <code>|i - j| &lt;= k</code> 且 <code>nums[j] == key</code> 。</p><p>以列表形式返回按 <strong>递增顺序</strong> 排序的所有 K 近邻下标。</p><p>示例1：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>], key = <span class="hljs-number">9</span>, k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：因此，nums[<span class="hljs-number">2</span>] == key 且 nums[<span class="hljs-number">5</span>] == key 。<br>- 对下标 <span class="hljs-number">0</span> ，|<span class="hljs-type">0</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&gt; k</span> 且 |<span class="hljs-type">0</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&gt; k</span> ，所以不存在 j 使得 |<span class="hljs-type">0</span> - j| <span class="hljs-type">&lt;= k</span> 且 nums[j] == key 。所以 <span class="hljs-number">0</span> 不是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">1</span> ，|<span class="hljs-type">1</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">1</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">2</span> ，|<span class="hljs-type">2</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">2</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">3</span> ，|<span class="hljs-type">3</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">3</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">4</span> ，|<span class="hljs-type">4</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">4</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">5</span> ，|<span class="hljs-type">5</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">5</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">6</span> ，|<span class="hljs-type">6</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">6</span> 是一个 K 近邻下标。<br>因此，按递增顺序返回 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span>, key = 2, k = 2<br>输出：<span class="hljs-comment">[0,1,2,3,4]</span><br>解释：对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums<span class="hljs-comment">[j]</span> == key ，所以每个下标都是一个 K 近邻下标。 <br>因此，返回 <span class="hljs-comment">[0,1,2,3,4]</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>key</code> 是数组 <code>nums</code> 中的一个整数</li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 <code>abs</code> 就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKDistantIndices</span>(<span class="hljs-params">self, nums, key, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] == key:<br>                tmp.append(i)<br>        <span class="hljs-built_in">print</span>(tmp)<br><br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(i - tmp[j]) &lt;= k:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i, j: &quot;</span>, i,j)<br>                    res.append(i)<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：5203-统计可以提取的工件"><a href="#第二题：5203-统计可以提取的工件" class="headerlink" title="第二题：5203.统计可以提取的工件"></a>第二题：5203.统计可以提取的工件</h1><p><a href="https://leetcode-cn.com/problems/count-artifacts-that-can-be-extracted/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1i, c1i, r2i, c2i]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p><ul><li><code>(r1i, c1i)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li><li><code>(r2i, c2i)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li></ul><p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [ri, ci]</code> 表示你将会挖掘单元格 <code>(ri, ci)</code> ，返回你可以提取的工件数目。</p><p>生成的测试用例满足：</p><ul><li>不存在重叠的两个工件。</li><li>每个工件最多只覆盖 <code>4</code> 个单元格。</li><li><code>dig</code> 中的元素互不相同。</li></ul><p>示例1：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-13-22-25-47.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, artifacts = <span class="hljs-string">[[0,0,0,0],[0,1,1,1]]</span>, dig = <span class="hljs-string">[[0,0],[0,1]]</span><br>输出：<span class="hljs-number">1</span><br>解释： <br>不同颜色表示不同的工件。挖掘的单元格用 <span class="hljs-string">&#x27;D&#x27;</span> 在网格中进行标记。<br>有 <span class="hljs-number">1</span> 个工件可以提取，即红色工件。<br>蓝色工件在单元格 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) 的部分尚未裸露出来，所以无法提取该工件。<br>因此，返回 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-13-22-26-06.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, artifacts = <span class="hljs-string">[[0,0,0,0],[0,1,1,1]]</span>, dig = <span class="hljs-string">[[0,0],[0,1],[1,1]]</span><br>输出：<span class="hljs-number">2</span><br>解释：红色工件和蓝色工件的所有部分都裸露出来（用 <span class="hljs-string">&#x27;D&#x27;</span> 标记），都可以提取。因此，返回 <span class="hljs-number">2</span> 。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n^2, 10^5)</code></li><li><code>artifacts[i].length == 4</code></li><li><code>dig[i].length == 2</code></li><li><code>0 &lt;= r1i, c1i, r2i, c2i, ri, ci &lt;= n - 1</code></li><li><code>r1i &lt;= r2i</code></li><li><code>c1i &lt;= c2i</code></li><li>不存在重叠的两个工件</li><li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li><li><code>dig</code> 中的元素互不相同</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">digArtifacts</span>(<span class="hljs-params">self, n, artifacts, dig</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type artifacts: List[List[int]]</span><br><span class="hljs-string">        :type dig: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 哈希表记录每个地方的状态</span><br>        <br>        <span class="hljs-comment"># 要用mark吗，还是说看起来直接暴力就行了</span><br>        reverse_mapping = &#123;&#125;<br>        d = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(artifacts))]<br>        m = [[-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(artifacts)):<br>            r1, c1, r2 ,c2 = artifacts[i]<br>            d[i] = <span class="hljs-number">0</span>  <span class="hljs-comment"># mapping</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r1, r2+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c1, c2+<span class="hljs-number">1</span>):<br>                    m[j][k] = <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 反向mapping，这个工件属于第几个</span><br>                    reverse_mapping[(j, k)] = i  <span class="hljs-comment"># jk角标的地方属于第i个工件</span><br>                    d[i] += <span class="hljs-number">1</span><br>        <span class="hljs-comment">#print(&quot;d: &quot;, d)</span><br>        <span class="hljs-comment">#print(&quot;m: &quot;, m)</span><br>        <span class="hljs-comment">#print(&quot;reverse_mapping: &quot;, reverse_mapping)</span><br>    <br>    <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dig)):<br>            r, c = dig[i]<br>            <span class="hljs-comment"># 先判断这个地方是不是有</span><br>            <span class="hljs-keyword">if</span> m[r][c] == <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># 再判断是第几个零件</span><br>                index = reverse_mapping[(r, c)]<br>                <span class="hljs-comment"># 减去第几个零件</span><br>                d[index] -= <span class="hljs-number">1</span><br>                <br>                m[r][c] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 挖掉</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">continue</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-comment">#print(d)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(d)):<br>            <span class="hljs-keyword">if</span> d[i] == <span class="hljs-number">0</span>:<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：5227-K-次操作后最大化顶端元素"><a href="#第三题：5227-K-次操作后最大化顶端元素" class="headerlink" title="第三题：5227.K 次操作后最大化顶端元素"></a>第三题：5227.K 次操作后最大化顶端元素</h1><p><a href="https://leetcode-cn.com/problems/maximize-the-topmost-element-after-k-moves/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code> 是栈顶的元素。</p><p>每一次操作中，你可以执行以下操作 <strong>之一</strong> ：</p><ul><li>如果栈非空，那么 <strong>删除</strong> 栈顶端的元素。</li><li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<strong>添加</strong> 回栈顶，这个元素成为新的栈顶元素。</li></ul><p>同时给你一个整数 <code>k</code> ，它表示你总共需要执行操作的次数。</p><p>请你返回 <strong>恰好</strong> 执行 <code>k</code> 次操作以后，栈顶元素的 <strong>最大值</strong> 。如果执行完 <code>k</code> 次操作以后，栈一定为空，请你返回 <code>-1</code> 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [5,2,2,4,0,6], k = 4<br>输出：5<br>解释：<br>4 次操作后，栈顶元素为<span class="hljs-number"> 5 </span>的方法之一为：<br>- 第<span class="hljs-number"> 1 </span>次操作：删除栈顶元素<span class="hljs-number"> 5 </span>，栈变为 [2,2,4,0,6] 。<br>- 第<span class="hljs-number"> 2 </span>次操作：删除栈顶元素<span class="hljs-number"> 2 </span>，栈变为 [2,4,0,6] 。<br>- 第<span class="hljs-number"> 3 </span>次操作：删除栈顶元素<span class="hljs-number"> 2 </span>，栈变为 [4,0,6] 。<br>- 第<span class="hljs-number"> 4 </span>次操作：将<span class="hljs-number"> 5 </span>添加回栈顶，栈变为 [5,4,0,6] 。<br>注意，这不是最后栈顶元素为<span class="hljs-number"> 5 </span>的唯一方式。但可以证明，4 次操作以后<span class="hljs-number"> 5 </span>是能得到的最大栈顶元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [2], k = 1<br>输出：<span class="hljs-string">-1</span><br>解释：<br>第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。<br>由于 1 次操作后无法得到一个非空的栈，所以我们返回 <span class="hljs-string">-1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i], k &lt;= 10^9</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 <code>nums</code> 的长度是 <code>10^5</code> 的时候就感觉可以模拟了，然后 <code>k</code> 比这个大就说明可能会有一部分相对特殊的case；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumTop</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <br>        jilu_remove = []<br>        now_max = -<span class="hljs-number">1</span><br>        cnt_op = <span class="hljs-number">0</span><br>        index = <span class="hljs-number">0</span><br>        res = -<span class="hljs-number">1</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment">#</span><br>            <span class="hljs-keyword">if</span> cnt_op == k - <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># 判断是再拿一个的高，还是把加回去的高</span><br>                <span class="hljs-keyword">try</span>:<br>                    nayige = nums[index+<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">except</span>:<br>                    nayige = -<span class="hljs-number">1</span><br>                <br>                cnt_op += <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(now_max, nayige)<br>                <br>            <br>            <span class="hljs-keyword">elif</span> cnt_op &lt; k:  <span class="hljs-comment"># 代表还能操作</span><br>                jilu_remove.append(nums[index])<br>                <span class="hljs-keyword">if</span> nums[index] &gt; now_max:<br>                    now_max = nums[index]<br>                index += <span class="hljs-number">1</span><br>                cnt_op += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>        <br>        <span class="hljs-comment"># 最后还有可能出现还剩很多的情况，因为len(nums)比k小，到时候要判断情况的</span><br>        left_times = k - cnt_op<br>        jilu_remove.sort(reverse=<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_times: &quot;</span>, left_times)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;jilu_remove: &quot;</span>, jilu_remove)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;res: &quot;</span>, res)<br>        <br>        <br>        <span class="hljs-comment"># 当剩余操作次数为left_times时</span><br>        left_times %= (<span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_times: &quot;</span>, left_times)<br>        <br>        <span class="hljs-keyword">if</span> left_times &lt;= <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> left_times != <span class="hljs-number">0</span>:<br>            res = now_max<br>        <br>        <br>        <span class="hljs-keyword">if</span> left_times &gt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> left_times % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 奇数</span><br>                    res = now_max<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 偶数</span><br>                    <span class="hljs-keyword">try</span>:<br>                        res = jilu_remove[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">except</span>:<br>                        res = -<span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">else</span>:<br>                res = now_max<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2055.蜡烛之间的盘子-python</title>
    <link href="/2022/03/08/algorithms/leetcode-python/2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90-python/"/>
    <url>/2022/03/08/algorithms/leetcode-python/2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90-python/</url>
    
    <content type="html"><![CDATA[<p>2055.蜡烛之间的盘子（中等）</p><p>每日一题的话就不在这里完整粘贴题目的题面了，换用自己的想法写法说一说</p><p>这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/plates-between-candles/">题目链接</a></p><p>题目大意：</p><p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> ，其中 <code>&#39;*&#39;</code> 表示一个 <strong>盘子</strong> ，<code>&#39;|&#39;</code> 表示一支 <strong>蜡烛</strong> 。</p><p>同时给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [lefti, righti]</code> 表示 <strong>子字符串</strong> <code>s[lefti...righti]</code> <strong>（包含左右端点的字符）</strong>。对于每个查询，你需要找到 <strong>子字符串中</strong> 在 <strong>两支蜡烛之间</strong> 的盘子的 数目 。如果一个盘子在 <strong>子字符串中</strong> 左边和右边 <strong>都</strong> 至少有一支蜡烛，那么这个盘子满足在 <strong>两支蜡烛之间</strong> 。</p><ul><li>比方说，<code>s = &quot;||**||**|*&quot;</code> ，查询 <code>[3, 8]</code> ，表示的是子字符串 <code>&quot;*||**|&quot;</code> 。子字符串中在两支蜡烛之间的盘子数目为 <code>2</code> ，子字符串中右边两个盘子在它们左边和右边 <strong>都</strong> 至少有一支蜡烛。</li></ul><p>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-08-21-16-07.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;**|**|***|&quot;</span>, queries = [[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>解释：<br>- queries[<span class="hljs-number">0</span>] 有两个盘子在蜡烛之间。<br>- queries[<span class="hljs-number">1</span>] 有三个盘子在蜡烛之间。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-08-21-16-18.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;***|**|*****|**||**|*&quot;</span>, queries = [[<span class="hljs-number">1</span>,<span class="hljs-number">17</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">14</span>,<span class="hljs-number">17</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]]<br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<br>- queries[<span class="hljs-number">0</span>] 有 <span class="hljs-number">9</span> 个盘子在蜡烛之间。<br>- 另一个查询没有盘子在蜡烛之间。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> 。</li><li><code>1 &lt;= queries.length &lt;= 10^5</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= left_i &lt;= right_i &lt; s.length</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">platesBetweenCandles</span>(<span class="hljs-params">self, s, queries</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type queries: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 经典前缀题目思路</span><br>        <span class="hljs-comment"># 先遍历两边，找到每个位置的左边和右边第一次碰到蜡烛的位置</span><br>        <span class="hljs-comment"># 然后再看前缀和，截止到当前位置处，出现过几个*了</span><br>        left_candle_idx = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        right_candle_idx = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        plate_prefix_sum = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br><br><br>        <span class="hljs-comment"># 先正着走一遍，找到每个index位置处左边的那个candle的角标</span><br>        left = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                left = i<br>                left_candle_idx[i] = i<br>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                left_candle_idx[i] = left<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_candle_idx: &quot;</span>, left_candle_idx)<br><br><br>        <span class="hljs-comment"># 倒着走一遍，找到每个index位置处右边的那个candle的角标</span><br>        right = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                right = i<br>                right_candle_idx[i] = i<br>            <span class="hljs-keyword">else</span>:<br>                right_candle_idx[i] = right<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;right_candle_idx: &quot;</span>, right_candle_idx)<br><br>        <span class="hljs-comment"># 正着走找prefix</span><br>        prefix = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                prefix += <span class="hljs-number">1</span><br>            plate_prefix_sum[i] = prefix<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;plate_prefix_sum: &quot;</span>, plate_prefix_sum)<br><br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>            l, r = queries[i][<span class="hljs-number">0</span>], queries[i][<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 特殊处理</span><br>            <span class="hljs-keyword">if</span> l == r:<br>                res.append(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            tmp = plate_prefix_sum[left_candle_idx[r]]-plate_prefix_sum[right_candle_idx[l]]<br>            <span class="hljs-comment"># 这里可能还会有异常，一下不好想感觉只能通过case看一下</span><br>            res.append(tmp) <span class="hljs-keyword">if</span> tmp &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> res.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98.验证二叉搜索树-python</title>
    <link href="/2022/03/07/algorithms/leetcode-python/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-python/"/>
    <url>/2022/03/07/algorithms/leetcode-python/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>98.验证二叉搜索树（中等）</p><p>题目大意：</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-22-56-46.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-23-10-32.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目范围在 <code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：自己称为上界下界法"><a href="#解法一：自己称为上界下界法" class="headerlink" title="解法一：自己称为上界下界法"></a>解法一：自己称为上界下界法</h2><p>该种方法不需要用到额外的变量那种感觉， 开始从一个最小和一个最大开始作为入口，然后递归的判断每个节点是不是在是不是在这个范围内即可</p><p>（二叉搜索树的性质：各个节点的<code>val</code>都不能相同）</p><p>对于根节点，其肯定包含在最开始的上界&#x2F;下界内，然后就开始递归，根的左子树必须在<code>(最小, 根的val)</code>开区间内，右子树必须在<code>(根的val, 最大)</code>开区间内</p><p>另外注意，因为是判断的题，最后要返回一个<code>bool</code>的值，所以自递归的时候每个地方也要返回一个<code>True/False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 上界-下界法</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root, lower, upper</span>):<br><br>            <span class="hljs-comment"># 出口条件    </span><br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-comment"># False的条件</span><br>            <span class="hljs-keyword">if</span> root.val &lt;= lower <span class="hljs-keyword">or</span> root.val &gt;= upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-comment"># 左子树的值应该在lower，root.val开区间之间</span><br>            <br>            <span class="hljs-keyword">if</span> dfs(root.left, lower, root.val) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>            <span class="hljs-comment"># 右子树的值应该在root.val，upper开区间之间</span><br>            <span class="hljs-keyword">if</span> dfs(root.right, root.val, upper) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">return</span> dfs(root, -<span class="hljs-number">1e15</span>, <span class="hljs-number">1e15</span>)<br></code></pre></td></tr></table></figure><h2 id="解法二：全局变量法"><a href="#解法二：全局变量法" class="headerlink" title="解法二：全局变量法"></a>解法二：全局变量法</h2><p>二叉搜索树本质上就是中序遍历要是递增的，所以使用中序遍历的思想搞一个自递归的函数就差不多了</p><p>同样是注意，因为自递归的，每个地方要有个<code>bool</code>类的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.pre_val = -<span class="hljs-number">1e15</span>  <span class="hljs-comment"># 写在这里的当做全局变量了</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # 这里使用二叉树中序遍历的思想，把这个函数制作为一个自递归的</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 出口</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">if</span> self.isValidBST(root.left) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>: <span class="hljs-comment"># 中序的基础上要有返回值</span><br>            <span class="hljs-keyword">if</span> root.val &gt; self.pre_val:<br>                self.pre_val = root.val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">return</span> self.isValidBST(root.right)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39.组合总和-python</title>
    <link href="/2022/03/07/algorithms/leetcode-python/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-python/"/>
    <url>/2022/03/07/algorithms/leetcode-python/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>39.组合总和（中等）</p><p>题目大意：</p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><figure class="highlight plaintext"><figcaption><span>中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs candidates```"><br>对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。<br><br>&lt;!--more--&gt;<br><br># 题目<br><br>给你一个 **无重复元素** 的整数数组 ```candidates``` 和一个目标整数 ```target``` ，找出 ```candidates``` 中可以使数字和为目标数 ```target``` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。<br><br>```candidates``` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 <br><br>对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。<br><br>示例1：<br></code></pre></td></tr></table></figure><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br>示例2：<br></code></pre></td></tr></table></figure><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br>示例3：<br></code></pre></td></tr></table></figure><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>提示：<br>- ```1 &lt;= candidates.length &lt;= <span class="hljs-number">30</span>```<br>- ```1 &lt;= candidates[i] &lt;= <span class="hljs-number">200</span>```<br>- ```candidate``` 中的每个元素都 **互不相同**<br>- ```1 &lt;= target &lt;= <span class="hljs-number">500</span>```<br><br># 分析和解答<br><br>这个题是个经典的回溯题，首先想一个dfs的构造：<br><br>- 每次要把现在的now_sum传进去，代表dfs到每一层的时候现在加到多少了，用来进行出口条件的判断；<br>- 每次要判断一个位置选还是不选，这样的话假设一个数组长度是n，每次要把现在到第几个n传递下去，而因为是dfs，每次不需要传递i+<span class="hljs-number">1</span>，还是可以传递i的；<br>- 每次要把list给加上，代表dfs的时候，现在选了哪些了，然后在第一个条件如果到出口的话，就要把list append进去；<br><br>```dfs```的开始状态，按照这个思路就是```0，<span class="hljs-number">0</span>，[]```，然后出口条件如果等于则append列表，如果大于则```return```，之后走新的```dfs```条件，每次i从当前的```now_idx```取到```n```，每个状态都生成一个分支，这里可以进行一个剪枝，如果超过了就```break```掉，然后这样的话就可以开展第一轮```dfs```了，先把选这个```i```位置处的```append```进去，然后用```copy.deepcopy()```传一下到下一层，然后再```list = list[:-<span class="hljs-number">1</span>]```把这个去除掉<br><br>**另外特别注意，这个题的数组需要先排序一下，否则循环剪枝那里可能后边还有更小的就<span class="hljs-keyword">break</span>了不会被放进来了**<br><br>```python<br>res = []<br><span class="hljs-title">def dfs(now_sum, now_idx, now_list):</span><br><span class="hljs-title">    if now_sum == target:</span><br>        res.append(now_list)<br><span class="hljs-title">    if now_sum &gt; target:</span><br>        <span class="hljs-keyword">return</span><br>    <br><span class="hljs-title">    for i in range(now_idx, len(candidates)):</span><br><span class="hljs-title">        if now_sum + candidates[i] &gt; target:</span><br>            <span class="hljs-keyword">break</span><br>        now_list.append(candidates[i])<br>        dfs(now_sum + candidates[i], i, copy.deepcopy(now_list))  # 注意这里要deepcopy<br><span class="hljs-title">        now_list = now_list[:</span>-<span class="hljs-number">1</span>]  # 截断下<br></code></pre></td></tr></table></figure><p>当时写的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        candidates.sort()  <span class="hljs-comment"># 先排个序</span><br>        res = []<br>        <span class="hljs-comment"># 递归要找出口，一个条件一个条件的加入到参数中</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">now_sum, tmp_list, now_idx</span>):<br>            <span class="hljs-keyword">if</span> now_sum == target:<br>                <span class="hljs-comment"># 需要解决一个去重问题，多加一个位标记，代表只能从后边的开始选了，比如说开始选择了3之后，就不能再开始选前边的2了</span><br>                res.append(tmp_list)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> now_sum &gt; target:  <span class="hljs-comment"># 加爆了，不满足return</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(now_idx, <span class="hljs-built_in">len</span>(candidates)):<br>                    <span class="hljs-keyword">if</span> now_sum + candidates[i] &lt;= target:<br>                        tmp_list.append(candidates[i])<br>                        dfs(now_sum + candidates[i], copy.deepcopy(tmp_list), i)  <span class="hljs-comment"># 下一次这个now_idx只能从当前的i之后开始了，这样解决重复问题</span><br>                        tmp_list = tmp_list[:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 回溯</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br><br>        dfs(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283场LeetCode周赛</title>
    <link href="/2022/03/07/algorithms/leetcode-weekly-contest/283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/07/algorithms/leetcode-weekly-contest/283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次感觉就是从头卡到尾哈哈哈，每个题或多或少都卡了一下，感觉近几次做题真的思想越来越僵化了，也可能和太久没写代码了有关吧，2月轻松了一个月，3月开始真的忙碌了hhh，等哪天闲下来要完整总结下做题用到的一些常用结构了；</p><p>看了下有写笔记的是273到283，算上新年鸽了一次正好十次，感觉可以十次总结下，之后找时间先写个新的博客~</p><p>第一题：上来就不顺了下，要考虑python怎么做这种字符串的操作，查了一下才知道<code>ord()</code>可以把字母转化为ASCII表，然后再用<code>chr()</code>把ASCII字符转换回串，然后实际上是一个简单的二重循环遍历；</p><p>第二题：这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了，之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了，中间写起来细节感觉很多，还是被坑了不少的。另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？；</p><p>第三题：好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping），开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个，但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了；</p><p>第四题：鸽了鸽了；</p><span id="more"></span><h1 id="第一题：2194-Excel表中某个范围内的单元格"><a href="#第一题：2194-Excel表中某个范围内的单元格" class="headerlink" title="第一题：2194.Excel表中某个范围内的单元格"></a>第一题：2194.Excel表中某个范围内的单元格</h1><p><a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>Excel 表中的一个单元格 <code>(r, c)</code> 会以字符串 <code>&quot;&lt;col&gt;&lt;row&gt;&quot;</code> 的形式进行表示，其中：</p><ul><li><code>&lt;col&gt;</code> 即单元格的列号 <code>c</code> 。用英文字母表中的 <strong>字母</strong> 标识。<ul><li>例如，第 <code>1</code> 列用 <code>&#39;A&#39;</code> 表示，第 <code>2</code> 列用 <code>&#39;B&#39;</code> 表示，第 <code>3</code> 列用 <code>&#39;C&#39;</code> 表示，以此类推。</li></ul></li><li><code>&lt;row&gt;</code> 即单元格的行号 <code>r</code> 。第 <code>r</code> 行就用 整数 <code>r</code> 标识。</li></ul><p>给你一个格式为 <code>&quot;&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;&quot;</code> 的字符串 <code>s</code> ，其中 <code>&lt;col1&gt;</code> 表示 <code>c1</code> 列，<code>&lt;row1&gt;</code> 表示 <code>r1</code> 行，<code>&lt;col2&gt;</code> 表示 <code>c2</code> 列，<code>&lt;row2&gt;</code> 表示 <code>r2</code> 行，并满足 <code>r1 &lt;= r2</code> 且 <code>c1 &lt;= c2</code> 。</p><p>找出所有满足 <code>r1 &lt;= x &lt;= r2</code> 且 <code>c1 &lt;= y &lt;= c2</code> 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 <strong>字符串</strong> 表示，并以 <strong>非递减</strong> 顺序排列（先按列排，再按行排）。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-19-17-22.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;K1:L2&quot;</span><br>输出：[<span class="hljs-string">&quot;K1&quot;</span>,<span class="hljs-string">&quot;K2&quot;</span>,<span class="hljs-string">&quot;L1&quot;</span>,<span class="hljs-string">&quot;L2&quot;</span>]<br>解释：<br>上图显示了列表中应该出现的单元格。<br>红色箭头指示单元格的出现顺序。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-19-19-50.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;A1:F1&quot;</span><br>输出：[<span class="hljs-string">&quot;A1&quot;</span>,<span class="hljs-string">&quot;B1&quot;</span>,<span class="hljs-string">&quot;C1&quot;</span>,<span class="hljs-string">&quot;D1&quot;</span>,<span class="hljs-string">&quot;E1&quot;</span>,<span class="hljs-string">&quot;F1&quot;</span>]<br>解释：<br>上图显示了列表中应该出现的单元格。 <br>红色箭头指示单元格的出现顺序。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>s.length == 5</code></li><li><code>&#39;A&#39; &lt;= s[0] &lt;= s[3] &lt;= &#39;Z&#39;</code></li><li><code>&#39;1&#39; &lt;= s[1] &lt;= s[4] &lt;= &#39;9&#39;</code></li><li><code>s</code> 由大写英文字母、数字、和 <code>&#39;:&#39;</code> 组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p><code>ord(&quot;a&quot;)</code>是把一个字符转化为ASCII码表示，例如该句会输出<code>97</code></p><p><code>chr(97)</code>是把一个ASCII码（或者也不一定，就是数字）转化为字符表示，例如该句会输出<code>a</code></p><p>知道上边两个操作后怎么遍历就不是难事了，代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cellsInRange</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s_1 = s[<span class="hljs-number">0</span>]<br>        n_1 = s[<span class="hljs-number">1</span>]<br>        s_2 = s[<span class="hljs-number">3</span>]<br>        n_2 = s[<span class="hljs-number">4</span>]<br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">ord</span>(s_1), <span class="hljs-built_in">ord</span>(s_2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(n_1), <span class="hljs-built_in">int</span>(n_2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># print(chr(i))</span><br>                <span class="hljs-comment"># print(str(j))</span><br>                res.append(<span class="hljs-string">&quot;&quot;</span>.join([<span class="hljs-built_in">chr</span>(i), <span class="hljs-built_in">str</span>(j)])) <br>                <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：6017-向数组中追加K个整数"><a href="#第二题：6017-向数组中追加K个整数" class="headerlink" title="第二题：6017.向数组中追加K个整数"></a>第二题：6017.向数组中追加K个整数</h1><p><a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你向 nums 中追加 k 个 未 出现在 nums 中的、<strong>互不相同</strong> 的 <strong>正</strong> 整数，并使结果数组的元素和 <strong>最小</strong> 。</p><p>返回追加到 <code>nums</code> 中的 <code>k</code> 个整数之和。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,4,25,10,25], k = 2<br>输出：5<br>解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>。<br>nums 最终元素和为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 25 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 25 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 70 </span>，这是所有情况中的最小值。<br>所以追加到数组中的两个整数之和是<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>，所以返回<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [5,6], k = 6<br>输出：25<br>解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是<span class="hljs-number"> 1 </span>、2 、3 、4 、7 和<span class="hljs-number"> 8 </span>。<br>nums 最终元素和为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 36 </span>，这是所有情况中的最小值。<br>所以追加到数组中的两个整数之和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 25 </span>，所以返回<span class="hljs-number"> 25 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i], k &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了</p><p>之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了</p><p>中间写起来细节感觉很多，还是被坑了不少的。</p><p>另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimalKSum</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        orig_k = k<br>        <span class="hljs-comment"># res = sum(nums)</span><br>        res = <span class="hljs-number">0</span><br>        nums.append(<span class="hljs-number">0</span>)<br>        nums.sort()<br>        <span class="hljs-comment"># print(nums)</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            tmp = nums[i] - nums[i-<span class="hljs-number">1</span>]  - <span class="hljs-number">1</span>  <span class="hljs-comment"># 差</span><br>            <span class="hljs-comment"># print(tmp)</span><br>            <span class="hljs-keyword">if</span> k &gt; tmp:<br>                <span class="hljs-comment"># 求和tmp个</span><br>                <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span>) &gt;= nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:  <br>                    res += (((nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) +  (nums[i] - <span class="hljs-number">1</span>)) * tmp) // <span class="hljs-number">2</span><br>                    <span class="hljs-comment"># print(&#x27;a&#x27;, nums[i-1] + 1, nums[i] - 1)</span><br>                    k -= tmp<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 求和k个</span><br>                res += (((nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) +  (nums[i-<span class="hljs-number">1</span>] + k)) * k) // <span class="hljs-number">2</span><br>                <span class="hljs-comment"># print(&#x27;b&#x27;, nums[i-1] + 1,nums[i-1] + k)</span><br>                k -= tmp<br>                <span class="hljs-keyword">break</span><br>          <br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-comment"># print(k)</span><br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 某些问题？</span><br>            <span class="hljs-comment"># 如果全部中间不够了</span><br>            res += (<span class="hljs-built_in">max</span>(nums) + <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(nums) + k) * k // <span class="hljs-number">2</span><br>            <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：2196-根据描述创建二叉树"><a href="#第三题：2196-根据描述创建二叉树" class="headerlink" title="第三题：2196.根据描述创建二叉树"></a>第三题：2196.根据描述创建二叉树</h1><p><a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 descriptions ，其中 descriptions[i] &#x3D; [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：</p><ul><li>如果 isLefti &#x3D;&#x3D; 1 ，那么 childi 就是 parenti 的左子节点。</li><li>如果 isLefti &#x3D;&#x3D; 0 ，那么 childi 就是 parenti 的右子节点。</li></ul><p>请你根据 <code>descriptions</code> 的描述来构造二叉树并返回其 <strong>根节点</strong> 。</p><p>测试用例会保证可以构造出 <strong>有效</strong> 的二叉树。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-19-40-30.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：descriptions = <span class="hljs-comment">[<span class="hljs-comment">[20,15,1]</span>,<span class="hljs-comment">[20,17,0]</span>,<span class="hljs-comment">[50,20,1]</span>,<span class="hljs-comment">[50,80,0]</span>,<span class="hljs-comment">[80,19,1]</span>]</span><br>输出：<span class="hljs-comment">[50,20,80,15,17,19]</span><br>解释：根节点是值为 50 的节点，因为它没有父节点。<br>结果二叉树如上图所示。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-03-07-19-41-17.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：descriptions = <span class="hljs-comment">[<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[2,3,0]</span>,<span class="hljs-comment">[3,4,1]</span>]</span><br>输出：<span class="hljs-comment">[1,2,null,null,3,4]</span><br>解释：根节点是值为 1 的节点，因为它没有父节点。 <br>结果二叉树如上图所示。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= descriptions.length &lt;= 10^4</code></li><li><code>descriptions[i].length == 3</code></li><li><code>1 &lt;= parenti, childi &lt;= 10^5</code></li><li><code>0 &lt;= isLefti &lt;= 1</code></li><li><code>descriptions</code> 所描述的二叉树是一棵有效二叉树</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping）</p><p>开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个</p><p>但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了；</p><p>两轮，第一轮存节点+直接建树，然后第二轮找root作为返回；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">createBinaryTree</span>(<span class="hljs-params">self, descriptions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type descriptions: List[List[int]]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">pre_insert</span>(<span class="hljs-params">root, item</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">if</span> root.val == item[<span class="hljs-number">0</span>]:<br>                <span class="hljs-comment"># pre_insert(root, )</span><br>                <span class="hljs-keyword">if</span> item[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                    root.left = TreeNode(val=item[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    root.right = TreeNode(val=item[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            <span class="hljs-keyword">return</span> pre_insert(root.left, item) <span class="hljs-keyword">or</span> pre_insert(root.right, item)<br>        <br>        <br>        mapping = &#123;&#125;<br>        have_father = &#123;&#125;<br>        root = <span class="hljs-literal">None</span><br>        <br>        <span class="hljs-keyword">for</span> i, des <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(descriptions):<br>            <br>            <span class="hljs-keyword">if</span> mapping.get(des[<span class="hljs-number">0</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                mapping[des[<span class="hljs-number">0</span>]] = TreeNode(val=des[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">if</span> mapping.get(des[<span class="hljs-number">1</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>                mapping[des[<span class="hljs-number">1</span>]] = TreeNode(val=des[<span class="hljs-number">1</span>])<br>            <br>            <span class="hljs-comment"># 边记录边建树</span><br>            <span class="hljs-keyword">if</span> des[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                mapping[des[<span class="hljs-number">0</span>]].left = mapping[des[<span class="hljs-number">1</span>]]  <br>            <span class="hljs-keyword">else</span>:<br>                mapping[des[<span class="hljs-number">0</span>]].right = mapping[des[<span class="hljs-number">1</span>]]<br>            <br>            have_father[des[<span class="hljs-number">1</span>]] = <span class="hljs-literal">True</span><br>        <br>        <br>        <span class="hljs-comment"># print(have_father)</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i, des <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(descriptions):<br>            <span class="hljs-keyword">if</span> have_father.get(des[<span class="hljs-number">0</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> mapping[des[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-触控板左右滑动失效问题</title>
    <link href="/2022/02/28/macOS%E5%8F%8ALinux-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/macOS%E5%8F%8ALinux-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>需求：某些场景下（其实感觉是插拔HDMI线外接显示器的时候），可能出现触控板手势左右滑动失效的问题；</p><span id="more"></span><h1 id="解决办法-killall-Dock"><a href="#解决办法-killall-Dock" class="headerlink" title="解决办法 killall Dock"></a>解决办法 killall Dock</h1><p>在网上查到的解决办法，可在终端执行如下命令，即可通过类似一种自动重启的方法解决这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall Dock<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>282场LeetCode周赛</title>
    <link href="/2022/02/27/algorithms/leetcode-weekly-contest/282%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/27/algorithms/leetcode-weekly-contest/282%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>又是光速做完前两个题，然后盯着第三题发呆的一周周赛，第三题这次用到的思路是二分，感觉还是要多刷题多积累，可能需要找个时间复盘一下做题常用到的思路了吧哈哈哈，现在感觉思路有点打不开了，可能要阶段性总结梳理下吧，这样避免下有些想法太极端了~</p><p>第一题：这个题python有<code>str.startswtih()</code>函数，用这个返回值的<code>True</code>和<code>False</code>直接加就行了；</p><p>第二题：一眼看过去都有点没看懂这个题，后来感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了；</p><p>第三题：这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了；</p><p>第四题：鸽了鸽了；</p><span id="more"></span><h1 id="第一题：6008-统计包含给定前缀的字符串"><a href="#第一题：6008-统计包含给定前缀的字符串" class="headerlink" title="第一题：6008.统计包含给定前缀的字符串"></a>第一题：6008.统计包含给定前缀的字符串</h1><p><a href="https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p><p>返回 <code>words</code> 中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p><p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是  <code>s</code> 的任一前导连续字符串。</p><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;pay&quot;</span>,<span class="hljs-string">&quot;attention&quot;</span>,<span class="hljs-string">&quot;practice&quot;</span>,<span class="hljs-string">&quot;attend&quot;</span>], pref = <span class="hljs-string">&quot;at&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：以 <span class="hljs-string">&quot;at&quot;</span> 作为前缀的字符串有两个，分别是：<span class="hljs-string">&quot;attention&quot;</span> 和 <span class="hljs-string">&quot;attend&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-string">&quot;win&quot;</span>,<span class="hljs-string">&quot;loops&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>], pref = <span class="hljs-string">&quot;code&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：不存在以 <span class="hljs-string">&quot;code&quot;</span> 作为前缀的字符串。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li><li><code>words[i]</code> 和 <code>pref</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>直接调用python的<code>str.startswith(pref)</code>函数就可以，这里或许可以借机复习下Trie树的数据结构，每个节点由一个mapping的词典和<code>is_last</code>标记组成，第一次插入一个单词的时候就是不断创造mapping里边嵌套的mapping，中间的节点is_last都是False，最后的一个节点is_last设置成True；之后插入第二个单词的时候就有一种寻迹的感觉了，如果已经有了就不用重复插入；</p><p>p.s.没想到这题和某top10排名大佬代码一模一样哈哈哈，奇怪的开心点增加了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prefixCount</span>(<span class="hljs-params">self, words, pref</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type words: List[str]</span><br><span class="hljs-string">        :type pref: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">if</span> word.startswith(pref):<br>               res += <span class="hljs-number">1</span> <br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2186-使两字符串互为字母异位词的最少步骤数"><a href="#第二题：2186-使两字符串互为字母异位词的最少步骤数" class="headerlink" title="第二题：2186.使两字符串互为字母异位词的最少步骤数"></a>第二题：2186.使两字符串互为字母异位词的最少步骤数</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> 。在一步操作中，你可以给 <code>s</code> 或者 <code>t</code> 追加 <strong>任一字符</strong> 。</p><p>返回使 <code>s</code> 和 <code>t</code> 互为 <strong>字母异位词</strong> 所需的最少步骤数。</p><p><strong>字母异位词</strong> 指字母相同但是顺序不同（或者相同）的字符串。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coats&quot;</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>- 执行 <span class="hljs-number">2</span> 步操作，将 <span class="hljs-string">&quot;as&quot;</span> 追加到 s = <span class="hljs-string">&quot;leetcode&quot;</span> 中，得到 s = <span class="hljs-string">&quot;leetcodeas&quot;</span> 。<br>- 执行 <span class="hljs-number">5</span> 步操作，将 <span class="hljs-string">&quot;leede&quot;</span> 追加到 <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coats&quot;</span> 中，得到 <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coatsleede&quot;</span> 。<br><span class="hljs-string">&quot;leetcodeas&quot;</span> 和 <span class="hljs-string">&quot;coatsleede&quot;</span> 互为字母异位词。<br>总共用去 <span class="hljs-number">2</span> + <span class="hljs-number">5</span> = <span class="hljs-number">7</span> 步。<br>可以证明，无法用少于 <span class="hljs-number">7</span> 步操作使这两个字符串互为字母异位词。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;night&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;thing&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length, t.length &lt;= 2 * 10^5</code></li><li><code>s</code> 和 <code>t</code> 由小写英文字符组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看到这个题就想着要拟合测试样例，感觉能拟合测试样例可能就差不多能做出来了，然后看到第二个样例感觉就是比较明显的Counter了，感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSteps</span>(<span class="hljs-params">self, s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s_counter = Counter(s)<br>        t_counter = Counter(t)<br>        <span class="hljs-comment"># print(s_counter)</span><br>        <span class="hljs-comment"># print(t_counter)</span><br>        <br>        s_t_counter = s_counter - t_counter<br>        t_s_counter = t_counter - s_counter<br>        <br>        <span class="hljs-comment"># print(&quot;s_t_counter:&quot;, s_t_counter)</span><br>        <span class="hljs-comment"># print(&quot;t_s_counter:&quot;, t_s_counter)</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> s_t_counter.items():<br>            res += value<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> t_s_counter.items():<br>            res += value<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：2187-完成旅途的最少时间"><a href="#第三题：2187-完成旅途的最少时间" class="headerlink" title="第三题：2187.完成旅途的最少时间"></a>第三题：2187.完成旅途的最少时间</h1><p><a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个数组 <code>time</code> ，其中 <code>time[i]</code> 表示第 <code>i</code> 辆公交车完成 <strong>一趟旅途</strong> 所需要花费的时间。</p><p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong> 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。</p><p>给你一个整数 <code>totalTrips</code> ，表示所有公交车 <strong>总共</strong> 需要完成的旅途数目。请你返回完成 <strong>至少</strong> <code>totalTrips</code> 趟旅途需要花费的 <strong>最少</strong> 时间。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [1,2,3], totalTrips = 5<br>输出：3<br>解释：<br>- 时刻 t =<span class="hljs-number"> 1 </span>，每辆公交车完成的旅途数分别为 [1,0,0] 。<br>  已完成的总旅途数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 1 </span>。<br>- 时刻 t =<span class="hljs-number"> 2 </span>，每辆公交车完成的旅途数分别为 [2,1,0] 。<br>  已完成的总旅途数为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 3 </span>。<br>- 时刻 t =<span class="hljs-number"> 3 </span>，每辆公交车完成的旅途数分别为 [3,1,1] 。<br>  已完成的总旅途数为<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 5 </span>。<br>所以总共完成至少<span class="hljs-number"> 5 </span>趟旅途的最少时间为<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [2], totalTrips = 1<br>输出：2<br>解释：<br>只有一辆公交车，它将在时刻 t =<span class="hljs-number"> 2 </span>完成第一趟旅途。<br>所以完成<span class="hljs-number"> 1 </span>趟旅途的最少时间为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= time.length &lt;= 10^5</code></li><li><code>1 &lt;= time[i], totalTrips &lt;= 10^7</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了；</p><p>二分的过程细节需要把握下，就是 <code>right left = mid</code> 还是 <code>mid + 1</code> 还是 <code>mid - 1</code> 这类的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTime</span>(<span class="hljs-params">self, time, totalTrips</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type time: List[int]</span><br><span class="hljs-string">        :type totalTrips: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">mid, time, totalTrips</span>):<br>            tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> time:<br>                tmp += mid // t<br>            <br>            <span class="hljs-keyword">if</span> tmp &gt;= totalTrips:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>        left = <span class="hljs-number">1</span><br>        right = <span class="hljs-built_in">min</span>(time) * totalTrips<br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment"># 中间那个时间</span><br>            <span class="hljs-comment"># 判断中间那个时间是否可以完成</span><br>            <span class="hljs-keyword">if</span> judge(mid, time, totalTrips):<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>二分查找</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>281场LeetCode周赛</title>
    <link href="/2022/02/27/algorithms/leetcode-weekly-contest/281%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/27/algorithms/leetcode-weekly-contest/281%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>依旧是前两个题很简单，然后第三题直接卡到死的节奏，感觉近几次周赛第三题感觉都不是很好，可能需要阶段性的复习一下？</p><p>总结下来的话算法似乎都是在可以知道范围内的，比如这次题印象比较深的就是要正确理解题意或者说不要走到和题意错误的路上，有些题可能需要灵光一现用一些广泛用的Coutner、二分、前缀和、有限队列单调栈类的，有些题可能写着写着会有思路吧。</p><p>总之感觉刷题这个事还是要持续进行，总有瓶颈也总需要突破，冲！</p><p>第一题：看到<code>n &lt; 1000</code>感觉就直接暴力模拟就行了，模拟起来还是相对简单的，python对字符的操作太方便了；</p><p>第二题：一个链表的操作题，很简单就能搞定了，纯链表题现在感觉没有太难的；</p><p>第三题：这个题这次又卡的时间太长了，开始想的是排序后原地交换的思路，然后感觉就思维掉到一个坑里边了，一直在排序后原地交换一些细节条件里考虑来考虑去。后来大佬提醒说可以用Counter后排序贪心的思路，感觉这个思路一下就简单并且明确了；</p><p>第四题：鸽了鸽了。</p><span id="more"></span><h1 id="第一题：2180-统计各位数字之和为偶数的整数个数"><a href="#第一题：2180-统计各位数字之和为偶数的整数个数" class="headerlink" title="第一题：2180.统计各位数字之和为偶数的整数个数"></a>第一题：2180.统计各位数字之和为偶数的整数个数</h1><p><a href="https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p><p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 4<br>输出：2<br>解释：<br>只有<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>满足小于等于<span class="hljs-number"> 4 </span>且各位数字之和为偶数。 <br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：num = <span class="hljs-number">30</span><br>输出：<span class="hljs-number">14</span><br>解释：<br>只有 <span class="hljs-number">14</span> 个整数满足小于等于 <span class="hljs-number">30</span> 且各位数字之和为偶数，分别是： <br><span class="hljs-number">2、4、6、8</span>、<span class="hljs-number">11、13、15、17</span>、<span class="hljs-number">19、20、22、24</span>、<span class="hljs-number">26</span> 和 <span class="hljs-number">28</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= num &lt;= 1000</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>考虑到数据范围的1000，直接暴力就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countEven</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">n</span>):<br>            res = <span class="hljs-number">0</span><br>            str_n = <span class="hljs-built_in">str</span>(n)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str_n)):<br>                res += <span class="hljs-built_in">int</span>(str_n[i])<br>            <span class="hljs-keyword">return</span> res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> judge(i):<br>                res += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2181-合并零之间的节点"><a href="#第二题：2181-合并零之间的节点" class="headerlink" title="第二题：2181.合并零之间的节点"></a>第二题：2181.合并零之间的节点</h1><p><a href="https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p><p>对于每两个相邻的 &#96;&#96;&#96;0&#96;&#96; ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。</p><p>返回修改后链表的头节点 <code>head</code> 。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-27-22-48-01.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：head = [0,3,1,0,4,5,2,0]<br>输出：[4,11]<br>解释：<br>上图表示输入的链表。修改后的链表包含：<br>- 标记为绿色的节点之和：3 +<span class="hljs-number"> 1 </span>= 4<br>- 标记为红色的节点之和：4 +<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>= 11<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-27-22-48-28.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入：head = [0,1,0,3,0,2,2,0]<br>输出：[1,3,4]<br>解释：<br>上图表示输入的链表。修改后的链表包含：<br><span class="hljs-bullet">- </span>标记为绿色的节点之和：1 = 1<br><span class="hljs-bullet">- </span>标记为红色的节点之和：3 = 3<br><span class="hljs-bullet">- </span>标记为黄色的节点之和：2 + 2 = 4<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>列表中的节点数目在范围 <code>[3, 2 * 10^5]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><strong>不</strong> 存在连续两个 <code>Node.val == 0</code> 的节点</li><li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看起来提示里很多条件都是避免特殊情况用的，链表题比较复杂的地方在于经常有一些很极端的case只能靠测试样例来debug，很难一次想到，这个题没有这个问题不过也需要注意下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeNodes</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_head = ListNode(val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>)<br>        q = new_head<br><br>        tmp = <span class="hljs-number">0</span><br>        head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> head.val == <span class="hljs-number">0</span>:<br>                tmp_node = ListNode(val=tmp)<br>                q.<span class="hljs-built_in">next</span> = tmp_node<br>                q = q.<span class="hljs-built_in">next</span><br>                tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                tmp += head.val<br><br>            head = head.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> new_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="第三题：2182-构造限制重复的字符串"><a href="#第三题：2182-构造限制重复的字符串" class="headerlink" title="第三题：2182.构造限制重复的字符串"></a>第三题：2182.构造限制重复的字符串</h1><p><a href="https://leetcode-cn.com/problems/construct-string-with-repeat-limit/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>s</code> 和一个整数 <code>repeatLimit</code> ，用 <code>s</code> 中的字符构造一个新字符串 <code>repeatLimitedString</code> ，使任何字母 <strong>连续</strong> 出现的次数都不超过 <code>repeatLimit</code> 次。你不必使用 <code>s</code> 中的全部字符。</p><p>返回 <strong>字典序最大的</strong> <code>repeatLimitedString</code> 。</p><p>如果在字符串 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 中的字母在字母表中出现时间比字符串 <code>b</code> 对应的字母晚，则认为字符串 <code>a</code> 比字符串 <code>b</code> <strong>字典序更大</strong> 。如果字符串中前 <code>min(a.length, b.length)</code> 个字符都相同，那么较长的字符串字典序更大。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;cczazcc&quot;</span>, repeatLimit = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;zzcccac&quot;</span><br>解释：使用 s 中的所有字符来构造 repeatLimitedString <span class="hljs-string">&quot;zzcccac&quot;</span>。<br>字母 &#x27;a&#x27; 连续出现至多 <span class="hljs-number">1</span> 次。<br>字母 &#x27;c&#x27; 连续出现至多 <span class="hljs-number">3</span> 次。<br>字母 &#x27;z&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。<br>因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。<br>该字符串是字典序最大的 repeatLimitedString ，所以返回 <span class="hljs-string">&quot;zzcccac&quot;</span> 。<br>注意，尽管 <span class="hljs-string">&quot;zzcccca&quot;</span> 字典序更大，但字母 &#x27;c&#x27; 连续出现超过 <span class="hljs-number">3</span> 次，所以它不是一个有效的 repeatLimitedString 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;aababab&quot;</span>, repeatLimit = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;bbabaa&quot;</span><br>解释：<br>使用 s 中的一些字符来构造 repeatLimitedString <span class="hljs-string">&quot;bbabaa&quot;</span>。 <br>字母 &#x27;a&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。 <br>字母 &#x27;b&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。 <br>因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 <br>该字符串是字典序最大的 repeatLimitedString ，所以返回 <span class="hljs-string">&quot;bbabaa&quot;</span> 。 <br>注意，尽管 <span class="hljs-string">&quot;bbabaaa&quot;</span> 字典序更大，但字母 &#x27;a&#x27; 连续出现超过 <span class="hljs-number">2</span> 次，所以它不是一个有效的 repeatLimitedString 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; repeatLimit &lt;&#x3D; s.length &lt;&#x3D; 10^5</li><li><code>s</code>由小写英文字母组成</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题现场做的时候又做了好久好久，最后还是gg了，当时主要考虑的是一种排序后交换的思路，但是交换的思路最后就越换越乱，比如换完了后在那个位置的“指针”是否要++这样的；</p><p>后来大佬给了一种Counter计数排序后贪心的思路感觉能想到的话代码实现就比较简单了，每次取最头的元素，然后取够个数了后就交替取一个下一个，如果没有下一个就代表已经取不了了，这样实际上有一种类似于队列的小思想在里边</p><p>另外删除列表中的一个元素可以用<code>del tmp[i]</code>这样的操作来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatLimitedString</span>(<span class="hljs-params">self, s, repeatLimit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type repeatLimit: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 还是要多锻炼多总结思路hhh</span><br>        <span class="hljs-comment"># 一种贪心算法的思想，Counter后排序，然后相对贪心一点的拿就行了</span><br>        <span class="hljs-comment"># 开始的思路想的是排序后有一种原地交换的感觉，但后来还是换着换着就乱了</span><br>        <br>        counter_s = Counter(s)<br>        <span class="hljs-comment"># print(counter_s)</span><br>        counter_s_list = <span class="hljs-built_in">sorted</span>([<span class="hljs-built_in">list</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> counter_s.items()], key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>        counter_s_list.reverse()<br>        <span class="hljs-comment"># print(counter_s_list)</span><br><br>        result = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(counter_s_list):  <span class="hljs-comment"># 循环直到为空为止，这里不用循环变量i，直接用0就行了</span><br>            <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;= repeatLimit:<br>                result.append(counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br>                counter_s_list = counter_s_list[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">else</span>:<br>                result.append(counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * repeatLimit)<br>                counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -= repeatLimit<br>                <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 如果还有的话，如果此时列表就1个了，就结束，否则和下一个交换</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(counter_s_list) &gt; <span class="hljs-number">1</span>:<br>                        result.append(counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>                        counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                            <span class="hljs-comment"># counter_s_list = counter_s_list[:1] + counter_s_list[2:]  # 去掉，这里写的其实不够简化</span><br>                            <span class="hljs-keyword">del</span> counter_s_list[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br><br>        <br>        <span class="hljs-comment"># print(result)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(result)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>链表</tag>
      
      <tag>计数</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>78.子集-python</title>
    <link href="/2022/02/21/algorithms/leetcode-python/78-%E5%AD%90%E9%9B%86-python/"/>
    <url>/2022/02/21/algorithms/leetcode-python/78-%E5%AD%90%E9%9B%86-python/</url>
    
    <content type="html"><![CDATA[<p>78.子集（中等）</p><p>题目大意：</p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：2-n遍历法"><a href="#解法一：2-n遍历法" class="headerlink" title="解法一：2^n遍历法"></a>解法一：2^n遍历法</h2><p>在某次周赛的时候积累到了这个思路，可以通过位运算的方法把0到n的二进制每个位的表示都提取出来，这样就可以实现每个位置选择&#x2F;不选择的2^n遍历法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 某次周赛积累到的2^n这种的遍历思路，可以实现暴力非递归</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_bits</span>(<span class="hljs-params">num</span>):<br>            l = []<br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                l.append(num&amp;<span class="hljs-number">1</span>)<br>                num &gt;&gt;= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> l<br><br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(nums)):<br>            l = get_bits(i)<br>            tmp = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>                <span class="hljs-keyword">if</span> l[j] == <span class="hljs-number">1</span>:<br>                    tmp.append(nums[j])<br>            ans.append(tmp)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="解法二：dfs回溯法"><a href="#解法二：dfs回溯法" class="headerlink" title="解法二：dfs回溯法"></a>解法二：dfs回溯法</h2><p>dfs的方法在本质上也是针对每个位置的选择，不选择。所以每次carry到递归下一个轮次状态就是位置i，<strong>针对位置i的选择和不选择两条dfs分支</strong>。</p><p>另外在这个题里发现dfs的时候需要deepcopy复制一份，列表在dfs过程中不能指向相同的地址，否则一个改动了就全部改动了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归思路，这个题涉及到了python的深浅拷贝问题，在dfs向下一层的时候本质上是复制了状态，所以要拷贝</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, tmp_list</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            :type i: int，代表当前到了dfs的第几层了</span><br><span class="hljs-string">            : type tmp_list: List[int]，代表当前带着哪些下到下一层了！！！！</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums):  <span class="hljs-comment"># 这类的递归一般用长度作为出口</span><br>                res.append(tmp_list)<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-comment"># 不取的dfs分支</span><br>            dfs(i+<span class="hljs-number">1</span>, copy.deepcopy(tmp_list))  <span class="hljs-comment"># 这里要传拷贝，否则会搞到一个分支上！！！</span><br>            <span class="hljs-comment"># 取的dfs分支</span><br>            tmp_list.append(nums[i])<br>            dfs(i+<span class="hljs-number">1</span>, copy.deepcopy(tmp_list))  <span class="hljs-comment"># 这里要传拷贝</span><br>            <br>        dfs(<span class="hljs-number">0</span>, [])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表的倒数第N个结点-python</title>
    <link href="/2022/02/21/algorithms/leetcode-python/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-python/"/>
    <url>/2022/02/21/algorithms/leetcode-python/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-python/</url>
    
    <content type="html"><![CDATA[<p>19.删除链表的倒数第 N 个结点（中等）</p><p>题目大意：</p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><p>题目大意：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-21-23-49-06.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这是一个经典的双指针题目了，保持pq指针之间的距离差是n，然后当p先到结尾后，把q.next那个地方删除了就可以。</p><p>这个题比较麻烦的地方在于很难一次性做对，需要自己构造一些相对极端的的case来测试下，例如只有一个节点的链表这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 注意自己构造一些badcase的例子，来把所有特殊情况覆盖掉</span><br>        <span class="hljs-comment"># 双指针法，双指针之间的差距是n</span><br>        p = head<br>        q = head<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            q = q.<span class="hljs-built_in">next</span><br>            i += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 让q指向最后一个不为None的，有一个异常情况是q已经是None了，应该删除头结点</span><br>        <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> q.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            p = p.<span class="hljs-built_in">next</span><br>            q = q.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 删除p</span><br>        p.<span class="hljs-built_in">next</span> = p.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101.对称二叉树-python</title>
    <link href="/2022/02/14/algorithms/leetcode-python/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-python/"/>
    <url>/2022/02/14/algorithms/leetcode-python/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>101.对称二叉树（简单）</p><p>题目大意：</p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">题目链接</a></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-14-15-53-42.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-14-15-53-53.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这种题又和完全的自递归题目有些区别，需要再构造一个dfscheck的函数，来套一下递归。</p><p>这个<code>dfs_check()</code>函数的输入是两个root这样的感觉，先判断当前节点的左右是否相等，然后往下嵌套递归，判断当前节点的左的左和当前节点右的右，还有当前节点左的右和当前节点右的左是不是一样就行了，在前边要加入一些None的出口递归条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_check</span>(<span class="hljs-params">root1, root2</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            用于判断一个点的左右子树是否轴对称，首次输入两个都是这个树的根</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-comment"># 当前节点的左右，然后递归下一层的左右！</span><br>            <span class="hljs-keyword">return</span> root1.val == root2.val <span class="hljs-keyword">and</span> dfs_check(root1.left, root2.right) <span class="hljs-keyword">and</span> dfs_check(root1.right, root2.left)<br><br>        <span class="hljs-keyword">return</span> dfs_check(root, root)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>617.合并二叉树-python</title>
    <link href="/2022/02/14/algorithms/leetcode-python/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-python/"/>
    <url>/2022/02/14/algorithms/leetcode-python/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>617.合并二叉树（简单）</p><p>题目大意：</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目链接</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-02-14-15-33-49.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这个题有一种自递归的感觉，题目的初始Solution类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1, root2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root1: TreeNode</span><br><span class="hljs-string">        :type root2: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>rtype是一个TreeNode类型的，所以能有一种自递归的感觉，先建立TreeNode，然后</p><p>这种自递归的题还是可以先把主干写好了，再决定递归出口那样的感觉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1, root2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root1: TreeNode</span><br><span class="hljs-string">        :type root2: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 整个题目有一种自递归的感觉</span><br>        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root2<br>        <span class="hljs-keyword">if</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root1<br>        <br>        merged_node = TreeNode(val=root1.val + root2.val)<br>        merged_node.left = self.mergeTrees(root1.left, root2.left)<br>        merged_node.right = self.mergeTrees(root1.right, root2.right)<br><br>        <span class="hljs-keyword">return</span>  merged_node<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>280场LeetCode周赛</title>
    <link href="/2022/02/14/algorithms/leetcode-weekly-contest/280%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/14/algorithms/leetcode-weekly-contest/280%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周做的状态和水平感觉都不是很好，第一个题做下去的时候就感觉不是很顺，第二个题直接就卡住了，感觉还是把第二题想的太简单或者说样例分析不太够？第三题直接没来得及看，最后复盘的时候感觉比赛有规定的时间内也不一定好想，和之前某一周ABCDE的前后缀和有点像，但是简单了一些；</p><p>第一题：一种模拟操作的感觉就行了？开始还以为要一些数学的操作，这种题如果告诉难度的话可能比较简单，但是如果不知道难度比较怕想到数学题上边去；</p><p>第二题：这个题当时做的时候直接就卡死了，卡了可以说一个多小时，还是样例可能误导了一种的感觉，最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了；</p><p>第三题：一种前缀和，或者说<strong>反向思路</strong>的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的；</p><p>第四题：鸽！</p><span id="more"></span><h1 id="第一题：2169-得到0的操作数"><a href="#第一题：2169-得到0的操作数" class="headerlink" title="第一题：2169.得到0的操作数"></a>第一题：2169.得到0的操作数</h1><p><a href="https://leetcode-cn.com/problems/count-operations-to-obtain-zero/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个 <strong>非负</strong> 整数 <code>num1</code> 和 <code>num2</code> 。</p><p>每一步 <strong>操作</strong> 中，如果 <code>num1 &gt;= num2</code> ，你必须用 <code>num1</code> 减 <code>num2</code> ；否则，你必须用 <code>num2</code> 减 <code>num1</code> 。</p><ul><li>例如， <code>num1 = 5</code> 且 <code>num2 = 4</code> ，应该用 <code>num1</code> 减 <code>num2</code> ，因此，得到 <code>num1 = 1</code> 和 <code>num2 = 4</code> 。然而，如果 <code>num1 = 4</code> 且 <code>num2 = 5</code> ，一步操作后，得到 <code>num1 = 4</code> 和 <code>num2 = 1</code> 。</li></ul><p>返回使 <code>num1 = 0</code> 或 <code>num2 = 0</code> 的 <strong>操作数</strong> 。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>- 操作 <span class="hljs-number">1</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span> 。由于 <span class="hljs-symbol">num1</span> &lt; <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num2</span> 减 <span class="hljs-symbol">num1</span> 得到 <span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span> - <span class="hljs-number">2</span> = <span class="hljs-number">1</span> 。<br>- 操作 <span class="hljs-number">2</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> &gt; <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 。<br>- 操作 <span class="hljs-number">3</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">1</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 。<br>此时 <span class="hljs-symbol">num1</span> = <span class="hljs-number">0</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-number">0</span> ，不需要再执行任何操作。<br>所以总操作数是 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>- 操作 <span class="hljs-number">1</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 得到 <span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span> - <span class="hljs-number">10</span> = <span class="hljs-number">0</span> 。<br>此时 <span class="hljs-symbol">num1</span> = <span class="hljs-number">0</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-number">0</span> ，不需要再执行任何操作。<br>所以总操作数是 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= num1, num2 &lt;= 105</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始还以为需要一些数学的操作，没想到直接循环模拟就行了，注意python的两个数值交换可以使用如下代码直接交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = b, a<br></code></pre></td></tr></table></figure><p>看了一些题解说是可以用辗转相除法，不禁想到信安数学里学过为数不多的数论知识都还给老师了哈哈哈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countOperations</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num1: int</span><br><span class="hljs-string">        :type num2: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> num1 == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> num2 == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> num1 &lt; num2:<br>                num1, num2 = num2, num1<br>            <span class="hljs-keyword">if</span> num1 &gt;= num2:<br>                num1 = num1 - num2<br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(num1, num2)</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：2170-使数组变成交替数组的最少操作数"><a href="#第二题：2170-使数组变成交替数组的最少操作数" class="headerlink" title="第二题：2170.使数组变成交替数组的最少操作数"></a>第二题：2170.使数组变成交替数组的最少操作数</h1><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，该数组由 <code>n</code> 个正整数组成。</p><p>如果满足下述条件，则数组 nums 是一个 <strong>交替数组</strong> ：</p><ul><li><code>nums[i - 2] == nums[i]</code> ，其中 <code>2 &lt;= i &lt;= n - </code> 。</li><li><code>nums[i - 1] != nums[i]</code> ，其中 <code>1 &lt;= i &lt;= n - 1</code> 。</li></ul><p>在一步 <strong>操作</strong> 中，你可以选择下标 <code>i</code> 并将 <code>nums[i]</code> <strong>更改</strong> 为 <strong>任一</strong> 正整数。</p><p>返回使数组变成交替数组的 <strong>最少操作数</strong> 。</p><p>示例1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,3,2,4,3]</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>使数组变成交替数组的方法之一是将该数组转换为 <span class="hljs-string">[3,1,3,1,3,1]</span> 。<br>在这种情况下，操作数为 <span class="hljs-number">3</span> 。<br>可以证明，操作数少于 <span class="hljs-number">3</span> 的情况下，无法使数组变成交替数组。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>使数组变成交替数组的方法之一是将该数组转换为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>].<br>在这种情况下，操作数为 <span class="hljs-number">2</span> 。<br>注意，数组不能转换成 [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。因为在这种情况下，nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]，不满足交替数组的条件。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉还是个很考思路的题，一旦有一些理解错或者路走歪了就容易做不出来了。</p><p>最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumOperations</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        oushu = [nums[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>)]<br>        jishu = [nums[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>)]<br>        oushu_counter = Counter(oushu)<br>        jishu_counter = Counter(jishu)<br>        <br>        <br>        oushu_counter_value = <span class="hljs-built_in">sorted</span>(oushu_counter.items(), key=<span class="hljs-keyword">lambda</span> x: -x[<span class="hljs-number">1</span>])<br>        jishu_counter_value = <span class="hljs-built_in">sorted</span>(jishu_counter.items(), key=<span class="hljs-keyword">lambda</span> x: -x[<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># 三种情况</span><br>        <span class="hljs-keyword">if</span> oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] != jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:<br>            max_num = oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oushu_counter_value) &lt; <span class="hljs-number">2</span>:<br>                oushu_counter_value.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>             <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(jishu_counter_value) &lt; <span class="hljs-number">2</span>:<br>                jishu_counter_value.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            <br>            <br>            max_num = <span class="hljs-built_in">max</span>(oushu_counter_value[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) - max_num<br></code></pre></td></tr></table></figure><h1 id="第三题：2171-拿出最少数目的魔法豆"><a href="#第三题：2171-拿出最少数目的魔法豆" class="headerlink" title="第三题：2171.拿出最少数目的魔法豆"></a>第三题：2171.拿出最少数目的魔法豆</h1><p><a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/comments/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 正 整数数组 <code>beans</code> ，其中每个整数表示一个袋子里装的魔法豆的数目。</p><p>请你从每个袋子中 <strong>拿出</strong> 一些豆子（也可以 <strong>不拿出</strong> ），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少</strong> 还有 一颗 魔法豆的袋子）魔法豆的数目 <strong>相等</strong> 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。</p><p>请你返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：beans = [4,1,6,5]<br>输出：4<br>解释：<br>- 我们从有<span class="hljs-number"> 1 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 1 </span>颗魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,6,5]<br>- 然后我们从有<span class="hljs-number"> 6 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,4,5]<br>- 然后我们从有<span class="hljs-number"> 5 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 1 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,4,4]<br>总共拿出了<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>个魔法豆，剩下非空袋子中魔法豆的数目相等。<br>没有比取出<span class="hljs-number"> 4 </span>个魔法豆更少的方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：beans = [2,10,3,2]<br>输出：7<br>解释：<br>- 我们从有<span class="hljs-number"> 2 </span>个魔法豆的其中一个袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,3,2]<br>- 然后我们从另一个有<span class="hljs-number"> 2 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,3,0]<br>- 然后我们从有<span class="hljs-number"> 3 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 3 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,0,0]<br>总共拿出了<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>个魔法豆，剩下非空袋子中魔法豆的数目相等。<br>没有比取出<span class="hljs-number"> 7 </span>个魔法豆更少的方案。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= beans.length &lt;= 105</code></li><li><code>1 &lt;= beans[i] &lt;= 105</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一眼看过去这种题目肯定是要排序的，后边发现只要排序+枚举就可以了，有一种反向思路的感觉</p><p>一种前缀和，或者说<strong>反向思路</strong>的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumRemoval</span>(<span class="hljs-params">self, beans</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type beans: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 第i个地方最多保留(n-i) * beans[i]个</span><br>        <br>        beans.sort()<br>        <br>        total = <span class="hljs-number">0</span><br>        max_save = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(beans)):<br>            total += beans[i]<br>            max_save = <span class="hljs-built_in">max</span>(max_save, (<span class="hljs-built_in">len</span>(beans)-i) * beans[i])<br>        <br>        <span class="hljs-keyword">return</span> total - max_save<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>贪心</tag>
      
      <tag>前缀和</tag>
      
      <tag>计数</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279场LeetCode周赛</title>
    <link href="/2022/02/07/algorithms/leetcode-weekly-contest/279%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/07/algorithms/leetcode-weekly-contest/279%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次手感还可以，在比赛时间做出了三个题，回看复盘的时候感觉当时状态可能确实好hhh，思路一路做下来没有中断的感觉。一些常见的操作包括filp一类的，还有就是下边这段代码可以直接取出来奇偶下标的！（实际是在280周赛复盘发现的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums[::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出偶数下标的value</span><br>nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出奇数下标的value</span><br></code></pre></td></tr></table></figure><p>还有个是index截断的重拼接可以使用下边这种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>第一题：印象比较深的是要把奇数偶数下标的分开拍，注意审题的感觉；</p><p>第二题：也是一个排序的思路，可以分大于0小于0两种情况分类讨论，还是很容易区分状态的；</p><p>第三题：一种设计题的思路，第一次很简单的做很快就超时了，超时后复盘发现可以用一些标识为来进行一些标志，有一个filp操作，标志出filp_status后，其他的操作都可以通过cnt直接O(1)的返回了，做题的时候状态比较好，感觉这个题还是没那么好想，也可能是做的时候根据badcase发现了优化思路吧；</p><p>第四题：鸽！</p><span id="more"></span><h1 id="第一题：2164-对奇偶下标分别排序"><a href="#第一题：2164-对奇偶下标分别排序" class="headerlink" title="第一题：2164.对奇偶下标分别排序"></a>第一题：2164.对奇偶下标分别排序</h1><p><a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。根据下述规则重排 <code>nums</code> 中的值：</p><ol><li>按 非递增 顺序排列 <code>nums</code> <strong>奇数下标</strong> 上的所有值。</li></ol><ul><li>举个例子，如果排序前 <code>nums = [4,1,2,3]</code> ，对奇数下标的值排序后变为 <code>[4,3,2,1]</code> 。奇数下标 <code>1</code> 和 <code>3</code> 的值按照非递增顺序重排。</li></ul><ol start="2"><li>按 非递减 顺序排列 <code>nums</code> <strong>偶数下标</strong> 上的所有值。</li></ol><ul><li>举个例子，如果排序前 <code>nums = [4,1,2,3]</code> ，对偶数下标的值排序后变为 <code>[2,1,4,3]</code> 。偶数下标 <code>0</code> 和 <code>2</code> 的值按照非递减顺序重排。</li></ul><p>返回重排 <code>nums</code> 的值之后形成的数组。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,1,2,3</span>]<br>输出：[<span class="hljs-number">2,3,4,1</span>]<br>解释：<br>首先，按非递增顺序重排奇数下标（<span class="hljs-number">1</span> 和 <span class="hljs-number">3</span>）的值。<br>所以，nums 从 [<span class="hljs-number">4,1,2,3</span>] 变为 [<span class="hljs-number">4,3,2,1</span>] 。<br>然后，按非递减顺序重排偶数下标（<span class="hljs-number">0</span> 和 <span class="hljs-number">2</span>）的值。<br>所以，nums 从 [<span class="hljs-number">4,1,2,3</span>] 变为 [<span class="hljs-number">2,3,4,1</span>] 。<br>因此，重排之后形成的数组是 [<span class="hljs-number">2,3,4,1</span>] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1]</span><br>输出：<span class="hljs-comment">[2,1]</span><br>解释：<br>由于只有一个奇数下标和一个偶数下标，所以不会发生重排。<br>形成的结果数组是 <span class="hljs-comment">[2,1]</span> ，和初始数组一样。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题主要是审题，开始审题错了还被坑了一回，注意是奇偶数下标这样的。</p><p>然后就是280场周赛get到的一个技巧，用下边这个代码操作可以把奇数偶数间隔的取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums[::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出偶数下标的value</span><br>nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出奇数下标的value</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortEvenOdd</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        o_index = nums[::<span class="hljs-number">2</span>]<br>        j_index = nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>        o_index.sort()<br>        j_index.sort(key=<span class="hljs-keyword">lambda</span> x: -x)<br><br>        result = []<br>        j = <span class="hljs-number">0</span><br>        k = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                result.append(o_index[j])<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(j_index[k])<br>                k += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第二题：2165-重排数字的最小值"><a href="#第二题：2165-重排数字的最小值" class="headerlink" title="第二题：2165.重排数字的最小值"></a>第二题：2165.重排数字的最小值</h1><p><a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数 <code>num</code> 。<strong>重排</strong> <code>num</code> 中的各位数字，使其值 <strong>最小化</strong> 且不含 <strong>任何</strong> 前导零。</p><p>返回不含前导零且值最小的重排数字。</p><p>注意，重排各位数字后，<code>num</code> 的符号不会改变。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：num = <span class="hljs-number">310</span><br>输出：<span class="hljs-number">103</span><br>解释：<span class="hljs-number">310</span> 中各位数字的可行排列有：<span class="hljs-number">013、031</span>、<span class="hljs-number">103、130、301</span>、<span class="hljs-number">310</span> 。<br>不含任何前导零且值最小的重排数字是 <span class="hljs-number">103</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：num = <span class="hljs-string">-7605</span><br>输出：<span class="hljs-string">-7650</span><br>解释：<span class="hljs-string">-7605</span> 中各位数字的部分可行排列为：<span class="hljs-string">-7650</span>、<span class="hljs-string">-6705</span>、<span class="hljs-string">-5076</span>、<span class="hljs-string">-0567</span>。<br>不含任何前导零且值最小的重排数字是 <span class="hljs-string">-7650</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>-10^15 &lt;= num &lt;= 10^15</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>要分开处理正数和负数的情况，然后贪心思路的感觉。在str和int类型之间来回转化。</p><p>如果是正数的处理要稍微复杂一点点，就是第一位不能以0起头，要选择一个不是0的index作为起头。</p><p>注意列表的拼接，可以使用如下的操作方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><p>题目解答如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestNumber</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        r_list = []<br><br>        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>:<br>            s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(-num))<br>            s.sort(key=<span class="hljs-keyword">lambda</span> x: -<span class="hljs-built_in">int</span>(x))<br>            <span class="hljs-comment"># 选一个最大的（第一个就是），进行重组</span><br>            return_int = -<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(s))<br>            <span class="hljs-comment"># print(return_int)</span><br>            <br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># num &gt;= 0</span><br>            s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(num))<br>            s.sort()<br>            <br>            index = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(s[i]) != <span class="hljs-number">0</span>:<br>                    index = i<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-built_in">print</span>(index)<br>            return_int = <span class="hljs-built_in">int</span>(s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:]))<br>            <span class="hljs-comment"># print(return_int)</span><br>    <br>        <span class="hljs-keyword">return</span> return_int<br></code></pre></td></tr></table></figure><h1 id="第三题：2166-设计位集"><a href="#第三题：2166-设计位集" class="headerlink" title="第三题：2166.设计位集"></a>第三题：2166.设计位集</h1><p><a href="https://leetcode-cn.com/problems/design-bitset/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>位集 Bitset</strong> 是一种能以紧凑形式存储位的数据结构。</p><p>请你实现 <code>Bitset</code> 类。</p><ul><li><code>Bitset(int size)</code> 用 <code>size</code> 个位初始化 Bitset ，所有位都是 <code>0</code> 。</li><li><code>void fix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>1</code> 。如果值已经是 <code>1</code> ，则不会发生任何改变。</li><li><code>void unfix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>0</code> 。如果值已经是 <code>0</code> ，则不会发生任何改变。</li><li><code>void flip()</code> 翻转 Bitset 中每一位上的值。换句话说，所有值为 <code>0</code> 的位将会变成 <code>1</code> ，反之亦然。</li><li><code>boolean all()</code> 检查 Bitset 中 <strong>每一位</strong> 的值是否都是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>boolean one()</code> 检查 Bitset 中 是否 <strong>至少一位</strong> 的值是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int count()</code> 返回 Bitset 中值为 1 的位的 <strong>总数</strong> 。</li><li><code>String toString()</code> 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 <code>i</code> 个下标处的字符应该与 Bitset 中的第 <code>i</code> 位一致。</li></ul><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入<br>[<span class="hljs-string">&quot;Bitset&quot;</span>, <span class="hljs-string">&quot;fix&quot;</span>, <span class="hljs-string">&quot;fix&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;unfix&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;unfix&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>], [], [], [<span class="hljs-number">0</span>], [], [], [<span class="hljs-number">0</span>], [], []]<br>输出<br>[null, null, null, null, false, null, null, true, null, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;01010&quot;</span>]<br><br>解释<br>Bitset bs = new Bitset(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> bitset = <span class="hljs-string">&quot;00000&quot;</span>.<br>bs.fix(<span class="hljs-number">3</span>);     <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">3</span> 处的值更新为 <span class="hljs-number">1</span> ，此时 bitset = <span class="hljs-string">&quot;00010&quot;</span> 。<br>bs.fix(<span class="hljs-number">1</span>);     <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">1</span> 处的值更新为 <span class="hljs-number">1</span> ，此时 bitset = <span class="hljs-string">&quot;01010&quot;</span> 。<br>bs.flip();     <span class="hljs-regexp">//</span> 翻转每一位上的值，此时 bitset = <span class="hljs-string">&quot;10101&quot;</span> 。<br>bs.all();      <span class="hljs-regexp">//</span> 返回 False ，bitset 中的值不全为 <span class="hljs-number">1</span> 。<br>bs.unfix(<span class="hljs-number">0</span>);   <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">0</span> 处的值更新为 <span class="hljs-number">0</span> ，此时 bitset = <span class="hljs-string">&quot;00101&quot;</span> 。<br>bs.flip();     <span class="hljs-regexp">//</span> 翻转每一位上的值，此时 bitset = <span class="hljs-string">&quot;11010&quot;</span> 。<br>bs.one();      <span class="hljs-regexp">//</span> 返回 True ，至少存在一位的值为 <span class="hljs-number">1</span> 。<br>bs.unfix(<span class="hljs-number">0</span>);   <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">0</span> 处的值更新为 <span class="hljs-number">0</span> ，此时 bitset = <span class="hljs-string">&quot;01010&quot;</span> 。<br>bs.count();    <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">2</span> ，当前有 <span class="hljs-number">2</span> 位的值为 <span class="hljs-number">1</span> 。<br>bs.toString(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-string">&quot;01010&quot;</span> ，即 bitset 的当前组成情况。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= size &lt;= 10^5</code></li><li><code>0 &lt;= idx &lt;= size - 1</code></li><li>至多调用 <code>fix</code>、<code>unfix</code>、<code>flip</code>、<code>all</code>、<code>one</code>、<code>count</code> 和 <code>toString</code> 方法 总共 <code>10^5</code> 次</li><li>至少调用 <code>all</code>、<code>one</code>、<code>count</code> 或 <code>toString</code> 方法一次</li><li>至多调用 <code>toString</code> 方法 <code>5</code> 次</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>要通过一个filp的操作把很多操作都变成O(1)的，</p><ul><li>fix和unfix的操作因为是数组角标的操作，所以是O(1)的，但是注意这个操作要根据filp的状态来决定</li><li>filp直接把self.filp_status修改了就行O(1)</li><li>all、one、count根据cnt值和filp_status共同确定也可以O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitset</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type size: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 都放在初始化里？</span><br>        self.bs = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        self.cnt = <span class="hljs-number">0</span><br>        self.filp_status = <span class="hljs-number">0</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fix</span>(<span class="hljs-params">self, idx</span>):  <span class="hljs-comment"># 这个没的改了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type idx: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.bs[idx] != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">1</span><br>            self.cnt += <span class="hljs-number">1</span>    <br>        <span class="hljs-keyword">elif</span> self.filp_status == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.bs[idx] != <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">0</span><br>            self.cnt += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unfix</span>(<span class="hljs-params">self, idx</span>):  <span class="hljs-comment"># 这个没的改了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type idx: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.bs[idx] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">0</span><br>            self.cnt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.filp_status == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.bs[idx] != <span class="hljs-number">1</span>:<br>            self.bs[idx] = <span class="hljs-number">1</span><br>            self.cnt -= <span class="hljs-number">1</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flip</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 翻转了</span><br>        <span class="hljs-keyword">if</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.filp_status = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            self.filp_status = <span class="hljs-number">0</span><br>        self.cnt = <span class="hljs-built_in">len</span>(self.bs) - self.cnt<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cnt == <span class="hljs-built_in">len</span>(self.bs):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">one</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cnt &gt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.cnt<br>        <br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.filp_status == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">str</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.bs])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">str</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-number">1</span>-x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.bs])<br><br><span class="hljs-comment"># Your Bitset object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Bitset(size)</span><br><span class="hljs-comment"># obj.fix(idx)</span><br><span class="hljs-comment"># obj.unfix(idx)</span><br><span class="hljs-comment"># obj.flip()</span><br><span class="hljs-comment"># param_4 = obj.all()</span><br><span class="hljs-comment"># param_5 = obj.one()</span><br><span class="hljs-comment"># param_6 = obj.count()</span><br><span class="hljs-comment"># param_7 = obj.toString()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>设计</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>277场LeetCode周赛</title>
    <link href="/2022/01/23/algorithms/leetcode-weekly-contest/277%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/23/algorithms/leetcode-weekly-contest/277%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>在大佬们的帮助下第一次周赛ak并进了前1000名还是很开心的hhh，前三个题是有史以来见过最水的周赛题，感觉全是easy难度的，最后一个题学习到了位运算的暴力遍历思路，而且还有一个题目特有的思想是只需要考虑说真话的人就行了，因为假的说话怎么都是有可能的，于是在假定所有说真话的人判断是否和条件有冲突就可以了。</p><p>另外突然感觉这次题目的前三题描述都好简单啊，喜欢这样的题，搞直接点行不行hhh</p><p>第一题：排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了；</p><p>第二题：自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了；</p><p>第三题：mapping就能解决，这种题还是很好想到mapping（哈希表）的；</p><p>第四题：感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了；</p><span id="more"></span><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-24-00-09-08.png"></p><h1 id="第一题：5989-元素计数"><a href="#第一题：5989-元素计数" class="headerlink" title="第一题：5989.元素计数"></a>第一题：5989.元素计数</h1><p><a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时具有一个严格较小元素和一个严格较大元素的元素数目。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [11,7,2,15]<br>输出：2<br>解释：元素<span class="hljs-number"> 7 </span>：严格较小元素是元素<span class="hljs-number"> 2 </span>，严格较大元素是元素<span class="hljs-number"> 11 </span>。<br>元素<span class="hljs-number"> 11 </span>：严格较小元素是元素<span class="hljs-number"> 7 </span>，严格较大元素是元素<span class="hljs-number"> 15 </span>。<br>总计有<span class="hljs-number"> 2 </span>个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [-3,3,3,90]<br>输出：2<br>解释：元素<span class="hljs-number"> 3 </span>：严格较小元素是元素 -3 ，严格较大元素是元素<span class="hljs-number"> 90 </span>。<br>由于有两个元素的值为<span class="hljs-number"> 3 </span>，总计有<span class="hljs-number"> 2 </span>个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countElements</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> nums[-<span class="hljs-number">1</span>] &gt; nums[i]:<br>                cnt += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：5991-按符号重排数组"><a href="#第二题：5991-按符号重排数组" class="headerlink" title="第二题：5991.按符号重排数组"></a>第二题：5991.按符号重排数组</h1><p><a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p><p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p><ol><li>任意 <strong>连续</strong> 的两个整数 <strong>符号相反</strong></li><li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li><li>重排后数组以正整数开头。</li></ol><p>重排元素满足上述条件后，返回修改后的数组。</p><p>示例1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [3,1,<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]<br>输出：[3,<span class="hljs-string">-2</span>,1,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]<br>解释：<br>nums 中的正整数是 [3,1,2] ，负整数是 [<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,<span class="hljs-string">-4</span>] 。<br>重排的唯一可行方案是 [3,<span class="hljs-string">-2</span>,1,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]，能满足所有条件。<br>像 [1,<span class="hljs-string">-2</span>,2,<span class="hljs-string">-5</span>,3,<span class="hljs-string">-4</span>]、[3,1,2,<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,<span class="hljs-string">-4</span>]、[<span class="hljs-string">-2</span>,3,<span class="hljs-string">-5</span>,1,<span class="hljs-string">-4</span>,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 <br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,1]<br>输出：[1,<span class="hljs-string">-1</span>]<br>解释：<br>1 是 nums 中唯一一个正整数，<span class="hljs-string">-1</span> 是 nums 中唯一一个负整数。<br>所以 nums 重排为 [1,<span class="hljs-string">-1</span>] 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 2 * 105</code></li><li><code>nums.length</code> 是 <strong>偶数</strong></li><li><code>1 &lt;= |nums[i]| &lt;= 105</code></li><li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rearrangeArray</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        nums_positive = []<br>        nums_negative = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i]  &gt; <span class="hljs-number">0</span>:<br>                nums_positive.append(nums[i])<br>            <span class="hljs-keyword">else</span>:<br>                nums_negative.append(nums[i])<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums_positive)):<br>            result.append(nums_positive[i])<br>            result.append(nums_negative[i])<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第三题：5990-找出数组中的所有孤独数字"><a href="#第三题：5990-找出数组中的所有孤独数字" class="headerlink" title="第三题：5990.找出数组中的所有孤独数字"></a>第三题：5990.找出数组中的所有孤独数字</h1><p><a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p><p>返回 <code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [10,6,5,8]<br>输出：[10,8]<br>解释：<br>-<span class="hljs-number"> 10 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 9 </span>和<span class="hljs-number"> 11 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 8 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 7 </span>和<span class="hljs-number"> 9 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 5 </span>不是一个孤独数字，因为<span class="hljs-number"> 6 </span>出现在 nums 中，反之亦然。<br>因此，nums 中的孤独数字是 [10, 8] 。<br>注意，也可以返回 [8, 10] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,5,3]<br>输出：[1,5]<br>解释：<br>-<span class="hljs-number"> 1 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 5 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 3 </span>不是一个孤独数字，因为它出现两次。<br>因此，nums 中的孤独数字是 [1, 5] 。<br>注意，也可以返回 [5, 1] 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>mapping就能解决，这种题还是很好想到mapping（哈希表）的；也或许题目中的任何顺序暗示了可以排序和mapping做吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLonely</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        mappings = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> mappings.get(nums[i]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                mappings[nums[i]] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                mappings[nums[i]] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mappings.items():<br>            <span class="hljs-comment"># 把孤独的加进来，用key</span><br>            <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> mappings.get(key-<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mappings.get(key+<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                result.append(key)<br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第四题：5992-基于陈述统计最多好人数"><a href="#第四题：5992-基于陈述统计最多好人数" class="headerlink" title="第四题：5992.基于陈述统计最多好人数"></a>第四题：5992.基于陈述统计最多好人数</h1><p><a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>戏中存在两种角色：</p><ul><li><strong>好人</strong>：该角色只说真话。</li><li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li></ul><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p><ul><li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li><li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li><li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li></ul><p>另外，玩家不会对自己进行陈述。形式上，对所有 <code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p><p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-24-00-43-36.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：statements = [[2,1,2],[1,2,2],[2,0,2]]<br>输出：2<br>解释：每个人都做一条陈述。<br>-<span class="hljs-number"> 0 </span>认为<span class="hljs-number"> 1 </span>是好人。<br>-<span class="hljs-number"> 1 </span>认为<span class="hljs-number"> 0 </span>是好人。<br>-<span class="hljs-number"> 2 </span>认为<span class="hljs-number"> 1 </span>是坏人。<br>以<span class="hljs-number"> 2 </span>为突破点。<br>- 假设<span class="hljs-number"> 2 </span>是一个好人：<br>    - 基于<span class="hljs-number"> 2 </span>的陈述，1 是坏人。<br>    - 那么可以确认<span class="hljs-number"> 1 </span>是坏人，2 是好人。<br>    - 基于<span class="hljs-number"> 1 </span>的陈述，由于<span class="hljs-number"> 1 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下会出现矛盾，所以假设无效。<br>        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。<br>    - 在认为<span class="hljs-number"> 2 </span>是好人的情况下，这组玩家中只有一个好人。<br>- 假设<span class="hljs-number"> 2 </span>是一个坏人：<br>    - 基于<span class="hljs-number"> 2 </span>的陈述，由于<span class="hljs-number"> 2 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下，0 和<span class="hljs-number"> 1 </span>都是坏人。<br>            - 在认为<span class="hljs-number"> 2 </span>是坏人但说真话的情况下，这组玩家中没有一个好人。<br>        - 说假话。在这种情况下，1 是好人。<br>            - 由于<span class="hljs-number"> 1 </span>是好人，0 也是好人。<br>            - 在认为<span class="hljs-number"> 2 </span>是坏人且说假话的情况下，这组玩家中有两个好人。<br>在最佳情况下，至多有两个好人，所以返回<span class="hljs-number"> 2 </span>。<br>注意，能得到此结论的方法不止一种。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-24-00-43-46.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：statements = [[2,0],[0,2]]<br>输出：1<br>解释：每个人都做一条陈述。<br>-<span class="hljs-number"> 0 </span>认为<span class="hljs-number"> 1 </span>是坏人。<br>-<span class="hljs-number"> 1 </span>认为<span class="hljs-number"> 0 </span>是坏人。<br>以<span class="hljs-number"> 0 </span>为突破点。<br>- 假设<span class="hljs-number"> 0 </span>是一个好人：<br>    - 基于与<span class="hljs-number"> 0 </span>的陈述，1 是坏人并说假话。<br>    - 在认为<span class="hljs-number"> 0 </span>是好人的情况下，这组玩家中只有一个好人。<br>- 假设<span class="hljs-number"> 0 </span>是一个坏人：<br>    - 基于<span class="hljs-number"> 0 </span>的陈述，由于<span class="hljs-number"> 0 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下，0 和<span class="hljs-number"> 1 </span>都是坏人。<br>            - 在认为<span class="hljs-number"> 0 </span>是坏人但说真话的情况下，这组玩家中没有一个好人。<br>        - 说假话。在这种情况下，1 是好人。<br>            - 在认为<span class="hljs-number"> 0 </span>是坏人且说假话的情况下，这组玩家中只有一个好人。<br>在最佳情况下，至多有一个好人，所以返回<span class="hljs-number"> 1 </span>。 <br>注意，能得到此结论的方法不止一种。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == statements.length == statements[i].length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li><li><code>statements[i][i] == 2</code></li></ul><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumGood</span>(<span class="hljs-params">self, statements</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type statements: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_good_people = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(statements)<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">state, statements</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(state)):<br>                <span class="hljs-keyword">if</span> state[i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 只判断是好人的情况</span><br>                    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                        <span class="hljs-keyword">if</span> i == j:<br>                            <span class="hljs-keyword">continue</span><br>                        <span class="hljs-keyword">if</span> statements[i][j] == <span class="hljs-number">2</span>:<br>                            <span class="hljs-keyword">continue</span><br>                        <span class="hljs-keyword">if</span> statements[i][j] != state[j]:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <br>        <span class="hljs-comment"># 学到了，2^n种状态，用位运算遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((<span class="hljs-number">2</span> ** n) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            now_good = <span class="hljs-number">0</span><br>            tmp = i<br>            state = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                state[cnt] = tmp &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> state[cnt] == <span class="hljs-number">1</span>:<br>                    now_good += <span class="hljs-number">1</span><br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>                cnt += <span class="hljs-number">1</span><br>            flag = judge(state, statements)<br>            <span class="hljs-keyword">if</span> flag:<br>                max_good_people = <span class="hljs-built_in">max</span>(max_good_people, now_good)<br>        <br>        <span class="hljs-keyword">return</span> max_good_people<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>HARD</tag>
      
      <tag>位运算</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>回溯</tag>
      
      <tag>计数</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70场LeetCode双周赛</title>
    <link href="/2022/01/23/algorithms/leetcode-weekly-contest/70%E5%9C%BALeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/23/algorithms/leetcode-weekly-contest/70%E5%9C%BALeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>不常做双周赛的题目hhh，这次的bfs走迷宫一类的题目还是让人印象很深的，简单的dfs bfs模板还是要熟练些，这种题还是比全排列的那种深度优先更让人好理解一些；</p><p>第一题：贪心就可以，排个序后每买两个不买一个；</p><p>第二题：这个隐藏数组题目在时间复杂度上还是被坑了一下的，如果不看示例自己在TLE后能不能想到还是个问题，对于首位序列lower upper的问题，从示例总结出来的“对齐”思路很关键；</p><p>第三题：一个标准的bfs题目模板，题目给的排序约束条件既可以按照自己的方法先都走完后再拿出来排，也可能可以作为优先队列的约束条件，还要注意题目的step其实暗示了bfs而不是dfs；</p><p>第四题：咕咕咕</p><span id="more"></span><h1 id="第一题：5971-打折购买糖果的最小开销"><a href="#第一题：5971-打折购买糖果的最小开销" class="headerlink" title="第一题：5971.打折购买糖果的最小开销"></a>第一题：5971.打折购买糖果的最小开销</h1><p><a href="https://leetcode-cn.com/problems/minimum-cost-of-buying-candies-with-discount/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一家商店正在打折销售糖果。每购买 <strong>两个</strong> 糖果，商店会 <strong>免费</strong> 送一个糖果。</p><p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong> 。</p><ul><li>比方说，总共有<code>4</code>个糖果，价格分别为<code>1</code>，<code>2</code>，<code>3</code>和<code>4</code>，一位顾客买了价格为<code>2</code>和<code>3</code>的糖果，那么他可以免费获得价格为<code>1</code>的糖果，但不能获得价格为<code>4</code>的糖果。</li></ul><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>cost</code>，其中<code>cost[i]</code>表示第<code>i</code>个糖果的价格，请你返回获得 <strong>所有</strong> 糖果的 <strong>最小</strong> 总开销。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [1,2,3]<br>输出：5<br>解释：我们购买价格为<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>的糖果，然后免费获得价格为<span class="hljs-number"> 1 </span>的糖果。<br>总开销为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>。这是开销最小的 唯一 方案。<br>注意，我们不能购买价格为<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>的糖果，并免费获得价格为<span class="hljs-number"> 2 </span>的糖果。<br>这是因为免费糖果的价格必须小于等于购买的<span class="hljs-number"> 2 </span>个糖果价格的较小值。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [6,5,7,9,2,2]<br>输出：23<br>解释：最小总开销购买糖果方案为：<br>- 购买价格为<span class="hljs-number"> 9 </span>和<span class="hljs-number"> 7 </span>的糖果<br>- 免费获得价格为<span class="hljs-number"> 6 </span>的糖果<br>- 购买价格为<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 2 </span>的糖果<br>- 免费获得价格为<span class="hljs-number"> 2 </span>的最后一个糖果<br>因此，最小总开销为<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 23 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [5,5]<br>输出：10<br>解释：由于只有<span class="hljs-number"> 2 </span>个糖果，我们需要将它们都购买，而且没有免费糖果。<br>所以总最小开销为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= cost.length &lt;= 100</code></li><li><code>1 &lt;= cost[i] &lt;= 100</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>贪！ 排序后贪心就可以了，记得写的时候对于这个continue的位置还纠结了下，不过复盘来说应该会有不少种写法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCost</span>(<span class="hljs-params">self, cost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cost = <span class="hljs-built_in">sorted</span>(cost, key=<span class="hljs-keyword">lambda</span> x: -x)<br>        cnt = <span class="hljs-number">0</span><br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cost)):<br>            <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                cnt = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">continue</span><br>            result += cost[i]<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第二题：5972-统计隐藏数组数目"><a href="#第二题：5972-统计隐藏数组数目" class="headerlink" title="第二题：5972.统计隐藏数组数目"></a>第二题：5972.统计隐藏数组数目</h1><p><a href="https://leetcode-cn.com/problems/count-the-hidden-sequences/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>differences</code> ，它表示一个长度为 <code>n + 1</code> 的 <strong>隐藏</strong> 数组 <strong>相邻</strong> 元素之间的 <strong>差值</strong> 。更正式的表述为：我们将隐藏数组记作 <code>hidden</code> ，那么 <code>differences[i] = hidden[i + 1] - hidden[i]</code> 。</p><p>同时给你两个整数 <code>lower</code> 和 <code>upper</code> ，它们表示隐藏数组中所有数字的值都在 闭 区间 <code>[lower, upper]</code> 之间。</p><ul><li>比方说，<code>differences = [1, -3, 4]</code> ，<code>lower = 1</code> ，<code>upper = 6</code> ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。<ul><li><code>[3, 4, 1, 5]</code> 和 <code>[4, 5, 2, 6]</code> 都是符合要求的隐藏数组。</li><li><code>[5, 6, 3, 7]</code> 不符合要求，因为它包含大于 6 的元素。</li><li><code>[1, 2, 3, 4]</code> 不符合要求，因为相邻元素的差值不符合给定数据。</li></ul></li></ul><p>请你返回 <strong>符合</strong> 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。</p><p>示例1：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">输入：differences = [<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-keyword">lower</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">upper</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">2</span><br>解释：符合要求的隐藏数组为：<br>- [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]<br>- [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]<br>所以返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：differences = [3,<span class="hljs-string">-4</span>,5,1,<span class="hljs-string">-2</span>], lower = <span class="hljs-string">-4</span>, upper = 5<br>输出：4<br>解释：符合要求的隐藏数组为：<br>- [<span class="hljs-string">-3</span>, 0, <span class="hljs-string">-4</span>, 1, 2, 0]<br>- [<span class="hljs-string">-2</span>, 1, <span class="hljs-string">-3</span>, 2, 3, 1]<br>- [<span class="hljs-string">-1</span>, 2, <span class="hljs-string">-2</span>, 3, 4, 2]<br>- [0, 3, <span class="hljs-string">-1</span>, 4, 5, 3]<br>所以返回 4 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stan">输入：differences = [<span class="hljs-number">4</span>,-<span class="hljs-number">7</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">lower</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">upper</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">0</span><br>解释：没有符合要求的隐藏数组，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; differences.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 105</li><li>-105 &lt;&#x3D; differences[i] &lt;&#x3D; 105</li><li>-105 &lt;&#x3D; lower &lt;&#x3D; upper &lt;&#x3D; 105</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始想到的是一种从lower开始全部遍历的策略，但是很容易的就超时了，后来从示例2发现可以使用一种“数学”方法，复盘认为最关键的内容就是要使用一种“对齐”的思想，这样就避免了把两边的情况都考虑上，只考虑一边就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfArrays</span>(<span class="hljs-params">self, differences, lower, upper</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type differences: List[int]</span><br><span class="hljs-string">        :type lower: int</span><br><span class="hljs-string">        :type upper: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # 看了一个示例后，感觉只算一遍，然后算一个max low就可以了吧</span><br><span class="hljs-string">        result = 0</span><br><span class="hljs-string">        for start_idx in range(lower, upper+1):</span><br><span class="hljs-string">            tmp_start_idx = start_idx</span><br><span class="hljs-string">            flag = True</span><br><span class="hljs-string">            for i in range(len(differences)):</span><br><span class="hljs-string">                tmp_start_idx += differences[i]</span><br><span class="hljs-string">                if not (tmp_start_idx &lt;= upper and tmp_start_idx &gt;= lower):</span><br><span class="hljs-string">                    flag = False </span><br><span class="hljs-string">                    break</span><br><span class="hljs-string">            if flag:</span><br><span class="hljs-string">                result += 1</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        return result</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = <span class="hljs-number">0</span><br>        tmp_start_idx = lower<br>        seq_max = lower<br>        seq_min = lower<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(differences)):<br>            tmp_start_idx += differences[i]<br>            seq_max = <span class="hljs-built_in">max</span>(seq_max, tmp_start_idx)<br>            seq_min = <span class="hljs-built_in">min</span>(seq_min, tmp_start_idx)<br><span class="hljs-comment">#         print(&quot;seq_max: &quot;, seq_max)</span><br><span class="hljs-comment">#         print(&quot;seq_min: &quot;, seq_min)</span><br><br>        d1 = upper - seq_max<br>        d2 = seq_min - lower<br>        <br>        <span class="hljs-comment"># 3种情况</span><br>        seq_max = seq_max + (lower - seq_min)<br>        seq_min = lower<br>        <br>        <span class="hljs-comment"># print(&quot;seq_max: &quot;, seq_max)</span><br>        <span class="hljs-comment"># print(&quot;seq_min: &quot;, seq_min)</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, upper - seq_max + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="第三题：5973-价格范围内最高排名的-K-样物品"><a href="#第三题：5973-价格范围内最高排名的-K-样物品" class="headerlink" title="第三题：5973.价格范围内最高排名的 K 样物品"></a>第三题：5973.价格范围内最高排名的 K 样物品</h1><p><a href="https://leetcode-cn.com/problems/k-highest-ranked-items-within-a-price-range/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，它的大小为 <code>m x n</code> ，表示一个商店中物品的分布图。数组中的整数含义为：</p><ul><li><code>0</code> 表示无法穿越的一堵墙。</li><li><code>1</code> 表示可以自由通过的一个空格子。</li><li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li></ul><p>从一个格子走到上下左右相邻格子花费 <code>1</code> 步。</p><p>同时给你一个整数数组 <code>pricing</code> 和 <code>start</code> ，其中 <code>pricing = [low, high]</code> 且 <code>start = [row, col]</code> ，表示你开始位置为 <code>(row, col)</code> ，同时你只对物品价格在 闭区间 <code>[low, high]</code> 之内的物品感兴趣。同时给你一个整数 <code>k</code> 。</p><p>你想知道给定范围 <strong>内</strong> 且 <strong>排名最高</strong> 的 <code>k</code> 件物品的 <strong>位置</strong> 。排名按照优先级从高到低的以下规则制定：</p><ol><li>距离：定义为从 <code>start</code> 到一件物品的最短路径需要的步数（<strong>较近</strong> 距离的排名更高）。</li><li>价格：<strong>较低</strong> 价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li><li>行坐标：<strong>较小</strong> 行坐标的有更高优先级。</li><li>列坐标：<strong>较小</strong> 列坐标的有更高优先级。</li></ol><p>请你返回给定价格内排名最高的 <code>k</code> 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code> 件物品，那么请将它们的坐标 <strong>全部</strong> 返回。</p><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>bfs的一个基础模板题，在写的时候先用了dfs结果超时了。复盘分析为什么使用bfs的原因，bfs可以保证每个地方step是一定递增1的，而不像dfs可能一个位置有多种走法。</p><p>后来看题解来说这个题实际上背后可能隐藏的是优先队列的思路，但是这块的内容确实还不太熟悉，什么时候先复习下大根堆小根堆的内容吧，滑动窗口那道hard题</p><h3 id="bfs正确题解代码49-x2F-49"><a href="#bfs正确题解代码49-x2F-49" class="headerlink" title="bfs正确题解代码49&#x2F;49"></a>bfs正确题解代码49&#x2F;49</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">highestRankedKItems</span>(<span class="hljs-params">self, grid, pricing, start, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type pricing: List[int]</span><br><span class="hljs-string">        :type start: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 过一个异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        <span class="hljs-comment"># 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <br>        x = start[<span class="hljs-number">0</span>]<br>        y = start[<span class="hljs-number">1</span>]<br>        vis[x][y] = <span class="hljs-number">1</span><br>        bfs_queue = []<br>        bfs_queue.append([x, y, <span class="hljs-number">0</span>, grid[x][y]])<br>        result = []<br>        <br>        <span class="hljs-comment"># 使用bfs的思路</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(bfs_queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 取队头并pop</span><br>            now_x, now_y, now_step, now_value = bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]<br>            <span class="hljs-keyword">if</span> now_value &gt;= pricing[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> now_value &lt;= pricing[<span class="hljs-number">1</span>]:<br>                result.append(bfs_queue[<span class="hljs-number">0</span>])<br>            bfs_queue = bfs_queue[<span class="hljs-number">1</span>:]<br>            <br>            <span class="hljs-comment"># 把四个方向满足条件的加入到队列中</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = now_x + dx[i]<br>                ny = now_y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; m <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> vis[nx][ny] == <span class="hljs-number">0</span>:<br>                    vis[nx][ny] = <span class="hljs-number">1</span><br>                    bfs_queue.append([nx, ny, now_step+<span class="hljs-number">1</span>, grid[nx][ny]])<br>        <br>        <br>        <span class="hljs-comment"># dfs(x, y, 0)</span><br>        result.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">2</span>], x[<span class="hljs-number">3</span>], x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) &gt; k:<br>            <span class="hljs-keyword">return</span> [[result[x][<span class="hljs-number">0</span>], result[x][<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [[x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result]         <br></code></pre></td></tr></table></figure><h3 id="dfs超时版本题解代码15-x2F-49"><a href="#dfs超时版本题解代码15-x2F-49" class="headerlink" title="dfs超时版本题解代码15&#x2F;49"></a>dfs超时版本题解代码15&#x2F;49</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">highestRankedKItems</span>(<span class="hljs-params">self, grid, pricing, start, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type pricing: List[int]</span><br><span class="hljs-string">        :type start: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 过一个异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        <span class="hljs-comment"># 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <br>        x = start[<span class="hljs-number">0</span>]<br>        y = start[<span class="hljs-number">1</span>]<br>        vis[x][y] = <span class="hljs-number">1</span><br>        <br>        result = []<br>        mappings = &#123;&#125;<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y, step</span>):<br>            <span class="hljs-keyword">if</span> grid[x][y] &lt;= pricing[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> grid[x][y] &gt;= pricing[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> mappings.get((x, y)) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    mappings[(x, y)] = [step, grid[x][y]]<br>                <span class="hljs-keyword">else</span>:<br>                    tmp_list = mappings[(x, y)]<br>                    <span class="hljs-keyword">if</span> step &lt; tmp_list[<span class="hljs-number">0</span>]:<br>                        mappings[(x, y)] = [step, grid[x][y]]<br>                <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; m <span class="hljs-keyword">and</span> ny &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> vis[nx][ny] == <span class="hljs-number">0</span>:<br>                    vis[nx][ny] = <span class="hljs-number">1</span><br>                    dfs(nx, ny, step+<span class="hljs-number">1</span>)<br>                    vis[nx][ny] = <span class="hljs-number">0</span><br>        <br>        dfs(x, y, <span class="hljs-number">0</span>)<br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mappings.items():            <br>            result.append([key[<span class="hljs-number">0</span>], key[<span class="hljs-number">1</span>], value[<span class="hljs-number">0</span>], value[<span class="hljs-number">1</span>]])<br>        <br>        <br>        result.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">2</span>], x[<span class="hljs-number">3</span>], x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <br>        <span class="hljs-comment"># print(result)</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) &gt; k:<br>            <span class="hljs-keyword">return</span> [[result[x][<span class="hljs-number">0</span>], result[x][<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [[x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>219.存在重复元素II-python</title>
    <link href="/2022/01/20/algorithms/leetcode-python/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II-python/"/>
    <url>/2022/01/20/algorithms/leetcode-python/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II-python/</url>
    
    <content type="html"><![CDATA[<p>219.存在重复元素II（简单）</p><p>题目大意：</p><p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，判断数组中是否存在两个<strong>不同的索引</strong><code>i</code>和<code>j</code>，满足<code>nums[i] == nums[j]</code>且<code>abs(i - j) &lt;= k</code>。如果存在，返回<code>true</code>；否则，返回<code>false</code>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">题目链接</a></p><p>题目大意：</p><p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，判断数组中是否存在两个<strong>不同的索引</strong><code>i</code>和<code>j</code>，满足<code>nums[i] == nums[j]</code>且<code>abs(i - j) &lt;= k</code>。如果存在，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li><li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li><li>0 &lt;&#x3D; k &lt;&#x3D; 105</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>用一个字典判断就行，这样每次更新最后出现的状态，O(n)时间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        temp_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> temp_dict.get(nums[i]) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> i - temp_dict.get(nums[i]) &lt;= k:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            temp_dict[nums[i]] = i  <span class="hljs-comment"># 每次强制更新为最后的，这样方便找最近的</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160.相交链表-python</title>
    <link href="/2022/01/17/algorithms/leetcode-python/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/01/17/algorithms/leetcode-python/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>160.相交链表（简单）</p><p>题目大意：</p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p><p>给你两个单链表的头节点<code>headA</code>和<code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回<code>null</code>。</p><p>图示两个链表在节点<code>c1</code>开始相交：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-17-16-20-00.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为<code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在<code>listA</code>中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在<code>listB</code>中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-17-16-28-41.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-17-16-28-58.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例3：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-17-16-29-05.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>listA</code>中节点数目为<code>m</code></li><li><code>listB</code>中节点数目为<code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果<code>listA</code>和<code>listB</code>没有交点，<code>intersectVal</code>为<code>0</code></li><li>如果<code>listA</code>和<code>listB</code>有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在面试的时候曾经被问过，判断两个链表是否有交有很多种方法，如果只是判断是否有交的话，最简单的方法就是两个链表都分别走到结尾处，如果结尾处是一样的，那么就判断两个链表在之前一定有交了；</p><p>这个题要求判断并找到两个链表相交的位置，一种非常简单的思路是把每个地方都存到一个字典里，这样找一下就行了，但是题目的附加要求是O(1)的时间复杂度，所以说不能这么做；</p><p>下边这个图也是看了题解后才明白的，这样最多走a+b这个长度的次数，两个走的长度是一样的，如果有交集则必定能相交！</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-17-16-16-56.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA, headB</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head1, head1: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> headB <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 循环结束的两种条件，一种是pq交到一个位置了，另外一种就是pq都是null，所以都是</span><br>        <span class="hljs-comment"># 只走一遍就可以了，a+b的长度</span><br>        p = headA<br>        q = headB<br>        <span class="hljs-keyword">while</span> p != q:<br>            <span class="hljs-keyword">if</span> p <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p = headB<br>            <span class="hljs-keyword">else</span>:<br>                p = p.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                q = headA<br>            <span class="hljs-keyword">else</span>:<br>                q = q.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> p<br></code></pre></td></tr></table></figure><p>复习单链表的一个写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136.只出现一次的数字-python</title>
    <link href="/2022/01/17/algorithms/leetcode-python/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-python/"/>
    <url>/2022/01/17/algorithms/leetcode-python/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-python/</url>
    
    <content type="html"><![CDATA[<p>136.只出现一次的数字（简单）</p><p>题目大意：</p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong>：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/single-number/">题目链接</a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong>：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>简单的位运算题目，因为题目说了其余每个元素都出现了两次，所以用xor就行了，真值表上异是1，同是0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        return_num = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            return_num ^= nums[i]  <span class="hljs-comment"># 异或</span><br>        <br>        <span class="hljs-keyword">return</span> return_num<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104.二叉树的最大深度-python</title>
    <link href="/2022/01/16/algorithms/leetcode-python/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-python/"/>
    <url>/2022/01/16/algorithms/leetcode-python/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-python/</url>
    
    <content type="html"><![CDATA[<p>104.二叉树的最大深度（简单）</p><p>题目大意：</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树<code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度3。</p><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这个题是一个典型的”自递归“系列的题目，首先复习一下树节点的写法（建议每个二叉树的题目都复习一下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=-<span class="hljs-number">1</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>复习Solution的写法和题解，注意这个maxDepth函数，他的返回值是一个int，代表直接调用这个函数就要得到最终答案的depth返回值，所以感觉是一个自递归的题目了，这种的递归dfs还是很好写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>275场LeetCode周赛</title>
    <link href="/2022/01/16/algorithms/leetcode-weekly-contest/275%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/16/algorithms/leetcode-weekly-contest/275%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前两个题实际上说感觉还没有那么容易想，第三个题的话感觉简化的思路是需要复盘梳理的，另外只能说Counter永远的神哈哈哈哈</p><p>第一题：这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用<code>matrix[i]</code>，而取矩阵的某一列没有什么很好的思路，可以用<code>[matrix[x][j] for x in range(n)]</code>，这里的<code>j</code>代表第<code>j</code>列；</p><p>第二题：比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可；</p><p>第三题：只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set&#x2F;dict&#x2F;Counter中，这样可以O(1)的判断是否存在；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：2133-检查是否每一行每一列都包含全部整数"><a href="#第一题：2133-检查是否每一行每一列都包含全部整数" class="headerlink" title="第一题：2133.检查是否每一行每一列都包含全部整数"></a>第一题：2133.检查是否每一行每一列都包含全部整数</h1><p><a href="https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对一个大小为<code>n x n</code>的矩阵而言，如果其每一行和每一列都包含从<code>1</code>到<code>n</code>的<strong>全部</strong>整数（含<code>1</code>和<code>n</code>），则认为该矩阵是一个<strong>有效</strong>矩阵。</p><p>给你一个大小为<code>n x n</code>的整数矩阵<code>matrix</code>，请你判断矩阵是否为一个有效矩阵：如果是，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[3,1,2],[2,3,1]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：在此例中，n = <span class="hljs-number">3</span> ，每一行和每一列都包含数字 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span> 。<br>因此，返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,2,3],[1,2,3]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：在此例中，n = <span class="hljs-number">3</span> ，但第一行和第一列不包含数字 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 。<br>因此，返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= matrix[i][j] &lt;= n</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用<code>matrix[i]</code>，而取矩阵的某一列没有什么很好的思路，可以用<code>[matrix[x][j] for x in range(n)]</code>，这里的<code>j</code>代表第<code>j</code>列；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkValid</span>(<span class="hljs-params">self, matrix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type matrix: List[List[int]]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>      <br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # tle</span><br><span class="hljs-string">        n = len(matrix)</span><br><span class="hljs-string">        target = [i+1 for i in range(n)]</span><br><span class="hljs-string">        target_count = Counter(target)</span><br><span class="hljs-string">        for i in range(n):</span><br><span class="hljs-string">            for j in range(n):</span><br><span class="hljs-string">                tmp_counter1 = Counter(matrix[i])</span><br><span class="hljs-string">                tmp_counter2 = Counter([matrix[x][j] for x in range(n)])</span><br><span class="hljs-string">                if not (tmp_counter1 == target_count and tmp_counter2 == target_count):</span><br><span class="hljs-string">                    return False</span><br><span class="hljs-string">        return True</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>    <br>        <span class="hljs-comment"># 只判断对角线就够了？</span><br>        n = <span class="hljs-built_in">len</span>(matrix)<br>        target = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        target_count = Counter(target)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tmp_counter1 = Counter(matrix[i])<br>            tmp_counter2 = Counter([matrix[x][i] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (tmp_counter1 == target_count <span class="hljs-keyword">and</span> tmp_counter2 == target_count):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2134-最少交换次数来组合所有的1-II"><a href="#第二题：2134-最少交换次数来组合所有的1-II" class="headerlink" title="第二题：2134.最少交换次数来组合所有的1 II"></a>第二题：2134.最少交换次数来组合所有的1 II</h1><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>交换</strong>定义为选中一个数组中的两个<strong>互不相同</strong>的位置并交换二者的值。</p><p><strong>环形</strong>数组是一个数组，可以认为<strong>第一个</strong>元素和<strong>最后一个</strong>元素<strong>相邻</strong>。</p><p>给你一个<strong>二进制环形</strong>数组<code>nums</code>，返回在<strong>任意位置</strong>将数组中的所有<code>1</code>聚集在一起需要的最少交换次数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,0,1,1,0,0]<br>输出：1<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[0,0,1,1,1,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[0,1,1,1,0,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[1,1,0,0,0,0,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>无法在交换<span class="hljs-number"> 0 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,1,1,0,0,1,1,0]<br>输出：2<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[1,1,1,0,0,0,0,1,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>[1,1,1,1,1,0,0,0,0] 交换<span class="hljs-number"> 2 </span>次。<br>无法在交换<span class="hljs-number"> 0 </span>次或<span class="hljs-number"> 1 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,0,0,1]<br>输出：0<br>解释：得益于数组的环形特性，所有的<span class="hljs-number"> 1 </span>已经聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>nums[i]</code>为<code>0</code>或者<code>1</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可；</p><p>另外注意，这种环形的可以通过补充在最后边来进行简易的实现，取模的思路有点麻烦了，python语言还有其专门使用的extend函数；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSwaps</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 处理出一个初始化的目标状态</span><br>        target_counter = Counter(nums)<br>        <span class="hljs-keyword">del</span> target_counter[<span class="hljs-number">0</span>]<br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target_counter[<span class="hljs-number">1</span>]):<br>            nums.append(nums[cnt])<br>            cnt += <span class="hljs-number">1</span><br>        <br>        min_swaps = target_counter[<span class="hljs-number">1</span>]<br>        init_counter = Counter(nums[<span class="hljs-number">0</span>: (target_counter[<span class="hljs-number">1</span>])])<br>        min_swaps = <span class="hljs-built_in">min</span>(min_swaps, (init_counter-target_counter)[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># print(init_counter)</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-target_counter[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>):<br>            init_counter -= Counter([nums[i-<span class="hljs-number">1</span>]])<br>            init_counter += Counter([nums[i+target_counter[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>]])<br>            <span class="hljs-comment"># print(init_counter)</span><br>            min_swaps = <span class="hljs-built_in">min</span>(min_swaps, (init_counter-target_counter)[<span class="hljs-number">0</span>])<br>            <br>        <br>        <span class="hljs-keyword">return</span> min_swaps<br></code></pre></td></tr></table></figure><h1 id="第三题：2135-统计追加字母可以获得的单词数"><a href="#第三题：2135-统计追加字母可以获得的单词数" class="headerlink" title="第三题：2135.统计追加字母可以获得的单词数"></a>第三题：2135.统计追加字母可以获得的单词数</h1><p><a href="https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从<strong>0</strong>开始的字符串数组<code>startWords</code>和<code>targetWords</code>。每个字符串都仅由<strong>小写英文字母</strong>组成。</p><p>对于<code>targetWords</code>中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次<strong>转换操作</strong>，得到的结果与当前<code>targetWords</code>字符串相等。</p><p><strong>转换操作</strong>如下面两步所述：</p><ol><li><strong>追加</strong>任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。</li></ol><ul><li>例如，如果字符串为<code>&quot;abc&quot;</code>，那么字母<code>&#39;d&#39;</code>、<code>&#39;e&#39;</code>或<code>&#39;y&#39;</code>都可以加到该字符串末尾，但<code>&#39;a&#39;</code>就不行。如果追加的是<code>&#39;d&#39;</code>，那么结果字符串为<code>&quot;abcd&quot;</code>。</li></ul><ol start="2"><li><strong>重排</strong>新字符串中的字母，可以按<strong>任意</strong>顺序重新排布字母。</li></ol><ul><li>例如，<code>&quot;abcd&quot;</code>可以重排为<code>&quot;acbd&quot;</code>、<code>&quot;bacd&quot;</code>、<code>&quot;cbda&quot;</code>，以此类推。注意，它也可以重排为<code>&quot;abcd&quot;</code>自身。</li></ul><p>找出<code>targetWords</code>中有多少字符串能够由<code>startWords</code>中的<strong>任一</strong>字符串执行上述转换操作获得。返回<code>targetWords</code>中这类<strong>字符串的数目</strong>。</p><p>注意：你仅能验证<code>targetWords</code>中的字符串是否可以由<code>startWords</code>中的某个字符串经执行操作获得。<code>startWords</code>中的字符串在这一过程中 不 发生实际变更。</p><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set&#x2F;dict&#x2F;Counter中，这样可以O(1)的判断是否存在；</p><p>其中感觉也有用到一种反向的思维，目标单词是startWord加上一个字母，所以startWord是目标单词减去一个字母，这样的话可能更容易想到是用一个set&#x2F;dict&#x2F;Counter来进行查找了；</p><p>还是很值得复盘的一个题目，感觉字母排序也是一个需要复盘的点；</p><p>TLE超时版本代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordCount</span>(<span class="hljs-params">self, startWords, targetWords</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type startWords: List[str]</span><br><span class="hljs-string">        :type targetWords: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # TLE</span><br><span class="hljs-string">        result_cnt = 0</span><br><span class="hljs-string">        none_counter = Counter(&quot;&quot;)</span><br><span class="hljs-string">        counter_start_words = [Counter(x) for x in startWords]</span><br><span class="hljs-string">        counter_target_words = [Counter(x) for x in targetWords]</span><br><span class="hljs-string">        for i in range(len(counter_target_words)):</span><br><span class="hljs-string">            flag = 0</span><br><span class="hljs-string">            for j in range(len(counter_start_words)):</span><br><span class="hljs-string">                # 剪枝</span><br><span class="hljs-string">                if len(targetWords[i]) - len(counter_start_words[j]) != 1:</span><br><span class="hljs-string">                    continue</span><br><span class="hljs-string">                if len([key for key in (counter_start_words[j] - counter_target_words[i]).keys()]) != 0:</span><br><span class="hljs-string">                    continue</span><br><span class="hljs-string">                </span><br><span class="hljs-string">                tmp_counter = counter_target_words[i] - counter_start_words[j]    </span><br><span class="hljs-string">                # 必须只有一个键，且这个键值为1，且这个不出现在原来的counter_target_words[i]中</span><br><span class="hljs-string">                key_list = [key for key in tmp_counter.keys()]</span><br><span class="hljs-string">                if len(key_list) == 1 and tmp_counter[key_list[0]] == 1 and counter_start_words[j].get(key_list[0]) is None:</span><br><span class="hljs-string">                    flag = 1</span><br><span class="hljs-string">                    break                    </span><br><span class="hljs-string">            if flag == 1:</span><br><span class="hljs-string">                result_cnt += 1</span><br><span class="hljs-string">        return result_cnt</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        set_start_words = [<span class="hljs-built_in">set</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> startWords]<br>        set_target_words = [<span class="hljs-built_in">set</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> targetWords]<br>        result_cnt = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(targetWords)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(startWords)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(targetWords[i]) - <span class="hljs-built_in">len</span>(startWords[j]) != <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(set_target_words[i].symmetric_difference(set_start_words[j]))) == <span class="hljs-number">1</span>:<br>                    <span class="hljs-built_in">print</span>(set_target_words[i], set_start_words[j])<br>                    result_cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> result_cnt<br><br></code></pre></td></tr></table></figure><p>修改后的不超时代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordCount</span>(<span class="hljs-params">self, startWords, targetWords</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type startWords: List[str]</span><br><span class="hljs-string">        :type targetWords: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        set_start_words = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(startWord))) <span class="hljs-keyword">for</span> startWord <span class="hljs-keyword">in</span> startWords])<br>        sorted_target_words = [<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(targetWord))) <span class="hljs-keyword">for</span> targetWord <span class="hljs-keyword">in</span> targetWords]<br>        counter_sorted_target_words = Counter(sorted_target_words)<br><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> targetWord, value <span class="hljs-keyword">in</span> counter_sorted_target_words.items():<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(targetWord)):<br>                tmp_s = targetWord[:i] + targetWord[i+<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">if</span> tmp_s <span class="hljs-keyword">in</span> set_start_words:<br>                    cnt += value<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>哈希表</tag>
      
      <tag>矩阵</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>276场LeetCode周赛</title>
    <link href="/2022/01/16/algorithms/leetcode-weekly-contest/276%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/16/algorithms/leetcode-weekly-contest/276%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前两题难度还是比较低的，第三题的话感觉dp这个思路还值得复盘研究一下，常见的一维dp数组感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值；</p><p>第一题：简单字符串模拟，有一些mod的使用，熟练度的题目；</p><p>第二题：从大到小贪心就行了，最后一次直接 +&#x3D; target - 1；</p><p>第三题：一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用<code>max()</code>而TLE，所以在优化方向上应该也找到后边一种思路的优化方向；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：5980-将字符串拆分为若干长度为k的组"><a href="#第一题：5980-将字符串拆分为若干长度为k的组" class="headerlink" title="第一题：5980.将字符串拆分为若干长度为k的组"></a>第一题：5980.将字符串拆分为若干长度为k的组</h1><p><a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串<code>s</code>可以按下述步骤划分为若干长度为<code>k</code>的组：</p><ul><li>第一组由字符串中的前<code>k</code>个字符组成，第二组由接下来的<code>k</code>个字符串组成，依此类推。每个字符都能够成为<strong>某一个</strong>组的一部分。</li><li>对于最后一组，如果字符串剩下的字符<strong>不足</strong><code>k</code>个，需使用字符<code>fill</code>来补全这一组字符。</li></ul><p>注意，在去除最后一个组的填充字符<code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是<code>s</code>。</p><p>给你一个字符串<code>s</code>，以及每组的长度<code>k</code>和一个用于填充的字符<code>fill</code>，按上述步骤处理之后，返回一个字符串数组，该数组表示<code>s</code>分组后<strong>每个组的组成情况</strong>。</p><p>示例1：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：s = <span class="hljs-string">&quot;abcdefghi&quot;</span>, k = <span class="hljs-number">3</span>, fill = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>]<br>解释：<br>前 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;abc&quot;</span> ，形成第一组。<br>接下来 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;def&quot;</span> ，形成第二组。<br>最后 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;ghi&quot;</span> ，形成第三组。<br>由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。<br>因此，形成 <span class="hljs-number">3</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：s = <span class="hljs-string">&quot;abcdefghij&quot;</span>, k = <span class="hljs-number">3</span>, fill = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jxx&quot;</span>]<br>解释：<br>与前一个例子类似，形成前三组 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br>对于最后一组，字符串中仅剩下字符 <span class="hljs-string">&#x27;j&#x27;</span> 可以用。为了补全这一组，使用填充字符 <span class="hljs-string">&#x27;x&#x27;</span> 两次。<br>因此，形成 <span class="hljs-number">4</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span>、<span class="hljs-string">&quot;ghi&quot;</span> 和 <span class="hljs-string">&quot;jxx&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 仅由小写英文字母组成</li><li>1 &lt;&#x3D; k &lt;&#x3D; 100</li><li>fill 是一个小写英文字母</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>简单的字符串模拟，需要比较熟练地使用mod</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">divideString</span>(<span class="hljs-params">self, s, k, fill</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type fill: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        return_list = []<br>        <br>        s_list = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s_list) % k != <span class="hljs-number">0</span>:<br>            s_list += [fill <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k - <span class="hljs-built_in">len</span>(s_list) % k)]<br>        <span class="hljs-built_in">print</span>(s_list)<br>        <br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s_list):<br>            return_list.append(<span class="hljs-string">&quot;&quot;</span>.join(s_list[i: i+k]))<br>            i += k<br>        <span class="hljs-keyword">return</span> return_list<br></code></pre></td></tr></table></figure><h1 id="第二题：5194-得到目标值的最少行动次数"><a href="#第二题：5194-得到目标值的最少行动次数" class="headerlink" title="第二题：5194.得到目标值的最少行动次数"></a>第二题：5194.得到目标值的最少行动次数</h1><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>你正在玩一个整数游戏。从整数<code>1</code>开始，期望得到整数<code>target</code>。</p><p>在一次行动中，你可以做下述两种操作之一：</p><ul><li>递增，将当前整数的值加 1（即，<code>x = x + 1</code>）。</li><li>加倍，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li></ul><p>在整个游戏过程中，你可以使用<strong>递增</strong>操作<strong>任意</strong>次数。但是只能使用<strong>加倍</strong>操作 至多<code>maxDoubles</code>次。</p><p>给你两个整数<code>target</code>和<code>maxDoubles</code>，返回从 1 开始得到<code>target</code>需要的最少行动次数。</p><p>示例1：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>, maxDoubles = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br>解释：一直递增 <span class="hljs-number">1</span> 直到得到 <span class="hljs-keyword">target</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 19, maxDoubles = 2<br>输出：7<br>解释：最初，x =<span class="hljs-number"> 1 </span>。<br>递增<span class="hljs-number"> 3 </span>次，x =<span class="hljs-number"> 4 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 8 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 9 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 18 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 19 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 10, maxDoubles = 4<br>输出：4<br>解释：<br>最初，x =<span class="hljs-number"> 1 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 2 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 4 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 5 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 109</li><li>0 &lt;&#x3D; maxDoubles &lt;&#x3D; 100</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>贪心，还是比较容易看出来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMoves</span>(<span class="hljs-params">self, target, maxDoubles</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :type maxDoubles: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> maxDoubles != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> target != <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                target -= <span class="hljs-number">1</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                target //= <span class="hljs-number">2</span><br>                cnt += <span class="hljs-number">1</span><br>                maxDoubles -= <span class="hljs-number">1</span><br>        <br>        cnt += target - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：5982-解决智力问题"><a href="#第三题：5982-解决智力问题" class="headerlink" title="第三题：5982.解决智力问题"></a>第三题：5982.解决智力问题</h1><p><a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从<strong>0</strong>开始的二维整数数组<code>questions</code>，其中<code>questions[i] = [pointsi, brainpoweri]</code>。</p><p>这个数组表示一场考试里的一系列题目，你需要<strong>按顺序</strong>（也就是从问题<code>0</code>开始依次解决），针对每个问题选择<strong>解决</strong>或者<strong>跳过</strong>操作。解决问题<code>i</code>将让你<strong>获得</strong><code>pointsi</code>的分数，但是你将<strong>无法</strong>解决接下来的<code>brainpoweri</code>个问题（即只能跳过接下来的<code>brainpoweri</code>个问题）。如果你跳过问题<code>i</code>，你可以对下一个问题决定使用哪种操作。</p><ul><li>比方说，给你<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>：<ul><li>如果问题<code>0</code>被解决了， 那么你可以获得<code>3</code>分，但你不能解决问题<code>1</code>和<code>2</code>。</li><li>如果你跳过问题<code>0</code>，且解决问题<code>1</code>，你将获得<code>4</code>分但是不能解决问题<code>2</code>和<code>3</code>。</li></ul></li></ul><p>请你返回这场考试里你能获得的<strong>最高</strong>分数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[3,2],[4,3],[4,4],[2,5]]<br>输出：5<br>解释：解决问题<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>得到最高分。<br>- 解决问题<span class="hljs-number"> 0 </span>：获得<span class="hljs-number"> 3 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 1 </span>和 2<br>- 解决问题<span class="hljs-number"> 3 </span>：获得<span class="hljs-number"> 2 </span>分<br>总得分为：3 +<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>。没有别的办法获得<span class="hljs-number"> 5 </span>分或者多于<span class="hljs-number"> 5 </span>分。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br>输出：7<br>解释：解决问题<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 4 </span>得到最高分。<br>- 跳过问题 0<br>- 解决问题<span class="hljs-number"> 1 </span>：获得<span class="hljs-number"> 2 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 2 </span>和 3<br>- 解决问题<span class="hljs-number"> 4 </span>：获得<span class="hljs-number"> 5 </span>分<br>总得分为：2 +<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 7 </span>。没有别的办法获得<span class="hljs-number"> 7 </span>分或者多于<span class="hljs-number"> 7 </span>分。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; questions.length &lt;&#x3D; 105</li><li>questions[i].length &#x3D;&#x3D; 2</li><li>1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>题目的名字好有意思哈哈哈哈，这是按时解决一下我的智力问题吗23333</p><p>一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用<code>max()</code>而TLE，所以在优化方向上应该也找到后边一种思路的优化方向；</p><p>TLE的写法，这里dp数组存储的是每个状态的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mostPoints</span>(<span class="hljs-params">self, questions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type questions: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        questions.reverse()<br>        dp = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> questions]  <span class="hljs-comment"># 每个位置上先初始化</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(questions)):  <span class="hljs-comment"># 每个位置有选得到和选不到两种状态的dp</span><br>            <span class="hljs-keyword">if</span> i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 选和不选两种状态</span><br>                <span class="hljs-comment"># 选的话</span><br>                tmp_choose = questions[i][<span class="hljs-number">0</span>] + <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>:i-questions[i][<span class="hljs-number">1</span>]])<br>                <span class="hljs-comment"># 不选的话</span><br>                tmp_not_choose = <span class="hljs-built_in">max</span>(dp[i-questions[i][<span class="hljs-number">1</span>]: i])<br>                dp[i] = <span class="hljs-built_in">max</span>(tmp_choose, tmp_not_choose)<br>                <br>                <span class="hljs-comment"># print(dp)</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>优化后的写法， 这里dp数组存储的是截止到这个状态的，下图是思路：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-16-21-16-46.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mostPoints</span>(<span class="hljs-params">self, questions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type questions: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> questions]<br>        questions.reverse()<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(questions)):<br>            <span class="hljs-keyword">if</span> i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 越界了的状态，维护不断增加的dp</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], questions[i][<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 没有越界的话，因为不断增加</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], questions[i][<span class="hljs-number">0</span>] + dp[i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># print(max(dp))</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(questions) - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记3-Docker常用命令-狂神视频</title>
    <link href="/2022/01/08/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/08/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>Docker的常用命令，主要分为镜像和容器两个部分，也是Docker学习的基础</p><p>这里的命令如果对基础linux有了解，或者对screen系列命令有了解感觉还是很熟悉的，就是感觉要多用或者结合项目才能真正的记住</p><span id="more"></span><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker version  # 显示docker的版本信息<br>docker info  # 显示docker更加详细的信息，sys级别系统信息，包括镜像和容器的数量等<br>docker 命令 --help  # 万能命令，帮助命令<br>docker --help<br></code></pre></td></tr></table></figure><p>帮助文档的地址：<br>docs.docker.com里有一个Reference</p><p>docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline</p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong> 查看所有本地主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解释</span><br>REPOSITORY镜像的仓库源<br>TAG镜像的标签<br>IMAGE ID    镜像的ID<br>CREATED镜像的创建时间<br>SIZE镜像的大小<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项，可以docker image -aq</span><br>Options:<br>  -a, --all             Show all images (default hides intermediate images) 列出所有镜像<br>  -q, --quiet           Only show image IDs 只显示镜像的id<br></code></pre></td></tr></table></figure><p><strong>docker search 搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker search mysql<br>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                             MySQL is a widely used, open-source relation…   11912     [OK]       <br>mariadb                           MariaDB Server is a high performing open sou…   4558      [OK]       <br>mysql/mysql-server                Optimized MySQL Server Docker images. Create…   895                  [OK]<br>phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   415       [OK]<br>......<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项，通过收藏来过滤</span><br>Options:<br>--filter=STARS=3000  # 搜索出来的镜像就是STARS大于3000的<br><br>[bupt_114@AIServer ~]$ docker search mysql --filter=STARS=3000<br>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   11912     [OK]       <br>mariadb   MariaDB Server is a high performing open sou…   4558      [OK]<br></code></pre></td></tr></table></figure><p><strong>docker pull 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]</span><br>[bupt_114@AIServer ~]$ docker pull mysql<br>Using default tag: latest  # 如果不写tag，默认就是latest<br>latest: Pulling from library/mysql          # <br>72a69066d2fe: Pull complete # 分层下载，docker image的核心 联合文件系统<br>93619dbc5b36: Pull complete <br>99da31dd6142: Pull complete <br>626033c43d70: Pull complete <br>37d5d7efb64e: Pull complete <br>ac563158d721: Pull complete <br>d2ba16033dad: Pull complete <br>688ba7d5c01a: Pull complete <br>00e060b6d11d: Pull complete <br>1c04857f594f: Pull complete <br>4d7cfa90e6ea: Pull complete <br>e0431212d27d: Pull complete <br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709# 签名，防伪标志<br>Status: Downloaded newer image for mysql:latest<br>docker.io/library/mysql:latest# 真实地址<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等价</span><br>docker pull mysql 和 docker pull docker.io/library/mysql:latest是等价的<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定版本下载</span><br>[bupt_114@AIServer ~]$ docker pull mysql:5.7  # 注意版本一定要在官方文档里有<br>【docker笔记3图2】<br><br>[bupt_114@AIServer ~]$ docker pull mysql:5.7<br>5.7: Pulling from library/mysql<br>72a69066d2fe: Already exists <br>93619dbc5b36: Already exists <br>99da31dd6142: Already exists <br>626033c43d70: Already exists <br>37d5d7efb64e: Already exists <br>ac563158d721: Already exists <br>d2ba16033dad: Already exists <br>0ceb82207cd7: Pull complete <br>37f2405cae96: Pull complete <br>e2482e017e53: Pull complete <br>70deed891d42: Pull complete <br>Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Status: Downloaded newer image for mysql:5.7<br>docker.io/library/mysql:5.7<br></code></pre></td></tr></table></figure><p><strong>docker rmi 删除镜像</strong><br>（既可以通过镜像的ID来删除，也可以通过镜像的名称来删除，涉及到删除的指令都非常危险啊）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker rmi -f c20987f18b13<br>Untagged: mysql:5.7<br>Untagged: mysql@sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Deleted: sha256:c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab302a76<br>Deleted: sha256:6567396b065ee734fb2dbb80c8923324a778426dfd01969f091f1ab2d52c7989<br>Deleted: sha256:0910f12649d514b471f1583a16f672ab67e3d29d9833a15dc2df50dd5536e40f<br>Deleted: sha256:6682af2fb40555c448b84711c7302d0f86fc716bbe9c7dc7dbd739ef9d757150<br>Deleted: sha256:5c062c3ac20f576d24454e74781511a5f96739f289edaadf2de934d06e910b92<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量删除所有的</span><br>[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq)  # 删除全部的容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker rmi -f 容器id     # 删除指定的容器<br>[bupt_114@AIServer ~]$ docker rmi -f 容器id 容器id 容器id   # 删除多个容器<br>[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq)  # 删除全部的容器<br></code></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</strong></p><p>在docker里面再装一个虚拟机！？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull centos<br></code></pre></td></tr></table></figure><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [可选参数] image<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数说明</span><br>--name=&quot;Name&quot;# 容器名字，跑起来要知道叫什么，tomcat01, tomcat02，用来区分容器<br>-d    # 后台方式运行<br>-it                 # 使用交互方式运行，进入容器查看内容<br>-p   # 指定容器的端口 -p 8080:8080，可以和主机映射起来也<br>-p ip:主机端口:容器端口<br>-p 主机端口:容器端口（常用）<br>-p 容器端口<br>容器端口<br>-P                  # 大P，随机指定端口<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span><br>[bupt_114@AIServer ~]$ docker run -it centos /bin/bash<br>[root@364710ff50c7 /]# <br>[root@364710ff50c7 /]# ls    # 查看容器内部的centos，基础版本，很多命令都是不完善的<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从容器中退回主机</span><br>[root@364710ff50c7 /]# exit<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>列出所有运行中的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps 命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出当前正在运行的容器</span><br>-a # 列出当前正在运行的容器 + 带出历史运行过的容器<br>-n=?    # 显示最近创建的容器，即个数<br>-q # 只显示容器的编号<br><br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                          PORTS     NAMES<br>364710ff50c7   centos         &quot;/bin/bash&quot;   5 minutes ago   Exited (0) About a minute ago             elated_lichterman<br>93427549984f   feb5d9fea6a5   &quot;/hello&quot;      29 hours ago    Exited (0) 29 hours ago                   exciting_villani<br>[bupt_114@AIServer ~]$ docker ps -a -n=1<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>364710ff50c7   centos    &quot;/bin/bash&quot;   7 minutes ago   Exited (0) 3 minutes ago             elated_lichterman<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit # 直接停止容器并退出<br>ctrl + P + Q   # 容器不停止并退出<br></code></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器id# 删除指定的容器，不能删除正在运行的容器，如果要强制删除，rm -f<br>docker rm -f $(docker ps -aq)   # 删除所有的容器<br>docker ps -a -q | xargs docker rm  # 删除所有的容器（docker玩的不错跑路就玩得不错哈哈哈哈）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行中的不能直接删除，要加-f代表force</span><br>[bupt_114@AIServer ~]$ docker rm f406a8591325<br>Error response from daemon: You cannot remove a running container f406a8591325995950d4defb6d7eefbe45bd5ec11e895f7238ce53de4546c297. Stop the container before attempting removal or force remove<br></code></pre></td></tr></table></figure><p><strong>启动和停止容器的操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器id# 启动容器<br>docker attach 容器id# 进入容器<br>docker restart 容器id# 重启容器<br>docker stop 容器id# 停止当前正在运行的容器<br>docker kill 容器id# 强制定制当前正在运行的容器<br><br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>87ac7567be74   centos    &quot;/bin/bash&quot;   9 seconds ago   Exited (0) 6 seconds ago             determined_cohen<br>[bupt_114@AIServer ~]$ docker start 87ac7567be74<br>87ac7567be74<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES<br>87ac7567be74   centos    &quot;/bin/bash&quot;   24 seconds ago   Up 4 seconds             determined_cohen<br>[bupt_114@AIServer ~]$ docker stop 87ac7567be74<br>87ac7567be74<br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><h2 id="常用的其他命令"><a href="#常用的其他命令" class="headerlink" title="常用的其他命令"></a>常用的其他命令</h2><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令，docker run -d 镜像名！</span><br>[bupt_114@AIServer ~]$ docker run -d centos<br>0aab13a3c396931520159092a755ccc7eb1a2fc56895ab2e2cc43267e86be432<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">问题，docker ps，发现centos停止了</span><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES<br>0aab13a3c396   centos    &quot;/bin/bash&quot;   12 seconds ago   Exited (0) 11 seconds ago             exciting_bose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx，容器启动后，发现自己没有提供服务，就会立刻停止，没有程序了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这块有点没理解，往后学习再看了</span><br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs<br><br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES<br>0aab13a3c396   centos    &quot;/bin/bash&quot;   15 minutes ago   Exited (0) 15 minutes ago             exciting_bose<br>[bupt_114@AIServer ~]$ docker logs -tf --tail 10 0aab13a3c396<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示日志</span><br>-tf  # 显示日志，f是实时追踪，滚动查看<br>--tail number# 要显示的日志条数<br></code></pre></td></tr></table></figure><p><strong>查看容器中的进程信息</strong> ps用来查linux的进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意，要容器正在运行才能查的出来</span><br><br>docker top [容器id]<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   15 seconds ago   Up 14 seconds             pensive_dirac<br>[bupt_114@AIServer ~]$ docker top 8d05d658639d<br>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD<br>root                11758               11735               0                   21:37               pts/0               00:00:00            /bin/bash<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   About a minute ago   Up About a minute             pensive_dirac<br>[bupt_114@AIServer ~]$ docker inspect 8d05d658639d<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732&quot;,<br>        &quot;Created&quot;: &quot;2022-01-07T13:37:12.953676774Z&quot;,<br>        &quot;Path&quot;: &quot;/bin/bash&quot;,<br>        &quot;Args&quot;: [],<br>        &quot;State&quot;: &#123;<br>            &quot;Status&quot;: &quot;running&quot;,<br>            &quot;Running&quot;: true,<br>            &quot;Paused&quot;: false,<br>            &quot;Restarting&quot;: false,<br>            &quot;OOMKilled&quot;: false,<br>            &quot;Dead&quot;: false,<br>            &quot;Pid&quot;: 11758,<br>            &quot;ExitCode&quot;: 0,<br>            &quot;Error&quot;: &quot;&quot;,<br>            &quot;StartedAt&quot;: &quot;2022-01-07T13:37:13.28978368Z&quot;,<br>            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;,<br>        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,<br>        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/resolv.conf&quot;,<br>        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hostname&quot;,<br>        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hosts&quot;,<br>        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732-json.log&quot;,<br>        &quot;Name&quot;: &quot;/pensive_dirac&quot;,<br>        &quot;RestartCount&quot;: 0,<br>        &quot;Driver&quot;: &quot;overlay2&quot;,<br>        &quot;Platform&quot;: &quot;linux&quot;,<br>        &quot;MountLabel&quot;: &quot;&quot;,<br>        &quot;ProcessLabel&quot;: &quot;&quot;,<br>        &quot;AppArmorProfile&quot;: &quot;&quot;,<br>        &quot;ExecIDs&quot;: null,<br>        &quot;HostConfig&quot;: &#123;<br>            &quot;Binds&quot;: null,<br>            &quot;ContainerIDFile&quot;: &quot;&quot;,<br>            &quot;LogConfig&quot;: &#123;<br>                &quot;Type&quot;: &quot;json-file&quot;,<br>                &quot;Config&quot;: &#123;&#125;<br>            &#125;,<br>            &quot;NetworkMode&quot;: &quot;default&quot;,<br>            &quot;PortBindings&quot;: &#123;&#125;,<br>            &quot;RestartPolicy&quot;: &#123;<br>                &quot;Name&quot;: &quot;no&quot;,<br>                &quot;MaximumRetryCount&quot;: 0<br>            &#125;,<br>            &quot;AutoRemove&quot;: false,<br>            &quot;VolumeDriver&quot;: &quot;&quot;,<br>            &quot;VolumesFrom&quot;: null,<br>            &quot;CapAdd&quot;: null,<br>            &quot;CapDrop&quot;: null,<br>            &quot;CgroupnsMode&quot;: &quot;host&quot;,<br>            &quot;Dns&quot;: [],<br>            &quot;DnsOptions&quot;: [],<br>            &quot;DnsSearch&quot;: [],<br>            &quot;ExtraHosts&quot;: null,<br>            &quot;GroupAdd&quot;: null,<br>            &quot;IpcMode&quot;: &quot;private&quot;,<br>            &quot;Cgroup&quot;: &quot;&quot;,<br>            &quot;Links&quot;: null,<br>            &quot;OomScoreAdj&quot;: 0,<br>            &quot;PidMode&quot;: &quot;&quot;,<br>            &quot;Privileged&quot;: false,<br>            &quot;PublishAllPorts&quot;: false,<br>            &quot;ReadonlyRootfs&quot;: false,<br>            &quot;SecurityOpt&quot;: null,<br>            &quot;UTSMode&quot;: &quot;&quot;,<br>            &quot;UsernsMode&quot;: &quot;&quot;,<br>            &quot;ShmSize&quot;: 67108864,<br>            &quot;Runtime&quot;: &quot;runc&quot;,<br>            &quot;ConsoleSize&quot;: [<br>                0,<br>                0<br>            ],<br>            &quot;Isolation&quot;: &quot;&quot;,<br>            &quot;CpuShares&quot;: 0,<br>            &quot;Memory&quot;: 0,<br>            &quot;NanoCpus&quot;: 0,<br>            &quot;CgroupParent&quot;: &quot;&quot;,<br>            &quot;BlkioWeight&quot;: 0,<br>            &quot;BlkioWeightDevice&quot;: [],<br>            &quot;BlkioDeviceReadBps&quot;: null,<br>            &quot;BlkioDeviceWriteBps&quot;: null,<br>            &quot;BlkioDeviceReadIOps&quot;: null,<br>            &quot;BlkioDeviceWriteIOps&quot;: null,<br>            &quot;CpuPeriod&quot;: 0,<br>            &quot;CpuQuota&quot;: 0,<br>            &quot;CpuRealtimePeriod&quot;: 0,<br>            &quot;CpuRealtimeRuntime&quot;: 0,<br>            &quot;CpusetCpus&quot;: &quot;&quot;,<br>            &quot;CpusetMems&quot;: &quot;&quot;,<br>            &quot;Devices&quot;: [],<br>            &quot;DeviceCgroupRules&quot;: null,<br>            &quot;DeviceRequests&quot;: null,<br>            &quot;KernelMemory&quot;: 0,<br>            &quot;KernelMemoryTCP&quot;: 0,<br>            &quot;MemoryReservation&quot;: 0,<br>            &quot;MemorySwap&quot;: 0,<br>            &quot;MemorySwappiness&quot;: null,<br>            &quot;OomKillDisable&quot;: false,<br>            &quot;PidsLimit&quot;: null,<br>            &quot;Ulimits&quot;: null,<br>            &quot;CpuCount&quot;: 0,<br>            &quot;CpuPercent&quot;: 0,<br>            &quot;IOMaximumIOps&quot;: 0,<br>            &quot;IOMaximumBandwidth&quot;: 0,<br>            &quot;MaskedPaths&quot;: [<br>                &quot;/proc/asound&quot;,<br>                &quot;/proc/acpi&quot;,<br>                &quot;/proc/kcore&quot;,<br>                &quot;/proc/keys&quot;,<br>                &quot;/proc/latency_stats&quot;,<br>                &quot;/proc/timer_list&quot;,<br>                &quot;/proc/timer_stats&quot;,<br>                &quot;/proc/sched_debug&quot;,<br>                &quot;/proc/scsi&quot;,<br>                &quot;/sys/firmware&quot;<br>            ],<br>            &quot;ReadonlyPaths&quot;: [<br>                &quot;/proc/bus&quot;,<br>                &quot;/proc/fs&quot;,<br>                &quot;/proc/irq&quot;,<br>                &quot;/proc/sys&quot;,<br>                &quot;/proc/sysrq-trigger&quot;<br>            ]<br>        &#125;,<br>        &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74-init/diff:/var/lib/docker/overlay2/70a302960300b9000282549b5adf25e9a4bd66f8e9c50f12844d5d156ea2c712/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br>        &quot;Mounts&quot;: [],<br>        &quot;Config&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;8d05d658639d&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: true,<br>            &quot;AttachStdout&quot;: true,<br>            &quot;AttachStderr&quot;: true,<br>            &quot;Tty&quot;: true,<br>            &quot;OpenStdin&quot;: true,<br>            &quot;StdinOnce&quot;: true,<br>            &quot;Env&quot;: [<br>                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;<br>            ],<br>            &quot;Cmd&quot;: [<br>                &quot;/bin/bash&quot;<br>            ],<br>            &quot;Image&quot;: &quot;centos&quot;,<br>            &quot;Volumes&quot;: null,<br>            &quot;WorkingDir&quot;: &quot;&quot;,<br>            &quot;Entrypoint&quot;: null,<br>            &quot;OnBuild&quot;: null,<br>            &quot;Labels&quot;: &#123;<br>                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,<br>                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,<br>                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,<br>                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,<br>                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;<br>            &#125;<br>        &#125;,<br>        &quot;NetworkSettings&quot;: &#123;<br>            &quot;Bridge&quot;: &quot;&quot;,<br>            &quot;SandboxID&quot;: &quot;e1251439f6970af7a132751b9c2f1bc9bcd997589ed16c1824047626a5c34153&quot;,<br>            &quot;HairpinMode&quot;: false,<br>            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,<br>            &quot;LinkLocalIPv6PrefixLen&quot;: 0,<br>            &quot;Ports&quot;: &#123;&#125;,<br>            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/e1251439f697&quot;,<br>            &quot;SecondaryIPAddresses&quot;: null,<br>            &quot;SecondaryIPv6Addresses&quot;: null,<br>            &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;,<br>            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>            &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>            &quot;GlobalIPv6PrefixLen&quot;: 0,<br>            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>            &quot;IPPrefixLen&quot;: 16,<br>            &quot;IPv6Gateway&quot;: &quot;&quot;,<br>            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>            &quot;Networks&quot;: &#123;<br>                &quot;bridge&quot;: &#123;<br>                    &quot;IPAMConfig&quot;: null,<br>                    &quot;Links&quot;: null,<br>                    &quot;Aliases&quot;: null,<br>                    &quot;NetworkID&quot;: &quot;46238680691e2ebb3e190ccf96fb7814787a55c663b4585dae38cd8e3abc4070&quot;,<br>                    &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;,<br>                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>                    &quot;IPPrefixLen&quot;: 16,<br>                    &quot;IPv6Gateway&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6PrefixLen&quot;: 0,<br>                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>                    &quot;DriverOpts&quot;: null<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令1</span><br>docker exec -it 容器id bashShell<br><br>[bupt_114@AIServer ~]$ docker exec -it 8d05d658639d /bin/bash<br>[root@8d05d658639d /]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令2，注意进入的是一个正在进行的命令行！！！！而不是开启一个新的窗口</span><br>docker attach 容器id<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   8 minutes ago   Up 8 minutes             pensive_dirac<br>[bupt_114@AIServer ~]$ docker attach 8d05d658639d<br>[root@8d05d658639d /]# ps -ef   <br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 13:37 pts/0    00:00:00 /bin/bash<br>root        30     1  0 13:45 pts/0    00:00:00 ps -ef<br>[root@8d05d658639d /]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment"># 进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dockerattach <span class="hljs-comment"># 进入容器正在执行的终端，不会启动新的进程！</span></span><br></code></pre></td></tr></table></figure><p><strong>从容器内拷贝文件到主机</strong> 注：从主机内拷到容器内一般用挂载来做！</p><p>容器内外是隔离的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp 容器id:容器内路径 目的的主机路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝使用一个手动过程，未来我们使用 -v 卷的技术，可以实现</span><br></code></pre></td></tr></table></figure><p>学习方式：命令全部跟着敲一遍，自己记录笔记</p><h2 id="docker命令小结"><a href="#docker命令小结" class="headerlink" title="docker命令小结"></a>docker命令小结</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-24-45.png"></p><p>docker的命令是十分多的，上边是常见的容器和镜像命令</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记2-安装环境-狂神视频</title>
    <link href="/2022/01/07/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/07/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>本篇博客记录根据狂神视频学习的Docker安装过程和一些安装后的基本配置</p><p>TODO 未来将在此博客补充Docker的离线部署过程，在真实的使用场景下还是有很多离线部署的场景需求的</p><span id="more"></span><h1 id="Docker安装环境和一些基础配置"><a href="#Docker安装环境和一些基础配置" class="headerlink" title="Docker安装环境和一些基础配置"></a>Docker安装环境和一些基础配置</h1><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p><strong>注，下述安装过程是联网配置的过程，如果是离线部署的话还需要未来进一步学习</strong></p><blockquote><p>环境准备</p></blockquote><p>1、需要会一点点Linux的基础；<br>2、CentOS7；<br>3、使用finalshell连接远程服务器进行操作；</p><p>个人在学习过程中在拥有root权限的zfx223服务器上操作，这样比较方便安装各种依赖环境等。环境查看如下所示：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 系统内核是3.10以上的</span><br>[root<span class="hljs-symbol">@AIServer</span> ~]<span class="hljs-meta"># uname -r</span><br><span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-957.</span>el7.x86_64<br>[root<span class="hljs-symbol">@AIServer</span> ~]<span class="hljs-meta"># </span><br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 查看系统版本</span><br><span class="hljs-section">[root@AIServer ~]</span><span class="hljs-comment"># cat /etc/os-release</span><br><span class="hljs-attr">NAME</span>=<span class="hljs-string">&quot;CentOS Linux&quot;</span><br><span class="hljs-attr">VERSION</span>=<span class="hljs-string">&quot;7 (Core)&quot;</span><br><span class="hljs-attr">ID</span>=<span class="hljs-string">&quot;centos&quot;</span><br><span class="hljs-attr">ID_LIKE</span>=<span class="hljs-string">&quot;rhel fedora&quot;</span><br><span class="hljs-attr">VERSION_ID</span>=<span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-attr">PRETTY_NAME</span>=<span class="hljs-string">&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="hljs-attr">ANSI_COLOR</span>=<span class="hljs-string">&quot;0;31&quot;</span><br><span class="hljs-attr">CPE_NAME</span>=<span class="hljs-string">&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="hljs-attr">HOME_URL</span>=<span class="hljs-string">&quot;https://www.centos.org/&quot;</span><br><span class="hljs-attr">BUG_REPORT_URL</span>=<span class="hljs-string">&quot;https://bugs.centos.org/&quot;</span><br><br><span class="hljs-attr">CENTOS_MANTISBT_PROJECT</span>=<span class="hljs-string">&quot;CentOS-7&quot;</span><br><span class="hljs-attr">CENTOS_MANTISBT_PROJECT_VERSION</span>=<span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-attr">REDHAT_SUPPORT_PRODUCT</span>=<span class="hljs-string">&quot;centos&quot;</span><br><span class="hljs-attr">REDHAT_SUPPORT_PRODUCT_VERSION</span>=<span class="hljs-string">&quot;7&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>安装</p></blockquote><p>参考帮助文档，docs.docker.com</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-05-32.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、 卸载旧的版本</span><br>[root@AIServer ~]# yum remove docker \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">                  docker-client \</span><br><span class="language-bash">&gt;                   docker-client-latest \</span><br><span class="language-bash">&gt;                   docker-common \</span><br><span class="language-bash">&gt;                   docker-latest \</span><br><span class="language-bash">&gt;                   docker-latest-logrotate \</span><br><span class="language-bash">&gt;                   docker-logrotate \</span><br><span class="language-bash">&gt;                   docker-engine</span><br>已加载插件：fastestmirror, langpacks<br>参数 docker 没有匹配<br>参数 docker-client 没有匹配<br>参数 docker-client-latest 没有匹配<br>参数 docker-common 没有匹配<br>参数 docker-latest 没有匹配<br>参数 docker-latest-logrotate 没有匹配<br>参数 docker-logrotate 没有匹配<br>参数 docker-engine 没有匹配<br>不删除任何软件包<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2、 需要的安装包</span><br>[root@AIServer ~]# yum install -y yum-utils<br>已加载插件：fastestmirror, langpacks<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * centos-gluster7: mirrors.aliyun.com<br> * centos-ovirt42: mirrors.aliyun.com<br> * centos-ovirt43: mirrors.aliyun.com<br> * centos-qemu-ev: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.huaweicloud.com<br>base                                                                                                                                                     | 3.6 kB  00:00:00     <br>centos-gluster7                                                                                                                                          | 3.0 kB  00:00:00     <br>centos-ovirt42                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-ovirt43                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-qemu-ev                                                                                                                                           | 3.0 kB  00:00:00     <br>centos-release-opstools                                                                                                                                  | 2.9 kB  00:00:00     <br>extras                                                                                                                                                   | 2.9 kB  00:00:00     <br>updates                                                                                                                                                  | 2.9 kB  00:00:00     <br>正在解决依赖关系<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">正在检查事务</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">软件包 yum-utils.noarch.0.1.1.31-50.el7 将被 升级</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">软件包 yum-utils.noarch.0.1.1.31-54.el7_8 将被 更新</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">解决依赖关系完成</span><br><br>依赖关系解决<br><br>================================================================================================================================================================================<br> Package                                   架构                                   版本                                               源                                    大小<br>================================================================================================================================================================================<br>正在更新:<br> yum-utils                                 noarch                                 1.1.31-54.el7_8                                    base                                 122 k<br><br>事务概要<br>================================================================================================================================================================================<br>升级  1 软件包<br><br>总计：122 k<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在更新    : yum-utils-1.1.31-54.el7_8.noarch                                                                                                                            1/2 <br>  清理        : yum-utils-1.1.31-50.el7.noarch                                                                                                                              2/2 <br>  验证中      : yum-utils-1.1.31-54.el7_8.noarch                                                                                                                            1/2 <br>  验证中      : yum-utils-1.1.31-50.el7.noarch                                                                                                                              2/2 <br><br>更新完毕:<br>  yum-utils.noarch 0:1.1.31-54.el7_8                                                                                                                                            <br><br>完毕！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">3、 设置镜像的仓库（通过仓库的方法进行安装）<br><br>sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo  # 默认是从国外下载的，十分慢<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过如下方式找到国内的</span><br>https://blog.csdn.net/lvdingding/article/details/112862396<br><br>yum-config-manager \<br>--add-repo \<br>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br><br>[root@AIServer ~]# yum-config-manager \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">--add-repo \</span><br><span class="language-bash">&gt; http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br>已加载插件：fastestmirror, langpacks<br>adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo<br>repo saved to /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新yum软件包索引，下述步骤中的fastestmirror还需要进一步学习</span><br>yum makecache <br><br>[root@AIServer ~]# yum makecache fast<br>已加载插件：fastestmirror, langpacks<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * centos-gluster7: mirrors.aliyun.com<br> * centos-ovirt42: mirrors.aliyun.com<br> * centos-ovirt43: mirrors.aliyun.com<br> * centos-qemu-ev: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.huaweicloud.com<br>base                                                                                                                                                     | 3.6 kB  00:00:00     <br>centos-gluster7                                                                                                                                          | 3.0 kB  00:00:00     <br>centos-ovirt42                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-ovirt43                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-qemu-ev                                                                                                                                           | 3.0 kB  00:00:00     <br>centos-release-opstools                                                                                                                                  | 2.9 kB  00:00:00     <br>docker-ce-stable                                                                                                                                         | 3.5 kB  00:00:00     <br>extras                                                                                                                                                   | 2.9 kB  00:00:00     <br>updates                                                                                                                                                  | 2.9 kB  00:00:00     <br>元数据缓存已建立<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4、安装docker相关的 docker-ce社区版， ee企业版  安装的过程一路<span class="hljs-built_in">yes</span>过去~</span><br>yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">5、 启动docker<br>systemctl start docker<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">6、 使用docker version查看是否安装成功<br>[bupt_114@AIServer ~]$ docker version  # 查看是否安装成功<br>Client: Docker Engine - Community<br> Version:           20.10.12<br> API version:       1.41<br> Go version:        go1.16.12<br> Git commit:        e91ed57<br> Built:             Mon Dec 13 11:45:41 2021<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      true<br><br>......<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">7、 hello-world<br><br>docker run hello-world<br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-06-12.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">8、 查看一下下载的这个hello-world镜像<br>[root@AIServer ~]# docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<br>[root@AIServer ~]# <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">了解，卸载docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载依赖</span><br>sudo yum remove docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除资源</span><br>sudo rm -rf /var/lib/docker<br>sudo rm -rf /var/lib/containerd<br></code></pre></td></tr></table></figure><h2 id="Docker各个用户权限的设置，用户组"><a href="#Docker各个用户权限的设置，用户组" class="headerlink" title="Docker各个用户权限的设置，用户组"></a>Docker各个用户权限的设置，用户组</h2><p>Reference: <a href="https://www.cnblogs.com/franson-2016/p/6412971.html">https://www.cnblogs.com/franson-2016/p/6412971.html</a></p><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><p>这是针对在阿里云上购买而言的，而且好像要收费？</p><p>1、登录阿里云，找到容器服务<br>2、找到镜像加速地址<br>3、配置使用</p><h2 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h2><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-09-18.png"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker是怎么工作的</strong></p><p>Docker是一个Clinet-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问</p><p>DockerServer接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-09-49.png"></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层。<br>2、Docker利用的是宿主机的内核，vm需要是Guest OS。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-10-23.png"></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-08-00-10-57.png"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1614.括号的最大嵌套深度-python</title>
    <link href="/2022/01/07/algorithms/leetcode-python/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-python/"/>
    <url>/2022/01/07/algorithms/leetcode-python/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-python/</url>
    
    <content type="html"><![CDATA[<p>1614.括号的最大嵌套深度（简单）</p><p>题目大意：</p><p>如果字符串满足以下条件之一，则可以称之为<strong>有效括号字符串（valid parentheses string</strong>，可以简写为<strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串<code>&quot;&quot;</code>，或者是一个不为<code>&quot;(&quot;</code>或<code>&quot;)&quot;</code>的单字符。</li><li>字符串可以写为<code>AB</code>（<code>A</code>与<code>B</code>字符串连接），其中<code>A</code>和<code>B</code>都是 有效括号字符串 。</li><li>字符串可以写为<code>(A)</code>，其中<code>A</code>是一个 有效括号字符串 。</li></ul><p>类似地，可以定义任何有效括号字符串<code>S</code>的 嵌套深度<code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中<code>C</code>是单个字符的字符串，且该字符不是<code>&quot;(&quot;</code>或者<code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中<code>A</code>和<code>B</code>都是 有效括号字符串</li><li><code>epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中<code>A</code>是一个 有效括号字符串</li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code>都是 有效括号字符串（嵌套深度分别为 0、1、2），而<code>&quot;)(&quot;</code>、<code>&quot;(()&quot;</code>都不是 有效括号字符串 。</p><p>给你一个<strong>有效括号字符串</strong><code>s</code>，返回该字符串的<code>s</code><strong>嵌套深度</strong>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">题目链接</a></p><p>题目大意：</p><p>如果字符串满足以下条件之一，则可以称之为<strong>有效括号字符串（valid parentheses string</strong>，可以简写为<strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串<code>&quot;&quot;</code>，或者是一个不为<code>&quot;(&quot;</code>或<code>&quot;)&quot;</code>的单字符。</li><li>字符串可以写为<code>AB</code>（<code>A</code>与<code>B</code>字符串连接），其中<code>A</code>和<code>B</code>都是 有效括号字符串 。</li><li>字符串可以写为<code>(A)</code>，其中<code>A</code>是一个 有效括号字符串 。</li></ul><p>类似地，可以定义任何有效括号字符串<code>S</code>的 嵌套深度<code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中<code>C</code>是单个字符的字符串，且该字符不是<code>&quot;(&quot;</code>或者<code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中<code>A</code>和<code>B</code>都是 有效括号字符串</li><li><code>epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中<code>A</code>是一个 有效括号字符串</li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code>都是 有效括号字符串（嵌套深度分别为 0、1、2），而<code>&quot;)(&quot;</code>、<code>&quot;(()&quot;</code>都不是 有效括号字符串 。</p><p>给你一个<strong>有效括号字符串</strong><code>s</code>，返回该字符串的<code>s</code><strong>嵌套深度</strong>。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1+(2*3)+((8)/4))+1&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：数字 <span class="hljs-number">8</span> 在嵌套的 <span class="hljs-number">3</span> 层括号中。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1)+((2))+(((3)))&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1+(2*3)/(2-1)&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 由数字 0-9 和字符 ‘+’、’-‘、’*’、’&#x2F;‘、’(‘、’)’ 组成</li><li>题目数据保证括号表达式 s 是 有效的括号表达式</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题如果是python的话只要搞个list模拟栈就可以了，每次操作的时候判断当前list的长度，来更新max_depth还是很简单的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        max_depth = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(c)<br>            <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                stack = stack[:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 截断到最后一个</span><br>            <br>            max_depth = <span class="hljs-built_in">max</span>(max_depth, <span class="hljs-built_in">len</span>(stack))<br>        <span class="hljs-keyword">return</span> max_depth<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64.最小路径和-python</title>
    <link href="/2022/01/06/algorithms/leetcode-python/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-python/"/>
    <url>/2022/01/06/algorithms/leetcode-python/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>64.最小路径和（中等）</p><p>题目大意：</p><p>给定一个包含非负整数的<code>m x n</code>网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">题目链接</a></p><p>题目大意：</p><p>给定一个包含非负整数的<code>m x n</code>网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-06-14-30-08.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; grid.length</li><li>n &#x3D;&#x3D; grid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 200</li><li>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>也是一眼就能看出来是二维dp的题目，往下走和往右都是只有一种不断累加的走法</p><p>之后的状态转移方程<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 一眼dp，然后想想dp的思路应该也挺简单的，做一个min应该就行吧</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <br>        <span class="hljs-comment"># 初始化dp数组的第一行，第一列</span><br>        <span class="hljs-comment">## 初始化dp数组的第一行</span><br>        now = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            now += grid[<span class="hljs-number">0</span>][i]<br>            dp[<span class="hljs-number">0</span>][i] = now<br>        <span class="hljs-comment">## 初始化dp数组的第一列</span><br>        now = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            now += grid[i][<span class="hljs-number">0</span>]<br>            dp[i][<span class="hljs-number">0</span>] = now<br>        <span class="hljs-comment"># print(dp)</span><br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j]<br>        <br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>62.不同路径-python</title>
    <link href="/2022/01/06/algorithms/leetcode-python/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-python/"/>
    <url>/2022/01/06/algorithms/leetcode-python/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>62.不同路径（中等）</p><p>题目大意：</p><p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">题目链接</a></p><p>题目大意：</p><p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-06-14-14-44.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于<code>2 * 109</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>很明显的二维dp，向下走的所有格子和向右走的所有格子都只有一种走法，所以初始化为1</p><p>之后的状态转移方程很好想<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-comment"># 把第一行第一列进行初始化，第一行第一列都只有一种走法</span><br>        <span class="hljs-comment">## 第一行 </span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>        <span class="hljs-comment">## 第一列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 开启新的dp状态转移</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-comment"># 新的mn位置处有几种到达走法</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141.环形链表-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>141.环形链表（简单）</p><p>题目大意：</p><p>给你一个链表的头节点<code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪<code>next</code>指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。如果<code>pos</code>是<code>-1</code>，则在该链表中没有环。注意：<code>pos</code>不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">题目链接</a></p><p>题目大意：</p><p>给你一个链表的头节点<code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪<code>next</code>指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。如果<code>pos</code>是<code>-1</code>，则在该链表中没有环。注意：<code>pos</code>不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-23-41-23.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-23-41-35.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p>示例3：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-23-41-45.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="方法1，普通的字典法"><a href="#方法1，普通的字典法" class="headerlink" title="方法1，普通的字典法"></a>方法1，普通的字典法</h2><p>这个node对象是可哈希化的，可以用来当做键，所以设置一个字典就知道了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        save_dict = &#123;&#125;<br>        <span class="hljs-keyword">while</span> head != <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> save_dict.get(head) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            save_dict[head] = <span class="hljs-number">1</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="方法2，巧妙的修改值法"><a href="#方法2，巧妙的修改值法" class="headerlink" title="方法2，巧妙的修改值法"></a>方法2，巧妙的修改值法</h2><p>妙！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> head != <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> head.val == <span class="hljs-string">&quot;啊哈哈哈哈&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                head.val = <span class="hljs-string">&quot;啊哈哈哈哈&quot;</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="方法3，快慢指针"><a href="#方法3，快慢指针" class="headerlink" title="方法3，快慢指针"></a>方法3，快慢指针</h2><p>一个慢的乌龟和一个快的兔子，兔子跑得快，如果有环那兔子是总能追上乌龟的</p><p>快慢指针需要注意不能条件的判断，要把例如head和head.next这种的一起来判断！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 先要把异常判断做好了</span><br>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        slow_turtle = head<br>        fast_rabbit = head.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">while</span> slow_turtle != fast_rabbit:<br>            <span class="hljs-keyword">if</span> fast_rabbit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> fast_rabbit.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                slow_turtle = slow_turtle.<span class="hljs-built_in">next</span><br>                fast_rabbit = fast_rabbit.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49.字母异位词分组-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-python/</url>
    
    <content type="html"><![CDATA[<p>49.字母异位词分组（中等）</p><p>题目大意：</p><p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong>是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/">题目链接</a></p><p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong>是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code>仅包含小写字母</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题想想自己做法也挺奇葩的，只能说Counter永远的神了</p><p>先重整理数组，在原有的字符串基础上变成<code>[字符串, Counter对象, 标记位（标记是否已经加入了）]</code></p><p>一个两重for循环，在外层for循环中，如果没有加入则加入，如果已经加入了则continue。在内层循环中，a-b, b-a判断Counter是否相等（这里比如a是外层的i，b是内层的j），如果相等并且没加入，就加入到外层循环初始化的list中，然后内层循环结束后append</p><p><strong>Counter永远的神！（除了效率hhh）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type strs: List[str]</span><br><span class="hljs-string">        :rtype: List[List[str]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>        <br>        <span class="hljs-comment"># 一旦用上Coutner耗时就会很高？ 不过Counter真的是个好东西</span><br>        temp_list = []<br>        <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(strs):<br>            temp_list.append([item, Counter(item), <span class="hljs-number">0</span>])  <span class="hljs-comment"># 0是一个标记位，标记是否被加进去了</span><br>        <br>        return_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp_list)):<br>            <span class="hljs-keyword">if</span> temp_list[i][<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            add_list = [temp_list[i][<span class="hljs-number">0</span>]]<br>            temp_list[i][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(temp_list)):<br>                <span class="hljs-keyword">if</span> temp_list[j][<span class="hljs-number">1</span>] == temp_list[i][<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> temp_list[j][<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>:<br>                    add_list.append(temp_list[j][<span class="hljs-number">0</span>])<br>                    temp_list[j][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>            return_list.append(add_list)<br>            add_list = []<br>    <br>        <span class="hljs-keyword">return</span> return_list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>排序</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48.旋转图像-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-python/</url>
    
    <content type="html"><![CDATA[<p>48.旋转图像（中等）</p><p>题目大意：</p><p>给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/">题目链接</a></p><p>题目大意：</p><p>给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-21-46-28.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-21-46-42.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1]]</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-string">[[3,1],[4,2]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>matrix.length == n</code></li><li><code>matrix[i].length == n</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>直接硬转实在是太考验人了，所以现在是两种方法，这样算起来就变简单非常多了</p><ul><li>先水平翻转，再沿副对角线翻转</li><li>先上下翻转，再沿主对角线翻转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type matrix: List[List[int]]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 首先进行左右翻转，然后按照副对角线进行翻转，在torch里是triu相关的操作，哈哈</span><br>        n = <span class="hljs-built_in">len</span>(matrix)  <span class="hljs-comment"># 一个 nxn 的矩阵</span><br>        <span class="hljs-comment">## 执行左右翻转</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n//<span class="hljs-number">2</span>):<br>                <span class="hljs-comment"># 执行翻转</span><br>                temp = matrix[i][j]<br>                matrix[i][j] = matrix[i][n-<span class="hljs-number">1</span>-j]<br>                matrix[i][n-<span class="hljs-number">1</span>-j] = temp<br>        <span class="hljs-comment"># print(matrix)</span><br>        <span class="hljs-comment">## 按照副对角线进行翻转，事后复盘来看的话，按照副对角线翻转有些复杂了</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>-i):<br>                <span class="hljs-comment"># 执行翻转</span><br>                temp = matrix[i][j]<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-j][n-<span class="hljs-number">1</span>-i]<br>                matrix[n-<span class="hljs-number">1</span>-j][n-<span class="hljs-number">1</span>-i] = temp<br>                <br>                <span class="hljs-comment"># print(i, j)</span><br>        <br>        <span class="hljs-comment"># print(matrix)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1576.替换所有的问号-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/1576-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/1576-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7-python/</url>
    
    <content type="html"><![CDATA[<p>1576.替换所有的问号（简单）</p><p>题目大意：</p><p>给你一个仅包含小写英文字母和<code>&#39;?&#39;</code>字符的字符串<code>s</code>，请你将所有的<code>&#39;?&#39;</code>转换为若干小写字母，使最终的字符串不包含任何<strong>连续重复</strong>的字符。</p><p>注意：你<strong>不能</strong>修改非<code>&#39;?&#39;</code>字符。</p><p>题目测试用例保证<strong>除</strong><code>&#39;?&#39;</code>字符<strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">题目链接</a></p><p>题目大意：</p><p>给你一个仅包含小写英文字母和<code>&#39;?&#39;</code>字符的字符串<code>s</code>，请你将所有的<code>&#39;?&#39;</code>转换为若干小写字母，使最终的字符串不包含任何<strong>连续重复</strong>的字符。</p><p>注意：你<strong>不能</strong>修改非<code>&#39;?&#39;</code>字符。</p><p>题目测试用例保证<strong>除</strong><code>&#39;?&#39;</code>字符<strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;?zs&quot;</span><br>输出：<span class="hljs-string">&quot;azs&quot;</span><br>解释：该示例共有 <span class="hljs-number">25</span> 种解决方案，从 <span class="hljs-string">&quot;azs&quot;</span> 到 <span class="hljs-string">&quot;yzs&quot;</span> 都是符合题目要求的。只有 <span class="hljs-string">&quot;z&quot;</span> 是无效的修改，因为字符串 <span class="hljs-string">&quot;zzs&quot;</span> 中有连续重复的两个 &#x27;z&#x27; 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ubv?w&quot;</span><br>输出：<span class="hljs-string">&quot;ubvaw&quot;</span><br>解释：该示例共有 <span class="hljs-number">24</span> 种解决方案，只有替换成 <span class="hljs-string">&quot;v&quot;</span> 和 <span class="hljs-string">&quot;w&quot;</span> 不符合题目要求。因为 <span class="hljs-string">&quot;ubvvw&quot;</span> 和 <span class="hljs-string">&quot;ubvww&quot;</span> 都包含连续重复的字符。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;j?qg??b&quot;</span><br>输出：<span class="hljs-string">&quot;jaqgacb&quot;</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;??yw?ipkj?&quot;</span><br>输出：<span class="hljs-string">&quot;acywaipkja&quot;</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 仅包含小写英文字母和 ‘?’ 字符</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>每日一题还是挺简单的，这题主要注意的情况是一个字符最多相邻两个，也就是说只要准备三个需要被换的字符，比如<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>就可以了</p><p>另外是还需要判断问号连续出现的情况就行了</p><p>另：python的字符串处理最好先用列表，然后再join到一起，耗时问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">modifyString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 注意可能连续出现两个问号！！！！</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;?&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><br>        letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]  <span class="hljs-comment"># 必将在三个字母中找到答案！ 这个地方还是挺关键的</span><br>        return_list = []  <span class="hljs-comment"># python字符串，先用list，然后join回去</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] != <span class="hljs-string">&#x27;?&#x27;</span>:<br>                return_list.append(s[i])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != s[i+<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> i == <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != return_list[i-<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != s[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> letter != return_list[i-<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(return_list)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记1-背景-狂神视频</title>
    <link href="/2022/01/05/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E8%83%8C%E6%99%AF-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/05/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E8%83%8C%E6%99%AF-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>在未来的项目部署中一定还会用到Docker，k8s等，该篇博客主要记录学习Docker的过程</p><p>之后还会整理一篇离线普通方式部署的博客，现在离线普通方式部署自己操作过几次弄的比较明白了，但是问题是对接方很难完全弄明白，所以也是学习Docker的原因之一吧</p><span id="more"></span><h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li><li>Docker Compose（集群编排）</li><li>Docker Swarm（集群管理，简化版k8s）</li><li>CI&#x2F;CD Jenkins</li></ul><h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h2><p>一款产品：开发-上线，两套环境！环境部署一次是非常麻烦的，应用环境，应用配置等</p><p>开发 —- 运维。问题：我在我的电脑上可以运行！版本更新，导致服务不可用（例如最近的log4j漏洞更新）！对于运维来说比较麻烦</p><p>开发即运维！环境配置是十分的麻烦，每一个机器都要部署环境（集群Redis，ES，Hadoop……）！费时费力。</p><p>发布一个项目，（jar + （Redis，MySQL，ES，jdk））一整套的环境，项目能不能都带上环境安装打包！</p><p>之前在服务器配置一个应用的环境Redis，MySQL，ES，jdk，Hadoop，配置超麻烦了，不能够跨平台。</p><p>Windows，最后发布到Linux，环境上的区别很大</p><p>传统：开发给一个jar包，其他交给运维来做</p><p>现在：开发打包部署上线，一套流程做完</p><p>&amp;nbsp;</p><p>java – apk – 发布（应用商店） – 张三使用apk – 安装即可用！</p><p>java – jar（环境） – 打包项目带上环境（镜像） – （Docker仓库：商店） – 下载我们发布的镜像 – 直接运行即可！</p><p>&amp;nbsp;</p><p>Docker给以上问题提出了解决方案，思想就来自于集装箱！</p><p>JRE – 多个应用（端口冲突） – 原来都是交叉的！</p><p><strong>隔离</strong>：Docker核心思想！打包装箱！每个箱子是互相隔离的</p><p>水果 生化武器</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！（Error analyze）</p><p>&amp;nbsp;</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>API小子哈哈哈哈，我爬了，还是做API小子吧</p><p>2013年docker开源，2014.4.9 docker1.0开源，相较于虚拟机非常轻量化。docker是一种容器技术。</p><p>虚拟机也是属于虚拟化技术，Docker容器技术也是一种虚拟化技术！</p><p>vm：centos等等，隔离，需要开启多个虚拟机！几G</p><p>docker：隔离，镜像（最核心的环境4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！</p><blockquote><p>聊聊docker</p></blockquote><p>Docker是基于Go语言开发的！是一个开源项目</p><p><a href="http://www.docker.com/">www.docker.com</a></p><p>docs.docker.com，Docker的文档是非常详细的</p><p>仓库地址：hub.docker.com git push, pull等等</p><p>虚拟化，容器沙箱机制</p><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><blockquote><p>之前的虚拟机技术</p></blockquote><p>虚拟机技术缺点：</p><p>1、资源占用非常多<br>2、冗余步骤多<br>3、启动很慢</p><blockquote><p>容器化技术 container</p></blockquote><p><strong>容器化技术不是模拟的一个完整的操作系统</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-15-40-13.png"></p><blockquote><p>比较Docker和虚拟机技术的不同</p></blockquote><ul><li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件；</li><li>容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li><li>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li></ul><blockquote><p>DevOps(开发、运维)</p></blockquote><p><strong>应用更快速的交付和部署</strong></p><p>传统：一堆帮助文档，安装程序</p><p>Docker：打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩缩容</strong></p><p>使用了docker之后，我们部署应用就像搭积木一样</p><p>Redis5，tomcat 分别升级</p><p>(redis, tomcat) 打包升级</p><p>水平扩展负载均衡</p><p><strong>更简单的系统运维</strong></p><p>在容器化之后，我们的开发，测试环境都是一致的，不会出现在我的电脑上能用，在别人的电脑上用不了这种情况</p><p><strong>更高效的计算资源利用</strong></p><p>一个服务器运行几十个redis等等，集群</p><p>Docker是内核级别的虚拟化，一个物理机上运行很多个容器实例</p><h1 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h1><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2022-01-05-15-55-22.png"></p><p>分成了三个部分，客户端、服务器、仓库</p><p>docker run运行一个哦让你去</p><p>docker pull拉取</p><p>docker build …..</p><p>镜像运行起来就变成容器了！ tomcat镜像，tomcat1容器，tomcat2容器，等等</p><p><strong>镜像（image）：</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 &#x3D;&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&#x3D;&gt; tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令！</p><p>目前就可以把这个容器理解为就是一个简易的linux系统，</p><p><strong>仓库（repository）：</strong></p><p>仓库就是存放镜像的地方！</p><ul><li>公有仓库</li><li>私有仓库</li></ul><p>Docker Hub（默认是国外的）</p><p>阿里云，都有容器服务（配置镜像加速）</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>274场LeetCode周赛</title>
    <link href="/2022/01/02/algorithms/leetcode-weekly-contest/274%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/02/algorithms/leetcode-weekly-contest/274%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前三个感觉都是水题，自己做的话感觉难得的10-20分钟就搞定了，因为是后来做的看了眼大佬们最快都做了20多分钟，前三个题这么简单的话第四题估计自己现在的水平很难做出来了；</p><p>第一题：一个由ab组成的字符串，如果b出现过了后边就不能出现a了，用一个flag判断就可以了；</p><p>第二题：用Counter统计每行1的个数，然后把0的行排除掉，<code>result += count[i] * count[i+1]</code>就可以了；</p><p>第三题：还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了；</p><p>第四题：未来有机会再试了</p><span id="more"></span><h1 id="第一题：2124-检查是否所有A都在B之前"><a href="#第一题：2124-检查是否所有A都在B之前" class="headerlink" title="第一题：2124.检查是否所有A都在B之前"></a>第一题：2124.检查是否所有A都在B之前</h1><p><a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个<strong>仅</strong>由字符<code>&#39;a&#39;</code>和<code>&#39;b&#39;</code>组成的字符串<code>s</code>。如果字符串中 每个<code>&#39;a&#39;</code>都出现在 每个<code>&#39;b&#39;</code>之前，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aaabbb&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br><span class="hljs-string">&#x27;a&#x27;</span> 位于下标 <span class="hljs-number">0</span>、<span class="hljs-number">1</span> 和 <span class="hljs-number">2</span> ；而 <span class="hljs-string">&#x27;b&#x27;</span> 位于下标 <span class="hljs-number">3</span>、<span class="hljs-number">4</span> 和 <span class="hljs-number">5</span> 。<br>因此，每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;abab&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>存在一个 <span class="hljs-string">&#x27;a&#x27;</span> 位于下标 <span class="hljs-number">2</span> ，而一个 <span class="hljs-string">&#x27;b&#x27;</span> 位于下标 <span class="hljs-number">1</span> 。<br>因此，不能满足每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;bbb&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>不存在 <span class="hljs-string">&#x27;a&#x27;</span> ，因此可以视作每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s[i] 为 ‘a’ 或 ‘b’</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>easy题，读懂题意就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> c == <span class="hljs-string">&#x27;a&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;b&#x27;</span>:<br>                flag = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2125-银行中的激光束数量"><a href="#第二题：2125-银行中的激光束数量" class="headerlink" title="第二题：2125.银行中的激光束数量"></a>第二题：2125.银行中的激光束数量</h1><p><a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>银行内部的防盗安全装置已经激活。给你一个下标从<strong>0</strong>开始的二进制字符串数组<code>bank</code>，表示银行的平面图，这是一个大小为<code>m x n</code>的二维矩阵。<code>bank[i]</code>表示第<code>i</code>行的设备分布，由若干<code>&#39;0&#39;</code>和若干<code>&#39;1&#39;</code>组成。<code>&#39;0&#39;</code>表示单元格是空的，而<code>&#39;1&#39;</code>表示单元格有一个安全设备。</p><p>对任意两个安全设备而言，<strong>如果同时</strong>满足下面两个条件，则二者之间存在 一个 激光束：</p><p>两个设备位于两个 不同行 ：<code>r1</code>和<code>r2</code>，其中<code>r1 &lt; r2</code>。<br>满足<code>r1 &lt; i &lt; r2</code>的<strong>所有</strong>行<code>i</code>，都<strong>没有安全设备</strong>。<br>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p><p>返回银行中激光束的总数量。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：bank = [<span class="hljs-string">&quot;011001&quot;</span>,<span class="hljs-string">&quot;000000&quot;</span>,<span class="hljs-string">&quot;010100&quot;</span>,<span class="hljs-string">&quot;001000&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：在下面每组设备对之间，存在一条激光束。总共是 <span class="hljs-number">8</span> 条激光束：<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<br> * bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] -- bank[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<br>注意，第 <span class="hljs-number">0</span> 行和第 <span class="hljs-number">3</span> 行上的设备之间不存在激光束。<br>这是因为第 <span class="hljs-number">2</span> 行存在安全设备，这不满足第 <span class="hljs-number">2</span> 个条件。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">bank </span>= [<span class="hljs-string">&quot;000&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-string">&quot;000&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：不存在两个位于不同行的设备<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; bank.length</li><li>n &#x3D;&#x3D; bank[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 500</li><li>bank[i][j] 为 ‘0’ 或 ‘1’</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解题意就比较好做了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfBeams</span>(<span class="hljs-params">self, bank</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bank: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = <span class="hljs-number">0</span><br>        num_list = []<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> bank:<br>            count = Counter(<span class="hljs-built_in">list</span>(item))[<span class="hljs-string">&#x27;1&#x27;</span>]<br>            <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span>:<br>                num_list.append(count)<br><br>        <span class="hljs-comment"># print(num_list)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num_list) - <span class="hljs-number">1</span>):<br>            result += num_list[i] * num_list[i+<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第三题：2126-摧毁小行星"><a href="#第三题：2126-摧毁小行星" class="headerlink" title="第三题：2126.摧毁小行星"></a>第三题：2126.摧毁小行星</h1><p><a href="https://leetcode-cn.com/problems/destroying-asteroids/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数<code>mass</code>，它表示一颗行星的初始质量。再给你一个整数数组<code>asteroids</code>，其中<code>asteroids[i]</code>是第<code>i</code>颗小行星的质量。</p><p>你可以按<strong>任意顺序</strong>重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量<strong>大于等于</strong>小行星的质量，那么小行星被<strong>摧毁</strong>，并且行星会<strong>获得</strong>这颗小行星的质量。否则，行星将被摧毁。</p><p>如果所有小行星<strong>都</strong>能被摧毁，请返回<code>true</code>，否则返回<code>false</code>。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mass = 10, asteroids = [3,9,19,5,21]<br>输出：true<br>解释：一种安排小行星的方式为 [9,19,5,3,21] ：<br>- 行星与质量为<span class="hljs-number"> 9 </span>的小行星碰撞。新的行星质量为：10 +<span class="hljs-number"> 9 </span>= 19<br>- 行星与质量为<span class="hljs-number"> 19 </span>的小行星碰撞。新的行星质量为：19 +<span class="hljs-number"> 19 </span>= 38<br>- 行星与质量为<span class="hljs-number"> 5 </span>的小行星碰撞。新的行星质量为：38 +<span class="hljs-number"> 5 </span>= 43<br>- 行星与质量为<span class="hljs-number"> 3 </span>的小行星碰撞。新的行星质量为：43 +<span class="hljs-number"> 3 </span>= 46<br>- 行星与质量为<span class="hljs-number"> 21 </span>的小行星碰撞。新的行星质量为：46 +<span class="hljs-number"> 21 </span>= 67<br>所有小行星都被摧毁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mass = 5, asteroids = [4,9,23,4]<br>输出：false<br>解释：<br>行星无论如何没法获得足够质量去摧毁质量为<span class="hljs-number"> 23 </span>的小行星。<br>行星把别的小行星摧毁后，质量为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 22 </span>。<br>它比<span class="hljs-number"> 23 </span>小，所以无法摧毁最后一颗小行星。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; mass &lt;&#x3D; 105</li><li>1 &lt;&#x3D; asteroids.length &lt;&#x3D; 105</li><li>1 &lt;&#x3D; asteroids[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">asteroidsDestroyed</span>(<span class="hljs-params">self, mass, asteroids</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type mass: int</span><br><span class="hljs-string">        :type asteroids: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        tmp_list = []<br>        <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(asteroids):<br>            <span class="hljs-keyword">if</span> item &lt;= mass:<br>                mass += item<br>            <span class="hljs-keyword">else</span>:<br>                tmp_list.append(item)<br>        <br>        tmp_list = <span class="hljs-built_in">sorted</span>(tmp_list, reverse=<span class="hljs-literal">False</span>)<br>        <br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> tmp_list:<br>            <span class="hljs-keyword">if</span> item &lt;= mass:<br>                mass += item<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>273场LeetCode周赛</title>
    <link href="/2021/12/26/algorithms/leetcode-weekly-contest/273%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2021/12/26/algorithms/leetcode-weekly-contest/273%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>第一题：感觉比较水，123400倒过来是004321，再倒回去是1234和原来的数字不一样了，这样其实可以直接判断末尾是不是0，还有是不是单独一个0就可以了；</p><p>第二题：矩阵内简单的模拟，up down left right，经过这四个操作后，不能越过矩阵的边界就行了，后缀在python里<code>[i:]</code>好像比较简单；</p><p>第三题：在当时做的时候何老板就在想是不是和数学有关的，后来听了卿哥的解答后感觉最关键的是abcde这个思路，这样比较容易可能能想到前缀和后缀的问题了，对于一个数字2，比如其角标在<code>[a, b, c, d, e]</code>五个位置，那么根据题意可以模拟下每个位置下的和，这样能看出来之间的关系，详见下文解答；</p><p>第四题：未来有机会再试了；</p><span id="more"></span><h1 id="第一题：2119-反转两次的数字"><a href="#第一题：2119-反转两次的数字" class="headerlink" title="第一题：2119.反转两次的数字"></a>第一题：2119.反转两次的数字</h1><p><a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>反转</strong>一个整数意味着倒置它的所有位。</p><p>例如，反转<code>2021</code>得到<code>1202</code>。反转<code>12300</code>得到<code>321</code>，<strong>不保留前导零</strong>。<br>给你一个整数<code>num</code>，<strong>反转</strong><code>num</code>得到<code>reversed1</code>，<strong>接着反转</strong><code>reversed1</code>得到<code>reversed2</code>。如果<code>reversed2</code>等于<code>num</code>，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">526</span><br>输出：<span class="hljs-keyword">true</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">625</span> ，接着反转 <span class="hljs-number">625</span> 得到 <span class="hljs-number">526</span> ，等于 <span class="hljs-built_in">num</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">1800</span><br>输出：<span class="hljs-keyword">false</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">81</span> ，接着反转 <span class="hljs-number">81</span> 得到 <span class="hljs-number">18</span> ，不等于 <span class="hljs-built_in">num</span> 。 <br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-keyword">true</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">0</span> ，接着反转 <span class="hljs-number">0</span> 得到 <span class="hljs-number">0</span> ，等于 <span class="hljs-built_in">num</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; num &lt;&#x3D; 106</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉不能被题面唬住了，还是判断后边有没有0就可以了，然后单独0的单独处理下；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameAfterReversals</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(num)) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(num)[-<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;0&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2120-执行所有后缀指令"><a href="#第二题：2120-执行所有后缀指令" class="headerlink" title="第二题：2120.执行所有后缀指令"></a>第二题：2120.执行所有后缀指令</h1><p><a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有一个<code>n x n</code>大小的网格，左上角单元格坐标<code>(0, 0)</code>，右下角单元格坐标<code>(n - 1, n - 1)</code>。给你整数<code>n</code>和一个整数数组<code>startPos</code>，其中<code>startPos = [startrow, startcol]</code>表示机器人最开始在坐标为<code>(startrow, startcol)</code>的单元格上。</p><p>另给你一个长度为<code>m</code>、下标从<code>0</code>开始的字符串<code>s</code>，其中<code>s[i]</code>是对机器人的第<code>i</code>条指令：<code>&#39;L&#39;</code>（向左移动），<code>&#39;R&#39;</code>（向右移动），<code>&#39;U&#39;</code>（向上移动）和 <code>&#39;D&#39;</code>（向下移动）。</p><p>机器人可以从<code>s</code>中的任一第<code>i</code>条指令开始执行。它将会逐条执行指令直到<code>s</code>的末尾，但在满足下述条件之一时，机器人将会停止：</p><p>下一条指令将会导致机器人移动到网格外。<br>没有指令可以执行。<br>返回一个长度为<code>m</code>的数组<code>answer</code>，其中<code>answer[i]</code>是机器人从第<code>i</code>条指令 开始 ，可以执行的 指令数目 。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">3</span>, startPos = <span class="hljs-selector-attr">[0,1]</span>, s = <span class="hljs-string">&quot;RRDDLU&quot;</span><br>输出：<span class="hljs-selector-attr">[1,5,4,3,1,0]</span><br>解释：机器人从 startPos 出发，并从第 <span class="hljs-selector-tag">i</span> 条指令开始执行：<br>- <span class="hljs-number">0</span>: <span class="hljs-string">&quot;RRDDLU&quot;</span> 在移动到网格外之前，只能执行一条 <span class="hljs-string">&quot;R&quot;</span> 指令。<br>- <span class="hljs-number">1</span>:  <span class="hljs-string">&quot;RDDLU&quot;</span> 可以执行全部五条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;DDLU&quot;</span> 可以执行全部四条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">3</span>:    <span class="hljs-string">&quot;DLU&quot;</span> 可以执行全部三条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">4</span>:     <span class="hljs-string">&quot;LU&quot;</span> 在移动到网格外之前，只能执行一条 <span class="hljs-string">&quot;L&quot;</span> 指令。<br>- <span class="hljs-number">5</span>:      <span class="hljs-string">&quot;U&quot;</span> 如果向上移动，将会移动到网格外。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">2</span>, startPos = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], s = <span class="hljs-string">&quot;LURD&quot;</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<br>- <span class="hljs-number">0</span>: <span class="hljs-string">&quot;LURD&quot;</span><br>- <span class="hljs-number">1</span>:  <span class="hljs-string">&quot;URD&quot;</span><br>- <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;RD&quot;</span><br>- <span class="hljs-number">3</span>:    <span class="hljs-string">&quot;D&quot;</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">1</span>, startPos = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], s = <span class="hljs-string">&quot;LRUD&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：无论机器人从哪条指令开始执行，都会移动到网格外。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; s.length</li><li>1 &lt;&#x3D; n, m &lt;&#x3D; 500</li><li>startPos.length &#x3D;&#x3D; 2</li><li>0 &lt;&#x3D; startrow, startcol &lt; n</li><li>s 由 ‘L’、’R’、’U’ 和 ‘D’ 组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较水，实际上是简单题，执行就可以了，后缀执行用<code>s[:i]</code>截断就可以了，边界的判断就像dfs couting lakes的判断一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">executeInstructions</span>(<span class="hljs-params">self, n, startPos, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type startPos: List[int]</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        matrix = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        cnt = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            startX = startPos[<span class="hljs-number">0</span>]<br>            startY = startPos[<span class="hljs-number">1</span>]<br>            tmp_seq = s[i:]<br>            <span class="hljs-comment"># print(cnt)</span><br>            <span class="hljs-keyword">for</span> j, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tmp_seq):<br>                <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startY - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>:<br>                        startY = startY - <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startY + <span class="hljs-number">1</span> &lt; n:<br>                        startY = startY + <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;U&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startX - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>:<br>                        startX = startX - <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;D&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startX + <span class="hljs-number">1</span> &lt; n:<br>                        startX = startX + <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>            <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：2121-相同元素的间隔之和"><a href="#第三题：2121-相同元素的间隔之和" class="headerlink" title="第三题：2121.相同元素的间隔之和"></a>第三题：2121.相同元素的间隔之和</h1><p><a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从<strong>0</strong>开始、由<code>n</code>个整数组成的数组<code>arr</code>。</p><p>arr 中两个元素的 间隔 定义为它们下标之间的<strong>绝对差</strong>。更正式地，<code>arr[i]</code>和<code>arr[j]</code>之间的间隔是<code>|i - j|</code>。</p><p>返回一个长度为<code>n</code>的数组<code>intervals</code>，其中<code>intervals[i]</code>是<code>arr[i]</code>和<code>arr</code>中每个相同元素（与<code>arr[i]</code>的值相同）的<strong>间隔之和</strong>。</p><p>注意：<code>|x|</code>是<code>x</code>的绝对值。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [2,1,3,1,2,3,3]<br>输出：[4,2,7,2,4,4,5]<br>解释：<br>- 下标<span class="hljs-number"> 0 </span>：另一个<span class="hljs-number"> 2 </span>在下标<span class="hljs-number"> 4 </span>，|0 - 4| = 4<br>- 下标<span class="hljs-number"> 1 </span>：另一个<span class="hljs-number"> 1 </span>在下标<span class="hljs-number"> 3 </span>，|1 - 3| = 2<br>- 下标<span class="hljs-number"> 2 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 6 </span>，|2 - 5| + |2 - 6| = 7<br>- 下标<span class="hljs-number"> 3 </span>：另一个<span class="hljs-number"> 1 </span>在下标<span class="hljs-number"> 1 </span>，|3 - 1| = 2<br>- 下标<span class="hljs-number"> 4 </span>：另一个<span class="hljs-number"> 2 </span>在下标<span class="hljs-number"> 0 </span>，|4 - 0| = 4<br>- 下标<span class="hljs-number"> 5 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 6 </span>，|5 - 2| + |5 - 6| = 4<br>- 下标<span class="hljs-number"> 6 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 5 </span>，|6 - 2| + |6 - 5| = 5<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [10,5,10,10]<br>输出：[5,0,3,4]<br>解释：<br>- 下标<span class="hljs-number"> 0 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>，|0 - 2| + |0 - 3| = 5<br>- 下标<span class="hljs-number"> 1 </span>：只有这一个<span class="hljs-number"> 5 </span>在数组中，所以到相同元素的间隔之和是 0<br>- 下标<span class="hljs-number"> 2 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>，|2 - 0| + |2 - 3| = 3<br>- 下标<span class="hljs-number"> 3 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>，|3 - 0| + |3 - 2| = 4<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; arr.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 105</li><li>1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>思路还是很巧妙的，假设一个<code>[a, b, c, d, e]</code>角标数组，现在要统计<code>c</code>这个位置下的角标绝对差，那么这个位置上就是<code>(c-a) + (c-b) + (d-c) + (e-c)</code>，如果要统计</p><figure class="highlight plaintext"><figcaption><span>+ (d-b) + (d-c) + (e-d)```，这样：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs d```这个位置下的角标绝对差，那么这个位置上就是```(d-a)"><br>- 在```c```的位置下看规律，前缀（left_sum）是```a+b```，后缀（right_sum）是```d+e```，求和是：```(c-a) + (c-b) + (d-c) + (e-c)```<br><br>- 在```d```的位置下看规律，前缀（left_sum）是```a+b+c```，后缀（right_sum）是```e```，求和是：```(d-a) + (d-b) + (d-c) + (e-d)```<br><br>这样感觉可以总结出来规律了，在哪个角标x位置，就是：``` ((x * 前缀个数) - 前缀) + (后缀 - (x * 后缀个数))```，这样前缀后缀可以通过一种类似于滑动窗口的方法更新，大大减少了时间复杂度。<br><br><br>```python<br>class Solution(object):<br>    def getDistances(self, arr):<br>        &quot;&quot;&quot;<br>        :type arr: List[int]<br>        :rtype: List[int]<br>        &quot;&quot;&quot;<br>        return_list = [0 for i in range(len(arr))]<br><br>        # 把arr转化为一个map，类似于3: [2, 5, 6]这样的，前边是数值，后边是数值的角标<br>        tmp_dict = &#123;&#125;  # &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;<br>        for i, item in enumerate(arr):<br>            if tmp_dict.get(arr[i]) is None:<br>                tmp_dict[arr[i]] = [i]<br>            else:<br>                tmp_dict[arr[i]].append(i)<br>        <br>        for key, value in tmp_dict.items():<br>            # 在每个value中，使用 a b c d e的思想<br>            left_sum = 0<br>            left_cnt = 0<br>            right_sum = 0<br>            right_cnt = 0<br>            for i in range(0, len(value)):<br>                right_sum += value[i]<br>                right_cnt += 1<br>            <br>            for i in range(len(value)):<br>                # 滑动窗口的感觉<br>                right_sum -= value[i]<br>                right_cnt -= 1<br>                return_list[value[i]] = (right_sum - (right_cnt * value[i])) + (left_cnt * value[i] - left_sum)<br>                left_sum += value[i]<br>                left_cnt += 1<br>                <br>        return return_list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>709.转换成小写字母-python</title>
    <link href="/2021/12/19/algorithms/leetcode-python/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D-python/"/>
    <url>/2021/12/19/algorithms/leetcode-python/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D-python/</url>
    
    <content type="html"><![CDATA[<p>709.转换成小写字母（简单）</p><p>题目大意：</p><p>给你一个字符串<code>s</code>，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/to-lower-case/">题目链接</a></p><p>给你一个字符串<code>s</code>，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span><br>输出：<span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;here&quot;</span><br>输出：<span class="hljs-string">&quot;here&quot;</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LOVELY&quot;</span><br>输出：<span class="hljs-string">&quot;lovely&quot;</span><br></code></pre></td></tr></table></figure><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>主要是python语言的转小写，<code>str.lower()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toLowerCase</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> s.lower()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>200.岛屿数量-python</title>
    <link href="/2021/12/17/algorithms/leetcode-python/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-python/"/>
    <url>/2021/12/17/algorithms/leetcode-python/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-python/</url>
    
    <content type="html"><![CDATA[<p>200.岛屿数量（中等）</p><p>题目大意：</p><p>给你一个由<code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/">题目链接</a></p><p>给你一个由<code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>poj2386 Couting Lake的模板<a href="http://poj.org/problem?id=2386">题目链接</a></p><p>走到每个位置上dfs，dfs不需要回溯所以很简单，就是把grid的所有状态修改了，这个题做过比较多次了比较熟悉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[str]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = <span class="hljs-string">&quot;0&quot;</span><br>            dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>            dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-string">&quot;1&quot;</span>:<br>                    dfs(nx, ny)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&quot;1&quot;</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                    dfs(i, j)<br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>并查集</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>312.戳气球-python</title>
    <link href="/2021/12/16/algorithms/leetcode-python/312-%E6%88%B3%E6%B0%94%E7%90%83-python/"/>
    <url>/2021/12/16/algorithms/leetcode-python/312-%E6%88%B3%E6%B0%94%E7%90%83-python/</url>
    
    <content type="html"><![CDATA[<p>312.戳气球（困难）</p><p>题目大意：</p><p>有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。 这里的<code>i - 1</code>和<code>i + 1</code>代表和<code>i</code>相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p><p>求所能获得硬币的最大数量。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">题目链接</a></p><p>有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。 这里的<code>i - 1</code>和<code>i + 1</code>代表和<code>i</code>相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例1：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>coins =  3<span class="hljs-number">*1</span><span class="hljs-number">*5</span>    +   3<span class="hljs-number">*5</span><span class="hljs-number">*8</span>   +  1<span class="hljs-number">*3</span><span class="hljs-number">*8</span>  + 1<span class="hljs-number">*8</span><span class="hljs-number">*1</span> = 167<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,5]</span><br><span class="hljs-string">输出：10</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; nums.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 500</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在没有见过之前几乎很难想到这个dp的思路，二维<code>dp[i][j]</code>数组代表的含义是，在开区间(i, j)之间所能获得的最大金币数。</p><p><strong>注意dp数组的初始化，避免深浅拷贝问题！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]  <span class="hljs-comment"># 避免深浅拷贝问题</span><br></code></pre></td></tr></table></figure><p>想到状态转移的递推关系，戳爆最后一个气球的时候，最后一个气球必然两边都是空的，也就是题目中说如果「如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球」，这个时候的状态，也就是<code>dp[0][len(nums)-1]</code>（注意这里的nums已经经过扩充，<code>nums.insert(0, 1)，nums.insert(len(nums), 1)</code>。</p><p>想在最后一个状态的状态转移方程，<code>dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]</code>，这里想法是要遍历k在整个区间上，找到一个最大的赋值给<code>dp[0][len(nums)-1]</code>。经过这个状态转移方程后，感觉可以慢慢想到是一种自底向上的动态规划策略，由于是开区间(i, j)，所以最小的窗口要从3开始，到len(nums)这个长度为止。然后用每个长度的窗口3、4 … len(nums)在上边滑动。循环整体结构如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间</span><br><span class="hljs-keyword">for</span> window_size <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>    <span class="hljs-comment"># 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-window_size):<br></code></pre></td></tr></table></figure><p>在每次的循环内部，需要计算<code>dp[i][i+window_size]</code>的值，这个就是上文中分析的开区间(i, j)之间能获得的最大金币数，遍历<code>for k in range(i+1, j)</code>，使用状态转移方程<code>dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]</code>，在不断的循环中窗口会扩大，也会自底向上。</p><p>完整解答如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxCoins</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        自底向上动态规划感觉可以算非常经典的题目了？</span><br><span class="hljs-string">        如果能想到dp数组的含义感觉还是可以理解的，但是感觉这个dp数组的含义实在不太好想</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        假设 dp[i][j] 表示【【【开区间】】】 (i,j) 内你能拿到的最多金币</span><br><span class="hljs-string">        想到这个递推的关系，删除【【【最后】】】一个气球k的时候，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j]</span><br><span class="hljs-string">        再加上这个题说如果i-1，i+1超出了数组的时候，就当他是一个数字为1的气球</span><br><span class="hljs-string"></span><br><span class="hljs-string">        所以如果在开始和最后补充上两个1的话，在新的数组上开区间(0, len(nums)-1)所能拿到的最大值，就是最终的状态了</span><br><span class="hljs-string">        这个状态在递推下，就等于最后一个删除的气球k，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j]，有一种分而治之的思想</span><br><span class="hljs-string"></span><br><span class="hljs-string">        由于是开区间，所以最小的长度为3才可以，也或许是先想出上边的递推公式后，再来看dp的思路，dp数组的含义是什么了，感觉还是得想状态转移</span><br><span class="hljs-string"></span><br><span class="hljs-string">        最后来看的话，这个题是一个自底向上的动态规划问题，要首先找到小区间的，例如对于一个长度为3的开区间，永远就是当前窗口中间的那个数字</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        解法的话按照答案的思路写了一遍，答案还是有很多内容需要注意到的</span><br><span class="hljs-string">            - 包括区间不要让角标超出限制</span><br><span class="hljs-string">            - 还有range_best中的ij参数是代表开区间，所以在遍历的时候for k in range(i+1, j)就可以这样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_range_best</span>(<span class="hljs-params">i, j</span>):<br>            max_value = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, j):<br>                tmp_value = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]<br>                max_value = <span class="hljs-built_in">max</span>(max_value, tmp_value)<br>            dp[i][j] = max_value<br><br><br>        nums.insert(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>        nums.insert(<span class="hljs-built_in">len</span>(nums), <span class="hljs-number">1</span>)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br><br>        <span class="hljs-comment"># 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间</span><br>        <span class="hljs-keyword">for</span> window_size <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-window_size):<br>                get_range_best(i, i+window_size)  <span class="hljs-comment"># 这个函数的作用是，找到在i, i+window_size这个开区间中，最大的那一个值，窗口大小是3（window_size=2时，就是那个值）</span><br>            <br>            <span class="hljs-comment"># print(dp)</span><br>            <span class="hljs-comment"># assert False</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>72.编辑距离-python</title>
    <link href="/2021/12/16/algorithms/leetcode-python/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-python/"/>
    <url>/2021/12/16/algorithms/leetcode-python/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-python/</url>
    
    <content type="html"><![CDATA[<p>72.编辑距离（困难）</p><p>题目大意：</p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">题目链接</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例1：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500</li><li>word1 和 word2 由小写英文字母组成</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>二维dp的题目，想象两个单词word1和word2，二维dp的每个位置上，代表word1的i位置处，和word2的j位置处情况下，多少次变换能达到是一样的情况；</p><p>个人习惯上把word1作为行来放置，把word2作为列来放置；</p><p>由于word1和word2都可能为空，所以在初始化二维dp数组的时候，行和列要分别是<code>len(word1)+1</code>和<code>len(word2)+1</code>，初始化dp数组的第一行第一列，想象i到j的这个顺序，第一列<code>dp[i][0]</code>代表word1在当前的情况下经过多少次操作能变成空，所以这个数值就等于i；第一行<code>dp[0][i]</code>就是代表空字符串经过多少次能变到word2的当前这个位置上。</p><p>现在初始化好了dp数组的第一行第一列，<strong>下边就来想状态转移这个方程</strong>，也是这个题目每次复习的时候需要想到的部分，<code>dp[i][j]</code>可以由<code>dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1]</code>得到：</p><ul><li><code>dp[i-1][j-1]</code>到<code>dp[i][j]</code>的操作是修改，注意修改这个操作需要判断word1 i位置处的值和word2 j位置处的值是不是相等的，如果相等的话则不需要修改，如果是不相等的话则需要修改，也就是<code>dp[i-1][j-1]+1</code>；</li><li><code>dp[i][j-1]</code>到<code>dp[i][j]</code>的操作是删除，想象最左上角的三个块，ij代表word1变到word2的这一种感觉。执行删除的情况下，状态转移后必然是<code>dp[i][j]=dp[i][j-1]+1</code>；</li><li><code>dp[i-1][j]</code>到<code>dp[i][j]</code>的操作是新增，同样是想象最左上角的三个块。执行新增的情况下，状态转移后必然是<code>dp[i][j]=dp[i-1][j]+1</code></li></ul><p>经过如上分析后，在每次判断时先判断是不是相等，如果相等的话，可以走<code>dp[i][j]=dp[i-1][j-1]</code>，代表不需要修改。如果是不相等的话就需要对三种情况进行min判断，<code>dp[i][j]=min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</code></p><p>经过上述循环后，因为在最开始前边补充的字符串为空的长度情况，所以<code>dp[len(word1)][len(word2)]</code>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1, word2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word1: str</span><br><span class="hljs-string">        :type word2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        二维dp的题目，dp数组代表，word1的前i个字符，和word2的前j个字符，需要几次修改可以变成一样的</span><br><span class="hljs-string">        回想题解里给出的那张图，要分别想到word1，word2为空字符串的情况</span><br><span class="hljs-string">        空串情况下的初始化状态比较容易想，一个字符串变成空串，就是这个字符串的长度的次数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 初始化dp数组状态，word1在行维度上，word2在列维度上</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意深浅拷贝的问题，这个还挺坑的，只能这么初始化数组</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][i] = i<br>        <br><br>        <span class="hljs-comment"># 假设每个地方想象的是从竖着的word1变到横着的word2的状态，那么[i-1][j-1]代表替换，[i-1][j]代表插入，[i][j-1]代表删除（想初始状态即可）</span><br>        <span class="hljs-comment"># 如果当前两个字符相等的情况下，保持不变（即不做修改[i-1][j-1]的状态）一定是最优的，因为无论增加或减少，则一定还需要1次操作</span><br>        <span class="hljs-comment"># 而如果当前两个字符不等的情况，则由删除，增加，修改三种之最小的+1次操作得到</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j]) +<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(word1)][<span class="hljs-built_in">len</span>(word2)]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.盛最多水的容器-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-python/</url>
    
    <content type="html"><![CDATA[<p>11.盛最多水的容器（中等）</p><p>题目大意：</p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>示例1：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-12-15-18-56-13.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,3,2,1,4]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; height.length</li><li>2 &lt;&#x3D; n &lt;&#x3D; 105</li><li>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</li></ul><h1 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h1><p>O(n^2)的方法很会超时</p><p>对上述方法采用双指针进行优化，整体性的思路如下：</p><p>在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i) <code>min(a[i], a[j]) * (j-i)</code></p><p>由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小</p><p>所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板（贪心的思想应该隐含在这里了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type height: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># O(n^2) time limit了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        max_water = 0</span><br><span class="hljs-string">        for i in range(len(height)):</span><br><span class="hljs-string">            for j in range(i, len(height)):</span><br><span class="hljs-string">                max_water = max(max_water, (j-i)*min(height[i], height[j]))</span><br><span class="hljs-string">        return max_water</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对上述方法采用双指针进行优化，整体性的思路如下：</span><br><span class="hljs-string">            在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i)</span><br><span class="hljs-string">            由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小</span><br><span class="hljs-string">            所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        i = <span class="hljs-number">0</span><br>        j = <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        max_water = (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j])<br>        <br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            <span class="hljs-keyword">if</span> height[i] &lt;= height[j]:  <span class="hljs-comment"># 等号随便给一边就可以了</span><br>                <span class="hljs-keyword">while</span> i &lt; j <span class="hljs-keyword">and</span> height[i] &lt;= height[j]:<br>                    max_water = <span class="hljs-built_in">max</span>(max_water, (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j]))<br>                    i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> j &gt; i <span class="hljs-keyword">and</span> height[j] &lt;= height[i]:<br>                    max_water = <span class="hljs-built_in">max</span>(max_water, (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j]))<br>                    j -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> max_water<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>15.三数之和（中等）</p><p>题目大意：</p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</li><li>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>O(n^3)是一种最容易想到的解法，但是会超时。</p><p>外层i，内层双指针+移动位置，移动位置主要是为去重的，每次ijk都要移动到下一个不一样的，指针的移动这里要模拟do-while循环，这个非常关键</p><p>既然是要求和为0，可以想到进行排序O(nlogn)，从小到大。之后的思路感觉是一种O(n^2)的思路，设立ijk</p><ul><li>i代表：一个基准的数字，可以看做jk位置处的数字加起来要等于-i位置处的数字</li><li>j，k代表：在i后边的数字序列中，j从头开始，k从尾开始，这样根据加了后的关系可以判断是j该往后移动还是k该往前移动</li></ul><p>由于题目中要求答案中不可以包含重复的三元组，这里就是题目里代码实现起来很容易出错的部分了，i，j，k在每次遍历的时候都要走到下一个不一样的地方去，这里感觉有一种do-while循环的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在如下的操作下，j最终会停在不相等的位置上</span><br>j += <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>要分加起来等于0，小于0，大于0三个讨论，其中等于0的情况jk一起移动</p><p>有剪枝操作，在排序了后如果i位置处都大于0了，那么就可以结束了</p><p>解答如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # O(n^3)，其中tuple这个操作用来去重用，tuple是可哈希化的，这种方法超时了</span><br><span class="hljs-string">        rlist = []</span><br><span class="hljs-string">        for i in range(len(nums)):</span><br><span class="hljs-string">            for j in range(i+1, len(nums)):</span><br><span class="hljs-string">                for k in range(j+1, len(nums)):</span><br><span class="hljs-string">                    if nums[i] + nums[j] + nums[k] == 0:</span><br><span class="hljs-string">                        tmplist = sorted([nums[i], nums[j], nums[k]])</span><br><span class="hljs-string">                        rlist.append(tuple(tmplist))</span><br><span class="hljs-string">        temp = list(set(rlist))</span><br><span class="hljs-string">        return [[x[0], x[1], x[2]] for x in temp]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 优化方法</span><br>        <span class="hljs-comment"># O(nlogn)排序+ O(n^2)双指针，一前一后，跳过后</span><br>        rlist = []<br>        nums = <span class="hljs-built_in">sorted</span>(nums)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">2</span>):<br>            <span class="hljs-comment"># 学习题解中的剪枝操作</span><br>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>: <br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]: <span class="hljs-comment"># 三元组不能重复，注意python的-1问题</span><br>                <span class="hljs-keyword">continue</span><br><br>            j = i + <span class="hljs-number">1</span><br>            k = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>:<br>                    rlist.append([nums[i], nums[j], nums[k]])<br>                    <span class="hljs-comment"># print(rlist)</span><br>                    <span class="hljs-comment"># j移动到下一个不一样的</span><br>                    j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br><br>                    k -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> k &gt; j <span class="hljs-keyword">and</span> nums[k] == nums[k+<span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-keyword">elif</span> nums[i] + nums[j] + nums[k] &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 太大了，k往左移动到一个不一样的</span><br>                    k -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> k &gt; j <span class="hljs-keyword">and</span> nums[k] == nums[k+<span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 模拟do-while循环</span><br>                    j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br>    <br>        <span class="hljs-keyword">return</span> rlist<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146.LRU缓存机制-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-python/</url>
    
    <content type="html"><![CDATA[<p>146.LRU缓存机制（中等）</p><p>题目大意：</p><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">题目链接</a></p><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; capacity &lt;&#x3D; 3000</li><li>0 &lt;&#x3D; key &lt;&#x3D; 10000</li><li>0 &lt;&#x3D; value &lt;&#x3D; 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h1 id="解答与分析"><a href="#解答与分析" class="headerlink" title="解答与分析"></a>解答与分析</h1><p>这个题实在是太经典了，而且是自己面试过程中真正被问到而没有做出来的题目，首先第一步要根据题目所给出的内容自定义LRUCache类，也借此进一步熟悉语法。</p><h2 id="自定义LRUCache类"><a href="#自定义LRUCache类" class="headerlink" title="自定义LRUCache类"></a>自定义LRUCache类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        self.capacity = capacity<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="使用双向链表来完成题目要求的操作时间复杂度要求"><a href="#使用双向链表来完成题目要求的操作时间复杂度要求" class="headerlink" title="使用双向链表来完成题目要求的操作时间复杂度要求"></a>使用双向链表来完成题目要求的操作时间复杂度要求</h2><p>题目中要求的O(1)时间复杂度下完成各个操作，主要靠的是cache词典和双向链表中的一些操作，缓存（cache）在这个题中十分关键</p><p>首先搞起来双向链表的基本模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiLinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=-<span class="hljs-number">1</span>, val=-<span class="hljs-number">1</span>, prev=<span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.key = key<br>        self.val = val<br>        self.prev = prev<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="LRUCache-init-中需要初始化的内容"><a href="#LRUCache-init-中需要初始化的内容" class="headerlink" title="LRUCache __init__中需要初始化的内容"></a>LRUCache __init__中需要初始化的内容</h2><p>按照题目一步步的来分析，首先分析需要哪些内容放在LRUcatch的init中，首先是题目中给了的capacity代表这个LRU cache的最大容量，之后是一个为0的current_size代表当前LRU cache的容量，之后可以根据做一些特殊的判断。还有就是一个词典的cache，代表有哪些已经在LRUcache中了，这里最关键的是记住这个cache中存储的是key-node的mapping。还有就是初始化一个双向链表，注意这个双向链表的头和尾虽然直接初始化了，但是这两个节点并没有什么含义，所以head.next和tail.prev中间这些的才感觉是有用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        self.capacity = capacity<br>        self.current_size = <span class="hljs-number">0</span><br>        self.cache = &#123;&#125;<br><br>        self.head = BiLinkedList()<br>        self.tail = BiLinkedList()<br>        self.head.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = self.head<br></code></pre></td></tr></table></figure><h2 id="分析LRUCache中的插入（put）操作和查找（get）操作"><a href="#分析LRUCache中的插入（put）操作和查找（get）操作" class="headerlink" title="分析LRUCache中的插入（put）操作和查找（get）操作"></a>分析LRUCache中的插入（put）操作和查找（get）操作</h2><h3 id="插入（put）"><a href="#插入（put）" class="headerlink" title="插入（put）"></a>插入（put）</h3><p>插入给了一个key和一个value。</p><p>首先判断key是不是已经在cache中了</p><ul><li><p>如果已经在cache中了</p><ul><li>在cache中删除这个key对应的node，然后把这个节点的更新值头插法搞到链表的最前边去。<strong>这里体现了双向链表的作用还有cache中key-node mapping的作用，，mapping找到一个node后，基于双向链表可完成O(1)的删除</strong></li></ul></li><li><p>如果不在的话</p><ul><li>首先判断目前的self.current_size和self.capacity的关系，<ul><li>如果相等了，则删除目前双向链表尾部的，之后用头插法在前边插入上。</li><li>如果self.current_size小于self.capacity，直接在头部插入后，self.capacity++就可以了</li></ul></li></ul></li></ul><h3 id="查找（get）"><a href="#查找（get）" class="headerlink" title="查找（get）"></a>查找（get）</h3><p>查找只给了一个key，返回这个key对应的value，如果找不到就返回-1</p><p>这个直接从cache中找就可以了，但是注意查找到的同样要删除，并且头插法到最前边来</p><h2 id="双向链表操作函数的编写"><a href="#双向链表操作函数的编写" class="headerlink" title="双向链表操作函数的编写"></a>双向链表操作函数的编写</h2><p>综上所述，在该题中需要双向链表的三种操作：（注意这里只管链表的操作，是否能执行这些操作的判断在其他地方试）</p><p>①头插法</p><p>②尾部删除：特别注意这里的尾部删除，在超出capacity的时候会执行尾部删除，<strong>这个时候要拿到尾部删除后的node</strong>，以便从cache中将其移除！！！！！！！！</p><p>③中间删除</p><p>下边这些实现还要经常复习，主要是涉及顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_head</span>(<span class="hljs-params">self, node</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入</span><br><span class="hljs-string">    注意这里，是插入到虚拟head之后的一个</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    node.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>    node.prev = self.head<br>    self.head.<span class="hljs-built_in">next</span>.prev = node<br>    self.head.<span class="hljs-built_in">next</span> = node<br>    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_tail</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除</span><br><span class="hljs-string">    注意这里，是删除虚拟尾结点前边的一个！</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    temp = self.tail.prev<br>    self.tail.prev = self.tail.prev.prev<br>    self.tail.prev.<span class="hljs-built_in">next</span> = self.tail<br>    temp.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    temp.prev = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> temp<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_inter</span>(<span class="hljs-params">self, node</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的中间节点删除</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>    node.<span class="hljs-built_in">next</span>.prev = node.prev<br></code></pre></td></tr></table></figure><h2 id="工具都造好了，最终整体上的代码实现如下，还要经常复习啊"><a href="#工具都造好了，最终整体上的代码实现如下，还要经常复习啊" class="headerlink" title="工具都造好了，最终整体上的代码实现如下，还要经常复习啊"></a>工具都造好了，最终整体上的代码实现如下，还要经常复习啊</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">使用双向链表的原因是因为双向链表的删除可以做到O(1)？也或许还有其他特性</span><br><span class="hljs-string">！注意题目中的关键字key存在于缓存中，要拿到关键字的值，也就是一个key-value的关系，一定要注意这个</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiLinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=-<span class="hljs-number">1</span>, value=-<span class="hljs-number">1</span>, prev=<span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.key = key<br>        self.value = value<br>        self.prev = prev<br>        self.prev = <span class="hljs-built_in">next</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type capacity: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.capacity = capacity<br>        self.current_size = <span class="hljs-number">0</span><br>        self.cache = &#123;&#125; <span class="hljs-comment"># 这个mapping是key -&gt; node！！</span><br>        <span class="hljs-comment"># 创建一个初始的头和一个初始的尾</span><br>        self.head = BiLinkedList()<br>        self.tail = BiLinkedList()<br>        self.head.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = self.head<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_head</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入</span><br><span class="hljs-string">        注意这里，是插入到虚拟head之后的一个</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        node.prev = self.head<br>        self.head.<span class="hljs-built_in">next</span>.prev = node<br>        self.head.<span class="hljs-built_in">next</span> = node<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_tail</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除</span><br><span class="hljs-string">        注意这里，是删除虚拟尾结点前边的一个！</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        temp = self.tail.prev<br>        self.tail.prev = self.tail.prev.prev<br>        self.tail.prev.<span class="hljs-built_in">next</span> = self.tail<br>        temp.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        temp.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> temp<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_inter</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的中间节点删除</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>        node.<span class="hljs-built_in">next</span>.prev = node.prev<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        # 注意get的时候，要把这个地方挪到最前边，因为LRU访问的时候要挪到前边来</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cache.get(key) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            node = self.cache.get(key)<br>            self.remove_inter(node)<br>            self.add_to_head(node)<br>            <span class="hljs-keyword">return</span> node.value<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :type value: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cache.get(key) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            需要头插入，如果插入后长度超过了capacity，就要进行尾部删除</span><br><span class="hljs-string">            cache需要变动</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            node = BiLinkedList(key=key, value=value)<br>            self.add_to_head(node)<br>            self.current_size += <span class="hljs-number">1</span><br>            self.cache[key] = node<br>            <span class="hljs-keyword">if</span> self.current_size &gt; self.capacity:  <span class="hljs-comment"># 超出容量了，要删除，同时cache也要删除</span><br>                temp = self.remove_tail()<br>                <span class="hljs-keyword">del</span> self.cache[temp.key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            已经有了，拿到一个node，需要先删除，然后挪到最前边</span><br><span class="hljs-string">            cache不需要变动</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            node = self.cache.get(key)<br>            self.remove_inter(node)<br>            node = BiLinkedList(key=key, value=value)  <span class="hljs-comment"># 更新val值</span><br>            self.cache[key] = node<br>            self.add_to_head(node)<br><br><br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>设计</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>383.赎金信-python</title>
    <link href="/2021/12/14/algorithms/leetcode-python/383-%E8%B5%8E%E9%87%91%E4%BF%A1-python/"/>
    <url>/2021/12/14/algorithms/leetcode-python/383-%E8%B5%8E%E9%87%91%E4%BF%A1-python/</url>
    
    <content type="html"><![CDATA[<p>383.赎金信（简单）</p><p>题目大意：</p><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 105</li><li>ransomNote 和 magazine 由小写英文字母组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>python中Counter的妙用，Counter是可以相减的！</p><p>所以说如果在ransomNote中，减掉magazine后是空的，就代表可以组成的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        c1 = Counter(ransomNote)<br>        c2 = Counter(magazine)<br>        <span class="hljs-keyword">return</span> c1 - c2 == Counter(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
      <tag>哈希表</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>139.单词拆分-python</title>
    <link href="/2021/12/14/algorithms/leetcode-python/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-python/"/>
    <url>/2021/12/14/algorithms/leetcode-python/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-python/</url>
    
    <content type="html"><![CDATA[<p>139.单词拆分（中等）</p><p>题目大意：给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-break/">题目链接</a></p><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;applepenapple&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。<br>     注意你可以重复使用字典中的单词。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 300</li><li>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000</li><li>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20</li><li>s 和 wordDict[i] 仅有小写英文字母组成</li><li>wordDict 中的所有字符串 互不相同</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在没见过之前想到dp还是挺难的，这里使用的是一维dp数组，其数组的含义是，当前这个位置下，能否被拆分成多个字典中的词</p><p>dp的状态转移方程想法是，从这个位置之前逐个遍历</p><ul><li>要么是0到这个位置能构成一个单词</li><li>要么是之前一个能构成字典中单词的位置，到现在这个位置之间的词也在字典中</li></ul><p>重点也是要特殊处理如下j&#x3D;&#x3D;0的情况，另外列表截取的左闭右开</p><p>这个题要用dp的思路，这个感觉是最难想的，dp的每个位置代表当前位置，是否所有单词都能包含在词典中；；；对于一个位置，如果之前出现过能包含在词典中的（dp[j]&#x3D;&#x3D;True），并且j到i（[j+1: i+1]）也在词典里，那么这个位置就是在的；；；注意按照这种思路，可能需要处理一些0的特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s, wordDict</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type wordDict: List[str]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 这个题很难看出是dp的思路了，一眼看过去还以为是Trie树，KMP这样的</span><br>        <span class="hljs-comment"># dp数组代表的含义是，当前这个位置下，[能否](bool)被拆分成多个字典词</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br>        dp = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]  <span class="hljs-comment"># 当前这个位置下，能否全部在词典中出现</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):    <br>            <span class="hljs-comment"># 如果i为0的情况</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> wordDict:<br>                    dp[i] = <span class="hljs-literal">True</span>            <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 对于一个位置判断是否能全部在词典中出现，等于前一个能出现的位置 and 那个位置到这个位置之间能不能出现</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[: i+<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> wordDict:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-comment"># j == 0没法走到这个情况</span><br>                    <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> s[j+<span class="hljs-number">1</span>: i+<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> wordDict:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(dp)</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>字典树</tag>
      
      <tag>记忆化搜索</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198.打家劫舍-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-python/</url>
    
    <content type="html"><![CDATA[<p>198.打家劫舍（中等）</p><p>题目大意：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">题目链接</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li></ul><h1 id="解答与分析"><a href="#解答与分析" class="headerlink" title="解答与分析"></a>解答与分析</h1><p>这个题dp的还是比较明显的，感觉可以算简单题了<code>dp[i] = max(dp[i-1], s[i] + dp[i-2])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + nums[i])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1446.连续字符-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6-python/</url>
    
    <content type="html"><![CDATA[<p>1446.连续字符（简单）</p><p>题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/consecutive-characters/">题目链接</a></p><p>题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：子字符串 <span class="hljs-string">&quot;ee&quot;</span> 长度为 <span class="hljs-number">2</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abbcccddddeeeeedcba&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：子字符串 <span class="hljs-string">&quot;eeeee&quot;</span> 长度为 <span class="hljs-number">5</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;triplepillooooow&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hooraaaaaaaaaaay&quot;</span><br>输出：<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>示例5：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tourist&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 500</li><li>s 只包含小写英文字母。</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>比较简单，O(n)遍历一次，如果不等清空重新计数就可以了，另外感觉有很多种实现方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPower</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        max_cnt = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == s[i-<span class="hljs-number">1</span>]:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt = <span class="hljs-number">1</span><br>            max_cnt = <span class="hljs-built_in">max</span>(max_cnt, cnt)<br><br>        <span class="hljs-keyword">return</span> max_cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208.实现Trie前缀树-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>208.最长递增子序列（中等）</p><p>题目大意：Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。</p><ul><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">题目链接</a></p><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。</p><ul><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false</li></ul><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]<br><br>解释<br>Trie trie = <span class="hljs-built_in">new</span> Trie();<br>trie.<span class="hljs-keyword">insert</span>(&quot;apple&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">False</span><br>trie.startsWith(&quot;app&quot;); // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">insert</span>(&quot;app&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; word.length, prefix.length &lt;&#x3D; 2000</li><li>word 和 prefix 仅由小写英文字母组成</li><li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>Trie树还是很经典的，同样是一个妙脆妙妙角一样妙的结构。这个题主要需要记住的是首先构建一个TrieNode，代表Trie树中的每个节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mapping = &#123;&#125;<br>        self.is_end = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在之后想想每次插入过程，<strong>每次都从root开始进行插入</strong>，第一次插入一个单词如“apple”的时候，首先是“a“，令<code>node=root</code>，因为现在node肯定是空的，所以使得<code>node.mapping[&#39;a&#39;]</code>为一个新的TrieNode，之后走到这个TrieNode上，<code>node=node.mapping.get(c)</code>。<strong>特别注意，这里的mapping key是每个char，value是TrieNode类型的</strong>，在插入的最后，要使得node.is_end&#x3D;True，标志出这个单词的结尾</p><p>在这样的插入条件下，第一次插入就是构建了一个超长的串。第二次插入的时候由于第一次插入过程中，有些节点已经可以共用了，所以就有“前缀”的感觉了，这样的感觉就是顺着串走，直到遇到新的后，就建立走到新的分支上，要想到Trie树并不是只插入一个字符串就结束了</p><p>找prefix和word都很简单，找word要多加一个判断is_end</p><p>题目解答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    实现一个TrieNode进行封装</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mapping = &#123;&#125;<br>        self.is_end = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = TrieNode()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        注意这个insert函数会多次执行，</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                node.mapping[c] = TrieNode()  <span class="hljs-comment"># 这里每次放入的是TreeNode</span><br>            node = node.mapping[c]<br>        node.is_end = <span class="hljs-literal">True</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            node = node.mapping[c]<br>        <span class="hljs-keyword">if</span> node.is_end == <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>·<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prefix: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(prefix):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            node = node.mapping[c]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字典树</tag>
      
      <tag>哈希表</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>438.找到字符串中所有字母异位词-python</title>
    <link href="/2021/12/12/algorithms/leetcode-python/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-python/"/>
    <url>/2021/12/12/algorithms/leetcode-python/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-python/</url>
    
    <content type="html"><![CDATA[<p>438.找到字符串中所有字母异位词（中等）</p><p>题目大意：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">题目链接</a></p><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>示例一：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104</li><li>s 和 p 仅包含小写字母</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题要构建一个“滑动窗口”来减少操作次数的感觉，就是说如果每i+&#x3D;1向后移动一位的时候，如果都重新计数，那么将会时间复杂度非常高。所以在每次移动的时候，只需要把i-1位置的删除，再加入i+window_size-1位置处最新的字符即可，这样的话每次移动只用操作两下；</p><p>一开始设置一个和p长度相等的s之后开始滑动窗口，删除头并新增尾只需要操作两次了（注意做字典判断相等时候，要把字典值为0的删除掉），另外注意print语句也会占用时间；</p><p>另外这个题也可以使用colletions.Counter，Counter可以进行一个计数操作，而且最关键的是<strong>Counter居然可以执行加减操作</strong>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1 = <span class="hljs-string">&quot;aaabbbccc&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count = Counter(text1)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count.get(<span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(text1_count)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;collections.Counter&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>text2 = <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>text2_count = Counter(text2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text2_count<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tmp = text1_count - text2_count<br><span class="hljs-meta">&gt;&gt;&gt; </span>tmp<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>在上述思路分析后，主要记住新加入的位置是i+window_size-1就好了，代码编写思路还是比较简单，这里使用了Counter的方法，实际上用字典的方法也可以，而且说不定可以增加效率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s, p</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type s: str</span><br><span class="hljs-string">    :type p: str</span><br><span class="hljs-string">    :rtype: List[int]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    rList = []<br>    window_size = <span class="hljs-built_in">len</span>(p)<br>    compare_dict = collections.Counter(p)<br>    record_s_dict = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-window_size+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> record_s_dict <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            record_s_dict = collections.Counter(s[i: window_size])<br>        <span class="hljs-keyword">else</span>:<br>            remove_head = collections.Counter(s[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># print(&quot;remove_head: &quot;, i, remove_head)</span><br>            add_tail = collections.Counter(s[i+window_size-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 调试还是比较容易看出来这个错误的</span><br>            <span class="hljs-comment"># print(&quot;add tail: &quot;, i, add_tail)</span><br>            record_s_dict -= remove_head<br>            record_s_dict += add_tail<br>            <span class="hljs-comment"># print(&quot;record_s_dict: &quot;, i, record_s_dict)</span><br>        <span class="hljs-keyword">if</span> record_s_dict == compare_dict:<br>            rList.append(i)<br>    <br>    <span class="hljs-keyword">return</span> rList<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-screen命令整理</title>
    <link href="/2021/12/08/macOS%E5%8F%8ALinux-screen%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2021/12/08/macOS%E5%8F%8ALinux-screen%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>需求：例如在跑深度学习等程序的时候，需要让程序挂载在后台执行，这时候就可以使用screen命令进行后台的挂载</p><span id="more"></span><h1 id="screen-ls"><a href="#screen-ls" class="headerlink" title="screen -ls"></a>screen -ls</h1><p>查看：<code>screen -ls</code>可以查看当前有哪些Attached&#x2F;Detached的screen界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:~$ screen -ls<br>There is a screen on:<br>        12442.xxxxxxx       (12/08/2021 02:12:53 PM)        (Detached)<br>1 Socket in /var/run/screen/S-lyx.=<br></code></pre></td></tr></table></figure><h1 id="screen-S-name"><a href="#screen-S-name" class="headerlink" title="screen -S [name]"></a>screen -S [name]</h1><p>新建：<code>screen -S [name]</code>可以打开一个新的名称为[name]的screen界面</p><h1 id="screen-r-name"><a href="#screen-r-name" class="headerlink" title="screen -r [name]"></a>screen -r [name]</h1><p>返回：<code>screen -r [name]</code>可以返回名称为[name]的screen界面（例如之前暂时退出了，可通过此命令返回），名称可通过<code>screen -ls</code>查看</p><h1 id="screen-X-S-id-quit"><a href="#screen-X-S-id-quit" class="headerlink" title="screen -X -S [id] quit"></a>screen -X -S [id] quit</h1><p>删除：<code>screen -X -S [id] quit</code>可以关闭挂载的一些screen，这里只用输入id号即可</p><h1 id="screen-D-name"><a href="#screen-D-name" class="headerlink" title="screen -D [name]"></a>screen -D [name]</h1><p>有些情况下，如果finalshell等ssh窗口已经关闭，但是还显示在Attached的状态，就需要先D掉再进去</p><p>&#96;&#96;&#96;screen -D [name]&#96;&#96;</p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2+ohmyzsh安装及插件配置</title>
    <link href="/2021/12/06/iterm2+ohmyzsh%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/12/06/iterm2+ohmyzsh%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>背景：iterm2可以替代macOS自带的terminal，而ohmyzsh是基于zsh命令行的一个扩展工具集，在其上可以安装插件来丰富命令行的功能（何老板推荐的syntax highlighting和auto suggestion）</p><span id="more"></span><h1 id="安装item2"><a href="#安装item2" class="headerlink" title="安装item2"></a>安装item2</h1><p>直接官网安装即可，安装后把其保留在程序坞中，手工替代terminal</p><blockquote><p><a href="https://iterm2.com/">https://iterm2.com/</a></p></blockquote><h1 id="安装ohmyzsh"><a href="#安装ohmyzsh" class="headerlink" title="安装ohmyzsh"></a>安装ohmyzsh</h1><p>直接执行官网的一句话命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://ohmyz.sh/#install">https://ohmyz.sh/#install</a></p></blockquote><h1 id="安装ohmyzsh的插件syntax-highlighting和auto-suggestion"><a href="#安装ohmyzsh的插件syntax-highlighting和auto-suggestion" class="headerlink" title="安装ohmyzsh的插件syntax highlighting和auto suggestion"></a>安装ohmyzsh的插件syntax highlighting和auto suggestion</h1><p>Reference:</p><blockquote><p><a href="https://www.jianshu.com/p/2f2c09ebfb7f">https://www.jianshu.com/p/2f2c09ebfb7f</a><br><a href="https://blog.csdn.net/qq_38839744/article/details/90247628">https://blog.csdn.net/qq_38839744/article/details/90247628</a></p></blockquote><h2 id="zsh-syntax-highlighting安装"><a href="#zsh-syntax-highlighting安装" class="headerlink" title="zsh-syntax-highlighting安装"></a>zsh-syntax-highlighting安装</h2><p>官网：</p><blockquote><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a></p></blockquote><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git <br>echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc<br></code></pre></td></tr></table></figure><p>生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.zshrc<br></code></pre></td></tr></table></figure><h2 id="Auto-suggestion的安装"><a href="#Auto-suggestion的安装" class="headerlink" title="Auto suggestion的安装"></a>Auto suggestion的安装</h2><p>auto suggestion是ohmyzsh的一个插件，作用基本上是根据历史输入指令记录即使的提示，能够提高效率</p><ol><li>git clone项目，并与ZSH建立关联</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span><span class="hljs-regexp">/plugins/</span>zsh-autosuggestions<br></code></pre></td></tr></table></figure><p>其中通过echo查看$ZSH_CUSTOM</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ echo $ZSH_CUSTOM<br>/Users/curious/.oh-my-zsh/custom<br></code></pre></td></tr></table></figure><ol start="2"><li>编辑~&#x2F;.zshrc文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>按i 进入–INSERT–编辑模式，使用上下左右键找找到plugins&#x3D;(git)这一行添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">plugins=(git zsh-autosuggestions)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-Learning</title>
    <link href="/2021/12/06/develop/docker/docker-Learning/"/>
    <url>/2021/12/06/develop/docker/docker-Learning/</url>
    
    <content type="html"><![CDATA[<p>背景：docker有一种更加轻量级虚拟机的感觉，正好在一个课程中需要使用HBase、Hadoop等，又不方便在本地安装，所以可以使用docker的方式，也借此机会学习docker</p><span id="more"></span><h1 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h1><p>macOS上可以安装docker destop，是个可视化的工具</p><blockquote><p><a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p></blockquote><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><ol><li>第一步，clone a repository</li></ol><p>Getting Started项目是一个简单的Github repository，包含了一切建立镜像（image）和运行为容器（container）的过程</p><p>通过在容器中运行git克隆存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:~ curious$ docker run --name repo alpine git clone https://github.com/docker/getting-started.git<br></code></pre></td></tr></table></figure><ol start="2"><li>之后，构建image</li></ol><p>Docker映像是仅用于容器的私有文件系统。它提供容器所需的所有文件和代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:~ curious$ cd getting-started <br>CuriousdeMacBook-Pro:getting-started curious$  docker build -t docker101tutorial .<br></code></pre></td></tr></table></figure><ol start="3"><li>运行第一个container</li></ol><p>基于上一步中生成的映像启动容器。运行容器会启动具有私有资源的应用程序，这些资源与计算机的其余部分安全隔离。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:getting-started curious$ docker run -d - p 80:80 --name docker-tutorial docker101tutorial cfd8702ce730feb351565711d7a44d147476d8faa18b03ae2d4815cc137d121b<br></code></pre></td></tr></table></figure><ol start="4"><li>保存并分享镜像</li></ol><p>在Docker Hub上保存和共享您的映像，以便其他用户可以轻松地在任何目标计算机上下载和运行映像。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github443问题的解决办法</title>
    <link href="/2021/12/06/mixed/git/github443%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2021/12/06/mixed/git/github443%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>背景：github经常遇到443问题，例如Failed to connect to github.com port 443: Operation timed out，这种情况下需要一些解决办法；</p><p>Reference：</p><blockquote><p><a href="https://www.jianshu.com/p/471aeba64724">https://www.jianshu.com/p/471aeba64724</a></p></blockquote><span id="more"></span><h1 id="解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）"><a href="#解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）" class="headerlink" title="解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）"></a>解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）</h1><ol><li>查询可以用的IP，在</li></ol><blockquote><p><a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></p></blockquote><p>上分别搜索<code>github.com、github.global-ssl.fastly.net</code></p><ol start="2"><li>修改host文件</li></ol><p>操作：<code>sudo vi /etc/hosts</code> 替换成以下ip即可</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">151.101.185.194</span> github.global-ssl.fastly.net<br><span class="hljs-number">192.30.253.112</span>  github.com<br></code></pre></td></tr></table></figure><p>之后就可以进行一些尝试了</p><h1 id="解决方法二（尝试了可以，需要梯子资源）"><a href="#解决方法二（尝试了可以，需要梯子资源）" class="headerlink" title="解决方法二（尝试了可以，需要梯子资源）"></a>解决方法二（尝试了可以，需要梯子资源）</h1><ol><li>设置代理的方法，首先查找梯子代理的端口：</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-12-06-11-45-05.png"></p><p>通过git config命令来设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy &quot;localhost:port&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>在使用完毕后可以改回来</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --unset http.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次hexo博客迁移过程</title>
    <link href="/2021/12/05/mixed/hexo/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/12/05/mixed/hexo/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>背景：换了一个新电脑，需要把原来在github上配置的yixuan004.github.io博客环境重新在本地部署，中间涉及到一些软件的安装等</p><span id="more"></span><h1 id="记录一次hexo博客迁移过程"><a href="#记录一次hexo博客迁移过程" class="headerlink" title="记录一次hexo博客迁移过程"></a>记录一次hexo博客迁移过程</h1><p>换了一个电脑后要重新部署自己的yixuan004.github.io博客，因为之前设置的已经比较完备了，把master分支和coding-pages分支（实际上的主分支）在github上分隔开了，所以首先拉取远程的coding-pages（实际上的主分支）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/yixuan004/yixuan004.github.io.git<br></code></pre></td></tr></table></figure><p>在之后需要在本地补充npm安装hexo环境，<strong>注意hexo环境必须安装在文件夹下</strong></p><p>如果本地没node&#x2F;npm环境的话，可到官网下载</p><blockquote><p><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo npm install hexo<br>sudo npm install npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>在这之后理论上就可以进行操作和push了，和之前的博客一样即可：</p><blockquote><p><a href="https://yixuan004.github.io/2021/09/13/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/">https://yixuan004.github.io/2021/09/13/我的首篇github博客/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28.实现strStr-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/28-%E5%AE%9E%E7%8E%B0strStr-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/28-%E5%AE%9E%E7%8E%B0strStr-python/</url>
    
    <content type="html"><![CDATA[<p>28.实现strStr()（中等）</p><p>题目大意：实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 <span class="hljs-number">0</span> 。这与 C 语言的 <span class="hljs-built_in">strstr</span>() 以及 Java 的 <span class="hljs-built_in">indexOf</span>() 定义相符。<br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 104</li><li>haystack 和 needle 仅由小写英文字符组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题就是KMP算法的完全模板，虽然题目标注的难度是简单但感觉那是调用函数直接的做法。。。例如在python中可以直接用str1.find(str2)来解决，而题目要考察的就是这个函数的实现</p><p>KMP算法非常巧妙，这里学习的是Youtube+b站转载翻译的一个思路：</p><blockquote><p><a href="https://www.bilibili.com/video/BV18k4y1m7Ar?p=1">https://www.bilibili.com/video/BV18k4y1m7Ar?p=1</a></p></blockquote><p>思路是首先在needle（又称pattern）上构建pre数组，或者有人称为next数组。next数组的含义很有可能在面试中被问到，自己写几个的话，感觉强行理解这个next数组就是当前这个位置下，pattern的首尾最长公共子串的数目，例如<code>abc ... abc</code>是一个首尾重复的，这样的话，j在回退的时候，不必每次都回退到头部，而是回退到next[j]的位置，复习一下这个构建next数组的操作，这个kmp算法感觉还是要做到经常操作的（暂时不太考虑很特殊的情况）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">construct_pre_arr</span>(<span class="hljs-params">pattern</span>):<br>    j = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">1</span><br>    pre = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(pattern):<br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[j]:<br>            pre[i] = j + <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> pattern[i] != pattern[j]:<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                pre[i] = <span class="hljs-number">0</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j = <span class="hljs-built_in">next</span>[j]    <br>    <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure><p>在构建好pre数组后，之后就是两个串来操作了，使用pre数组，让在串str1中寻找pattern的时候，不用每次都回退到pattern的头部，自己手工复习一下这个写法，整个写法上来看是先判断有没有（j是否遍历到了最后一位），再找是哪一段。这里基本只是运用pre数组了，比之前修改还简单些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span>  <span class="hljs-comment"># str1的index</span><br>j = <span class="hljs-number">0</span>  <span class="hljs-comment"># pattern的index</span><br><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(str1) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(pattern):<br>    <span class="hljs-keyword">if</span> str1[i] == pattern[j]:<br>        i += <span class="hljs-number">1</span><br>        j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            j = pre[j]<br><br><span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(pattern):<br>    <span class="hljs-keyword">return</span> i - j<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>整体题目的解答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(haystack), <span class="hljs-built_in">len</span>(needle)<br>       <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_pre_array</span>(<span class="hljs-params">needle</span>):  <span class="hljs-comment"># 这个是计算pattern串的pre数组</span><br>            pre = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(needle))]<br>            j = <span class="hljs-number">0</span><br>            i = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(needle):<br>                <span class="hljs-keyword">if</span> needle[i] == needle[j]:<br>                    pre[i] = j + <span class="hljs-number">1</span>  <span class="hljs-comment"># 注意这里的等于j + 1，实际上就是一个长度的感觉</span><br>                    j += <span class="hljs-number">1</span><br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                        pre[i] = <span class="hljs-number">0</span><br>                        i += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> j != <span class="hljs-number">0</span>:<br>                        j = pre[j-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 精髓</span><br>            <span class="hljs-keyword">return</span> pre  <span class="hljs-comment"># pre数组的含义是，单个串在这个位置上，前缀长度等于后缀长度的个数，但是为什么要这么做还不是很理解</span><br>        pre = compute_pre_array(needle)<br>       <br>        <span class="hljs-comment"># step2 使用pre数组</span><br>        i = <span class="hljs-number">0</span>  <span class="hljs-comment"># 串1的index</span><br>        j = <span class="hljs-number">0</span>  <span class="hljs-comment"># 串2的index</span><br>        <span class="hljs-keyword">while</span> i &lt; m <span class="hljs-keyword">and</span> j &lt; n:<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[j]:<br>                i += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> j != <span class="hljs-number">0</span>:<br>                    j = pre[j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle):<br>            <span class="hljs-keyword">return</span> i - j <span class="hljs-comment"># i停下的位置找回去</span><br>        <span class="hljs-keyword">else</span>: <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>519.随机翻转矩阵-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-python/</url>
    
    <content type="html"><![CDATA[<p>519.随机翻转矩阵（中等）</p><p>题目大意：给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) 被选取的概率应当均等。</p><p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p><p>实现 Solution 类：</p><ul><li>Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象</li><li>int[] flip() 返回一个满足 matrix[i][j] &#x3D;&#x3D; 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1</li><li>void reset() 将矩阵中所有的值重置为 0</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/random-flip-matrix/">题目链接</a></p><p>给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) 被选取的概率应当均等。</p><p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p><p>实现 Solution 类：</p><ul><li>Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象</li><li>int[] flip() 返回一个满足 matrix[i][j] &#x3D;&#x3D; 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1</li><li>void reset() 将矩阵中所有的值重置为 0</li></ul><p>示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;Solution&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;reset&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>]<br>[[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [], [], [], [], []]<br>输出<br>[null, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], null, [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]<br><br>解释<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>solution.flip();  // 返回 [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]，此时返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]、[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 的概率应当相同<br>solution.flip();  // 返回 [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]，因为 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 已经返回过了，此时返回 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] 的概率应当相同<br>solution.flip();  // 返回 [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]，根据前面已经返回过的下标，此时只能返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>solution.reset(); // 所有值都重置为 <span class="hljs-number">0</span> ，并可以再次选择下标返回<br>solution.flip();  // 返回 [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]，此时返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]、[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 的概率应当相同<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; m, n &lt;&#x3D; 104</li><li>每次调用flip 时，矩阵中至少存在一个值为 0 的格子。</li><li>最多调用 1000 次 flip 和 reset 方法。</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题如果未来会被问到的话，首先需要自己熟悉一下手写基础框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, m, n</span>):<br>        self.m = m<br>        self.n = n<br>        <span class="hljs-comment"># do something</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># do something</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># do something</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>目前使用一种非常简单的方法就解决了，每次随机一个[0, m-1]，随机一个[0, n-1]（使用random.randint(a, b)，注意这里a，b都是闭区间的），用一个dict判断d[(rand_m, rand_n)]是否有，如果有就一直重新随机，直到不存在，不存在的情况下加入dict。清空则就是清空词典。但这个运气最差得情况下会调用很多次随机函数，所以实际上不符合题意的，只是比较简单实现，暂时不属于hot100题就未来补充了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.m = m<br>        self.n = n<br>        self.temp_dict = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flip</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 把self的值取过来</span><br>        m = self.m<br>        n = self.n<br>        <br>        m_temp = random.randint(<span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>)<br>        n_temp = random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">while</span> self.temp_dict.get((m_temp, n_temp)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            m_temp = random.randint(<span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>)<br>            n_temp = random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br>        self.temp_dict[(m_temp, n_temp)] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> [m_temp, n_temp]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.temp_dict = &#123;&#125;<br><br><span class="hljs-comment"># Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Solution(m, n)</span><br><span class="hljs-comment"># param_1 = obj.flip()</span><br><span class="hljs-comment"># obj.reset()</span><br></code></pre></td></tr></table></figure><h1 id="优化解法（减少随机函数的调用次数）待补充"><a href="#优化解法（减少随机函数的调用次数）待补充" class="headerlink" title="优化解法（减少随机函数的调用次数）待补充"></a>优化解法（减少随机函数的调用次数）待补充</h1>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>TODO优化</tag>
      
      <tag>数学</tag>
      
      <tag>水塘抽样</tag>
      
      <tag>随机化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121.买卖股票的最佳时机-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-python/</url>
    
    <content type="html"><![CDATA[<p>121.买卖股票的最佳时机（简单）</p><p>题目大意：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">题目链接</a></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。</p><p>设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 105</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉比较简单，先设置now_min为arr[0]，然后从角标1开始遍历，每次判断现在的arr[i]-now_min是否最大值，如果是则更新最大值。之后更新now_min，如果当前位置小于now_min就更新；</p><p>之前在一本算法书上应该看过这个题，想象一根从最低点到最高点的连线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-comment"># 异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 逻辑处理</span><br>        max_p = <span class="hljs-number">0</span><br>        now_min = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            max_p = <span class="hljs-built_in">max</span>(max_p, prices[i] - now_min)<br><br>            <span class="hljs-keyword">if</span> prices[i] &lt; now_min:<br>                now_min = prices[i]<br>        <br>        <span class="hljs-keyword">return</span> max_p<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300.最长递增子序列-python</title>
    <link href="/2021/12/01/algorithms/leetcode-python/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-python/"/>
    <url>/2021/12/01/algorithms/leetcode-python/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-python/</url>
    
    <content type="html"><![CDATA[<p>300.最长递增子序列（中等）</p><p>题目大意：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</li><li>104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：O-n-2-向前查找法"><a href="#解法一：O-n-2-向前查找法" class="headerlink" title="解法一：O(n^2)向前查找法"></a>解法一：O(n^2)向前查找法</h2><p>O(n^2)的解法还是比较好想的（简单题），先创建一个一维dp数组，然后走到每个位置的时候要往前看，看看前边比当前数字小的那些数组位置处，选择一个这些位置里dp值最大的，+1得到现在这个位置的dp值。最后返回max(dp)就可以</p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 思路还是很简单的，设置dp数组，走到每个位置后，【往前找】比这个位置小的元素，然后选一个最大的dp[i] + 1当做当前位置的dp</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h2 id="解法二：优化解法（二分查找）待补充"><a href="#解法二：优化解法（二分查找）待补充" class="headerlink" title="解法二：优化解法（二分查找）待补充"></a>解法二：优化解法（二分查找）待补充</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分查找</tag>
      
      <tag>TODO优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串-python</title>
    <link href="/2021/11/30/algorithms/leetcode-python/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-python/"/>
    <url>/2021/11/30/algorithms/leetcode-python/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-python/</url>
    
    <content type="html"><![CDATA[<p>3.无重复字符的最长子串（中等）</p><p>题目大意：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目链接</a></p><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</li><li>s 由英文字母、数字、符号和空格组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题要及时get到使用滑动窗口来解决这个问题，因为题目要求的是”子串“，这是一个连续的</p><p>在get到是用滑动窗口解决问题后，滑动窗口本身来讲感觉就是一个队列，这个题是变长的</p><p><strong>整体上的思路是：</strong></p><p>遍历字符串，如果遇到不在滑动窗口（队列）中的字符，就加入队列的右边。如果遇到出现在队列中的字符，则队列的左边要缩到这个字符出现的下一位（感觉也可以用<code>find(xxx) + 1</code>来优化），然后再把这个字符加入进去；</p><p>在每次遍历i的时候，判断当前变长滑动窗口的大小和当前的最大值，来更新最大值，用来最终返回</p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 滑动窗口对应的数据结构是queue &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        que = []<br>        max_len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">while</span> s[i] <span class="hljs-keyword">in</span> que:<br>                que = que[<span class="hljs-number">1</span>:] <span class="hljs-comment"># </span><br>            que.append(s[i])<br>            max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-built_in">len</span>(que))<br>        <br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>423.从英文中重建数字-python</title>
    <link href="/2021/11/29/algorithms/leetcode-python/423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97-python/"/>
    <url>/2021/11/29/algorithms/leetcode-python/423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97-python/</url>
    
    <content type="html"><![CDATA[<p>423.从英文中重建数字（中等）</p><p>题目大意：给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">题目链接</a></p><p>给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：s = <span class="hljs-string">&quot;owoztneoer&quot;</span><br>输出：<span class="hljs-string">&quot;012&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：s = <span class="hljs-string">&quot;fviefuro&quot;</span><br>输出：<span class="hljs-string">&quot;45&quot;</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 105</li><li>s[i] 为 [“e”,”g”,”f”,”i”,”h”,”o”,”n”,”s”,”r”,”u”,”t”,”w”,”v”,”x”,”z”] 这些字符之一</li><li>s 保证是一个符合题目要求的字符串</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这种题有一种脑筋急转弯的感觉，每个数字的英文中会有一些特点，这样可以统计出来每个英文字母在哪些数字中出现了，如下图所示。这样可以通过计数的方式来从“出现一次”的分析，例如“x”只在six中出现，之后可以像数独一样链着分析。</p><p>统计分析规律，列出每个字母在哪些数字的英文中出现了，然后有些字母实际上只在一个数字中出现了，统计这些字母的个数就是这个数字的个数。然后来有些字母在两个数字中出现的，贪心下</p><p><strong>需要注意，尽量避免使用一个字母在一个单词中出现两次的，例如nine中的n</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">zero</span><br><span class="hljs-literal">one</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">three</span> <br><span class="hljs-literal">four</span><br><span class="hljs-literal">five</span><br><span class="hljs-literal">six</span><br><span class="hljs-literal">seven</span><br><span class="hljs-literal">eight</span><br><span class="hljs-literal">nine</span><br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-30-00-12-10.png"></p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">originalDigits</span>(<span class="hljs-params">self, s</span>):<br>        cnt_dict = &#123;&#125;<br>        m = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> cnt_dict.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cnt_dict[c] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt_dict[c] += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 单位的</span><br>        m[<span class="hljs-number">8</span>] = cnt_dict.get(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">4</span>] = cnt_dict.get(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">2</span>] = cnt_dict.get(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">6</span>] = cnt_dict.get(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">0</span>] = cnt_dict.get(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 两位的</span><br>        m[<span class="hljs-number">5</span>] = cnt_dict.get(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">4</span>]<br>        m[<span class="hljs-number">3</span>] = cnt_dict.get(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">8</span>]<br>        m[<span class="hljs-number">7</span>] = cnt_dict.get(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">5</span>]<br><br>        <span class="hljs-comment"># 差0 1 和 9</span><br>        m[<span class="hljs-number">0</span>] = cnt_dict.get(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">3</span>] - m[<span class="hljs-number">4</span>]<br>        m[<span class="hljs-number">1</span>] = cnt_dict.get(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">0</span>] - m[<span class="hljs-number">2</span>] - m[<span class="hljs-number">4</span>]<br>        <span class="hljs-comment"># m[9] = cnt_dict.get(&#x27;n&#x27;, 0) - m[1] - m[7] # 字母尽量选择出现1次的，所以n不行</span><br>        m[<span class="hljs-number">9</span>] = cnt_dict.get(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">5</span>] - m[<span class="hljs-number">6</span>] - m[<span class="hljs-number">8</span>]<br><br>        <span class="hljs-comment"># 可否优化</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">str</span>(i) * m[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>700.二叉搜索树中的搜索-python</title>
    <link href="/2021/11/29/algorithms/leetcode-python/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-python/"/>
    <url>/2021/11/29/algorithms/leetcode-python/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-python/</url>
    
    <content type="html"><![CDATA[<p>700.二叉树中的搜索（简单）</p><p>题目大意：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">题目链接</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉搜索树:<br><br>        <span class="hljs-number">4</span><br>       / <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>   <span class="hljs-number">7</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br><br>和值: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>应该返回如下子树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">2</span>     <br> / <span class="hljs-string">\</span>   <br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题需要明白，return type如果是有类型的，例如这里是TreeNode类型，在此函数内部的递归循环中，每个返回值也要是TreeNode类型的，类似于这题里边的<code>return self.searchBST(root.left, val)</code>，调用的时候是return funct()</p><p>TreeNode类，每次手写一下保持手感</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># None要放到前边</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> val == root.val:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">if</span> val &lt; root.val:<br>            <span class="hljs-keyword">return</span> self.searchBST(root.left, val)<br>        <span class="hljs-keyword">elif</span> val &gt; root.val:<br>            <span class="hljs-keyword">return</span> self.searchBST(root.right, val)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次pycharm的配置过程</title>
    <link href="/2021/11/24/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1pycharm%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/11/24/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1pycharm%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在之前会用vscode远程连接服务器写代码，pycharm是另外一种的操作，用了pycharm后感觉可以在本地也备份一份的感觉</p><p>在同步的时候，可以本地不存储那些数据文件，只存储核心的代码文件，这样如果远程服务器和github无法连接的时候，就可以将本地的那些代码文件向github同步（正好在向github同步的时候要避免对于数据的同步，而只同步代码）</p><span id="more"></span><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><ol><li>新建project</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-22-57-01.png"></p><ol start="2"><li>选择路径这里，这里venv可以随意选择（个人感觉最好不选择，但是不一定能跳过这一步）</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-22-58-37.png"></p><ol start="3"><li>打开File -&gt; Preference，选择Interpreter</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-00-48.png"></p><p>这里的Interpreter需要选择远程的ssh Interpreter<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-01-51.png"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-05-04.png"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-05-14.png"></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-05-57.png"></p><ol start="4"><li>设置deployment，设置有远程文件夹和本地文件夹的同步</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-09-45.png"></p><ol start="5"><li>测试torch.cuda.is_available()</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-10-41.png"></p><ol start="6"><li>设置本地删除文件后，远程也会随之删除</li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-24-23-12-10.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/149040742">https://zhuanlan.zhihu.com/p/149040742</a><br><a href="https://blog.csdn.net/renhanchi/article/details/93769003">https://blog.csdn.net/renhanchi/article/details/93769003</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录服务器miniconda配置虚拟环境</title>
    <link href="/2021/11/10/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8miniconda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/11/10/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8miniconda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>在服务器上之前自己一直用的是virtualenv的环境建立虚拟环境，有一种比较依赖本机已经安装了相关python的感觉。另外昨天在使用virtualenv的时候发现pip的版本对应有些问题，会报sys.stderr.write(f”ERROR: {exc}”)这个错</p><p>大佬同学推荐了一个miniconda的方法，感觉安装起来很方便，虚拟环境感觉都可以使用类似的方法了</p><span id="more"></span><p>Reference：<br><code>https://conda.io/en/latest/miniconda.html</code></p><h1 id="安装Linux-Installers"><a href="#安装Linux-Installers" class="headerlink" title="安装Linux Installers"></a>安装Linux Installers</h1><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-10-09-43-27.png"></p><p>下载后会得到一个<code>Miniconda3-latest-Linux-x86_64.sh</code>，上传到服务器上后可通过bash直接安装</p><h1 id="建立、启动虚拟环境"><a href="#建立、启动虚拟环境" class="headerlink" title="建立、启动虚拟环境"></a>建立、启动虚拟环境</h1><p>可通过如下命令建立启动虚拟环境，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">conda create -n myenv python=3.8 // 安装python</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">conda activate myenv</span><br><span class="hljs-meta prompt_">(myenv)$ </span><span class="language-bash">pip install ...</span> <br></code></pre></td></tr></table></figure><h1 id="安装torch，torchvision，cudatoolkit"><a href="#安装torch，torchvision，cudatoolkit" class="headerlink" title="安装torch，torchvision，cudatoolkit"></a>安装torch，torchvision，cudatoolkit</h1><p>使用conda可以不依赖pip进行安装，conda安装一些内容好像可以非常方便。自己在尝试pip install pytorch的时候经常出现和cuda版本对应不上的问题，还有就是pytorch0.4.1的版本中没有boolTensor，所以需要把pytorch搞成1.x版本并且和cuda版本对应的上</p><p>首先使用nvidia-smi查看当前cuda</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-13-16-20-10.png"></p><p>在pytorch官网<a href="https://pytorch.org/get-started/previous-versions/%E4%B8%8A%E6%9F%A5%E7%9C%8Bprevious">https://pytorch.org/get-started/previous-versions/上查看previous</a> version，一般来说1.4.0，1.6.0比较稳定？</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-13-16-21-01.png"></p><p>输入命令进行安装：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-13-16-21-42.png"></p><p>测试如下：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-11-13-16-35-55.png"></p><h1 id="另外一种直接pip-install的方式（from-zkh）"><a href="#另外一种直接pip-install的方式（from-zkh）" class="headerlink" title="另外一种直接pip install的方式（from zkh）"></a>另外一种直接pip install的方式（from zkh）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu113<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP代码学习笔记</title>
    <link href="/2021/10/30/research/code/NLP%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/30/research/code/NLP%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>记录一些代码中常用的操作说明及bug解决记录</p><span id="more"></span><h1 id="nn-Embedding-from-pretrained"><a href="#nn-Embedding-from-pretrained" class="headerlink" title="nn.Embedding.from_pretrained"></a>nn.Embedding.from_pretrained</h1><p>整个代码的上下文是在做label_ids和slot_ids的embedding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_slot_value_lookup</span>(<span class="hljs-params">self, label_ids, slot_ids</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    self.sv_encoder = BertForUtteranceEncoding.from_pretrained(</span><br><span class="hljs-string">            os.path.join(args.bert_dir, &#x27;bert-base-uncased&#x27;)</span><br><span class="hljs-string">        )</span><br><span class="hljs-string">    # 作者把调用sv_encoder的部分fix住</span><br><span class="hljs-string">    for p in self.sv_encoder.bert.parameters():</span><br><span class="hljs-string">        p.requires_grad = False</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    self.sv_encoder.<span class="hljs-built_in">eval</span>() <span class="hljs-comment"># 切换到evaluate模式</span><br><br>    <span class="hljs-comment"># Slot encoding，这个是fix住的部分</span><br>    slot_type_ids = torch.zeros(slot_ids.size(), dtype=torch.long).to(self.device) <span class="hljs-comment"># 初始化一个空的slot_type_ids</span><br>    slot_mask = slot_ids &gt; <span class="hljs-number">0</span><br>    hid_slot, _ = self.sv_encoder(slot_ids.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    slot_type_ids.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    slot_mask.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    output_all_encoded_layers=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 获取CLS的token，hidden的</span><br>    hid_slot = hid_slot[:, <span class="hljs-number">0</span>, :] <span class="hljs-comment"># 博客中指出，这样的操作是在获取CLStoken，而CLStoken是用来进行分类的，也一般被认为是整句话的embedding</span><br>    hid_slot = hid_slot.detach()<br>    self.slot_lookup = nn.Embedding.from_pretrained(hid_slot, freeze=<span class="hljs-literal">True</span>) <span class="hljs-comment"># slot的embedding结果，是不可以训练的</span><br></code></pre></td></tr></table></figure><h1 id="报在同时使用cpu和gpu的错误"><a href="#报在同时使用cpu和gpu的错误" class="headerlink" title="报在同时使用cpu和gpu的错误"></a>报在同时使用cpu和gpu的错误</h1><p>报在同时使用cpu和gpu的错误除了tensor要tensor.to(device)以外，model也要.to(device)，否则可能会报在同时使用cpu和gpu的错误</p><h1 id="pytorch中判断两个tensor是否相等"><a href="#pytorch中判断两个tensor是否相等" class="headerlink" title="pytorch中判断两个tensor是否相等"></a>pytorch中判断两个tensor是否相等</h1><ol><li><p>tensor.equal()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 该方法用于比较两个tensor是否一样，一样则返回True否则为False</span><br>a = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>b = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(a.equal(b))    <span class="hljs-comment"># 返回True</span><br></code></pre></td></tr></table></figure></li><li><p>tensor.eq()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 该方法用于主元素比较是否相等，相等则在对应位置返回True，否则为False</span><br>a = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>b = torch.tensor([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(a.eq(b))  <span class="hljs-comment"># 返回tensor([False,True,False,True]),与a==b返回的结果一样</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="pytorch输出整个tensor的方法"><a href="#pytorch输出整个tensor的方法" class="headerlink" title="pytorch输出整个tensor的方法"></a>pytorch输出整个tensor的方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.set_printoptions(profile=<span class="hljs-string">&quot;full&quot;</span>)<br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># prints the whole tensor</span><br>torch.set_printoptions(profile=<span class="hljs-string">&quot;default&quot;</span>) <span class="hljs-comment"># reset</span><br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># prints the truncated tensor</span><br></code></pre></td></tr></table></figure><p>在这样的输出下，之后就可以写到文件里了</p><h1 id="tensor-x3D-tensor-0-0"><a href="#tensor-x3D-tensor-0-0" class="headerlink" title="tensor &#x3D; tensor[0, :, 0]"></a>tensor &#x3D; tensor[0, :, 0]</h1><p>这种操作可能代表着仅需要获取bert的cls token的embedding结果，也被认为是整句话的embedding</p><h1 id="contigous-view"><a href="#contigous-view" class="headerlink" title=".contigous().view()"></a>.contigous().view()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">.contigous().view()<br></code></pre></td></tr></table></figure><p>有些tensor并不是占用一整块内存，而是由不同的数据块组成，而tensor的view()操作依赖于内存是整块的，这时只需要执行contigous()这个函数，把tensor变成在内存中连续分布的形式，再使用view。</p><p>Pytorch0.4中，增加了一个reshape函数，就相当于contigous().view()的功能了！</p><h1 id="pytorch常用的张量操作及归一化算法实现"><a href="#pytorch常用的张量操作及归一化算法实现" class="headerlink" title="pytorch常用的张量操作及归一化算法实现"></a>pytorch常用的张量操作及归一化算法实现</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/76255917">https://zhuanlan.zhihu.com/p/76255917</a></p></blockquote><h1 id="squeeze-和-unsqueeze"><a href="#squeeze-和-unsqueeze" class="headerlink" title=".squeeze() 和 .unsqueeze()"></a>.squeeze() 和 .unsqueeze()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">.squeeze()<br>.unsqueeze()<br></code></pre></td></tr></table></figure><p>squeeze()为压缩的意思，即去掉维度数为1的dim，默认是去掉所有为1的，但是也可以自己指定，但如果指定的维度不为1则不会发生任何改变。</p><p>unsqueeze(dim)则与squeeze(dim)正好相反，为添加一个维度的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># print(&quot;hidden.shape: &quot;, hidden.shape) # torch.Size([96, 1, 768]</span><br>hidden = hidden.squeeze() <span class="hljs-comment"># .squeeze()舍弃维度</span><br><span class="hljs-comment"># print(&quot;after .squeeze(), hidden.shape: &quot;, hidden.shape) # torch.Size([96, 768])</span><br></code></pre></td></tr></table></figure><h1 id="nn-GRU-与-nn-LSTM"><a href="#nn-GRU-与-nn-LSTM" class="headerlink" title="nn.GRU 与 nn.LSTM"></a>nn.GRU 与 nn.LSTM</h1><p>循环神经网络是一种能够自适应的变长网络，能够对带有上下文的连续序列很好地进行编码</p><blockquote><p><a href="https://pytorch.org/docs/stable/torch.html">https://pytorch.org/docs/stable/torch.html</a></p></blockquote><h2 id="基本文档说明"><a href="#基本文档说明" class="headerlink" title="基本文档说明"></a>基本文档说明</h2><p><strong>参数设置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">input_size: 单个LSTM神经元的输入维度<br>hidden_size: 单个LSTM神经元的隐含层输出维度<br>num_layers: LSTM的层数，这里指的是叠起来的层数，而不是展开的层数，展开是自适应的。<br>bias: 计算过程中是否需要偏置<br>batch_first: batch是否位于第一个维度，很多时候容易混淆，将在之后进一步解释<br>dropout: 其中每一层输出的dropout概率，默认为<span class="hljs-number">0</span>即不进行dropout，需要注意的一点是最后一层的输出是不会加上dropout概率的。也就是说，当只用到一层LSTM的时候，这个参数是不起作用的。<br>bidirectional: 是否双向，当设置为<span class="hljs-literal">True</span>的时候，输出会为将双向LSTM的输出进行拼接，输出的feature size会增加一倍<br>proj_size: 很多博客中都没有解释，用到的时候可能需要参考 <span class="hljs-comment"># https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html#torch.nn.LSTM</span><br><br>self.nbt = nn.LSTM(input_size=self.bert_output_dim,<br>                              hidden_size=self.hidden_dim,<br>                              num_layers=self.rnn_num_layers,<br>                              dropout=self.hidden_dropout_prob,<br>                              batch_first=<span class="hljs-literal">True</span>)<br><br>self.nbt = nn.GRU(input_size=self.bert_output_dim,<br>                              hidden_size=self.hidden_dim, <span class="hljs-comment"># args.hidden_dim</span><br>                              num_layers=self.rnn_num_layers,<br>                              dropout=self.hidden_dropout_prob,<br>                              batch_first=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><strong>Inputs</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span>: <span class="hljs-built_in">input</span>, (h_0, c_0)<br><br><span class="hljs-built_in">input</span>: 当batch_first = <span class="hljs-literal">False</span>的时候(L, N, H_in)，当batch_first=<span class="hljs-literal">True</span>的时候(N, L, H_in)<br>h_0: (D*num_layers, N, H_out)，containing the initial hidden state <span class="hljs-keyword">for</span> each element <span class="hljs-keyword">in</span> the batch. Defaults to zeros <span class="hljs-keyword">if</span> (h_0, c_0) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> provided.<br>c_0: (D*num_layers, N, H_cell)，containing the initial cell state <span class="hljs-keyword">for</span> each element <span class="hljs-keyword">in</span> the batch. Defaults to zeros <span class="hljs-keyword">if</span> (h_0, c_0) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> provided.<br><br>其中：<br>    N是batch_size<br>    L是每句话的长度<br>    如果使用双向LSTM则D是<span class="hljs-number">2</span>，否则是<span class="hljs-number">1</span><br>    H_in是输入的hiddendim（例如是bert的输出<span class="hljs-number">768</span>）<br>    H_cell是LSTM内部的hidden_size<br>    H_out和输入参数中的proj_size相关，但基本可以理解为就是hidden_size，<br></code></pre></td></tr></table></figure><p><strong>Outputs</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Outputs: output, (h_n, c_n)<br><br>output: 当batch_first=<span class="hljs-literal">False</span>的时候是(L, N, D*H_out)，当batch_first=<span class="hljs-literal">True</span>的时候是(N, L, D*H_out)，其中包括了LSTM最后一层的输出h_t，对于每个t时刻。在PackedSequence相关上还有其他的操作，不过暂时就先不管了<br>h_n: (D*num_layers, N, H_out)包含了每个batch中最后的一个hidden state的element<br>c_n: (D*num_layersm N, H_cell)包含了最后一个cell的state，对于每个batch的最后一个element？<br></code></pre></td></tr></table></figure><h2 id="关于循环神经网络"><a href="#关于循环神经网络" class="headerlink" title="关于循环神经网络"></a>关于循环神经网络</h2><h3 id="关于输入输出的三个维度"><a href="#关于输入输出的三个维度" class="headerlink" title="关于输入输出的三个维度"></a>关于输入输出的三个维度</h3><p>自：维度在tensor的变化中始终是最关键的部分，怎么理解维度背后的含义？</p><p>对于输入输出，我们首先需要注意是传给的网络输出必须是三维的<br>其中每个维度代表的意思，我们习惯的方式是[batch_size, sequence_length, feature_size]<br>具体来说，假如输入的是句子的话，每个维度的含义就是：</p><p>[一次投入到网络中的句子的条数，句子的长度，句子中每个单词对应的向量维度]</p><p>自：在SUMBT代码中，这里的输入该怎么一步步的理解</p><h3 id="关于batch-first"><a href="#关于batch-first" class="headerlink" title="关于batch first"></a>关于batch first</h3><p>这个是一个非常有趣的参数，他能够将输入的形式变为我们习惯的[batch_size, seq_len, feature_size]</p><p>也就是说原本输入参数的形式是[seq_len, batch_size, feature_size]可以视作原本为一列一句话，现在给我们改成了更习惯的一行一句话</p><p>更通俗的来说，就是原本一行为一个句子，变成每一列为一个句子，其实设置了batch_first，也不过是在内部也是使用了第1维度和第2维度的转置操作来变成初始形式</p><p>在SUMBT中怎么理解这个事情？……</p><h1 id="DST任务中的slot-accuracy和joint-accuracy"><a href="#DST任务中的slot-accuracy和joint-accuracy" class="headerlink" title="DST任务中的slot_accuracy和joint_accuracy"></a>DST任务中的slot_accuracy和joint_accuracy</h1><p>slot_accuracy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">acc_slot = torch.<span class="hljs-built_in">sum</span>(accuracy, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>() / torch.<span class="hljs-built_in">sum</span>(labels.view(-<span class="hljs-number">1</span>, slot_dim) &gt; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>()<br></code></pre></td></tr></table></figure><p>个人总结：按照三个槽分别算，对的除以总的（需要去除padding）就是slot_accuracy</p><p>joint_accuracy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">acc = <span class="hljs-built_in">sum</span>(torch.<span class="hljs-built_in">sum</span>(accuracy, <span class="hljs-number">1</span>) / slot_dim).<span class="hljs-built_in">float</span>() / torch.<span class="hljs-built_in">sum</span>(labels[:, :, <span class="hljs-number">0</span>].view(-<span class="hljs-number">1</span>) &gt; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>() <span class="hljs-comment"># joint accuracy</span><br></code></pre></td></tr></table></figure><p>个人总结：每轮对话的算成一个，例如在每轮对话中有3个槽，对了2个，该轮对话就是0.66，之后把所有轮对话的加在一起，除以对话的有效轮数就是joint_accuracy</p><h1 id="tqdm中的desc参数"><a href="#tqdm中的desc参数" class="headerlink" title="tqdm中的desc参数"></a>tqdm中的desc参数</h1><p>这里desc参数是进度条的前缀名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tqdm(dev_dataloader, desc=<span class="hljs-string">&quot;Validation&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="tensorboard的使用"><a href="#tensorboard的使用" class="headerlink" title="tensorboard的使用"></a>tensorboard的使用</h1><p>看起来tensorboard和tensorboardX不是一个东西？ 所以需要使用pip install进行安装(venv环境下)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install tensorboard</span><br>...<br>(venvsumbt) lyx@h1:/hdd1/lyx$ tensorboard<br>TensorFlow installation not found - running with reduced feature set.<br>Error: A logdir or db must be specified. For example `tensorboard --logdir mylogdir` or `tensorboard --db sqlite:~/.tensorboard.db`. Run `tensorboard --helpfull` for details and examples.<br></code></pre></td></tr></table></figure><p>使用方法如下（SUMBT-lyx为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venvsumbt) lyx@h1:/hdd1/lyx/SUMBT-lyx$ tensorboard --logdir=&#x27;SUMBT-lyx/tensorboard/output&#x27;<br>TensorFlow installation not found - running with reduced feature set.<br><br>NOTE: Using experimental fast data loading logic. To disable, pass<br>    &quot;--load_fast=false&quot; and report issues on GitHub. More details:<br>    https://github.com/tensorflow/tensorboard/issues/4784<br><br>Serving TensorBoard on localhost; to expose to the network, use a proxy or pass --bind_all<br>TensorBoard 2.7.0 at http://localhost:6007/ (Press CTRL+C to quit)<br></code></pre></td></tr></table></figure><p>此时还需要配合一条端口转发命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh lyx@xxx.xxx.xxx.xxx -L 6007:localhost:6007<br></code></pre></td></tr></table></figure><p>注意要在训练前另开一个bash执行如下，然后再开启训练，否则可能会出现tensorboard没有显示的情况<br>使用绝对路径！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/ckpt-output<br><br>tensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/20211020-1152-lyx测试<br></code></pre></td></tr></table></figure><h1 id="TensorDataset，SequentialSampler，Dataloader相关"><a href="#TensorDataset，SequentialSampler，Dataloader相关" class="headerlink" title="TensorDataset，SequentialSampler，Dataloader相关"></a>TensorDataset，SequentialSampler，Dataloader相关</h1><p>Reference:</p><blockquote><p><a href="https://pytorch.org/docs/stable/data.html?highlight=sequentialsampler#torch.utils.data.SequentialSampler">https://pytorch.org/docs/stable/data.html?highlight=sequentialsampler#torch.utils.data.SequentialSampler</a></p></blockquote><p>在代码中看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">xxx_sampler = SequentialSampler(xxx_data)  <span class="hljs-keyword">or</span> RandomSampler(xxx_data)<br>xxx_dataloader = DataLoader(xxx_data, sampler=xxx_sampler, batch_size=...)<br></code></pre></td></tr></table></figure><p>自：一般来说在训练过程中使用RandomSampler，dev和test过程中使用SequentialSampler，</p><p>在DST任务中因为和上下文一些状态有关，所以是不是只能顺序采样</p><h2 id="CLASS-torch-utils-data-SequentialSampler-data-source"><a href="#CLASS-torch-utils-data-SequentialSampler-data-source" class="headerlink" title="CLASS torch.utils.data.SequentialSampler(data_source)"></a>CLASS torch.utils.data.SequentialSampler(data_source)</h2><p>按顺序采样元素，始终按相同顺序采样（构建一个迭代器）</p><p>源代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialSampler</span>(Sampler[<span class="hljs-built_in">int</span>]):<br>    <span class="hljs-string">r&quot;&quot;&quot;Samples elements sequentially, always in the same order.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        data_source (Dataset): dataset to sample from</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    data_source: Sized<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data_source: Sized</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.data_source = data_source<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>) -&gt; Iterator[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.data_source)))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data_source)<br></code></pre></td></tr></table></figure><h2 id="CLASS-torch-utils-data-RandomSampler-data-source-replacement-x3D-False-num-samples-x3D-None-generator-x3D-None"><a href="#CLASS-torch-utils-data-RandomSampler-data-source-replacement-x3D-False-num-samples-x3D-None-generator-x3D-None" class="headerlink" title="CLASS torch.utils.data.RandomSampler(data_source, replacement&#x3D;False, num_samples&#x3D;None, generator&#x3D;None)"></a>CLASS torch.utils.data.RandomSampler(data_source, replacement&#x3D;False, num_samples&#x3D;None, generator&#x3D;None)</h2><p>随机抽取元素样本。如果没有替换，则从无序数据集中采样。如果使用替换，则用户可以指定要绘制的样本数</p><p>源代码见：</p><blockquote><p><a href="https://pytorch.org/docs/stable/_modules/torch/utils/data/sampler.html#RandomSampler">https://pytorch.org/docs/stable/_modules/torch/utils/data/sampler.html#RandomSampler</a></p></blockquote><h1 id="np-prod"><a href="#np-prod" class="headerlink" title="np.prod()"></a>np.prod()</h1><p>Reference: </p><blockquote><p><a href="https://blog.csdn.net/weixin_40522801/article/details/106578775">https://blog.csdn.net/weixin_40522801/article/details/106578775</a></p></blockquote><p>np.prod()用来计算所有元素的乘积，pro应该是product的简写，开始的时候不是很明白为什么在计算acc的时候会使用np.prod这个函数，后来发现这个是在计算jointacc上的很好用的函数，因为对于jointacc来说一轮中只要有一个错就算错了</p><p>下边这个代码展示了一个JointGA的计算方式，注意在fuzz模式下，可能出现不是1的单轮jointacc值，但是还会有一种越乘越小的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Joint goal accuracy.</span><br>goal_acc[JOINT_GOAL_ACCURACY] = np.prod(list_acc) <span class="hljs-keyword">if</span> list_acc <span class="hljs-keyword">else</span> NAN_VAL<br></code></pre></td></tr></table></figure><h1 id="fuzz-token-sort-ratio"><a href="#fuzz-token-sort-ratio" class="headerlink" title="fuzz.token_sort_ratio()"></a>fuzz.token_sort_ratio()</h1><p>在对于DST任务non-categorical槽进行评价的时候，很多方法中会使用fuzz这个模式匹配，代码如下，其中str_ref（erence）是真值字符串，str_hyp（othesis）是预测的那个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">match_score = fuzz.token_sort_ratio(str_ref, str_hyp) / <span class="hljs-number">100.0</span><br></code></pre></td></tr></table></figure><p>解读下fuzz.token_sort_ratio这个函数，在源代码中调用顺序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">token_sort_ratio</span>(<span class="hljs-params">s1, s2, force_ascii=<span class="hljs-literal">True</span>, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return a measure of the sequences&#x27; similarity between 0 and 100</span><br><span class="hljs-string">    but sorting the token before comparing.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> _token_sort(s1, s2, partial=<span class="hljs-literal">False</span>, force_ascii=force_ascii, full_process=full_process)<br><br><span class="hljs-meta">@utils.check_for_none</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_token_sort</span>(<span class="hljs-params">s1, s2, partial=<span class="hljs-literal">True</span>, force_ascii=<span class="hljs-literal">True</span>, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    自己注释：按照token进行排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    sorted1 = _process_and_sort(s1, force_ascii, full_process=full_process)<br>    sorted2 = _process_and_sort(s2, force_ascii, full_process=full_process)<br><br>    <span class="hljs-keyword">if</span> partial:<br>        <span class="hljs-keyword">return</span> partial_ratio(sorted1, sorted2)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> ratio(sorted1, sorted2)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_process_and_sort</span>(<span class="hljs-params">s, force_ascii, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return a cleaned string with token sorted</span><br><span class="hljs-string">    返回一个按照token排序的干净的string，这里这个干净就是调用full_process</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># pull tokens</span><br>    ts = utils.full_process(s, force_ascii=force_ascii) <span class="hljs-keyword">if</span> full_process <span class="hljs-keyword">else</span> s<br>    tokens = ts.split()<br><br>    <span class="hljs-comment"># sort tokens and join</span><br>    sorted_string = <span class="hljs-string">u&quot; &quot;</span>.join(<span class="hljs-built_in">sorted</span>(tokens))<br>    <span class="hljs-keyword">return</span> sorted_string.strip()<br><br><span class="hljs-comment"># utils.full_process</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">full_process</span>(<span class="hljs-params">s, force_ascii=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Process string by</span><br><span class="hljs-string">        -- removing all but letters and numbers</span><br><span class="hljs-string">        -- trim whitespace</span><br><span class="hljs-string">        -- force to lower case</span><br><span class="hljs-string">        if force_ascii == True, force convert to ascii</span><br><span class="hljs-string">    这里是几种字符过滤方式，    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> force_ascii:<br>        s = asciidammit(s)<br>    <span class="hljs-comment"># Keep only Letters and Numbers (see Unicode docs).</span><br>    string_out = StringProcessor.replace_non_letters_non_numbers_with_whitespace(s) <span class="hljs-comment"># 用空格替代所有不是字母和数字的</span><br>    <span class="hljs-comment"># Force into lowercase.</span><br>    string_out = StringProcessor.to_lower_case(string_out)<br>    <span class="hljs-comment"># Remove leading and trailing whitespaces.</span><br>    string_out = StringProcessor.strip(string_out)<br>    <span class="hljs-keyword">return</span> string_out<br></code></pre></td></tr></table></figure><p>首先把一个字符串不是字母、数字的字符都用空格替换并转化成小写，然后按照空格切分后进行排序，排序后按照字符级别计算编辑距离比。</p><p>编辑距离比的计算方式是：(len(str1)+len(str2)-编辑距离) &#x2F; (len(str1)+len(str2))</p><p>例如：<br>“Curious San Francisco”（字符含空格长度为21） 和 “San Francisco”（字符不含空格长度为13），编辑距离为8<br>(21 + 13 - 8) &#x2F; (21 + 13) &#x3D; 0.7647</p><p>“CuriousAAA San Francisco”（字符含空格长度为24） 和 “San Francisco”（字符不含空格长度为13），编辑距离为11<br>(24 + 13 - 11) &#x2F; (24 + 13) &#x3D; 0.7027</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-统计文件夹下的文件目录个数</title>
    <link href="/2021/10/28/macOS%E5%8F%8ALinux-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/10/28/macOS%E5%8F%8ALinux-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>需求：希望直接在命令行中统计文件夹下的文件、目录个数</p><span id="more"></span><ol><li><p>统计文件夹下文件个数，包括子文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR | grep <span class="hljs-string">&quot;^-&quot;</span>| <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li><li><p>统计文件夹下目录个数，包括子目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR | grep <span class="hljs-string">&quot;^d&quot;</span>| <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS删除一个文件夹下的.DS_Store</title>
    <link href="/2021/10/11/macOS%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84-DS-Store/"/>
    <url>/2021/10/11/macOS%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84-DS-Store/</url>
    
    <content type="html"><![CDATA[<p>进入目标目录，输入以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./ -name &quot;.DS_Store&quot; -depth -exec rm &#123;&#125; \;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer积累阅读</title>
    <link href="/2021/10/07/research/others/Transformer%E7%A7%AF%E7%B4%AF%E9%98%85%E8%AF%BB/"/>
    <url>/2021/10/07/research/others/Transformer%E7%A7%AF%E7%B4%AF%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>Transformer是Google的研究者在2017年《Attention Is All You Need》论文中提出的用于seq2seq任务的模型，它没有RNN的循环结构或CNN的卷积结构，在机器翻译等任务中取得了一定的提升。</p><p>主要的motivation在于RNN、LSTM、GRU类的序列结构中的固有顺序属性阻碍了训练样本之间的并行化，对于长序列，内存限制将阻碍对训练样本的批量处理。</p><p>Transformer中完全依赖于注意力机制对输入输出的全局依赖关系进行建模。因为对依赖的建模完全依赖于注意力机制，Transformer使用的注意力机制被称为自注意力（self-attention）</p><span id="more"></span><p>References:</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/85864250">https://zhuanlan.zhihu.com/p/85864250</a><br><a href="http://jalammar.github.io/illustrated-transformer/">http://jalammar.github.io/illustrated-transformer/</a></p></blockquote><h1 id="A-High-Level-Look"><a href="#A-High-Level-Look" class="headerlink" title="A High-Level Look"></a>A High-Level Look</h1><p>把整个Transformer当做一个黑盒，在机器翻译任务中，一种语言作为Transformer的输入，另外一种经过翻译后的语言作为Transformer的输出。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-00-23-19.png"></p><p>略微细化下，我们看到Transformer架构由Encoding组件，Decoding组件，还有Encoding Decoding两个组件之间的连接组成。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-00-25-51.png"></p><p>其中的Encoding组件是一个由encoders组成的栈。Decoding组件是一个由和encoders相同数目的decoders组成的栈。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-01-21-44.png"></p><p>编码器在结构上都是相同的（但是互相之间不共享权重）。每一层分为两个子层，分别是Self-Attention机制和Feed Forward Neural Network</p><p>编码器的输入首先要通过一个self-attention层，一个帮助编码器在编码特定单词时查看输入句子中其他单词的层。将在之后进一步分析。</p><p>self-attention层的输出反馈给前馈神经网络（feed forward neural network），完全相同的前馈网络独立应用于每个位置。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-14-45-35.png"></p><p>解码器具有这两个层，但在这两个层之间有一个Encoder-Decoder注意力层，帮助解码器关注输入句子的相关部分（类似于seq2seq模型中注意力的作用）。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-14-57-11.png"></p><h1 id="Bringing-The-Tensors-Into-The-Picture"><a href="#Bringing-The-Tensors-Into-The-Picture" class="headerlink" title="Bringing The Tensors Into The Picture"></a>Bringing The Tensors Into The Picture</h1><p>首先使用embedding算法将每个输入字词转化为向量。使用这种小型的vectors来进行表示。（在SUMBT中，这一步对应了哪一步？为什么这里每个输入字词会变为vectors?）<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-08-15-01-00.png"></p><p>embedding只发生在最底层的编码器中。所有编码器都有一个共同的抽象概念，即它们接收一个大小为512的向量列表——在底部编码器中是word embedding，在其他编码器中则是直接位于下方的编码器的输出。这个列表的大小是我们可以设置的超参数，基本上是训练数据集中最长句子的长度。</p><p>在输入序列中word embedding后，每个单词都会流经编码器的两层。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-11-15-30-06.png"></p><p>在这里，我们看到Transformer的一个关键属性，<strong>即每个位置的字在编码器中通过自己的路径流动。在self-attention层中，这些路径之间存在依赖关系。</strong>然而前馈层（feed forward layer）没有这些依赖关系，因此在流经前馈层时，可以并行执行各种路径。</p><p>接下来，把示例切换到一个较短的句子，并查看编码器的每个子层中放生了什么。</p><h1 id="Now-We’re-Encoding"><a href="#Now-We’re-Encoding" class="headerlink" title="Now We’re Encoding!"></a>Now We’re Encoding!</h1><p>正如我们已经提到的，编码器接收向量列表作为输入（在SUMBT中就是bert embedding后的那些内容）。它通过将这些向量传递到self-attention层，然后传入前馈神经网络，然后将输出向上发送到下一个编码器来处理该列表。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-11-15-39-22.png"><br>每个位置的单词都经过一个自我注意过程。然后，它们各自通过一个前馈神经网络——一个完全相同的网络，每个向量分别通过它。</p><h1 id="Self-Attention-at-a-High-Level"><a href="#Self-Attention-at-a-High-Level" class="headerlink" title="Self Attention at a High Level"></a>Self Attention at a High Level</h1><p>不要被我胡说“self-attention”这个词所愚弄，因为这是每个人都应该熟悉的概念。在阅读《Attention Is All You Need》这篇论文之前，博客作者从未想到过这个概念。让我们总结一下它的工作原理。</p><p>假设以下句子是我们要翻译的输入句子：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The animal didn<span class="hljs-comment">&#x27;t cross the street because it was too tired</span><br></code></pre></td></tr></table></figure><p>在这一句子中，“it”指代的是什么？是指代的street还是animal？对于人类这是简单的，但是对于算法这是复杂的</p><p>当我们的模型在处理“it”这个单词的时候，self-attention允许把“it”和“animal”联系起来</p><p>当模型在处理每个单词的时候（输入语句的每个位置处），self-attention允许其关注输入语句的其他位置来寻求线索，并得出一种对于这个word更好的encoding</p><p>如果对RNN足够熟悉，请考虑如何维护hidden state，使得RNN能够将其已处理的先前单词&#x2F;向量的表示形式与其正在处理的当前单词&#x2F;向量结合起来。self-attention是Transformer用来将其他相关单词的“理解”bake到我们当前正在处理的单词中的方法。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-11-15-48-30.png"></p><p>当我们在编码器#5（堆栈中的顶部编码器）中对单词“it”进行编码时，部分注意力机制将注意力集中在“动物”上，并将其表示的一部分烘焙到“it”的编码中。</p><font color="red">这里需要更加明确self-attention机制的输入输出分别是什么，从个人理解来说是3个输入，1个输出？</font><h1 id="Self-Attention-in-Detail"><a href="#Self-Attention-in-Detail" class="headerlink" title="Self-Attention in Detail"></a>Self-Attention in Detail</h1><p>让我们先看看如何使用向量计算自我注意，然后继续看看它是如何实际实现的——使用矩阵</p><p>计算self-attention的第一步是从编码器的每个输入向量中创建三个向量（在本例中，是每个单词的embedding），所以对于每个单词，我们创建Query vector，一个Key vector， 和一个Value vector。<strong>这些向量是通过将embedding乘以我们在训练过程中训练的三个矩阵来创建的</strong></p><font color="red">突然注意到768 / 64 = 12</font><p>请注意，这些新向量的维数小于嵌入向量，它们的维数为64，而且如和编码器输入&#x2F;输出向量的维数为512。它们不必更小，这是一种架构选择，可以使用MultiHeadAttention（多头注意力机制）来使得计算保持不变（这里是指维度？）</p><p>将x1乘以WQ权重矩阵生成q1，即与该单词相关联的“查询”向量。我们最终创建了输入句子中每个单词的“查询”、“键”和“值”投影。</p><p>（差一张手画的图插进来）</p><p>什么是query key value向量？</p><font color="red">根据师兄的解释，query感觉可以理解成一个自己的内容信息，而key理解成一个别人的信息，这样在和别人进行比较的时候就是上是用自己的q和别人所有的k进行比较</font><p>它们是用于计算和思考注意力机制的抽象概念，继续阅读下面的注意力是如何计算的，就会知道关于每个向量所扮演角色的几乎所有内容。</p><p>计算self-attention的<strong>第二步</strong>是计算分数，假设我们正在计算本例中第一个单词“Thinking”的自我关注度。我们需要给输入句子中的每个单词打分。分数决定了当我们在某个位置对一个单词进行编码时，要把多少注意力放在输入句子的其他部分上。</p><p>分数是通过将query向量的点积与我们正在评分的各个单词的key向量相结合来计算的。因此，如果我们处理位置#1的单词的自我注意，第一个分数将是q1和k1的点积。第二个分数是q1和k2的点积。<strong>（点积将会得到一个分数）</strong></p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-12-12-12-03.png"></p><p><strong>第三步和第四步</strong>是将分数除以8（论文中使用的关键向量维数的平方根–64。这会导致更稳定的梯度。这里可能有其他可能的值，但这是默认值），然后通过softmax操作传递结果。Softmax将分数标准化，使其全部为正值，加起来等于1。</p><p>此softmax分数确定每个单词在此位置的表达量。很明显，这个位置上的单词将具有最高的softmax分数，但有时关注与当前单词相关的另一个单词会很有用。</p><p><strong>第五步</strong>是将每个值向量乘以softmax分数（准备将他们相加）。这里的直觉是保持我们想要关注的单词的完整值，并忽略不相关的单词（例如，将它们乘以0.001这样的小数字）</p><p><strong>第六步</strong>是对加权值向量求和。这将在该位置（对于第一个单词）生成自我注意层的输出。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-12-13-22-21.png"></p><p>自我注意力计算到此结束。结果向量是我们可以发送到前馈神经网络的向量。然而，在实际实现中，这种计算是以矩阵形式进行的，以加快处理速度。现在我们来看一下，我们已经看到了单词级计算的直觉。</p><h1 id="Matrix-Calculation-of-Self-Attention"><a href="#Matrix-Calculation-of-Self-Attention" class="headerlink" title="Matrix Calculation of Self-Attention"></a>Matrix Calculation of Self-Attention</h1><p>第一步是计算查询、键和值矩阵。我们通过将嵌入项打包到矩阵X中，并将其乘以我们训练的权重矩阵（WQ，WK，WV）来实现这一点。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-12-14-07-46.png"></p><p>X矩阵中的每一行对应于输入句子中的一个单词。我们再次看到嵌入向量（512，或图中的4个框）和q&#x2F;k&#x2F;v向量（64，或图中的3个框）的大小差异</p><p>最后，由于我们处理的是矩阵，我们可以将第二步到第六步浓缩成一个公式来计算自我注意层的输出。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-12-14-13-01.png"></p><h1 id="The-Beast-With-Many-Heads"><a href="#The-Beast-With-Many-Heads" class="headerlink" title="The Beast With Many Heads"></a>The Beast With Many Heads</h1><p>本文通过添加了一种称为“Multi-Head”注意力的机制，进一步细化了self-attention层。从这两个方面提高了注意层的性能：</p><ol><li><p>它扩展了模型关注不同位置的能力。是的，在上面的例子中，z1包含了一些其他单词所产生的编码，但是它可能被更加实际的单词本身所支配（这里是指权重比较高？）。如果我们翻译一句话，比如“动物没有过马路是因为它太累了”，我们会想知道“它”指的是哪个词。</p></li><li><p>它为注意力层提供了多个“表示子空间”（有一种增大参数量的感觉？）。正如我们接下来将要看到的，对于multihead-attention，我们不仅有一组，而且有多组query&#x2F;key&#x2F;value权重矩阵（Transformer使用8个attentionhead，因此每个编码器&#x2F;解码器有8组）。这些集合中的每一个都是随机初始化的。然后，在训练之后，使用每个集合将输入embedding（或来自较低编码器&#x2F;解码器的向量）投影到不同的表示子空间。</p></li></ol><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-09-54-56.png"></p><p>通过multihead-attention，我们为每个head维护单独的Q&#x2F;K&#x2F;V权重矩阵，从而产生不同的Q&#x2F;K&#x2F;V矩阵。和前面一样，我们用X乘以W^Q&#x2F;W^K&#x2F;W^V矩阵，得到Q&#x2F;K&#x2F;V矩阵。</p><p>如果我们做上边所述的同样的self-attention计算，只需使用不同的权重矩阵进行八次不同的计算，我们最终得到八个不同的Z矩阵。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-10-01-25.png"></p><p>这给我们留下了一点挑战，前馈层不需要八个矩阵，它需要一个矩阵（每个单词对应一个向量（自：这里说的是z？））。所以我们需要一种方法把这八个元素压缩成一个矩阵。</p><p>我们怎么做？我们将矩阵合并（concatenate），然后将它们乘以一个额外的权重矩阵W^O。</p><font color="red">这里感觉是concate表示了的不行，还要把这些融合到一起才行？或者说要保证输入的X和输出的Z是shape相同的？multi-head如果是这样的操作的话就是一种增加参数量的作用？ 其亮点还主要在于“平权”的对待各个位置处，起到一种self-attention的作用。</font><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-10-10-57.png"></p><p>这几乎就是multi-head attention的全部内容。这是相当多的矩阵，如果把他们放在一个图表示就可以更直观的看到这个过程。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-10-15-18.png"></p><p>既然我们已经谈到了multihead attention，那么让我们回顾一下之前示例，看看在我们的示例语句中对单词“it”进行编码时，不同的注意力头集中在哪里。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-10-21-43.png"></p><p>当我们对“它”这个词进行编码时，一个注意力集中在“动物”身上，而另一个注意力集中在“疲劳”身上——从某种意义上说，模型对“它”这个词的表达同时包含了一些“动物”和“疲劳”的表达。</p><p>然而，如果我们把所有的注意力都放在画面上，事情就更难解释了：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-13-10-24-34.png"></p><h1 id="其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了"><a href="#其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了" class="headerlink" title="其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了"></a>其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了</h1>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DST论文阅读-SUMBT</title>
    <link href="/2021/09/27/research/papers/DST%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-SUMBT/"/>
    <url>/2021/09/27/research/papers/DST%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-SUMBT/</url>
    
    <content type="html"><![CDATA[<p>SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking论文阅读笔记<br>SUMBT: 槽-话语匹配的对话状态跟踪器，用来进行通用和可扩展的信念跟踪</p><span id="more"></span><p>References:</p><blockquote><p>Lee H, Lee J, Kim T Y. SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking[C]&#x2F;&#x2F;Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics. 2019: 5478-5483.<br>对话状态跟踪学习笔记：<a href="https://blog.csdn.net/zerozzl01/article/details/112215175">https://blog.csdn.net/zerozzl01/article/details/112215175</a></p></blockquote><p>注：分段和作者的文章不一定相同</p><h1 id="一些基础概念的个人笔记补充"><a href="#一些基础概念的个人笔记补充" class="headerlink" title="一些基础概念的个人笔记补充"></a>一些基础概念的个人笔记补充</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对话状态跟踪（dialogue state tracking）是任务型（task-oriented）对话系统中的一部分。更具体的来说，是对话管理中的一部分。对话状态是从对话开始到当前对话的用户目标的总结，通常表现为多组槽-值（slot-value）的组合的形式，有时也会包括对话所属的领域、用户意图等信息。对话状态跟踪是指结合对话历史、当前对话、前一轮对话状态等信息，推断并更新当前对话状态的过程</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>1）领域（domain）：可以理解为业务场景，如hotel、train、restaurant等。<br>2）意图（intention）：用户话语的目的，如请求信息、提供信息、确认信息等。<br>3）槽（slot）：槽指某种信息，与完成任务所需要获得的某种信息相对应。比如在预定酒店这个任务中，相关的槽有name、area、price range等。餐馆示例：[area, food, price range]<br>4）本体（ontology）：数据集中，涉及到的所有领域、意图、槽以及相关的所有值构成的数据字典，称为该数据集的本体。</p><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>1）联合目标准确率（joint goal accuracy）&#x2F; 联合状态准确率（joint state accuracy）：一般也简称joint accuracy。对于每轮对话，将预测的对话状态和真实的对话状态进行比较，当且仅当对话状态中所有的（domain，slot，value）预测正确时，才认为对话状态预测正确。<br><font color="red"><br>问题记录：<br>这里需要结合论文所给出的代码查看下联合目标准确率的具体含义，到底是不是一次对话过程中，全部状态正确才算正确？<br></font></p><p>2）槽位准确率（slot accuracy）：单独比较每个（domain，slot，value），当预测值与真实值匹配时，认为预测正确。</p><p>3）推断时间复杂度（inference time complexity, ITC）：ITC的计算方式是完成一次对话状态预测，需要inference多少次。ITC越小越好。</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在面向目标（goal-oriented）的对话系统中，信念跟踪器（belief trackers）预测每个对话回合时的槽值对概率分布。以前的神经网络方法已经为领域（ontology）和槽依赖的belief trackers进行了建模，导致领域本体配置缺乏灵活性。</p><font color="red">问题记录：以往的方法，建模的跟踪器都是领域/槽位依赖的，所以欠缺领域本体设置的灵活性。作者把这些以往的方法统称为slot-dependent methods。这个地方怎么理解，欠缺设置的灵活性？</font><p>在本文中，作者提出了一种新的通用（universal）并可扩展（scalable）的信念跟踪器方法，被称作slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器，SUMBT）。模型通过基于上下文语义的注意力机制来学习领域槽类别（domain-slot-types）与对话中出现的槽-值对之间的关系。更进一步的，模型通过一种非参数的方法预测槽-值对的值。</p><font color="red">这里所说的“基于上下文语义的注意力机制”类似就是用BERT作为tokenizer的这个感觉？</font><p>根据作者在两个对话语料库WOZ2.0和MultiWOZ上的实验结果，与槽依赖的方法相比，该模型的性能有所提高，并达到了最先进的joint accuracy。</p><font color="red">还要通过后文的阅读，理解这里作者所说的槽依赖（slot-dependent）的方法到底和作者所提的方法有什么不同。</font><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>随着会话代理的广泛使用，面向目标的系统越来越受到学术界和工业界的关注。面向目标的对话系统帮助用户实现目标，如在对话结束时预定餐厅或预定航班。随着对话的进行，系统需要更新对话状态的分布，对话状态包括用户的意图、可信息的槽位、和可请求的槽位。这被称作belief tracking（信念跟踪）或者被称作dialogue state tracking（对话状态跟踪, DST）。</p><font color="red">问题记录：这里对应到数据集上到底在预测什么，除了槽值对外，看起来还有很多需要记录的地方？</font><p>例如，对于给定的域（domain）和槽类型（slot-types），（例：‘restaurant’ domain 和 ‘food’ 槽类型），这个任务估计了在领域本体中<strong>预定义</strong>的，相对应的候选槽值对（slot-value）概率（例：‘Korean’和‘Modern European’）</p><p>由于系统使用DST的预测输出，根据对话策略（Policy Learning环节？）选择下一个操作，因此DST的准确性对于提高系统整体性能至关重要。<strong>此外，对话系统应该能够以灵活的方式处理新添加的域和槽，因此开发可伸缩的对话状态跟踪器是不可避免的。</strong> 关于这一点，Chen等人提出一种从意图-话语对中捕捉关系的模型，用于意图扩展。</p><font color="red">问题记录：这里说以灵活的方式处理新添加的域和槽，这个不应该都是已定义好的，为什么会能增加，作者一直在围绕着可扩展性讲故事。（相对于去雾类的论文中的一些idea，这些想法是否属于在NLP领域中直观的想法）</font><p>传统基于统计方法的belief trackers容易受到词汇和形态变化的影响，因为他们依赖于手动构建的语义词典。随着深度学习方法的兴起，一些neural belief trackers（NBT）被提出，并通过学习单词的语义神经表征来提高性能。然而，可扩展性仍然是一个挑战，先前提出的方法要么对每个域、槽单独建模，要么难以添加本体中未定义的新槽值。</p><p>在本文中，我们致力于开发一个“可伸缩”和“通用”的belief tracker，其中只有一个信念跟踪器用于处理任何域和槽类型。为了解决这个问题，我们提出了一种新的方法，称为slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器），他是一种与域和槽独立的对话状态跟踪器，其结构如figure 1所示。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-27-12-06-39.png"></p><p>灵感来自机器阅读理解技术，SUMBT考虑domain-slot type这个组合（例如 ‘restaurant-food’）将其视为一个问题，并在一对用户和系统话语中找到相应的槽值对，假设话语中存在期望的答案。</p><p>SUMBT使用最近提出的BERT对系统和用户的话语（utterance）进行编码，BERT提供句子的语境化语义表示。此外，domain-slot-types 和 slot-values也使用BERT进行字面编码</p><font color="red">上边的意思是，这几个地方都会被BERT编码：[CLS] what type of food would you like? [SEP] a moderately priced modern European food.[SEP]<p>[CLS] restaurant - food [SEP]</p><p>[CLS] modern European [SEP]<br></p></font><p></p><p>然后SUMBT根据上下文语义向量，学习与话语词中domain-slot-type相关的“参加方式（the way where to attend）”。该模型基于某些度量以非参数方式预测slot-value的标签，从而使模型体系结构在结构上不依赖于域和slot-types。因此，单个SUMBT可以处理一对domain-slot-type和slot-value，还可以利用多个域和槽之间的共享知识</p><font color="red">或许这篇文章是比较早把BERT结合进来的操作？</font><p>作者在两个目标面向的对话语料库：WOZ2.0 和 MultiWOZ 上通过实验证明该提议模型的有效性。还将定性分析该模型的工作原理。并将其实现公开发布。</p><h1 id="SUMBT"><a href="#SUMBT" class="headerlink" title="SUMBT"></a>SUMBT</h1><p>所提出的模型由4部分组成，就像图1中所示的。<br>① BERT encoders，用来对【槽】，【值】，【话语】进行encoding（图中的灰色和蓝色部分）<br>② 一个 slot-用户话语匹配的network（图中的红色部分）<br>③ 一个对话状态跟踪器（图中的橙色部分）<br>④ 一个无参数的鉴别器（discriminator，图中的最上端虚线连接）</p><h2 id="Contextual-Semantic-Encoders"><a href="#Contextual-Semantic-Encoders" class="headerlink" title="Contextual Semantic Encoders"></a>Contextual Semantic Encoders</h2><p>对于句子编码器，我们采用了预训练的BERT模型，这是一个双向Transformer编码器的深层堆栈。与普通的词向量相比，这种方式提供了上下文带有语义化的词向量。更进一步的，它提供了词句和句子等词序列的聚合表示，因此我们可以获得由多个词组合的slot-types或slot-values。</p><p>这里主要记录下：</p><p>slot-values: [[area_slot1, area_slot2, area_slot3…], [food_slot1, …], [price_range_1, …]]</p><p>slot-types: [area, food, price range]</p><p>经过一系列操作处理后：</p><p>y_vt label_token_ids根据v_t slot-values得到: [torch.Size([7, 32]), torch.Size([xx1, 32]), torch.Size([xx2, 32])]，这里xx1，xx2分别代表food和price range的标签数目</p><p>q_s slot_token_ids根据s domain-slot-types得到: torch.Size([3, 32])，因为在WOZ这个数据集中只有3个label</p><h2 id="Slot-Utterance-Matching"><a href="#Slot-Utterance-Matching" class="headerlink" title="Slot-Utterance Matching"></a>Slot-Utterance Matching</h2><p>为了从话语中检索与domain-slot-type（area，food，price range）对应的相关信息，该模型使用注意力机制。把domain-slot-type经过encoder的encoded vector q^s作为一个query，将其与【每个each】单词位置的上下文语义向量u相匹配，然后计算注意力分数。</p><p>这里，作者采用了multi-head attention的注意力机制。多头注意力机制将查询矩阵Q、key矩阵K和value矩阵V映射为不同的线性h投影，然后在这些矩阵上执行缩放点积注意力机制。slot s 和 t处的话语之间的有注意上下文向量hst是：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-28-17-32-41.png"></p><font color="red">这里的注意力机制可能需要结合代码和原理详细的学习一下，感觉主要是计算用户每一个词是在哪个domain-slot-type做一个分类的感觉？</font><h2 id="Belief-Tracker-对话状态跟踪器"><a href="#Belief-Tracker-对话状态跟踪器" class="headerlink" title="Belief Tracker 对话状态跟踪器"></a>Belief Tracker 对话状态跟踪器</h2><p>随着对话的进行，每个回合的belief state由之前的对话历史和当前的对话回合决定。这个对话流可以被RNN类的LSTM和GRU，或者Transformer decoders建模（例如：left-to-right uni-directional Transformers）</p><p>在本项工作中，上下文向量h_t，还有RNN的上一个state被送入到RNN中，这是用来学习与目标的slot-values相接近的语义向量</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-28-19-27-17.png"></p><font color="red">等于说每次训练的时候，送入的是当前domain-slot-type和用户utterance的结合，在WOZ数据集上的反应就是，每次训练使用[area, food, price range]这个domain-slot-type结合用户的话术，通过注意力机制实现了用户话语更加关注哪个，然后将这个注意力机制结合之前状态等得到的hidden计算结果与slot-values匹配得到最小的</font><p>作者考虑到BERT是使用layer normalization进行nomal化的，RNN输出的d_t也被送入到一个layer normalizaiton层，来帮助训练训练收敛。</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-28-19-46-31.png"></p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-命令行工具diff</title>
    <link href="/2021/09/16/macOS%E5%8F%8ALinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7diff/"/>
    <url>/2021/09/16/macOS%E5%8F%8ALinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7diff/</url>
    
    <content type="html"><![CDATA[<p>需求：如果使用beyond compare等工具做diff还是有时候有些不方便的，或者说不够灵活。可以在macOS或者Linux系统中直接使用语句进行diff操作，并且在这里补充了一些关于zsh配置和colordiff的说明。</p><span id="more"></span><h1 id="1-流程和操作说明"><a href="#1-流程和操作说明" class="headerlink" title="1. 流程和操作说明"></a>1. 流程和操作说明</h1><p>在目录下执行如下语句即可进行简单的diff操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diff -u [file A] [file B]</span><br></code></pre></td></tr></table></figure><h1 id="2-colordiff及zsh相关配置"><a href="#2-colordiff及zsh相关配置" class="headerlink" title="2. colordiff及zsh相关配置"></a>2. colordiff及zsh相关配置</h1><p>在目前使用的苹果电脑环境下，通过如上语句显示diff没有高亮不方便阅读，故通过如下命令安装colordiff</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install colordiff</span><br></code></pre></td></tr></table></figure><p>安装完成后，可以在任意一个zsh窗口下执行命令进行带颜色的diff操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">colordiff -u [file A] [file B]</span><br></code></pre></td></tr></table></figure><p>原来的diff已经不用了，可以指定diff直接到colordiff，在当前zsh窗口下执行如下命令，即可在当前窗口完成diff代替colordiff的操作（注：可以使用文件查看）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> diff=colordiff</span><br></code></pre></td></tr></table></figure><p>如果要每次都生效，需要执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.zshrc</span><br><br>在最后一行加入<br>alias diff=colordiff<br></code></pre></td></tr></table></figure><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-16-23-42-12.png"></p><h1 id="3-效果展示"><a href="#3-效果展示" class="headerlink" title="3. 效果展示"></a>3. 效果展示</h1><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-16-23-49-33.png"></p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dialogue-State-Tracking简述</title>
    <link href="/2021/09/14/research/papers/Dialogue-State-Tracking%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/09/14/research/papers/Dialogue-State-Tracking%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>学习一些中文论文来大概理解下DST这个任务：</p><p>Reference:</p><blockquote><p>郑正凯. 基于深度学习端到端的对话状态跟踪研究[D].山东大学,2021.</p></blockquote><span id="more"></span><h1 id="1-Dialogue-State-Tracking简述"><a href="#1-Dialogue-State-Tracking简述" class="headerlink" title="1. Dialogue State Tracking简述"></a>1. Dialogue State Tracking简述</h1><p>dst任务一般用在任务型对话中，是pipeline中的一个部分。组成对话系统的各模块按照①自然语言理解（NLU）、②对话状态跟踪（DST）、③策略学习（Policy Learning）、④自然语言生成（NLG）四部分组成。</p><p>其中NLU模块将输入文本转化为结构化的语义表示，提取出对用户当前话语中与任务相关的信息，主要使用意图识别和槽值填充的方法；</p><p>DST模块负责维护系统状态，即获取用户目标，对用户目标进行实时更新；</p><p>PL模块负责根据系统状态选择合适的信息对用户进行反馈；</p><p>NLG模块负责把系统反馈的信息转化为自然语言输出给用户。</p><h1 id="2-对话状态跟踪相关理论"><a href="#2-对话状态跟踪相关理论" class="headerlink" title="2. 对话状态跟踪相关理论"></a>2. 对话状态跟踪相关理论</h1><p>英文数据集MultiWOZ 2.0 2.1 2.2 2.3，其中2.3应该是非常新的版本</p><p>中文数据集CrossWOZ</p><h2 id="2-1-数据组成结构"><a href="#2-1-数据组成结构" class="headerlink" title="2.1 数据组成结构"></a>2.1 数据组成结构</h2><p>在对话状态跟踪任务中，数据由以下几方面组成：基于特定任务的槽值对、用户当前轮输入、上轮次的系统反馈（以前所有轮？）、上轮次的系统状态（以前所有轮？）</p><p>（1）槽值对（Slot-Value）<br>“槽”指系统向用户提供服务之前需要事先确定的信息，而“槽值”是指用户需要提供给系统的具体信息。槽值是具体信息，槽是槽值的统称，一个槽可以对应多个槽值，同一领域内一个槽值只能对应一个槽。</p><p>在跨领域对话系统中，槽的上类称为领域，比如餐馆、酒店、景点等；一个领域可以对应很多槽（酒店有价格、酒店有地理位置……），一个槽也可以对应很多领域（酒店有价格、餐厅有价格……）。<strong>所以我们将领域与槽拼接起来作为槽，这样使得槽变成了唯一</strong>，例如“酒店-名称”，“景点-价格”</p><p>在任务型系统中，一般都会有多个槽，每个槽有多个值，用户的意图是多样且不确定的，系统需要与用户通过多轮互动获取用户的真实意图，如在旅游咨询系统中，将“景点-名称”、“酒店-价格”，“餐馆-推荐菜”等用户需要提供信息的类定义为槽，而“餐馆-推荐菜”对应的“北京烤鸭”，“小笼包”等均为槽值。<strong>对话状态追踪的目的是在每一轮对话中能够准确识别出用户是否表达出某个槽</strong>通过对数据集中槽值对进行统计分析可以获得槽值对形式的知识库，这个知识库能够作为主体文件参与模型的训练与预测。</p><p>（2）用户当前轮输入<br>在多轮对话中，用户当前输入作为对话状态追踪的重要信息，当前轮输入可以是陈述需求或者有疑问推荐，也可以是对上一轮系统反馈的回答及提出新的要求。通过与系统的交互过程中，用户可以随时更新自己的需求，系统会根据用户输入的信息及时更新对话状态。</p><p>（3）上轮次的系统状态与系统反馈（<strong>系统角度</strong>）<br>在DST任务中，一般都会初始化系统状态为{Slot: None}，通过不断地更新状态使得系统获取相关信息。在DST过程中，上下文信息在一定程度上影响了后续的动作，由于上一轮系统反馈与当前轮用户输入有着密切联系，所以一般对话状态跟踪模型均会将上一轮系统状态及反馈作为输入。</p><p>而上一轮的系统反馈无外乎两种信息，一种是针对上一轮用户输入给出的问答式回复或推荐，另一种是由于用户给与的信息量不足或者意图不明确，需要用户增加信息，所以系统会主动向用户发送确认或者请求。</p><p>系统确认是对用户进行槽值确认，如“你喜欢面条吗？”，此时系统的状态为{food: noodle，request: None …}【需要用户增加信息】</p><p>系统请求是询问用户特定槽对应的值，如“不幸的是，价格便宜的已售罄，请选择其他价格范围的菜品”，此时系统状态变为{food: noodle, request: price range}【需要用户增加信息】</p><h2 id="2-2-对话状态追踪过程（DST）"><a href="#2-2-对话状态追踪过程（DST）" class="headerlink" title="2.2 对话状态追踪过程（DST）"></a>2.2 对话状态追踪过程（DST）</h2>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConvLab-2 Getting Started</title>
    <link href="/2021/09/14/ConvLab-2%20Getting%20Started/"/>
    <url>/2021/09/14/ConvLab-2%20Getting%20Started/</url>
    
    <content type="html"><![CDATA[<p>ConvLab-2.ipynb</p><p>ConvLab-2是一个开源工具包，使研究人员能够使用最先进的模型构建面向任务的对话系统，执行端到端评估，并诊断系统的弱点。作为ConvLab的继承者，ConvLab-2继承了ConvLab的框架，但集成了更强大的对话模型并支持更多的数据集。此外，作者还开发了一个分析工具和一个交互式工具，以帮助研究人员诊断（diagnosing）对话系统。</p><p>从这里学习一些对话系列的模型，服务器上操作遇到一些问题，目前还是用google colab操作的</p><p>Reference：</p><blockquote><p><a href="https://github.com/thu-coai/ConvLab-2">https://github.com/thu-coai/ConvLab-2</a></p></blockquote><span id="more"></span><h2 id="1-初始化准备，installation"><a href="#1-初始化准备，installation" class="headerlink" title="1. 初始化准备，installation"></a>1. 初始化准备，installation</h2><p>git clone 自己fork git的内容（<strong>注意在colab环境下的修改一定要同步到本地中，或者说每次都是本地改完想办法传到colab&#x2F;github上</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!git clone https://github.com/yixuan004/ConvLab-2.git &amp;&amp; cd ConvLab-2 &amp;&amp; pip install -e .<br></code></pre></td></tr></table></figure><p>安装spacy使用的en_core_web_sm，来解决BERTNLU中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!python -m spacy download en_core_web_sm<br></code></pre></td></tr></table></figure><h2 id="2-build-an-agent"><a href="#2-build-an-agent" class="headerlink" title="2. build an agent"></a>2. build an agent</h2><p>这里感觉是构建一个机器自动应答的pipeline，包括NLU，DST，Policy和NLG这些模块，组合在一起可以作为机器端的对话机器的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> convlab2.nlu.jointBERT.multiwoz <span class="hljs-keyword">import</span> BERTNLU<br><span class="hljs-keyword">from</span> convlab2.nlu.milu.multiwoz <span class="hljs-keyword">import</span> MILU<br><span class="hljs-keyword">from</span> convlab2.dst.rule.multiwoz <span class="hljs-keyword">import</span> RuleDST<br><span class="hljs-keyword">from</span> convlab2.policy.rule.multiwoz <span class="hljs-keyword">import</span> RulePolicy<br><span class="hljs-keyword">from</span> convlab2.nlg.template.multiwoz <span class="hljs-keyword">import</span> TemplateNLG<br><span class="hljs-keyword">from</span> convlab2.dialog_agent <span class="hljs-keyword">import</span> PipelineAgent, BiSession<br><span class="hljs-keyword">from</span> convlab2.evaluator.multiwoz_eval <span class="hljs-keyword">import</span> MultiWozEvaluator<br><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;import done!&quot;</span>)<br></code></pre></td></tr></table></figure><p>建立模型并建造一个agent</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># go to README.md of each model for more information</span><br><span class="hljs-comment"># BERT nlu，understanding</span><br>sys_nlu = BERTNLU()<br><span class="hljs-comment"># simple rule DST，tracking</span><br>sys_dst = RuleDST()<br><span class="hljs-comment"># rule policy，rule</span><br>sys_policy = RulePolicy()<br><span class="hljs-comment"># template NLG，生成</span><br>sys_nlg = TemplateNLG(is_user=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># assemble，集成到一个pipeline里</span><br>sys_agent = PipelineAgent(sys_nlu, sys_dst, sys_policy, sys_nlg, name=<span class="hljs-string">&#x27;sys&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;build agent done!&quot;</span>)<br></code></pre></td></tr></table></figure><p>和agent进行手动输入对话测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对话1</span><br>sys_agent.response(<span class="hljs-string">&quot;I want to find a moderate hotel&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>We have <span class="hljs-number">18</span> such places . How about bridge guest house ? Fits your request perfectly .<br><br>sys_agent.response(<span class="hljs-string">&quot;Which type of hotel is it ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>It <span class="hljs-keyword">is</span> a guesthouse .<br><br>sys_agent.response(<span class="hljs-string">&quot;OK , where is its address ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>It <span class="hljs-keyword">is</span> located at <span class="hljs-number">124</span> tenison road.<br><br>sys_agent.response(<span class="hljs-string">&quot;Thank you !&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Thank you <span class="hljs-keyword">for</span> contacting the <span class="hljs-built_in">help</span> desk . Have a great day .<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对话2</span><br>sys_agent.response(<span class="hljs-string">&quot;Try to find me a Chinese restaurant in south area .&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>There are <span class="hljs-number">3</span> different places that <span class="hljs-keyword">match</span> your description . The lucky star has some great reviews . How about chinese ?<br><br>sys_agent.response(<span class="hljs-string">&quot;Which kind of food it provides ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>They serve chinese .<br><br>sys_agent.response(<span class="hljs-string">&quot;Book a table for 5 , this Sunday .&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Your reference number <span class="hljs-keyword">is</span> 00000003 .<br></code></pre></td></tr></table></figure><h2 id="3-Build-a-simulator-to-chat-with-the-agent-and-evaluate"><a href="#3-Build-a-simulator-to-chat-with-the-agent-and-evaluate" class="headerlink" title="3. Build a simulator to chat with the agent and evaluate"></a>3. Build a simulator to chat with the agent and evaluate</h2><p>构建一个模拟器与代理聊天并评估</p><ul><li><p>在许多一对一面向任务的对话系统中，模拟器对于训练RL代理是必不可少的。在我们的框架中，我们不区分用户和系统。所有发言者都是代理人。模拟器也是一个代理，内部有特定的策略以实现用户目标。</p></li><li><p>我们对模拟器使用Agenda策略，该策略需要对话行为输入，这意味着我们应该将PipelineAgent的DST参数设置为None。然后PipelineAgent将直接将对话act传递给策略。有关更多详细信息，请参阅PipelineAgent文档。（这里不是很明白为什么要把user_policy设置为None）</p></li></ul><p>这里是模拟器，因为是模拟器所以代表了用户，这样在交互的过程中并不需要跟踪对话状态，所以不需要DST？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># MILU</span><br>user_nlu = MILU()<br><span class="hljs-comment"># not use dst</span><br>user_dst = <span class="hljs-literal">None</span><br><span class="hljs-comment"># rule policy</span><br>user_policy = RulePolicy(character=<span class="hljs-string">&#x27;usr&#x27;</span>)<br><span class="hljs-comment"># template NLG</span><br>user_nlg = TemplateNLG(is_user=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># assemble</span><br>user_agent = PipelineAgent(user_nlu, user_dst, user_policy, user_nlg, name=<span class="hljs-string">&#x27;user&#x27;</span>) <span class="hljs-comment"># user的agent！</span><br></code></pre></td></tr></table></figure><p>现在我们有了一个simulator和一个agent。我们将使用现有的简单的一对一会话控制器BiSession，还可以定义自己的Session class来应对自己的特殊需求</p><p>我们添加了MultiWozEvaluator来评估性能。它使用的解析的对话框act input 和策略输出对话框act来计算inform f1、book rate以及任务是否成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">evaluator = MultiWozEvaluator()<br>sess = BiSession(sys_agent=sys_agent, user_agent=user_agent, kb_query=<span class="hljs-literal">None</span>, evaluator=evaluator)<br></code></pre></td></tr></table></figure><p>让这两个代理进行会话！key是BiSession类的next_turn这个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_seed</span>(<span class="hljs-params">r_seed</span>):<br>    random.seed(r_seed)<br>    np.random.seed(r_seed)<br>    torch.manual_seed(r_seed)<br><br>set_seed(<span class="hljs-number">20210914</span>)<br><br>sys_response = <span class="hljs-string">&#x27;&#x27;</span><br>sess.init_session()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;init goal:&#x27;</span>)<br>pprint(sess.evaluator.goal)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">50</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    sys_response, user_response, session_over, reward = sess.next_turn(sys_response)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;user:&#x27;</span>, user_response)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sys:&#x27;</span>, sys_response)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">if</span> session_over <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;task success:&#x27;</span>, sess.evaluator.task_success())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;book rate:&#x27;</span>, sess.evaluator.book_rate())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;inform precision/recall/f1:&#x27;</span>, sess.evaluator.inform_F1())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;final goal:&#x27;</span>)<br>pprint(sess.evaluator.goal)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">100</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>init goal:<br>&#123;<span class="hljs-string">&#x27;attraction&#x27;</span>: &#123;<span class="hljs-string">&#x27;info&#x27;</span>: &#123;<span class="hljs-string">&#x27;area&#x27;</span>: <span class="hljs-string">&#x27;east&#x27;</span>&#125;,<br>                <span class="hljs-string">&#x27;reqt&#x27;</span>: &#123;<span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;entrance fee&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;phone&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>&#125;&#125;&#125;<br>--------------------------------------------------<br>user: I am planning a trip to town <span class="hljs-keyword">and</span> want to sight see a bit . Can you let me know some attractions I may be interested <span class="hljs-keyword">in</span> ? Can you recommend some attractions <span class="hljs-keyword">in</span> the east ?<br>sys: There are <span class="hljs-number">10</span> , anything <span class="hljs-keyword">in</span> particular you are looking <span class="hljs-keyword">for</span> ? I recommend saint barnabas press gallery. They are located at the belfast yard, coldham<span class="hljs-string">&#x27;s road .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Sounds good . Could I get the phone number of the attraction ? Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The attraction phone number is 01223902088 . Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I will need the entrance fee please .</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I would like to know the entrance fee .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: What are the entrance fees ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you tell me the entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Is there an entrance fee ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you tell me the entrance fee ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I will need the entrance fee please .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I would like to know the entrance fee .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I just need to know how much the entrance fee is .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you give me the entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">task success: 0</span><br><span class="hljs-string">book rate: None</span><br><span class="hljs-string">inform precision/recall/f1: (1.0, 0.6666666666666666, 0.8)</span><br><span class="hljs-string">--------------------------------------------------</span><br><span class="hljs-string">final goal:</span><br><span class="hljs-string">&#123;&#x27;</span>attraction<span class="hljs-string">&#x27;: &#123;&#x27;</span>info<span class="hljs-string">&#x27;: &#123;&#x27;</span>area<span class="hljs-string">&#x27;: &#x27;</span>east<span class="hljs-string">&#x27;&#125;,</span><br><span class="hljs-string">                &#x27;</span>reqt<span class="hljs-string">&#x27;: &#123;&#x27;</span>address<span class="hljs-string">&#x27;: &quot;the belfast yard, coldham&#x27;</span>s road<span class="hljs-string">&quot;,</span><br><span class="hljs-string">                         &#x27;entrance fee&#x27;: &#x27;?&#x27;,</span><br><span class="hljs-string">                         &#x27;phone&#x27;: &#x27;01223902088&#x27;&#125;&#125;&#125;</span><br><span class="hljs-string">====================================================================================================</span><br></code></pre></td></tr></table></figure><h2 id="还有一些其他简易操作，例如Try-different-module-combinations，Use-analysis-tool-to-diagnose-the-system，见-ipynb中的整理了"><a href="#还有一些其他简易操作，例如Try-different-module-combinations，Use-analysis-tool-to-diagnose-the-system，见-ipynb中的整理了" class="headerlink" title="还有一些其他简易操作，例如Try different module combinations，Use analysis tool to diagnose the system，见.ipynb中的整理了"></a>还有一些其他简易操作，例如Try different module combinations，Use analysis tool to diagnose the system，见.ipynb中的整理了</h2>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiWOZ数据集学习</title>
    <link href="/2021/09/13/MultiWOZ%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/09/13/MultiWOZ%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>主要记录了通过了解数据集作为对DST任务的入门，MultiWOZ数据集是适用于<strong>任务型对话</strong>系统的数据集，目前看了一遍这个简介后还是不太明白，感觉还需要各种渠道多了解下</p><p>Reference：</p><blockquote><p>任务型对话系统数据集详解大全（MultiWOZ &#x2F;DSTC） <a href="https://zhuanlan.zhihu.com/p/200747822">https://zhuanlan.zhihu.com/p/200747822</a> </p></blockquote><span id="more"></span><h1 id="2021-9-13-首次学习"><a href="#2021-9-13-首次学习" class="headerlink" title="2021.9.13 首次学习"></a>2021.9.13 首次学习</h1><h2 id="1-MultioWOZ的前世今生"><a href="#1-MultioWOZ的前世今生" class="headerlink" title="1. MultioWOZ的前世今生"></a>1. MultioWOZ的前世今生</h2><p>·New WOZ：2018年剑桥大学研究人员在提出一个新的multi-domain DST模型的同时，顺带提出了New WOZ数据集，被看作是1.0的最初版本，发表在ACL；</p><p>·MultiWOZ 2.0：在1.0版本不错后，这些研究人员首次提出了MultiWOZ这个数据集，也就是一般所说的MultiWOZ 2.0，是当年EMNLP的Best Paper；</p><p>·MultiWOZ 2.1：2019年亚马逊的研究人员对MultiWOZ 2.0数据集中的一些错误进行修正，添加了对槽位的解释和对话行为的标注，代表MultiWOZ 2.1版本</p><p>·MultiWOZ 2.2：2020年google的研究人员在2.1的基础上提出升级版2.2；</p><h2 id="2-MultiWOZ这个名字的由来"><a href="#2-MultiWOZ这个名字的由来" class="headerlink" title="2. MultiWOZ这个名字的由来"></a>2. MultiWOZ这个名字的由来</h2><p>MultiWOZ的全称是Multi Domain Wizard-of-Oz，其中Wizard-of-Oz是Wizard-of-Oz Experiment或者Wizard-of-Oz Testing或者Wizard-of-Oz Method，是一种方法、技术。简单来说，你以为你在跟机器对话，实际上这个机器的背后是另一个人，是一种使还没有实现的技术先通过人工模拟系统的相应的技术手段。</p><p>因为用到了Wizard-of-Oz方法进行数据的制作和收集，所以采用这个名字。也提到了crowd-sourcing众包的方法，比较通俗的解释是“众包找人来干活，但不花钱，找社会上的志愿者，你一点我一点大家一起把这个事情完成”。关于这个方法作者还展示了他们做的GUI，专门用来让大众制作收集数据集。</p><h2 id="3-MultiWOZ-2-0数据集细节："><a href="#3-MultiWOZ-2-0数据集细节：" class="headerlink" title="3. MultiWOZ 2.0数据集细节："></a>3. MultiWOZ 2.0数据集细节：</h2><p>·主要目标：在旅游城市的信息中心获取旅游者查询的高度自然对话</p><p>·Domain（域）：Attraction，Hospital，Police，Hotel，Restaurant，Taxi，Train，其中后四个域属于扩展域，包括子任务Booking。每段对话涉及1-5个领域，因此长度和复杂性差别很大。全部的act和slot如下：</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-09-13-20-49-44.png"></p><p>·数量及分布：10438个对话，其中3406个单领域对话，7032个多领域对话，多领域中，包含最少2-5个领域。70%的对话超过10个会和，其中单领域平均轮数为8.93，多领域为15.39。在数据里，对话的序号前面是SNG的就是单轮，MUL的就是多轮。</p><p>·数据结构：每个对话包含a goal，multiple user，system utterances(系统话语)，belief state（？信度状态），dialogue acts and slots（可能需要结合具体数据进一步理解下）</p><p>·Belief state：有三个部分，分别是semi，book，booked、其中semi是特定领域里的槽值；book在特定领域的booking slots；booked是book的一个子集，在book这个字典里，是booked entity</p><p>↑这段话不太好理解，感觉还得从具体数据内容来看</p><h2 id="4-MultiWOZ-as-a-New-Benchmark"><a href="#4-MultiWOZ-as-a-New-Benchmark" class="headerlink" title="4. MultiWOZ as a New Benchmark"></a>4. MultiWOZ as a New Benchmark</h2><p>MultiWOZ作为新的benchmark，提供了三个子任务，分别是，dialogue state tracking、dialogue-act-to-text generation，dialogue context-to-text generation</p><p>其中<br>·Dialogue state tracking：用在餐厅子领域的overall和joint goals的accuracy作为评价指标</p><p>相关指标更新见：<a href="https://github.com/budzianowski/multiwoz">https://github.com/budzianowski/multiwoz</a></p><p>感觉理解的还不是很清楚，还需要进一步看下对话相关的任务一类的来理解吧</p><h1 id="2021-10-24-笔记补充-MultiWOZ2-2以及MultiWOZ系列的前世今生"><a href="#2021-10-24-笔记补充-MultiWOZ2-2以及MultiWOZ系列的前世今生" class="headerlink" title="2021.10.24 笔记补充 MultiWOZ2.2以及MultiWOZ系列的前世今生"></a>2021.10.24 笔记补充 MultiWOZ2.2以及MultiWOZ系列的前世今生</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>MultiWOZ2.2数据集发表在ACL2020上，发布了MultiWOZ数据集的升级版，作者来自google和伊利诺伊大学芝加哥分校</p><blockquote><p><a href="https://aclanthology.org/2020.nlp4convai-1.13/">https://aclanthology.org/2020.nlp4convai-1.13/</a></p></blockquote><h2 id="MultiWOZ发展史"><a href="#MultiWOZ发展史" class="headerlink" title="MultiWOZ发展史"></a>MultiWOZ发展史</h2><ol><li>NewWOZ（ACL2018），但好像用的人不多？</li><li>MultiWOZ2.0（EMNLP2018）</li><li>MultiWOZ2.1 针对2.0中的一些错误进行修正，添加了对槽位的解释和对对话行为的标注，亚马逊研究人员。<blockquote><p>Eric M, Goel R, Paul S, et al. MultiWOZ 2.1: A Consolidated Multi-Domain Dialogue Dataset with State Corrections and State Tracking Baselines[C]&#x2F;&#x2F;Proceedings of the 12th Language Resources and Evaluation Conference. 2020: 422-428.</p></blockquote></li><li>MultiWOZ2.2（ACL 2020），是2.1的进一步升级版</li></ol><h2 id="标注错误"><a href="#标注错误" class="headerlink" title="标注错误"></a>标注错误</h2><p>下面开始介绍2.2对2.1的改进，首先是标注错误。<br>在了解标注错误之前，首先了解一下什么是<strong>Wizard-of-Oz setup</strong>。<br>Wizard-of-Oz setup是由两个众包工人组成一队，一个扮演user，一个扮演agent。<br>每组对话由一个特定的目标来驱动。<br>在每轮user对话结束后，扮演agent的众包工会标注出更新后的对话状态，并依此生成一个回复。<br>由于这种方法是完全靠人工去标注的，那么就会容易产生噪声。</p><h2 id="Hallucinated-Values（直译为“幻觉价值观”）"><a href="#Hallucinated-Values（直译为“幻觉价值观”）" class="headerlink" title="Hallucinated Values（直译为“幻觉价值观”）"></a>Hallucinated Values（直译为“幻觉价值观”）</h2><p>作者将标注中错误的value分为4类。如下的4种</p><ol><li><p>Early Markup：未来会出现的槽值被agent标注为了当前的值，如图所示，User说了：Help me find a moderate price british food place please，此时系统回复了restaurant one seven is a nice place. Do you want to book? 此时应该意图还没有锁在r-name&#x3D;one seven上<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-24-22-05-41.png"></p></li><li><p>Annotation from Database：这些值没有在对话中出现，而是被程序错误的从数据库中抽取出来的。<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-24-22-12-29.png"></p></li><li><p>Typo：一些印刷或者排版书写错误<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-24-22-33-29.png"></p></li><li><p>Implicit Time Processing：一些隐式的时间表示，有可能是根据前面的相对时间加减计算出来的时间，也有时候会四舍五入到最接近的时间。这样会家中模型学习的负担<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-24-22-33-40.png"></p></li></ol><h2 id="状态更新不一致"><a href="#状态更新不一致" class="headerlink" title="状态更新不一致"></a>状态更新不一致</h2><p>状态更新不一致的主要原因有两种：</p><ol><li><p>value来源有多个：一个槽值在对话状态可能有各种来源：由用户提供、由系统提供、从对话状态中不同的domain下的值继承过来的、来源于本体中定义的。</p></li><li><p>value的释义不规范：多个value其实含义是一样的。2.1在定义这些内容的时候缺乏一个显式的规则。这就使得模型训练的时候造成困惑，比如说同时有18：00和6pm，其实都是对的，但是训练过程中ground truth只有一个，那么就会错误的惩罚另一个<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-00-00-53.png"></p></li><li><p>跟踪策略不一致：众包工人标注时的标准不一致，有的只标注了用户提到的value，有的将用户统一的agent提到的value也标了进来<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-09-13-23.png"></p></li></ol><h2 id="本体中的问题"><a href="#本体中的问题" class="headerlink" title="本体中的问题"></a>本体中的问题</h2><p>在MultiWOZ2.0中定义了一个本体，他声称美居乐所有slot的value。但是后来的研究人员发现这个本体其实是很不完整的，所以为了达到很好的效果，研究人员往往要自己再重新定义一个自己的本体。为了解决这个问题，2.1试图列出对话状态中的所有值来重建本体，但是仍然存在一些未解决的问题。</p><p>比如说：</p><ol><li>在同一槽位中具有相同语义的多个value</li></ol><ul><li>8pm&#x3D;20:00，a and b guesthouse &#x3D; a and b guest house</li></ul><ol start="2"><li>本体中多个slot-value无法与数据库中的实体相关联<strong>（这个地方不是很理解）</strong></li></ol><h2 id="纠正程序"><a href="#纠正程序" class="headerlink" title="纠正程序"></a>纠正程序</h2><p><strong>为了解决上面提到了这些问题，作者这里提到了一套纠正程序</strong></p><p>首先，关于本体。在本体为slot枚举所有可能的value是一件很不现实的事情。比如餐馆的名称，订餐的时间。</p><p>因此这里沿用了一种Schema的概念，也就是categorical和non-categorical的区别</p><p>categorical：slot中value有限（数量小于50），value列举出所有可能的值<br>non-categorical：具有大量possible values的slot，value从对话历史中提取出来</p><p>schema将所有slot分成两类，一类叫做non-categorical，另一类叫做categorical</p><p>non-categorical包括那些具有大量可能value的slot，schema中对这些slot不去预定义一个value的list，对于这类slot的value是从对话历史中提取出来的</p><p>categorical包含了那些value有限的slot，以及在训练数据中具体value数量少于50个的slot。在schema里头对这类slot会列举出所有可能的value<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-09-40-25.png"></p><p>自：MWZ2.0数据集中的schema好像是比较明显的。</p><h2 id="Categorical-Slots"><a href="#Categorical-Slots" class="headerlink" title="Categorical Slots"></a>Categorical Slots</h2><p>对于分类槽位，所有可能的值都是由2.1的数据库构建的。</p><p>其中有两个特殊的词，dont-care和unknown</p><ul><li>don’t care是用户在对某一个值没有偏好的时候使用的</li><li>unknown指的是那些在schema中的值无法满足用户特定的需求</li></ul><p>例如：<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-09-43-09.png"></p><h2 id="Non-categorical-Slots"><a href="#Non-categorical-Slots" class="headerlink" title="Non-categorical Slots"></a>Non-categorical Slots</h2><p>对于非分类槽位。上面已经说过，它的value是从历史对话中提取出来的。作者这里使用一种字符串匹配的方式找到对话历史中语义最接近的值。如果有多个，就取最近提到的那个</p><p>在2.2中，在标注中允许一个slot有多个value，模型预测出来任意一个都算对<br><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-09-48-10.png"></p><p>当多个slot对应的是同一个value的时候，作者这里采用链式存储的思想。后来的slot不标注span，而是标注这个value对应的原始的slot</p><p><img src="http://yixuan004.oss-cn-hangzhou.aliyuncs.com/img/2021-10-25-09-54-53.png"></p><p>这个图也显示了有在categorical和non-categorical上分别计算JointAcc的习惯</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
      <tag>Dataset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的首篇github博客!</title>
    <link href="/2021/09/13/mixed/hexo/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/09/13/mixed/hexo/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>何老版推荐的github.io+hexo好用啊</strong></p><p><strong>个人代码管理+笔记博客什么的都可以写在github这里了</strong></p><p>主要写了hexo + github.io的双分支部署说明和步骤，以及本地运维和新建修改，切换主题等操作。</p><span id="more"></span><p>References：</p><blockquote><p>简易部署相关：<a href="https://www.jianshu.com/p/390f202c5b0e">https://www.jianshu.com/p/390f202c5b0e</a><br>多分支部署相关：<a href="https://blog.csdn.net/sherlockyb/article/details/94180548">https://blog.csdn.net/sherlockyb/article/details/94180548</a><br>切换主题相关：<a href="https://github.com/stkevintan/hexo-theme-material-flow">https://github.com/stkevintan/hexo-theme-material-flow</a> </p></blockquote><h2 id="1-hexo-github-io的双分支部署的说明"><a href="#1-hexo-github-io的双分支部署的说明" class="headerlink" title="1. hexo + github.io的双分支部署的说明"></a>1. hexo + github.io的双分支部署的说明</h2><p>简易部署带来的问题：</p><p>如果使用简单的hexo配置，那么本地的一些md等文件将丢失，所以现在有master（存储hexo生成的）和coding-pages（静态的）两个分支；</p><p>master用来存储hexo生成的+yixuan004.github.io页面显示的内容（html），而coding-pages存放了一些原本的markdown文件，还有一些_config.yml等，这样如果未来某一天本地环境崩溃了，还可以很快的git clone恢复；</p><h2 id="2-hexo-github-io的双分支部署步骤"><a href="#2-hexo-github-io的双分支部署步骤" class="headerlink" title="2. hexo + github.io的双分支部署步骤"></a>2. hexo + github.io的双分支部署步骤</h2><ol><li><p>在github建立一个包含README.md的项目，命名为 username.github.io，主分支为master分支；</p></li><li><p>直接在github branch的位置处新建一个coding-pages分支，并将其设置为默认分支。此时master分支和coding-pages分支应该都会有一个README.md文件，但实际上是不需要的，在后边可能需要用强制推分支的方法把这个README覆盖掉</p></li><li><p>在本地的一个文件夹中（例如yixuan004.github.io文件夹）中初始化一个hexo项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init</span><br></code></pre></td></tr></table></figure></li><li><p>将本地的hexo项目与远程仓库关联，在本地的那个地方使用git init生成隐藏的.git文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br></code></pre></td></tr></table></figure></li></ol><p>在之后通过如下命令将远程的那个git关联上的感觉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add origin https://github.com/yixuan004/yixuan004.github.io.git</span><br></code></pre></td></tr></table></figure><p>在之后，由于远程的默认分支是coding-pages，所以本地也需要新建一个coding-pages分支（<strong>注：本地的操作因为仅需要向coding-pages同步，所以本地工作也要切换到这个分支的感觉</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b coding-pages</span><br></code></pre></td></tr></table></figure><p>由于远程之前可能有一个没什么用处的README，这里可以使用强制推的方法解决，但这个应该不是合理的解决办法，只是自己用来省事解决一下了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把本地的所有内容都加入git（hexo会自动生成一个git init，那些内容每次可能hexo clean会clean掉，所以要忽略那些）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push -u origin coding-pages -f</span><br></code></pre></td></tr></table></figure><ol start="5"><li><p>安装hexo向git推送的包（在文件夹下操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install hexo-deployer-git --save</span><br></code></pre></td></tr></table></figure></li><li><p>修改hexo项目中的_config.yml，这里要写上master分支，因为貌似hexo在github.io上默认显示master分支的内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/yixuan004/yixuan004.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li><li><p>推送相关（联合第4步使用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin coding-pages</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean <span class="hljs-comment"># 这个步骤放在第一步也可以，但是感觉有gitignore在应该这样就可以了</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo d</span><br></code></pre></td></tr></table></figure><p><strong>个人感觉远程的master分支是通过这个hexo自动推送，而远程的coding-pages分支是自己手工推送的感觉</strong></p></li></ol><h2 id="3-hexo-github-io的本地操作说明"><a href="#3-hexo-github-io的本地操作说明" class="headerlink" title="3. hexo + github.io的本地操作说明"></a>3. hexo + github.io的本地操作说明</h2><h3 id="3-1-新增博客文章"><a href="#3-1-新增博客文章" class="headerlink" title="3.1 新增博客文章"></a>3.1 新增博客文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new [文章名称]<br></code></pre></td></tr></table></figure><p>在这之后，会在source&#x2F;_posts目录下生成[文章名称].md文件，对其进行编写即可进行博客书写，注意在最开始会自动生成如下内容，可以通过自己编辑增加tags和categories</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 我的首篇github博客!<br>date: 2021-09-13 08:01:04<br>tags: <br><span class="hljs-bullet">    -</span> hexo相关<br>categories:<br><span class="hljs-section">    - 编程开发</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="3-2-本地修改运维操作"><a href="#3-2-本地修改运维操作" class="headerlink" title="3.2 本地修改运维操作"></a>3.2 本地修改运维操作</h3><p>在本地完成一些修改后，建议顺序执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin coding-pages</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo d</span><br></code></pre></td></tr></table></figure><h2 id="4-切换hexo主题"><a href="#4-切换hexo主题" class="headerlink" title="4. 切换hexo主题"></a>4. 切换hexo主题</h2><p>可参考：</p><blockquote><p><a href="https://github.com/stkevintan/hexo-theme-material-flow">https://github.com/stkevintan/hexo-theme-material-flow</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
