<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>修改hosts文件使得服务器可以访问github</title>
    <link href="/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/"/>
    <url>/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/</url>
    
    <content type="html"><![CDATA[<p>之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用</p><p>在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改<code>/etc/hosts</code>文件的方式</p><span id="more"></span><h1 id="修改hosts文件使得服务器可以访问github"><a href="#修改hosts文件使得服务器可以访问github" class="headerlink" title="修改hosts文件使得服务器可以访问github"></a>修改hosts文件使得服务器可以访问github</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>首先登录如下网站，找到一个可以ping到的github ip地址：<a href="https://ping.chinaz.com/github.com">https://ping.chinaz.com/github.com</a></p><p><img src="/_posts/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119200639129.png" alt="image-20221119200639129"></p><p>通过root账号修改<code>/etc/hosts</code>文件，加入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">140.82.113.3www.github.com<br>140.82.113.3github.com<br></code></pre></td></tr></table></figure><p>加入后效果如下，再次<code>ping www.github.com</code>，可以得到响应，证明正确</p><img src="/_posts/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119200931544.png" alt="image-20221119200931544" style="zoom:50%;"><img src="/_posts/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119201002658.png" alt="image-20221119201002658" style="zoom:50%;">]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo图片路径的配置</title>
    <link href="/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>在使用hexo搭建博客的时候，<code>./source/images</code>路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到</p><p>但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在</p><p>所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移</p><span id="more"></span><h1 id="hexo图片路径的配置"><a href="#hexo图片路径的配置" class="headerlink" title="hexo图片路径的配置"></a>hexo图片路径的配置</h1><h2 id="1-安装插件hexo-asset-image"><a href="#1-安装插件hexo-asset-image" class="headerlink" title="1. 安装插件hexo-asset-image"></a>1. 安装插件hexo-asset-image</h2><h3 id="1-1-reference"><a href="#1-1-reference" class="headerlink" title="1.1 reference"></a>1.1 reference</h3><p><a href="https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2">https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2</a></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2 操作"></a>1.2 操作</h3><p>使用npm进行安装，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install https://github.com/CodeFalling/hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>注意，这里很多其他博客提供的安装命令如下，但实际尝试的时候可能由于版本等问题，导致无法生效，这些命令可能不好使</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-renderer-marked --save<br>npm install hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>之后，将<code>_config.yml</code>文件的做如下修改（注：后面的marked可能是不需要的，可能是对应<code>hexo-render-marked</code>的配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">_config.yml<br>post_asset_folder: true<br>marked:<br>  prependRoot: true<br>  postAsset: true<br></code></pre></td></tr></table></figure><p>在上述配置后，在执行<code>hexo new [FILENAME]</code>的时候，会自动生成这个文件名字的md和对应的文件名字的文件夹，这里可以在文件夹后加入<code>.assets</code>，和目前我自己本机的typora环境对应上</p><p>至此操作完成</p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BERT源代码阅读学习</title>
    <link href="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习</p><span id="more"></span><h1 id="BERT源代码阅读学习"><a href="#BERT源代码阅读学习" class="headerlink" title="BERT源代码阅读学习"></a>BERT源代码阅读学习</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>BERT源代码学习：<a href="https://zhuanlan.zhihu.com/p/360988428">https://zhuanlan.zhihu.com/p/360988428</a></p><p>Attention is all you need： <a href="https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf</a></p><p>BERT：<a href="https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ">https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ</a></p><p>Attention机制详解：<a href="https://zhuanlan.zhihu.com/p/47282410">https://zhuanlan.zhihu.com/p/47282410</a></p><p>positional embedding absolute&#x2F;relative等不同方式：<a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>torch中的einsum：<a href="https://zhuanlan.zhihu.com/p/361209187">https://zhuanlan.zhihu.com/p/361209187</a></p><p>Self-Attention with Relative Position Representations: <a href="https://arxiv.org/pdf/1803.02155.pdf">https://arxiv.org/pdf/1803.02155.pdf</a></p><h2 id="1-模型结构（论文-amp-Transformer架构截图）"><a href="#1-模型结构（论文-amp-Transformer架构截图）" class="headerlink" title="1. 模型结构（论文&amp;Transformer架构截图）"></a>1. 模型结构（论文&amp;Transformer架构截图）</h2><h3 id="1-1-论文-amp-Transformer架构截图"><a href="#1-1-论文-amp-Transformer架构截图" class="headerlink" title="1.1 论文&amp;Transformer架构截图"></a>1.1 论文&amp;Transformer架构截图</h3><h4 id="1-1-1-Transformer架构图"><a href="#1-1-1-Transformer架构图" class="headerlink" title="1.1.1 Transformer架构图"></a>1.1.1 Transformer架构图</h4><p>左边代表Encoder部分，右边代表Decoder部分。两边的区别个人理解是：</p><ul><li>Encoder是作为NLU（Natrual Language Understanding）来使用的，所以在输入的时候Encoder是能看到全局信息的。从目前接触到的任务来说还是Encoder这边的结构更加常用一些，大部分任务感觉还是属于在NLU的范畴，NLG那边的有些就显得不太好评测或者不是很靠谱；</li><li>但是在输入Decoder的时候，因为Decoder一般被NLG（Natural Language Generation）类的任务来使用，所以其需要根据上文来生成下文，故在输入的时候需要加mask，即 <code>Masked Multi-Head Attention</code>。此外在decoder部分中还有一个接收来自Encoder那边信息的Multi-Head Attention，也被称作 <code>encoder-decoder attention layer</code>，这个地方query来自于前一级的decoder层输出，但其key和value来自于encoder的输出，那么理解来说就是decoder的每一个位置作为key和encoder那边key计算相似度，然后聚合来自encoder那边的value信息；</li><li><font color="red">和同学讨论后补充：对于Transformer架构的信息，像T5这样的encoder-decoder模型，或者说像是一类依据文本生成文本的，比如翻译任务，那就是使用到整个Transformer架构，其中的encoder-decoder attention可以理解为我需要看着原来的文本来做生成，然后把query看做普通RNN架构中的x，这样x需要聚合来自全部输入文本的信息做attention；对于BERT这类就是只用到Encoder架构；对于GPT类的可能就只是用Decoder部分，里面就没有encoder-decoder attention那个部分了；</font></li></ul><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711105616573.png" alt="image-20220711105616573" style="zoom:50%;"><h4 id="1-1-2-Multi-Head-Self-Attention"><a href="#1-1-2-Multi-Head-Self-Attention" class="headerlink" title="1.1.2 Multi-Head Self Attention"></a>1.1.2 Multi-Head Self Attention</h4><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711105642016.png" alt="image-20220711105642016"></p><h4 id="1-1-3-BERT-Embedding"><a href="#1-1-3-BERT-Embedding" class="headerlink" title="1.1.3 BERT Embedding"></a>1.1.3 BERT Embedding</h4><p>这个是bert模型结构的embedding输入，也需要联合代码看一下这个过程是怎么实现的。</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711110109758.png" alt="image-20220711110109758"></p><p>这里补充贴一张LUKE的图，虽然没看过但是看起来加了一个Entity Type Embedding，好像还是个比较有名的工作</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712195033334.png" alt="image-20220712195033334"></p><h2 id="2-代码学习"><a href="#2-代码学习" class="headerlink" title="2. 代码学习"></a>2. 代码学习</h2><h3 id="2-1-基础简化pipeline代码"><a href="#2-1-基础简化pipeline代码" class="headerlink" title="2.1 基础简化pipeline代码"></a>2.1 基础简化pipeline代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> modeling_bert  <span class="hljs-comment"># 从这里看源代码</span><br><br><span class="hljs-comment"># 预训练模型加载</span><br>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br>model = BertModel.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br><br><span class="hljs-comment"># 输入&amp;输出</span><br>text = <span class="hljs-string">&quot;Germany beat Argentina 2-0 in the World Cup Final.&quot;</span><br>encoded_input = tokenizer(text, return_tensors=<span class="hljs-string">&#x27;pt&#x27;</span>)<br>output = model(**encoded_input)<br><br><span class="hljs-comment"># 获取一句话的输出，还有cls token的输出</span><br><span class="hljs-built_in">print</span>(output[<span class="hljs-string">&#x27;pooler_output&#x27;</span>].shape)  <span class="hljs-comment"># torch.Size([1, 768])</span><br><span class="hljs-built_in">print</span>(output[<span class="hljs-string">&#x27;last_hidden_state&#x27;</span>].shape)  <span class="hljs-comment"># torch.Size([1, 14, 768])</span><br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><p>总结：加载<strong>config.json</strong>、<strong>vocab.txt</strong>还有<strong>pytorch_model.bin</strong>三个文件。其中通过 <code>from_pretrained(&quot;./bert_base_uncased&quot;)</code>进行指定路径，如果不指定路径的话好像会从huggingface那边下载model，指定路径的话就需要文件夹下有这三个文件；</p><h3 id="2-2-model"><a href="#2-2-model" class="headerlink" title="2.2 model"></a>2.2 model</h3><h4 id="2-2-1-embeddings、encoder、pooler（※重点）"><a href="#2-2-1-embeddings、encoder、pooler（※重点）" class="headerlink" title="2.2.1 embeddings、encoder、pooler（※重点）"></a>2.2.1 embeddings、encoder、pooler（※重点）</h4><p>通过<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code>加载模型后，首先可以在这里调试model这个对象包含的内容，model是BertModel的实例化，模型结构主要由<code>model.embeddings </code>（BERTEmbeddings类对象），<code>model.encoder</code>（BertEncoder类对象），<code>model.pooler</code>（BertPooler对象）组成。点开后可以看到各个地方的模型结构与层数，之后会随着模型调试查看数据流向和数据维度的变化。</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711135726421.png" alt="image-20220711135726421"></p><h5 id="·-class-BertEmbeddings层结构"><a href="#·-class-BertEmbeddings层结构" class="headerlink" title="· class BertEmbeddings层结构"></a>· class BertEmbeddings层结构</h5><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;modeling_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertEmbeddings</span>(nn.Module):<br>    <span class="hljs-string">&quot;&quot;&quot;Construct the embeddings from word, position and token_type embeddings.&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h6 id="1-init"><a href="#1-init" class="headerlink" title="1) init"></a>1) <strong>init</strong></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=config.pad_token_id)<br>    self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)<br>    self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)<br><br>    <span class="hljs-comment"># self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load</span><br>    <span class="hljs-comment"># any TensorFlow checkpoint file</span><br>    self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>    self.dropout = nn.Dropout(config.hidden_dropout_prob)<br>    <span class="hljs-comment"># position_ids (1, len position emb) is contiguous in memory and exported when serialized</span><br>    self.position_embedding_type = <span class="hljs-built_in">getattr</span>(config, <span class="hljs-string">&quot;position_embedding_type&quot;</span>, <span class="hljs-string">&quot;absolute&quot;</span>)<br>    self.register_buffer(<span class="hljs-string">&quot;position_ids&quot;</span>, torch.arange(config.max_position_embeddings).expand((<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">if</span> version.parse(torch.__version__) &gt; version.parse(<span class="hljs-string">&quot;1.6.0&quot;</span>):<br>        self.register_buffer(<br>            <span class="hljs-string">&quot;token_type_ids&quot;</span>,<br>            torch.zeros(self.position_ids.size(), dtype=torch.long),<br>            persistent=<span class="hljs-literal">False</span>,<br>        )<br></code></pre></td></tr></table></figure><p>简单对init进行解释，这里有三个<code>nn.Embedding</code>层：</p><ul><li>self.word_embeddings：维度从vocab_size（30522）到hidden_size（768）转化，<font color="red">TODO：padding_idx的参数是做什么用的？</font> </li><li>self.position_embeddings：维度从max_position_embeddings（512）到hidden_size（768）转化；</li><li>self.token_type_embeddings：维度从config.type_vocab_size（2，这里的2代表的是有两种类别的，第一个[SEP]前都是0，第二个[SEP]前都是1，这样交叉的）到到hidden_size（768），或者是用来表示padding地方的差异；</li></ul><p>这里的<code>self.LayerNorm</code>和<code>self.dropout</code>是剩下两个和forward比较相关的层，初始化都比较正常</p><p><font color="red">和同学讨论下这个nn.Embedding层的用处，之前对这个层一直不是太理解，大概目前的理解是传入的一个比如input_ids是[1, 14]这个shape的，首先其被转化成一个one-hot的表示也就是[1, 14, 30522(这个维度类似一个词典大小)]，然后过一个[30522, 768]的，两个乘在一起就有一种对应位把元素取出来的感觉，这样就得到了最终的embedding表示[1, 14, 768]</font> </p><p><font color="red">词表大小30522是针对input_ids embedding的，那么针对positional embedding就是max_seq_len，针对token type的就是2（只有0和1代表两类交替的）</font></p><h6 id="2-forward"><a href="#2-forward" class="headerlink" title="2) forward"></a>2) forward</h6><p>forward传入的参数中</p><ul><li>input_ids **[1, seq_len]**：tensor([[ 101, 2762, 3786, 5619, 1016, 1011, 1014, 1998, 2180, 1996, 2088, 2452, 2345,  102]])，这是tokenizer.convert_tokens_to_ids()的结果应该，那边BERT好像还对应了个wordpiecetoken，101是[CLS]，102是[PAD]</li><li>token_type_ids **[1, seq_len]**：tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])，传入的没有[SEP]，只有一类token</li><li>position_ids：暂时为None</li><li>inputs_embeds：暂时为None</li></ul><p>step1：根据input_ids提取得到的seq_len长度，初始化position_ids **[1, seq_len]**：tensor([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13]])</p><p>step2：获取input_embeds和token_type_embeddings，通过上面的传入参数以及nn.Embedding层，并把这两个加在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> inputs_embeds <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    inputs_embeds = self.word_embeddings(input_ids)<br>token_type_embeddings = self.token_type_embeddings(token_type_ids)<br><br>embeddings = inputs_embeds + token_type_embeddings<br></code></pre></td></tr></table></figure><p>embeddings.shape <strong>[1, seq_len, hidden_dim]</strong></p><p>step3：如果self.position_embedding_type是”absolute”绝对的话，就传入后加上position_embeddings，此时embeddings.shape **[1, seq_len, hidden_dim]**没有变化；absolute就是绝对位置编码，理解是[0, 1, 2, 3…]这样的绝对位置；<font color="red">还有一种position_embedding是相对位置编码的embedding，部分代码整合在了BertSelfAttention这个类中，博客参考：<a href="https://blog.csdn.net/chenf1995/article/details/122971023">https://blog.csdn.net/chenf1995/article/details/122971023</a></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;absolute&quot;</span>:<br>    position_embeddings = self.position_embeddings(position_ids)<br>    embeddings += position_embeddings<br></code></pre></td></tr></table></figure><p>step4：过LayerNorm和dropout，维度不会改变，BertEmbeddings这个类最终输出了一个embeddings <strong>[1, seq_len, hidden_dim]<strong>的信息，代表将要输入进入encoder结构部分的embedding</strong>input_embedding+token_type_embedding+position_embedding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">embeddings = self.LayerNorm(embeddings)<br>embeddings = self.dropout(embeddings)<br><span class="hljs-keyword">return</span> embeddings<br></code></pre></td></tr></table></figure><h6 id="3-综合别人博客做一个总结"><a href="#3-综合别人博客做一个总结" class="headerlink" title="3) 综合别人博客做一个总结"></a>3) 综合别人博客做一个总结</h6><p>word_embeddings是上文中subword tokenization对应的词嵌入；</p><p>token_type_embeddings是用于表示当前词所在的句子，辅助区别句子与padding，句子对通过[SEP]分隔之间的差异；</p><p>position_embeddings是句子中每个词的位置嵌入，用于区别词的顺序，博客说这个地方是训练出来的（从代码看确实如此），而不是计算得到固定嵌入，可能固定嵌入不利于拓展；</p><p>三个embedding层不带权重直接加在一起，过LayerNorm+dropout后产生输出，大小为**[batch_size, seq_len, hidden_size]**</p><h6 id="4-补充：positional-embedding的不同方式"><a href="#4-补充：positional-embedding的不同方式" class="headerlink" title="4) 补充：positional embedding的不同方式"></a>4) 补充：positional embedding的不同方式</h6><p><a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>背景：</p><p>词与词之间的顺序关系往往影响整个句子的含义，因此在对文本数据进行建模的时候需要考虑词与词之间的顺序关系；</p><p>建模文本中的顺序关系必须要使用positional encoding吗？-&gt; 不一定，只有使用位置不敏感的模型对文本数据进行建模的时候，才需要额外使用positional encoding；如果模型的输出会随着输入文本数据顺序的变化而变化，那么这个模型就是关于位置敏感的，反之则是位置不敏感的；</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713092751251.png" alt="image-20220713092751251"></p><p>在常用的文本模型中，RNN类的就是关于位置敏感的，使用RNN类模型对文本数据建模的时候，模型结构天然考虑了文本中词与词之间的顺序关系。<strong>而以attention机制为核心的transformer则是位置不敏感的，使用这一类位置不敏感的模型的时候需要额外加入positional encoding引入文本中词与词的顺序关系；</strong></p><p>具体操作：</p><p>对于transformer模型的positional encoding有两种主流方式：即绝对位置编码和相对位置编码</p><p>其中<strong>absolute positional embedding（绝对位置编码）</strong>是相对简单理解的，直接对不同位置随机初始化一个positional embedding，加到word embedding和token_type embedding上输入模型作为参数进行训练</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711110109758.png" alt="image-20220711110109758"></p><p>另一种是<strong>relative positional embedding（相对位置编码）</strong>，首先motivation是不同位置的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1 2和3 4距离都只差1，这些关于位置的<strong>相对含义</strong>模型通过绝对位置编码是否能够学习？绝对位置编码没有约束位置之间这些隐含关系，只能期待他隐式的学习到，所以是否有更合理的方法能够显式的让模型理解位置的相对关系？</p><p><font color="blue">11111</font> </p><p>详细看一下huggingface transformer代码中的这个部分，参数有”absolute”、”relative_key”和”relative_key_query”三种，这些参数在<code>class BertSelfAttention(nn.Module)</code>这个类中，而不是在最开始的<code>BertEmbedding</code>那块的</p><ul><li><code>absolute</code>：默认值，这部分就不用处理（对这个地方的处理在Embedding层）</li><li><code>relative_key</code>：对key_layer作处理，将其与这里的<code>positional_embedding</code>和key矩阵相乘作为key相关的位置编码；</li><li><code>relative_key_query</code>：对key和value都进行相乘以作为位置编码。</li></ul><p><font color="red">用下面代码简单加一下注释</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        ...<br>        <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>          self.max_position_embeddings = config.max_position_embeddings  <span class="hljs-comment"># 512</span><br>          self.distance_embedding = nn.Embedding(<span class="hljs-number">2</span> * config.max_position_embeddings - <span class="hljs-number">1</span>, self.attention_head_size)  <span class="hljs-comment"># [512*2-1, 64 (即hidden//head_num)]</span><br>        ...<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>    seq_length = hidden_states.size()[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 14</span><br>    position_ids_l = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [14, 1]shape的tensor</span><br>    position_ids_r = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment"># [1, 14]</span><br>    distance = position_ids_l - position_ids_r  <span class="hljs-comment"># [seqlen, seq_len]</span><br>    positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - <span class="hljs-number">1</span>)  <span class="hljs-comment"># [seqlen, seqlen, hidden_size]</span><br>    positional_embedding = positional_embedding.to(dtype=query_layer.dtype)  <span class="hljs-comment"># fp16 compatibility</span><br><br>    <br>    <span class="hljs-comment"># query_layer : batchsize, seqlen, hidden -&gt; batchsize, head_num, seqlen, hidden//head_num【multi-head】</span><br><br>    <span class="hljs-comment"># bhld,lrd -&gt; bhld不变，lrd去掉一个维度变成rd -&gt; bhld不变, rd转置变成dr -&gt; 乘 -&gt; bhlr</span><br>    <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span>:<br>        relative_position_scores = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>        attention_scores = attention_scores + relative_position_scores<br>    <span class="hljs-keyword">elif</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>        relative_position_scores_query = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>        relative_position_scores_key = torch.einsum(<span class="hljs-string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)<br>        attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key<br></code></pre></td></tr></table></figure><ul><li><code>seq_length</code>：这句话的长度，比如14</li><li><code>position_ids_l</code>：初始化是一个例如[14, 1]的向量，存储的类似于[[0], [1], [2] …]这样的</li><li><code>position_ids_r</code>：初始化是一个例如[1, 14]的向量，存储的类似于[[0, 1, 2, 3, 4]]这样的</li><li><code>distance</code>：初始化直接用<code>position_ids_l</code>-<code>position_ids_r</code>，这里直接广播减法，是一个[14, 14]维度的</li></ul><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713165208863.png" alt="image-20220713165208863"></p><p>因为这个地方是在attention这块来做的embedding，attention那边的scoreshape是[batch, head, seq_len, seq_len]的，代表query每个位置处对于key的注意力，那么可以在这里对query和key都搞positional embedding</p><p>通过上面几个做操作搞了一个<code>positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1)</code>，这个有点不为什么每个要把512-1给加上，这样处理完后distance变成了如下所示的tensor</p><p><font color="red">两个距离相隔最远是512，那么这样处理后能保证所有数字都是&gt;&#x3D;0的，因为离的最远的也就是512了，然后最远的将会到达1023那个感觉</font> </p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713170145685.png" alt="image-20220713170145685"></p><p>positional_embedding由distance_embedding层后得到，distance_embedding层的传入参数是[512<em>2-1, 64 (即hidden&#x2F;&#x2F;head_num)]也能理解了，因为词表大小是差不多0-1023的；；positional_embedding的shape是</em>*[seq_len, seq_len, hidden]**的，如果是一个batch的话，那么应该是这个batch里面最大的那个seq_len？</p><p>下面代码把query_layer[1, 12, 14, 64]和positional_embedding[14, 14, 64]作为这个<code>torch.einsum</code>的输入，这个地方参考文档<a href="https://zhuanlan.zhihu.com/p/361209187%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%8A%E5%BD%A2%E7%8A%B6bhld,lrd%E7%9A%84%E4%B8%A4%E4%B8%AAtensor%E5%8A%A0%E6%88%90%E4%B8%80%E4%B8%AAbhlr%E7%9A%84%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E7%94%A8%E4%B8%A4%E4%B8%AAl%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%89%8D%E9%9D%A2%E4%B8%A4%E4%B8%AAseq_len%E6%9C%AC%E8%B4%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Equery%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Ekey%EF%BC%8C%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E9%95%BF%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%AD%89%E9%95%BF%E7%9A%84%E4%BA%86%EF%BC%9B">https://zhuanlan.zhihu.com/p/361209187，就是把形状bhld,lrd的两个tensor加成一个bhlr的，这里为什么没用两个l可能是因为前面两个seq_len本质上一个来自于query，一个来自于key，而实际上是不需要等长的，只是一般操作默认为等长的了；</a></p><p>重点：这里以第一个作为示例，l和d在前后的箭头中都出现了，那就是在这两个维度上操作,query_layer[1, 12, <strong>14</strong>, <strong>64</strong>]和positional_embedding[<strong>14</strong>, 14, <strong>64</strong>]，转置乘，出来一个relative_position_scores_query**[1, 12, 14, 14]**的，聚合来自position的信息</p><p><font color="red">TODO：还弄得没那么明白，大概明白个意思，之后还要详细看看</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">relative_position_scores_query = torch.einsum(<span class="hljs-string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)<br>relative_position_scores_key = torch.einsum(<span class="hljs-string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)<br></code></pre></td></tr></table></figure><p>最后，执行下述代码，注意这个<strong>相对位置编码</strong>过程可以只对query做，也可以对query和key同时做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key<br></code></pre></td></tr></table></figure><p><font color="red">TODO：</font> <a href="https://zhuanlan.zhihu.com/p/121126531%E8%BF%99%E9%87%8C%E8%BF%98%E4%BB%8B%E7%BB%8D%E5%88%B0%E4%BA%86%EF%BC%9ASinusoidal">https://zhuanlan.zhihu.com/p/121126531这里还介绍到了：Sinusoidal</a> Position Encoding和Complex embedding</p><h5 id="·class-BertSelfAttention：被BertAttention调用（※重点）"><a href="#·class-BertSelfAttention：被BertAttention调用（※重点）" class="headerlink" title="·class BertSelfAttention：被BertAttention调用（※重点）"></a>·class BertSelfAttention：被BertAttention调用（※重点）</h5><h6 id="1-init-1"><a href="#1-init-1" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-keyword">if</span> config.hidden_size % config.num_attention_heads != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(config, <span class="hljs-string">&quot;embedding_size&quot;</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">f&quot;The hidden size (<span class="hljs-subst">&#123;config.hidden_size&#125;</span>) is not a multiple of the number of attention &quot;</span><br>                <span class="hljs-string">f&quot;heads (<span class="hljs-subst">&#123;config.num_attention_heads&#125;</span>)&quot;</span><br>            )<br><br>        self.num_attention_heads = config.num_attention_heads<br>        self.attention_head_size = <span class="hljs-built_in">int</span>(config.hidden_size / config.num_attention_heads)<br>        self.all_head_size = self.num_attention_heads * self.attention_head_size<br><br>        self.query = nn.Linear(config.hidden_size, self.all_head_size)<br>        self.key = nn.Linear(config.hidden_size, self.all_head_size)<br>        self.value = nn.Linear(config.hidden_size, self.all_head_size)<br><br>        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)<br>        self.position_embedding_type = position_embedding_type <span class="hljs-keyword">or</span> <span class="hljs-built_in">getattr</span>(<br>            config, <span class="hljs-string">&quot;position_embedding_type&quot;</span>, <span class="hljs-string">&quot;absolute&quot;</span><br>        )<br>        <span class="hljs-keyword">if</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key&quot;</span> <span class="hljs-keyword">or</span> self.position_embedding_type == <span class="hljs-string">&quot;relative_key_query&quot;</span>:<br>            self.max_position_embeddings = config.max_position_embeddings<br>            self.distance_embedding = nn.Embedding(<span class="hljs-number">2</span> * config.max_position_embeddings - <span class="hljs-number">1</span>, self.attention_head_size)<br><br>        self.is_decoder = config.is_decoder<br></code></pre></td></tr></table></figure><p>这个地方是整个BERT架构中非常核心的区域</p><ul><li>self.num_attention_heads &#x3D; config.num_attention_heads：几头注意力机制，在config文件里这里设置为12（一般BERT也是12）</li><li>self.attention_head_size &#x3D; int(config.hidden_size &#x2F; config.num_attention_heads)：config.hidden_size是768，所以每个头的hidden_size将会是768&#x2F;12&#x3D;64；</li><li>self.all_head_size是self.num_attention_heads（12）再乘回self.attention_head_size（64），猜测这样的原因是因为整除造成的可能回来后就不是768了；<font color="red">从其他博客也看到和剪枝有关</font> </li><li>self.query、self.key、self.value三个权重矩阵，都是一个hidden_size（768）到内部这个all_head_size（可能是768，也可能有损失）的转化；</li><li>self.dropout &#x3D; nn.Dropout(config.attention_probs_dropout_prob)：简单的dropout层；</li><li>self.position_embedding_type：这与相对&#x2F;绝对位置编码有关，如果是绝对位置编码那么在BertEmbedding层里面已经给结合进去了，<font color="blue">如果是相对位置编码要在这里实现，不过这个地方暂时先跳过了</font>；</li><li>self.is_decoder &#x3D; config.is_decoder：标识是否decoder，BERT只是一个encoder就不涉及到这个部分了；</li></ul><h6 id="2-forward-1"><a href="#2-forward-1" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">transpose_for_scores</span>(<span class="hljs-params">self, x</span>):<br>    new_x_shape = x.size()[:-<span class="hljs-number">1</span>] + (self.num_attention_heads, self.attention_head_size)<br>    x = x.view(new_x_shape)<br>    <span class="hljs-keyword">return</span> x.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>首先是这个函数，这个函数是拆多头用的，输入的x是[batch, seq_len, hidden]的，先指定new_shape是[batch, seq_len, num_attention_heads, attention_head_size]（一般可以认为是[batch, seq_len, 12, 64]），然后.view转化，然后再通过permute改变顺序为**[batch, attention_head_size, seq_len, num_attention_heads]**，这样是因为attention_head_size可以归为”batch“那边的维度了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    mixed_query_layer = self.query(hidden_states)<br><br><span class="hljs-comment"># 忽略了cross-attention部分</span><br>    <span class="hljs-comment"># hidden_states [batch, seqlen, hidden]</span><br>    key_layer = self.transpose_for_scores(self.key(hidden_states))  <span class="hljs-comment"># [batch, num_head, seqlen_key, hidden//num_head]</span><br>    value_layer = self.transpose_for_scores(self.value(hidden_states))<br>    query_layer = self.transpose_for_scores(mixed_query_layer) <span class="hljs-comment"># [batch, num_head, seqlen_query, hidden//num_head]</span><br><br>    <span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>    attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))  <span class="hljs-comment"># </span><br><br>    <span class="hljs-comment"># 忽略了相对位置编码的处理</span><br><br>    attention_scores = attention_scores / math.sqrt(self.attention_head_size)<br>    <span class="hljs-keyword">if</span> attention_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span><br>        attention_scores = attention_scores + attention_mask<br><br>    <span class="hljs-comment"># Normalize the attention scores to probabilities.</span><br>    attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment"># This is actually dropping out entire tokens to attend to, which might</span><br>    <span class="hljs-comment"># seem a bit unusual, but is taken from the original Transformer paper.</span><br>    attention_probs = self.dropout(attention_probs)<br><br>    <span class="hljs-comment"># Mask heads if we want to</span><br>    <span class="hljs-keyword">if</span> head_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        attention_probs = attention_probs * head_mask<br><br>    context_layer = torch.matmul(attention_probs, value_layer)  <span class="hljs-comment"># [batch, num_head, seqlen, hidden//num_head]</span><br><br>    context_layer = context_layer.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).contiguous()<br>    new_context_layer_shape = context_layer.size()[:-<span class="hljs-number">2</span>] + (self.all_head_size,)<br>    context_layer = context_layer.view(new_context_layer_shape)<br><br>    outputs = (context_layer, attention_probs) <span class="hljs-keyword">if</span> output_attentions <span class="hljs-keyword">else</span> (context_layer,)<br><br>    <span class="hljs-comment"># 忽略了is_decoder部分</span><br>    <br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>上面贴出来的这段代码省略了针对<code>is_cross_attention</code>（即encoder-decoder attention那个部分的一些处理），此外还忽略了<code>if self.is_decoder:</code>部分的处理，并且忽略了<code>if self.position_embedding_type == &quot;relative_key&quot; </code>相对位置编码部分的处理；</p><p>step1：首先是这个部分，hidden_states**[batch, seq_len, hidden_size]<strong>这个tensor过了self.query、self.value、self.key三个linear矩阵，由于这三个linear一般不改变hidden_size，这样得到的是三个</strong>[batch, seq_len, hidden_size]<strong>形状的tensor，通过上面提到的transpose_for_scores进行reshape，得到三个</strong>[batch, head_num, seq_len, attention_head_size]**（一般可以是[1, 12, seq_len, 768]）这样的tensor，并且被命名为key_layer、value_layer、query_layer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mixed_query_layer = self.query(hidden_states)<br>key_layer = self.transpose_for_scores(self.key(hidden_states))<br>value_layer = self.transpose_for_scores(self.value(hidden_states))<br>query_layer = self.transpose_for_scores(mixed_query_layer)<br></code></pre></td></tr></table></figure><p>step2：这里就是Q·K^T那个部分了，转置就是在后两个维度上转置，输出的attention_scores是**[batch, head_num, seq_len, seq_len]**形状的tensor，代表query中每个位置处对key全局所有的注意力（后面要过softmax）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>step3：依照博客简单理解一下不同的positional_embedding_type，<font color="blue">这个部分暂时忽略了</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">absolute：默认值，这部分就不用处理；<br>relative_key：对key_layer作处理，将其与这里的positional_embedding和key矩阵相乘作为key相关的位置编码；<br>relative_key_query：对key和value都进行相乘以作为位置编码。<br></code></pre></td></tr></table></figure><p>step4：计算attention_scores，attention_probs；attention_scores在计算query和key的点乘后除以根号下d_k，<strong>注意这里的self.attention_head_size是64那个地方的，也就是分成12个头后每个头的hidden_size</strong>，如果带有attention_mask的话<font color="red">（注意，一般来说肯定是会有atttention_mask的，应该会在调用这个BertAttention的时候传给他，因为一个batch中大家不等长，肯定要通过mask padding到512这种感觉的）</font> ；；在计算attention_scores时候用的是加法，因为softmax那块要一个很大的负数，比如-1e9这样的，然后过softmax，注意softmax的维度是-1代表query中每个token对所有key位置处的token的attention；；；最后过一个self.dropout，<font color="red">TODO：暂时有点没理解为什么在这里过dropout，而不是乘了之后</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span><br>attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>))<br><br><span class="hljs-comment"># 忽略了相对位置编码的处理</span><br><br>attention_scores = attention_scores / math.sqrt(self.attention_head_size)<br><span class="hljs-keyword">if</span> attention_mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span><br>    attention_scores = attention_scores + attention_mask<br><br><span class="hljs-comment"># Normalize the attention scores to probabilities.</span><br>attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># This is actually dropping out entire tokens to attend to, which might</span><br><span class="hljs-comment"># seem a bit unusual, but is taken from the original Transformer paper.</span><br>attention_probs = self.dropout(attention_probs)<br></code></pre></td></tr></table></figure><p>step5：这里主要就是输出整合了，再reshape回去，变成了**[batch, seq_len, hidden_size]**的这个形状，另外看到config中output_attentions那个参数的作用，要不要把每层的这个attention返回回去，至此<code>class BertSelfAttention(nn.Module)</code>这个地方的forward结束了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">context_layer = torch.matmul(attention_probs, value_layer)<br><br>context_layer = context_layer.permute(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>).contiguous()<br>new_context_layer_shape = context_layer.size()[:-<span class="hljs-number">2</span>] + (self.all_head_size,)<br>context_layer = context_layer.view(new_context_layer_shape)<br><br>outputs = (context_layer, attention_probs) <span class="hljs-keyword">if</span> output_attentions <span class="hljs-keyword">else</span> (context_layer,)<br><span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><h5 id="·class-BertSelfOutput-被BertAttention调用"><a href="#·class-BertSelfOutput-被BertAttention调用" class="headerlink" title="·class BertSelfOutput: 被BertAttention调用"></a>·class BertSelfOutput: 被BertAttention调用</h5><h6 id="1-init-amp-forward"><a href="#1-init-amp-forward" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertSelfOutput</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.hidden_size)<br>        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>        self.dropout = nn.Dropout(config.hidden_dropout_prob)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.dropout(hidden_states)<br>        hidden_states = self.LayerNorm(hidden_states + input_tensor)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>这个地方代码结构是相对比较简单的，<font color="red"><strong>这里也展现出了BERT中存在的一层add&amp;norm操作，这里应该还只是attention这个部分的内容</strong></font> </p><h5 id="·class-BertAttention：被BertLayer调用"><a href="#·class-BertAttention：被BertLayer调用" class="headerlink" title="·class BertAttention：被BertLayer调用"></a>·class BertAttention：被BertLayer调用</h5><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712110214629.png" alt="image-20220712110214629" style="zoom:50%;"><h6 id="1-init-2"><a href="#1-init-2" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config, position_embedding_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.self = BertSelfAttention(config, position_embedding_type=position_embedding_type)<br>        self.output = BertSelfOutput(config)<br>        self.pruned_heads = <span class="hljs-built_in">set</span>()<br></code></pre></td></tr></table></figure><p>attention的实现还是不在这里，self.self这个是multi-head self attention机制的实现，self.output的操作是第一个这里完成的部分；</p><p>该层中使用到了<code>self.pruned_heads = set()</code>这样一种节约显存的技术，暂时没有了解太深；</p><h6 id="2-forward-2"><a href="#2-forward-2" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    self_outputs = self.self(<br>        hidden_states,<br>        attention_mask,<br>        head_mask,<br>        encoder_hidden_states,<br>        encoder_attention_mask,<br>        past_key_value,<br>        output_attentions,<br>    )<br>    attention_output = self.output(self_outputs[<span class="hljs-number">0</span>], hidden_states)<br>    outputs = (attention_output,) + self_outputs[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># add attentions if we output them</span><br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>有了上面的<code>BertSelfAttention</code>和<code>BertSelfOutput</code>后，这个组件就比较好理解了</p><h5 id="·class-BertIntermediate-被BertLayer调用"><a href="#·class-BertIntermediate-被BertLayer调用" class="headerlink" title="·class BertIntermediate: 被BertLayer调用"></a>·class BertIntermediate: 被BertLayer调用</h5><p>在BertAttention这个模块后，还有一个FFNN的操作，这里包含有激活函数；<font color="red">TODO：为什么有些地方需要激活函数，有些地方就不用？像CV那边的话，经常几个层过后就来一个激活，但是这里比如BertAttention里面就没有激活</font> </p><h6 id="1-init-amp-forward-1"><a href="#1-init-amp-forward-1" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertIntermediate</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config.hidden_act, <span class="hljs-built_in">str</span>):<br>            self.intermediate_act_fn = ACT2FN[config.hidden_act]<br>        <span class="hljs-keyword">else</span>:<br>            self.intermediate_act_fn = config.hidden_act<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.intermediate_act_fn(hidden_states)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>这个里面调用了<code>config.hidden_act</code>，在config文件那边的话这个地方是<code>&quot;gelu&quot;</code>，对应的也就是gelu激活函数，整体来看这个层结构还是很简单的，<font color="red">其中注意dense这个层把768转化为一个config.intermediate_size3072了</font> </p><h5 id="·class-BertOutput-被BertLayer调用"><a href="#·class-BertOutput-被BertLayer调用" class="headerlink" title="·class BertOutput: 被BertLayer调用"></a>·class BertOutput: 被BertLayer调用</h5><p><font color="red">注意这里不是BertSelfOutput，刚才那个是中间层的，这个是一个BLOCK的</font> </p><h6 id="1-init-amp-forward-2"><a href="#1-init-amp-forward-2" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertOutput</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)<br>        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)<br>        self.dropout = nn.Dropout(config.hidden_dropout_prob)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:<br>        hidden_states = self.dense(hidden_states)<br>        hidden_states = self.dropout(hidden_states)<br>        hidden_states = self.LayerNorm(hidden_states + input_tensor)<br>        <span class="hljs-keyword">return</span> hidden_states<br></code></pre></td></tr></table></figure><p>主要负责的也是一些整合，还有residual的部分，<font color="red">其中注意dense层把intermidiate_size又转化会config.hidden_size了</font> </p><h5 id="·-class-BertLayer-nn-Module-：被BertEncoder调用"><a href="#·-class-BertLayer-nn-Module-：被BertEncoder调用" class="headerlink" title="· class BertLayer(nn.Module)：被BertEncoder调用"></a>· class BertLayer(nn.Module)：被BertEncoder调用</h5><h6 id="1-init-3"><a href="#1-init-3" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.chunk_size_feed_forward = config.chunk_size_feed_forward<br>    self.seq_len_dim = <span class="hljs-number">1</span><br>    self.attention = BertAttention(config)<br>    self.is_decoder = config.is_decoder<br>    self.add_cross_attention = config.add_cross_attention<br>    <span class="hljs-keyword">if</span> self.add_cross_attention:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_decoder:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self&#125;</span> should be used as a decoder model if cross attention is added&quot;</span>)<br>        self.crossattention = BertAttention(config, position_embedding_type=<span class="hljs-string">&quot;absolute&quot;</span>)<br>    self.intermediate = BertIntermediate(config)<br>    self.output = BertOutput(config)<br></code></pre></td></tr></table></figure><p>可以简单理解为，依次调用了BertAttention、BertIntermediate、BertOutput完成了一个BLOCK的操作</p><h6 id="2-forward-3"><a href="#2-forward-3" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params"></span><br><span class="hljs-params">    self,</span><br><span class="hljs-params">    hidden_states: torch.Tensor,</span><br><span class="hljs-params">    attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    head_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_hidden_states: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    encoder_attention_mask: <span class="hljs-type">Optional</span>[torch.FloatTensor] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    past_key_value: <span class="hljs-type">Optional</span>[<span class="hljs-type">Tuple</span>[<span class="hljs-type">Tuple</span>[torch.FloatTensor]]] = <span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    output_attentions: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">bool</span>] = <span class="hljs-literal">False</span>,</span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Tuple</span>[torch.Tensor]:<br>    <span class="hljs-comment"># decoder uni-directional self-attention cached key/values tuple is at positions 1,2</span><br>    self_attn_past_key_value = past_key_value[:<span class="hljs-number">2</span>] <span class="hljs-keyword">if</span> past_key_value <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br>    self_attention_outputs = self.attention(<br>        hidden_states,<br>        attention_mask,<br>        head_mask,<br>        output_attentions=output_attentions,<br>        past_key_value=self_attn_past_key_value,<br>    )<br>    <span class="hljs-comment"># 忽略一些is_decoder的操作</span><br>    <br>    attention_output = self_attention_outputs[<span class="hljs-number">0</span>]<br><br>    outputs = self_attention_outputs[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># add self attentions if we output attention weights</span><br><br>    layer_output = apply_chunking_to_forward(<br>        self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output<br>    )<br>    outputs = (layer_output,) + outputs<br><br>    <span class="hljs-comment"># if decoder, return the attn key/values as the last output</span><br>    <span class="hljs-keyword">if</span> self.is_decoder:<br>        outputs = outputs + (present_key_value,)<br><br>    <span class="hljs-keyword">return</span> outputs<br></code></pre></td></tr></table></figure><p>组装起来</p><h5 id="·-class-BertEncoder-nn-Module-层结构"><a href="#·-class-BertEncoder-nn-Module-层结构" class="headerlink" title="· class BertEncoder(nn.Module)层结构"></a>· class BertEncoder(nn.Module)层结构</h5><h6 id="1-init-4"><a href="#1-init-4" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>    <span class="hljs-built_in">super</span>().__init__()<br>    self.config = config<br>    self.layer = nn.ModuleList([BertLayer(config) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(config.num_hidden_layers)])<br>    self.gradient_checkpointing = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在这里通过<code>config.num_hidden_layers</code>指定了这个<code>BertLayer</code>结构的层数，进一步详细查看<code>BertLayer</code>层的代码，应该对应的就是Transformer架构中如图所示的N×这个部分</p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712093703201.png" alt="image-20220712093703201" style="zoom:50%;"><h6 id="2-forward-4"><a href="#2-forward-4" class="headerlink" title="2) forward"></a>2) forward</h6><p>主要是把N个Layer串接起来forward，返回值封装了一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_outputs.py</span><br><span class="hljs-meta">@dataclass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseModelOutputWithPastAndCrossAttentions</span>(<span class="hljs-title class_ inherited__">ModelOutput</span>):<br></code></pre></td></tr></table></figure><h5 id="·-class-BertPooler："><a href="#·-class-BertPooler：" class="headerlink" title="· class BertPooler："></a>· class BertPooler：</h5><p>这个主要是针对[CLS]token又过了一个pooler</p><p>禁用的话：bertmodel初始化有一个配置add_pooling_layer默认为True，改成false就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertPooler</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.dense = nn.Linear(config.hidden_size, config.hidden_size)<br>        self.activation = nn.Tanh()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:<br>        <span class="hljs-comment"># We &quot;pool&quot; the model by simply taking the hidden state corresponding</span><br>        <span class="hljs-comment"># to the first token.</span><br>        first_token_tensor = hidden_states[:, <span class="hljs-number">0</span>]<br>        pooled_output = self.dense(first_token_tensor)<br>        pooled_output = self.activation(pooled_output)<br>        <span class="hljs-keyword">return</span> pooled_output<br></code></pre></td></tr></table></figure><p><font color="red">TODO：这里还有些内容不是很明白，待和zkh讨论，比如说为什么叫pool，然后[CLS]这个token为什么要做这些的操作</font> </p><h5 id="·-class-BertModel-各层组合在一起整体的说明"><a href="#·-class-BertModel-各层组合在一起整体的说明" class="headerlink" title="· class BertModel(): 各层组合在一起整体的说明"></a>· class BertModel(): 各层组合在一起整体的说明</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertModel</span>(<span class="hljs-title class_ inherited__">BertPreTrainedModel</span>):<br>embedding_output = self.embeddings(<br>    input_ids=input_ids,<br>    position_ids=position_ids,<br>    token_type_ids=token_type_ids,<br>    inputs_embeds=inputs_embeds,<br>    past_key_values_length=past_key_values_length,<br>)<br>encoder_outputs = self.encoder(<br>    embedding_output,<br>    attention_mask=extended_attention_mask,<br>    head_mask=head_mask,<br>    encoder_hidden_states=encoder_hidden_states,<br>    encoder_attention_mask=encoder_extended_attention_mask,<br>    past_key_values=past_key_values,<br>    use_cache=use_cache,<br>    output_attentions=output_attentions,<br>    output_hidden_states=output_hidden_states,<br>    return_dict=return_dict,<br>)<br>sequence_output = encoder_outputs[<span class="hljs-number">0</span>]<br>pooled_output = self.pooler(sequence_output) <span class="hljs-keyword">if</span> self.pooler <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p>重点代码感觉在这个部分，其他部分在制作一些mask类的地方</p><h4 id="2-2-2-model-state-dict"><a href="#2-2-2-model-state-dict" class="headerlink" title="2.2.2 model.state_dict()"></a>2.2.2 model.state_dict()</h4><h5 id="·-加载预训练model"><a href="#·-加载预训练model" class="headerlink" title="· 加载预训练model"></a>· 加载预训练model</h5><p><font color="red">这里加载的时候应该是用到了config.json文件和pytorch_model.bin这两个文件，而vocab.txt应该是tokenizer.from_pretrained()时候用到的，这里详细看一下config.json文件和pytorch_model.bin这两个文件是怎么被用到的</font> </p><p>在加载模型后，可以通过打印<code>model.state_dict()</code>调试看到模型的各个参数，这里因为是from_pretrained的，所以已经加载了pytorch_model.bin文件中的内容，而且每次加载出来的结果也都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预训练版本</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br>config = BertConfig()<br>model = BertModel.from_pretrained(<span class="hljs-string">&quot;./bert_base_uncased&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711141124709.png" alt="image-20220711141124709"></p><p>加载model，也就是<code>BertModel.from_pretrained(pretrained_model_name_or_path)</code>对应的函数在如下路径，<strong>这个地方只要是bert的模型结构，不管是bert-base还是bert-large</strong>是都可以通过这里加载的，主要就是读取对应的<strong>config.json文件和pytorch_model.bin这两个文件</strong>：</p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;modeling_utils.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Optional</span>[<span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike]], *model_args, **kwargs</span>):<br></code></pre></td></tr></table></figure><h6 id="1-注解说明"><a href="#1-注解说明" class="headerlink" title="1) 注解说明"></a>1) 注解说明</h6><ul><li><p>从预训练的模型配置中实例化预训练的pytorch模型，该模型默认使用 <code>model.eval()</code>设置为评估模式；</p><p><font color="red">和同学讨论后补充：model.eval()一般涉及到dropout层与normalization层；；；在BERT和这种NLP领域下，因为BN不怎么用，所以LN实际上只是单个样本内部在seq_len这个维度上做norm，就不涉及到eval这块了，也就是说在NLP任务的eval这里可能只影响到dropout层；</font> </p><p><font color="red">再补充一些BN上的细节，BN在做训练的时候，均值和方差来自于这一组batch的计算，在inference的时候，使用<strong>全局</strong>的均值和方差，这个全局的均值和方差由之前的每个mini-batch记录而来。</font> </p><p><font color="red">设是[batch, seq_len, hidden]，那么BN会计算出来一个[1, seq_len, hidden]的均值；；；LN就会计算出来一个[batch, 1, hidden]的均值，然后怎么怎么处理</font> </p></li><li><p>输出的警告<code>Weights from XXX not initialized from pretrained model</code>表示XXX部分的权重没有出现，将使用模型其余部分进行训练，可以通过下游任务来微调这些权重：</p><p>如果把config文件的层数增加，比如从12层增加到14层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of BertModel were not initialized from the model checkpoint at .&#x2F;bert_base_uncased and are newly initialized: [‘bert.encoder.layer.13.attention.output.dense.weight’, ‘bert.encoder.layer.12.intermediate.dense.bias’, ‘bert.encoder.layer.13.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.dense.bias’, ‘bert.encoder.layer.13.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.weight’, ‘bert.encoder.layer.13.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.13.output.dense.bias’, ‘bert.encoder.layer.13.intermediate.dense.bias’, ‘bert.encoder.layer.13.output.LayerNorm.bias’, ‘bert.encoder.layer.13.output.dense.weight’, ‘bert.encoder.layer.12.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.bias’, ‘bert.encoder.layer.13.output.LayerNorm.weight’, ‘bert.encoder.layer.12.output.LayerNorm.weight’, ‘bert.encoder.layer.13.attention.self.query.bias’, ‘bert.encoder.layer.13.attention.self.query.weight’, ‘bert.encoder.layer.12.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.12.attention.output.dense.bias’, ‘bert.encoder.layer.12.attention.self.key.bias’, ‘bert.encoder.layer.12.output.dense.weight’, ‘bert.encoder.layer.12.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.13.intermediate.dense.weight’, ‘bert.encoder.layer.12.output.LayerNorm.bias’, ‘bert.encoder.layer.13.attention.self.key.bias’, ‘bert.encoder.layer.12.intermediate.dense.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.12.output.dense.bias’, ‘bert.encoder.layer.12.attention.output.dense.weight’]</p></blockquote></li><li><p>输出的警告<code>Weights from XXX not used in YYY</code>表示预训练文件中的层XXX不被YYY使用，因此那些权重将被丢弃；</p><p>如果把config文件的层数减少，比如从12层减小到10层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of the model checkpoint at .&#x2F;bert_base_uncased were not used when initializing BertModel: [‘bert.encoder.layer.10.intermediate.dense.weight’, ‘cls.predictions.decoder.weight’, ‘cls.predictions.transform.dense.bias’, ‘bert.encoder.layer.11.attention.self.value.bias’, ‘bert.encoder.layer.11.attention.output.dense.bias’, ‘bert.encoder.layer.10.output.dense.bias’, ‘bert.encoder.layer.10.attention.self.key.bias’, ‘bert.encoder.layer.10.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.value.weight’, ‘bert.encoder.layer.11.attention.self.key.bias’, ‘bert.encoder.layer.11.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.LayerNorm.bias’, ‘bert.encoder.layer.11.output.dense.bias’, ‘cls.predictions.transform.LayerNorm.weight’, ‘bert.encoder.layer.10.attention.output.dense.bias’, ‘cls.seq_relationship.bias’, ‘bert.encoder.layer.10.attention.self.value.bias’, ‘bert.encoder.layer.10.attention.output.dense.weight’, ‘cls.predictions.bias’, ‘bert.encoder.layer.10.attention.self.query.weight’, ‘bert.encoder.layer.11.attention.self.query.bias’, ‘cls.predictions.transform.LayerNorm.bias’, ‘bert.encoder.layer.11.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.query.bias’, ‘cls.predictions.transform.dense.weight’, ‘bert.encoder.layer.10.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.dense.weight’, ‘bert.encoder.layer.11.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.self.query.weight’, ‘cls.seq_relationship.weight’, ‘bert.encoder.layer.11.attention.self.value.weight’, ‘bert.encoder.layer.11.intermediate.dense.weight’, ‘bert.encoder.layer.10.output.LayerNorm.weight’, ‘bert.encoder.layer.11.attention.output.dense.weight’, ‘bert.encoder.layer.10.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.dense.weight’, ‘bert.encoder.layer.11.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.output.LayerNorm.weight’]</p></blockquote><p>这里额外输出了几个<code>cls.xxx</code>，就是说没有使用这些检查点的权重，从一些解释来看这些内容应该是要被下游分类器用到的，这些内容将被初始化重新训练。目前代码里只是直接简单应用了这个的输出，而没有针对下游任务fine-tune那些的过程；</p></li></ul><h6 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2) 参数说明"></a>2) 参数说明</h6><ul><li><p><code> pretrained_model_name_or_path (`str` or `os.PathLike`, *optional*)</code></p><p>1）可以是一个字符串代表<code>model id</code>，这个model id可以从huggingface.co上获取，比如直接使用<code>bert-base-uncased</code>，或者使用带有用户名称的这个model id例如<code>hfl/chinese-macbert-base</code>，这种使用方法下可能会从huggingface那边完成下载；</p><p>2）可以是一个包含有pytorch_model.bin和config.json文件的路径，例如<code>./bert_base_uncased/</code>，注意这个目录下的内容需要通过<code>PreTrainedModel.save_pretrained</code>方法来得到，否则保存出来的文件可能和transformer（huggingface这一套）不太配合；</p><p>3）其余用法不太常见或者一般不使用，好像可以从tensorflow和flax的checkpoint进行加载，如果设置为None的话就是通过其他办法已经把config和state_dict给加载进去了；</p></li><li><p><code>output_attentions</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code></p><p>这是一个可能相对再常用一点的参数，模型输出的output包含了一个<code>output[&#39;attentions&#39;]</code>的参数输出，在调试的时候发现他是一个长度为12的tuple（这里的长度12是bert的层数），tuple中每个位置上是 <code>shape[1,12, seq_len, seq_len]</code>（这里的长度12应该是multi-head的头数目），output_attentions应该是 <code>softmax((query · key)/sqrt(d_k))</code>的结果；注意<code>shape[1,12, seq_len, seq_len]</code>这个地方，softmax应该是在-1dim上做的，代表<strong>query中的每个位置处，对于每一个key的attention score</strong>，所以来做求和的话，应该能得到一个1的结果；</p><p><font color="red">在后面看forward代码的时候，还要回来看一下这个地方</font> </p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711172228802.png" alt="image-20220711172228802"></p></li><li><p><code>hidden_states</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;, output_hidden_states=True)</code></p><p>这是中间层（隐层）tensor的output输出，<font color="red">和output_attentions一样，这些内容既可以在from_pretrained中给带过去，<strong>也可以直接写在config.json</strong>文件里</font></p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711173534108.png" alt="image-20220711173534108"></p></li><li><p>上面可能是一些相对常用的参数，暂时理解来说在<code>.from_pretrained(&quot;./bert_base_uncased&quot;)</code>这个方法中带的其他一些参数可以和config加参数起到同样的效果，也就证明这个方法用到了config.json这个文件</p></li></ul><h6 id="3-内部流程说明（※重点）"><a href="#3-内部流程说明（※重点）" class="headerlink" title="3) 内部流程说明（※重点）"></a>3) 内部流程说明（※重点）</h6><p>内部这个地方还是写的比较详细的，像各种Exception也都实现的非常完整，大概理解一下其中的重点部分，主要目标就是加载config.json和pytorch_model.bin两个文件。</p><p><font color="red"><strong>config.json和pytorch_model.bin应该只有model这边用到，tokenizer那边只用到vocab.txt；；从model.from_pretrained接收参数是一个路径，而tokenizer.from_pretrained接收参数是一个vocab.txt文件的路径或者上级路径感觉也能证明这一点</strong></font> </p><ul><li><p>首先加载config.json</p><p>在下面这段代码中，config_path加载到了pretrained_model_name_or_path中的内容，也就是<code>&quot;./bert_base_uncased&quot;</code>，向下层<code>cls.config_class.from_pretrained</code>传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-comment"># Load config if we don&#x27;t provide a configuration</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(config, PretrainedConfig):<br>    config_path = config <span class="hljs-keyword">if</span> config <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> pretrained_model_name_or_path<br>    config, model_kwargs = cls.config_class.from_pretrained(<br>        config_path,<br>        cache_dir=cache_dir,<br>        return_unused_kwargs=<span class="hljs-literal">True</span>,<br>        force_download=force_download,<br>        resume_download=resume_download,<br>        proxies=proxies,<br>        local_files_only=local_files_only,<br>        use_auth_token=use_auth_token,<br>        revision=revision,<br>        _from_auto=from_auto_class,<br>        _from_pipeline=from_pipeline,<br>        **kwargs,<br>    )<br><span class="hljs-keyword">else</span>:<br>    model_kwargs = kwargs<br></code></pre></td></tr></table></figure><p>这里debug调试了一下<code>cls.config_class</code>：<code>&lt;class &#39;transformers.models.bert.configuration_bert.BertConfig&#39;&gt;</code>，于是在去看<code>BertConfig</code>这块的<code>.from_pretrained</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike], **kwargs</span>) -&gt; <span class="hljs-string">&quot;PretrainedConfig&quot;</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    一些注释，为了放在md里暂时删除了</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;model_type&quot;</span> <span class="hljs-keyword">in</span> config_dict <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&quot;model_type&quot;</span>) <span class="hljs-keyword">and</span> config_dict[<span class="hljs-string">&quot;model_type&quot;</span>] != cls.model_type:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;You are using a model of type <span class="hljs-subst">&#123;config_dict[<span class="hljs-string">&#x27;model_type&#x27;</span>]&#125;</span> to instantiate a model of type &quot;</span><br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;cls.model_type&#125;</span>. This is not supported for all configurations of models and can yield errors.&quot;</span><br>        )<br><br>    <span class="hljs-keyword">return</span> cls.from_dict(config_dict, **kwargs)<br></code></pre></td></tr></table></figure><p>在往下看，调用了<code>cls.get_config_dict</code>这个函数，最后一路往下找，直到找到这里，加载json文件，返回一个dict对象，在上面那段代码里最后return了一个<code>cls.from_dict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_dict_from_json_file</span>(<span class="hljs-params">cls, json_file: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike]</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(json_file, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> reader:<br>        text = reader.read()<br>    <span class="hljs-keyword">return</span> json.loads(text)<br></code></pre></td></tr></table></figure><p>看了一下<code>cls.from_dict</code>，应该是这里最终返回了一个BertConfig类的对象，<font color="red">这里字典前面加两个*号是将字典解开成为独立的元素作为形参</font> </p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711232228890.png" alt="image-20220711232228890" style="zoom:50%;"></li><li><p>其次加载pytorch_model.bin文件</p><p>通过在<code>config_path</code>目录下寻找文件，命中了<code>pytorch_model.bin</code>这个pytorch的checkpoint文件</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711224750910.png" alt="image-20220711224750910"></p><p>找到这个文件后，这里做了一个和cache判断的操作，这个和huggingface这里实现可以到远程下载有关，如果过了这个函数后还是本地的路径，那就说明是用的本地的文件实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-comment"># Load from URL or cache if already cached</span><br>resolved_archive_file = cached_path(<br>    archive_file,<br>    cache_dir=cache_dir,<br>    force_download=force_download,<br>    proxies=proxies,<br>    resume_download=resume_download,<br>    local_files_only=local_files_only,<br>    use_auth_token=use_auth_token,<br>    user_agent=user_agent,<br>)<br></code></pre></td></tr></table></figure><p>因为是pytorch形式的checkpoint，在这里<code>load_state_dict()</code></p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711233904281.png" alt="image-20220711233904281"></p><p>把<code>state_dict</code>传入这里，进一步进行处理，这里返回就会有<code>missing unexpect</code>这些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-keyword">elif</span> from_pt:<br>    <span class="hljs-keyword">if</span> low_cpu_mem_usage:<br>        cls._load_pretrained_model_low_mem(model, loaded_state_dict_keys, resolved_archive_file)<br>    <span class="hljs-keyword">else</span>:<br>        model, missing_keys, unexpected_keys, mismatched_keys, error_msgs = cls._load_pretrained_model(<br>            model,<br>            state_dict,<br>            resolved_archive_file,<br>            pretrained_model_name_or_path,<br>            ignore_mismatched_sizes=ignore_mismatched_sizes,<br>            sharded_metadata=sharded_metadata,<br>            _fast_init=_fast_init,<br>        )<br></code></pre></td></tr></table></figure><p>在如下函数中完成比对操作，<strong>这里一些的输出错误经过<code>state_dict</code>的比对而发现，也就对应了“2.2.2节中，加载预训练model中第一部分，作者在开头给出的注解说明”</strong>，至此这两个文件</p><p><font color="blue"></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span><br><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_load_pretrained_model</span>(<span class="hljs-params"></span><br><span class="hljs-params">    cls,</span><br><span class="hljs-params">    model,</span><br><span class="hljs-params">    state_dict,</span><br><span class="hljs-params">    resolved_archive_file,</span><br><span class="hljs-params">    pretrained_model_name_or_path,</span><br><span class="hljs-params">    ignore_mismatched_sizes=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">    sharded_metadata=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">    _fast_init=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params"></span>):<br>    <span class="hljs-comment"># Retrieve missing &amp; unexpected_keys</span><br>    model_state_dict = model.state_dict()<br>    expected_keys = <span class="hljs-built_in">list</span>(model_state_dict.keys())<br>    loaded_keys = <span class="hljs-built_in">list</span>(state_dict.keys()) <span class="hljs-keyword">if</span> state_dict <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">else</span> sharded_metadata[<span class="hljs-string">&quot;all_checkpoint_keys&quot;</span>]<br>    prefix = model.base_model_prefix<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fix_key</span>(<span class="hljs-params">key</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;beta&quot;</span> <span class="hljs-keyword">in</span> key:<br>            <span class="hljs-keyword">return</span> key.replace(<span class="hljs-string">&quot;beta&quot;</span>, <span class="hljs-string">&quot;bias&quot;</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;gamma&quot;</span> <span class="hljs-keyword">in</span> key:<br>            <span class="hljs-keyword">return</span> key.replace(<span class="hljs-string">&quot;gamma&quot;</span>, <span class="hljs-string">&quot;weight&quot;</span>)<br>        <span class="hljs-keyword">return</span> key<br><br>    loaded_keys = [_fix_key(key) <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> loaded_keys]<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prefix) &gt; <span class="hljs-number">0</span>:<br>        has_prefix_module = <span class="hljs-built_in">any</span>(s.startswith(prefix) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> loaded_keys)<br>        expects_prefix_module = <span class="hljs-built_in">any</span>(s.startswith(prefix) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys)<br>    <span class="hljs-keyword">else</span>:<br>        has_prefix_module = <span class="hljs-literal">False</span><br>        expects_prefix_module = <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># key re-naming operations are never done on the keys</span><br>    <span class="hljs-comment"># that are loaded, but always on the keys of the newly initialized model</span><br>    remove_prefix_from_model = <span class="hljs-keyword">not</span> has_prefix_module <span class="hljs-keyword">and</span> expects_prefix_module<br>    add_prefix_to_model = has_prefix_module <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> expects_prefix_module<br><br>    <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>        expected_keys_not_prefixed = [s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> s.startswith(prefix)]<br>        expected_keys = [<span class="hljs-string">&quot;.&quot;</span>.join(s.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:]) <span class="hljs-keyword">if</span> s.startswith(prefix) <span class="hljs-keyword">else</span> s <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys]<br>    <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>        expected_keys = [<span class="hljs-string">&quot;.&quot;</span>.join([prefix, s]) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> expected_keys]<br><br>    missing_keys = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(expected_keys) - <span class="hljs-built_in">set</span>(loaded_keys))<br>    unexpected_keys = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(loaded_keys) - <span class="hljs-built_in">set</span>(expected_keys))<br><br>    <span class="hljs-comment"># Some models may have keys that are not in the state by design, removing them before needlessly warning</span><br>    <span class="hljs-comment"># the user.</span><br>    <span class="hljs-keyword">if</span> cls._keys_to_ignore_on_load_missing <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> pat <span class="hljs-keyword">in</span> cls._keys_to_ignore_on_load_missing:<br>            missing_keys = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> missing_keys <span class="hljs-keyword">if</span> re.search(pat, k) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-keyword">if</span> cls._keys_to_ignore_on_load_unexpected <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> pat <span class="hljs-keyword">in</span> cls._keys_to_ignore_on_load_unexpected:<br>            unexpected_keys = [k <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> unexpected_keys <span class="hljs-keyword">if</span> re.search(pat, k) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>]<br><br>    <span class="hljs-keyword">if</span> _fast_init:<br>        <span class="hljs-comment"># retrieve unintialized modules and initialize</span><br>        uninitialized_modules = model.retrieve_modules_from_names(<br>            missing_keys, add_prefix=add_prefix_to_model, remove_prefix=remove_prefix_from_model<br>        )<br>        <span class="hljs-keyword">for</span> module <span class="hljs-keyword">in</span> uninitialized_modules:<br>            model._init_weights(module)<br><br>    <span class="hljs-comment"># Make sure we are able to load base models as well as derived models (with heads)</span><br>    start_prefix = <span class="hljs-string">&quot;&quot;</span><br>    model_to_load = model<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cls.base_model_prefix) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(model, cls.base_model_prefix) <span class="hljs-keyword">and</span> has_prefix_module:<br>        start_prefix = cls.base_model_prefix + <span class="hljs-string">&quot;.&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(cls.base_model_prefix) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">hasattr</span>(model, cls.base_model_prefix) <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> has_prefix_module:<br>        model_to_load = <span class="hljs-built_in">getattr</span>(model, cls.base_model_prefix)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">any</span>(key <span class="hljs-keyword">in</span> expected_keys_not_prefixed <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> loaded_keys):<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">&quot;The state dictionary of the model you are training to load is corrupted. Are you sure it was &quot;</span><br>                <span class="hljs-string">&quot;properly saved?&quot;</span><br>            )<br><br>    <span class="hljs-keyword">if</span> state_dict <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Whole checkpoint</span><br>        mismatched_keys = []<br>        <span class="hljs-keyword">if</span> ignore_mismatched_sizes:<br>            <span class="hljs-keyword">for</span> checkpoint_key <span class="hljs-keyword">in</span> loaded_keys:<br>                model_key = checkpoint_key<br>                <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>                    <span class="hljs-comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span><br>                    model_key = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prefix&#125;</span>.<span class="hljs-subst">&#123;checkpoint_key&#125;</span>&quot;</span><br>                <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>                    <span class="hljs-comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span><br>                    model_key = <span class="hljs-string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:])<br><br>                <span class="hljs-keyword">if</span> (<br>                    model_key <span class="hljs-keyword">in</span> model_state_dict<br>                    <span class="hljs-keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape<br>                ):<br>                    mismatched_keys.append(<br>                        (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)<br>                    )<br>                    <span class="hljs-keyword">del</span> state_dict[checkpoint_key]<br><br>        error_msgs = _load_state_dict_into_model(model_to_load, state_dict, start_prefix)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># Sharded checkpoint</span><br>        <span class="hljs-comment"># This should always be a list but, just to be sure.</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(resolved_archive_file, <span class="hljs-built_in">list</span>):<br>            resolved_archive_file = [resolved_archive_file]<br><br>        error_msgs = []<br>        <span class="hljs-keyword">for</span> shard_file <span class="hljs-keyword">in</span> resolved_archive_file:<br>            state_dict = load_state_dict(shard_file)<br>            <span class="hljs-comment"># Mistmatched keys contains tuples key/shape1/shape2 of weights in the checkpoint that have a shape not</span><br>            <span class="hljs-comment"># matching the weights in the model.</span><br>            mismatched_keys = []<br>            <span class="hljs-keyword">if</span> ignore_mismatched_sizes:<br>                <span class="hljs-keyword">for</span> checkpoint_key <span class="hljs-keyword">in</span> loaded_keys:<br>                    model_key = checkpoint_key<br>                    <span class="hljs-keyword">if</span> remove_prefix_from_model:<br>                        <span class="hljs-comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span><br>                        model_key = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prefix&#125;</span>.<span class="hljs-subst">&#123;checkpoint_key&#125;</span>&quot;</span><br>                    <span class="hljs-keyword">elif</span> add_prefix_to_model:<br>                        <span class="hljs-comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span><br>                        model_key = <span class="hljs-string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">1</span>:])<br><br>                    <span class="hljs-keyword">if</span> (<br>                        model_key <span class="hljs-keyword">in</span> model_state_dict<br>                        <span class="hljs-keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape<br>                    ):<br>                        mismatched_keys.append(<br>                            (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)<br>                        )<br>                        <span class="hljs-keyword">del</span> state_dict[checkpoint_key]<br><br>            error_msgs += _load_state_dict_into_model(model_to_load, state_dict, start_prefix)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(error_msgs) &gt; <span class="hljs-number">0</span>:<br>        error_msg = <span class="hljs-string">&quot;\n\t&quot;</span>.join(error_msgs)<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">f&quot;Error(s) in loading state_dict for <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>:\n\t<span class="hljs-subst">&#123;error_msg&#125;</span>&quot;</span>)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(unexpected_keys) &gt; <span class="hljs-number">0</span>:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> were not used when &quot;</span><br>            <span class="hljs-string">f&quot;initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>: <span class="hljs-subst">&#123;unexpected_keys&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;- This IS expected if you are initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model trained on another task &quot;</span><br>            <span class="hljs-string">f&quot;or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).\n&quot;</span><br>            <span class="hljs-string">f&quot;- This IS NOT expected if you are initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model that you expect &quot;</span><br>            <span class="hljs-string">f&quot;to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).&quot;</span><br>        )<br>    <span class="hljs-keyword">else</span>:<br>        logger.info(<span class="hljs-string">f&quot;All model checkpoint weights were used when initializing <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span>.\n&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(missing_keys) &gt; <span class="hljs-number">0</span>:<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span><br>            <span class="hljs-string">f&quot;and are newly initialized: <span class="hljs-subst">&#123;missing_keys&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span><br>        )<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(mismatched_keys) == <span class="hljs-number">0</span>:<br>        logger.info(<br>            <span class="hljs-string">f&quot;All the weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span>.\n&quot;</span><br>            <span class="hljs-string">f&quot;If your task is similar to the task the model of the checkpoint was trained on, &quot;</span><br>            <span class="hljs-string">f&quot;you can already use <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> for predictions without further training.&quot;</span><br>        )<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mismatched_keys) &gt; <span class="hljs-number">0</span>:<br>        mismatched_warning = <span class="hljs-string">&quot;\n&quot;</span>.join(<br>            [<br>                <span class="hljs-string">f&quot;- <span class="hljs-subst">&#123;key&#125;</span>: found shape <span class="hljs-subst">&#123;shape1&#125;</span> in the checkpoint and <span class="hljs-subst">&#123;shape2&#125;</span> in the model instantiated&quot;</span><br>                <span class="hljs-keyword">for</span> key, shape1, shape2 <span class="hljs-keyword">in</span> mismatched_keys<br>            ]<br>        )<br>        logger.warning(<br>            <span class="hljs-string">f&quot;Some weights of <span class="hljs-subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="hljs-subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span><br>            <span class="hljs-string">f&quot;and are newly initialized because the shapes did not match:\n<span class="hljs-subst">&#123;mismatched_warning&#125;</span>\n&quot;</span><br>            <span class="hljs-string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span><br>        )<br><br>    <span class="hljs-keyword">return</span> model, missing_keys, unexpected_keys, mismatched_keys, error_msgs<br></code></pre></td></tr></table></figure></li></ul><h6 id="4-额外补充"><a href="#4-额外补充" class="headerlink" title="4) 额外补充"></a>4) 额外补充</h6><p>应该是这里的实例化把config给model传进去了，于是model需要的key可能少于、或者多于提供给他的key（pytorch_model.bin）,这里是一个<code>super().__init__()</code>，可能是调用到<code>nn.Module</code>这个上层了，然后依据传入的config不知道怎么操作，把层数什么的网络结构给拼上了；<font color="red">另：也有可能是要加载到这个&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;modeling_bert.py里面的BertModel类，这样BertModel类是super代表的上层？</font> </p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712001457966.png" alt="image-20220712001457966"></p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712001307673.png" alt="image-20220712001307673"></p><h5 id="·-通过config加载空模型并设置seed"><a href="#·-通过config加载空模型并设置seed" class="headerlink" title="· 通过config加载空模型并设置seed"></a>· 通过config加载空模型并设置seed</h5><p>如果是没有from_pretrained，而是通过<code>model = BertModel()</code>加载空模型的话，打印会看到初始化的参数，如下所示（另外注意，这种不从预训练文件中读取的话，需要加载config参数）：<br><font color="blue">BertConfig、BertModel、BertTokenizer</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 空模型加载版本</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertModel, BertConfig<br>config = BertConfig()<br>model = BertModel(config)<br></code></pre></td></tr></table></figure><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711141742912.png" alt="image-20220711141742912"></p><p>这里如果再次尝试加载空模型的时候，因为参数是随机初始化的，所以参数初始化结果可能有所不同，如下图所示</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711142519040.png" alt="image-20220711142519040"></p><p>通过set_seed进行指定，可以保证每次加载空模型时初始化的参数是一样的，set_seed的代码段如下，（实际使用上来说其实不一定需要写成这种函数的方式，直接写个几行就可以）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_seed</span>(<span class="hljs-params">seed</span>):<br>    torch.manual_seed(seed)<br>    torch.cuda.manual_seed_all(seed)<br>    np.random.seed(seed)<br>    random.seed(seed)<br>    torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><br>setup_seed(<span class="hljs-number">42</span>)  <span class="hljs-comment"># 设置随机数种子</span><br></code></pre></td></tr></table></figure><p><font color="red">这个地方加载config的时候直接用到的是config &#x3D; BertConfig()，也就是BertConfig类中的内容，对这里进行了一下详细的调试，目前的理解是他实现了一个BertConfig类，继承自PretrainedConfig这个大类。平常在fine-tune阶段直接用到的config.json文件应该是从这个BertConfig保存而来的；；；如果要是自己训练的话，可能可以实现一个新的<strong>XxxConfig</strong>类，然后内部把参数什么的都设置为自己想要的，比如层数减少一些什么的</font> </p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;models&#x2F;bert&#x2F;configuration_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BertConfig</span>(<span class="hljs-title class_ inherited__">PretrainedConfig</span>):<br>  ...<br>    model_type = <span class="hljs-string">&quot;bert&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        vocab_size=<span class="hljs-number">30522</span>,</span><br><span class="hljs-params">        hidden_size=<span class="hljs-number">768</span>,</span><br><span class="hljs-params">        num_hidden_layers=<span class="hljs-number">12</span>,</span><br><span class="hljs-params">        num_attention_heads=<span class="hljs-number">12</span>,</span><br><span class="hljs-params">        intermediate_size=<span class="hljs-number">3072</span>,</span><br><span class="hljs-params">        hidden_act=<span class="hljs-string">&quot;gelu&quot;</span>,</span><br><span class="hljs-params">        hidden_dropout_prob=<span class="hljs-number">0.1</span>,</span><br><span class="hljs-params">        attention_probs_dropout_prob=<span class="hljs-number">0.1</span>,</span><br><span class="hljs-params">        max_position_embeddings=<span class="hljs-number">512</span>,</span><br><span class="hljs-params">        type_vocab_size=<span class="hljs-number">2</span>,</span><br><span class="hljs-params">        initializer_range=<span class="hljs-number">0.02</span>,</span><br><span class="hljs-params">        layer_norm_eps=<span class="hljs-number">1e-12</span>,</span><br><span class="hljs-params">        pad_token_id=<span class="hljs-number">0</span>,</span><br><span class="hljs-params">        position_embedding_type=<span class="hljs-string">&quot;absolute&quot;</span>,</span><br><span class="hljs-params">        use_cache=<span class="hljs-literal">True</span>,</span><br><span class="hljs-params">        classifier_dropout=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">        **kwargs</span><br><span class="hljs-params">    </span>):<br>        <span class="hljs-built_in">super</span>().__init__(pad_token_id=pad_token_id, **kwargs)<br><br>        self.vocab_size = vocab_size<br>        self.hidden_size = hidden_size<br>        self.num_hidden_layers = num_hidden_layers<br>        self.num_attention_heads = num_attention_heads<br>        self.hidden_act = hidden_act<br>        self.intermediate_size = intermediate_size<br>        self.hidden_dropout_prob = hidden_dropout_prob<br>        self.attention_probs_dropout_prob = attention_probs_dropout_prob<br>        self.max_position_embeddings = max_position_embeddings<br>        self.type_vocab_size = type_vocab_size<br>        self.initializer_range = initializer_range<br>        self.layer_norm_eps = layer_norm_eps<br>        self.position_embedding_type = position_embedding_type<br>        self.use_cache = use_cache<br>        self.classifier_dropout = classifier_dropout<br></code></pre></td></tr></table></figure><h5 id="·-保存模型"><a href="#·-保存模型" class="headerlink" title="· 保存模型"></a>· 保存模型</h5><p>通过如下命令可以完成一个模型的保存，这样会在目录下生成<strong>config.json</strong>、<strong>pytorch_model.bin</strong>这两个文件，结合上面的BertConfig，如果有一个自己的模型的话，就可以魔改一下那边的XxxConfig，比如减小一些层数训练什么的，下次通过from_pretrained应该就可以加载回来了；；；这里也要集合下上面那个<strong>加载预训练model</strong>来一起看；；；</p><p><font color="red">或者说，这套BertConfig和<code>from transformers.models.bert import modeling_bert </code>那边的bert模型是对应的，只要修改BertConfig这些参数就可以制作自己的bert了，比如可能有BertTiny，或者其他版本的，都可以通过Bert这边的pipeline来走这样一个流程</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model.save_pretrained(<span class="hljs-string">&quot;directory_on_my_computer&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-3-tokenizer"><a href="#2-3-tokenizer" class="headerlink" title="2.3 tokenizer"></a>2.3 tokenizer</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">tokenizer</span> <span class="hljs-operator">=</span> BertTokenizer(<span class="hljs-string">&quot;./bert_base_uncased/vocab.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>tokenizer的from_pretrain在这里</p><blockquote><p>&#x2F;Users&#x2F;curious&#x2F;opt&#x2F;miniconda3&#x2F;envs&#x2F;venv2&#x2F;lib&#x2F;python3.9&#x2F;site-packages&#x2F;transformers&#x2F;tokenization_utils_base.py</p></blockquote><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712122136461.png" alt="image-20220712122136461"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@classmethod</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">from_pretrained</span>(<span class="hljs-params">cls, pretrained_model_name_or_path: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, os.PathLike], *init_inputs, **kwargs</span>):<br><br>    <span class="hljs-comment"># 这里省略了一些类似于本地没读到就远程下载的操作，绥中得到一个resolved_vocab_files文件向_from_pretrained传递</span><br><br>    <span class="hljs-keyword">return</span> cls._from_pretrained(<br>      resolved_vocab_files,<br>      pretrained_model_name_or_path,<br>      init_configuration,<br>      *init_inputs,<br>      use_auth_token=use_auth_token,<br>      cache_dir=cache_dir,<br>      **kwargs,<br>    )<br></code></pre></td></tr></table></figure><p><font color="red">TODO：这里是不是还有些加入特殊token的操作，曾经在一些论文代码里见过</font> </p><p>tokenizer的作用就是把一句话按照vocab中转成一个id那个感觉，tokenizer.tokenize、tokenizer.convert_tokens_to_ids()和其反向的tokenizer_convert_ids_to_tokens比较常用；</p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712123154538.png" alt="image-20220712123154538"></p><h2 id="3-Transformer-amp-BERT论文阅读中的重点记录"><a href="#3-Transformer-amp-BERT论文阅读中的重点记录" class="headerlink" title="3. Transformer&amp;BERT论文阅读中的重点记录"></a>3. Transformer&amp;BERT论文阅读中的重点记录</h2><h3 id="3-1-Attention-is-all-you-need"><a href="#3-1-Attention-is-all-you-need" class="headerlink" title="3.1 Attention is all you need"></a>3.1 Attention is all you need</h3><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214108979.png" alt="image-20220712214108979"></p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214133925.png" alt="image-20220712214133925"></p><p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214114211.png" alt="image-20220712214114211"></p><img src="/_posts/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214155672.png" alt="image-20220712214155672" style="zoom:50%;"><p>就是那个指数，如果有一个特别大的，他softmax算出来就很趋向于1了</p><p>这个现象会随着指数的增大而明显，比如指数是3的时候，就不明显，指数是20的时候就很明显</p><h3 id="3-2-BERT"><a href="#3-2-BERT" class="headerlink" title="3.2 BERT"></a>3.2 BERT</h3><p>TODO</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器连接github与token的配置</title>
    <link href="/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>有时候换了常用的git开发环境，在一个新环境上<code>git clone</code>，<code>git push</code>项目的时候，需要重新输入用户名和密码（token）</p><p>在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存</p><span id="more"></span><h1 id="服务器连接github与token配置"><a href="#服务器连接github与token配置" class="headerlink" title="服务器连接github与token配置"></a>服务器连接github与token配置</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>在github头像 -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens -&gt; Generate new token</p><p>这里生成一个新的token，clone等操作的时候用这个token就可以</p><p><img src="/_posts/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/2022-11-18-16-42-36.png"></p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>295场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1299)+t2(1577)；</p><p>这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧；</p><p>第一题：简单字典计数；</p><p>第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>第三题：咕咕QAQ；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2287-重排字符形成目标字符串【难度：1299】"><a href="#第一题：2287-重排字符形成目标字符串【难度：1299】" class="headerlink" title="第一题：2287.重排字符形成目标字符串【难度：1299】"></a>第一题：2287.重排字符形成目标字符串【难度：1299】</h1><p><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p><p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p><p>示例1：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;ilovecodingonleetcode&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;code&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">1</span> 个副本，选取下标为 <span class="hljs-number">4</span> 、<span class="hljs-number">5</span> 、<span class="hljs-number">6</span> 和 <span class="hljs-number">7</span> 的字符。<br>对于 <span class="hljs-string">&quot;code&quot;</span> 的第 <span class="hljs-number">2</span> 个副本，选取下标为 <span class="hljs-number">17</span> 、<span class="hljs-number">18</span> 、<span class="hljs-number">19</span> 和 <span class="hljs-number">20</span> 的字符。<br>形成的字符串分别是 <span class="hljs-string">&quot;ecod&quot;</span> 和 <span class="hljs-string">&quot;code&quot;</span> ，都可以重排为 <span class="hljs-string">&quot;code&quot;</span> 。<br>可以形成最多 <span class="hljs-number">2</span> 个 <span class="hljs-string">&quot;code&quot;</span> 的副本，所以返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>示例2</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;abcba&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>选取下标为 <span class="hljs-number">0</span> 、<span class="hljs-number">1</span> 和 <span class="hljs-number">2</span> 的字符，可以形成 <span class="hljs-string">&quot;abc&quot;</span> 的 <span class="hljs-number">1</span> 个副本。 <br>可以形成最多 <span class="hljs-number">1</span> 个 <span class="hljs-string">&quot;abc&quot;</span> 的副本，所以返回 <span class="hljs-number">1</span> 。<br>注意，尽管下标 <span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 分别有额外的 <span class="hljs-string">&#x27;a&#x27;</span> 和 <span class="hljs-string">&#x27;b&#x27;</span> ，但不能重用下标 <span class="hljs-number">2</span> 处的 <span class="hljs-string">&#x27;c&#x27;</span> ，所以无法形成 <span class="hljs-string">&quot;abc&quot;</span> 的第 <span class="hljs-number">2</span> 个副本。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：s = <span class="hljs-string">&quot;abbaccaddaeea&quot;</span>, <span class="hljs-keyword">target</span> = <span class="hljs-string">&quot;aaaaa&quot;</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>选取下标为 <span class="hljs-number">0</span> 、<span class="hljs-number">3</span> 、<span class="hljs-number">6</span> 、<span class="hljs-number">9</span> 和 <span class="hljs-number">12</span> 的字符，可以形成 <span class="hljs-string">&quot;aaaaa&quot;</span> 的 <span class="hljs-number">1</span> 个副本。<br>可以形成最多 <span class="hljs-number">1</span> 个 <span class="hljs-string">&quot;aaaaa&quot;</span> 的副本，所以返回 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= target.length &lt;= 10</code></li><li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>简单字典计数；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rearrangeCharacters</span>(<span class="hljs-params">self, s, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type target: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt_s = Counter(s)<br>        cnt_target = Counter(target)<br>        <br>        res = <span class="hljs-number">1e9</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt_target.items():<br>            res = <span class="hljs-built_in">min</span>(res, cnt_s[key]//value)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2288-价格减免【难度：1577】"><a href="#第二题：2288-价格减免【难度：1577】" class="headerlink" title="第二题：2288.价格减免【难度：1577】"></a>第二题：2288.价格减免【难度：1577】</h1><p><a href="https://leetcode.cn/problems/apply-discount-to-prices/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>&#39;$&#39;</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。</p><ul><li>例如 <code>&quot;$100&quot;</code>、<code>&quot;$23&quot;</code> 和 <code>&quot;$6.75&quot;</code> 表示价格，而 <code>&quot;100&quot;</code>、<code>&quot;$&quot;</code> 和 <code>&quot;2$3&quot;</code> 不是。</li></ul><p><strong>注意</strong>：本题输入中的价格均为整数。</p><p>给你一个字符串 <code>sentence</code>  和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p><p>返回表示修改后句子的字符串。</p><p>示例1：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">输入：sentence = <span class="hljs-string">&quot;there are <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span> and 5<span class="hljs-variable">$</span> candies in the shop&quot;</span>, discount = <span class="hljs-number">50</span><br>输出：<span class="hljs-string">&quot;there are <span class="hljs-variable">$0</span>.50 <span class="hljs-variable">$1</span>.00 and 5<span class="hljs-variable">$</span> candies in the shop&quot;</span><br>解释：<br>表示价格的单词是 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 和 <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> 。 <br>- <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 减免 <span class="hljs-number">50</span>% 为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.50&quot;</span> ，所以 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.50&quot;</span> 。<br>- <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> 减免 <span class="hljs-number">50</span>% 为 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ，所以 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> 替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>.00&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">输入：sentence = <span class="hljs-string">&quot;1 2 <span class="hljs-variable">$3</span> 4 <span class="hljs-variable">$5</span> <span class="hljs-variable">$6</span> 7 8<span class="hljs-variable">$</span> <span class="hljs-variable">$9</span> <span class="hljs-variable">$10</span><span class="hljs-variable">$</span>&quot;</span>, discount = <span class="hljs-number">100</span><br>输出：<span class="hljs-string">&quot;1 2 <span class="hljs-variable">$0</span>.00 4 <span class="hljs-variable">$0</span>.00 <span class="hljs-variable">$0</span>.00 7 8<span class="hljs-variable">$</span> <span class="hljs-variable">$0</span>.00 <span class="hljs-variable">$10</span><span class="hljs-variable">$</span>&quot;</span><br>解释：<br>任何价格减免 <span class="hljs-number">100</span>% 都会得到 <span class="hljs-number">0</span> 。<br>表示价格的单词分别是 <span class="hljs-string">&quot;<span class="hljs-variable">$3</span>&quot;</span>、<span class="hljs-string">&quot;<span class="hljs-variable">$5</span>&quot;</span>、<span class="hljs-string">&quot;<span class="hljs-variable">$6</span>&quot;</span> 和 <span class="hljs-string">&quot;<span class="hljs-variable">$9</span>&quot;</span>。<br>每个单词都替换为 <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>.00&quot;</span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 10^5</code></li><li><code>sentence</code> 由小写英文字母、数字、<code>&#39; &#39;</code> 和 <code>&#39;$&#39;</code> 组成</li><li><code>sentence</code> 不含前导和尾随空格</li><li><code>sentence</code> 的所有单词都用单个空格分隔</li><li>所有价格都是 <strong>正</strong> 整数且不含前导零</li><li>所有价格 <strong>最多</strong> 为  <code>10</code> 位数字</li><li><code>0 &lt;= discount &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>P.S. 借这个题想说好讨厌这种描述又长，又带着小数的题啊，感觉不像是正路的题目；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">discountPrices</span>(<span class="hljs-params">self, sentence, discount</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type sentence: str</span><br><span class="hljs-string">        :type discount: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        tmp_list = sentence.split()<br>        res_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br><br>            <span class="hljs-keyword">if</span> tmp_list[i][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;$&#x27;</span>:<br>                <span class="hljs-keyword">try</span>:<br>                    tmp = <span class="hljs-built_in">int</span>(tmp_list[i][<span class="hljs-number">1</span>:])<br>                    tmp = tmp - (tmp * discount * <span class="hljs-number">1.0</span> /<span class="hljs-number">100</span>)<br>                    tmp = <span class="hljs-string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(tmp)<br>                    tmp = <span class="hljs-string">&#x27;$&#x27;</span> + tmp<br>                    res_list.append(tmp)<br>                <span class="hljs-keyword">except</span>:<br>                    res_list.append(tmp_list[i])<br>            <span class="hljs-keyword">else</span>:<br>                res_list.append(tmp_list[i])<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27; &#x27;</span>.join(res_list)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>296场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1241)+t2(1416)+t3(1445)；</p><p>难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟&#x2F;贪心就可以完成了；</p><p>第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><p>第二题：排序后贪心，维护一个组内的最大最小值；</p><p>第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2293-极大极小游戏【难度：1241】"><a href="#第一题：2293-极大极小游戏【难度：1241】" class="headerlink" title="第一题：2293.极大极小游戏【难度：1241】"></a>第一题：2293.极大极小游戏【难度：1241】</h1><p><a href="https://leetcode.cn/problems/min-max-game/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p><p>对 <code>nums</code> 执行下述算法：</p><ol><li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>用 <code>newNums</code> 替换 <code>nums</code> 。</li><li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li></ol><p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p><p>示例1：</p><p><img src="/images/2022-06-19-17-05-41.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,3,5,2,4,8,2,2]</span><br>输出：1<br>解释：重复执行算法会得到下述数组。<br>第一轮：nums = <span class="hljs-comment">[1,5,4,2]</span><br>第二轮：nums = <span class="hljs-comment">[1,4]</span><br>第三轮：nums = <span class="hljs-comment">[1]</span><br>1 是最后剩下的那个数字，返回 1 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">3</span><br>解释：<span class="hljs-number">3</span> 就是最后剩下的数字，返回 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1024</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums.length</code> 是 <code>2</code> 的幂</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMaxGame</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <br>        <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br>            tmp = []<br>            idx = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>):<br>                <span class="hljs-keyword">if</span> idx % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                    tmp.append(<span class="hljs-built_in">min</span>(nums[i], nums[i+<span class="hljs-number">1</span>]))<br>                    idx += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    tmp.append(<span class="hljs-built_in">max</span>(nums[i], nums[i+<span class="hljs-number">1</span>]))<br>                    idx += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(tmp)</span><br>            nums = copy.deepcopy(tmp)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>        <span class="hljs-comment"># print(tmp)</span><br>        <span class="hljs-keyword">return</span> tmp[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><h1 id="第二题：2294-划分数组使最大差为-K【难度：1416】"><a href="#第二题：2294-划分数组使最大差为-K【难度：1416】" class="headerlink" title="第二题：2294.划分数组使最大差为 K【难度：1416】"></a>第二题：2294.划分数组使最大差为 K【难度：1416】</h1><p><a href="https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p><p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p><p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,6,1,2,5], k = 2<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 2 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 1 </span>。<br>由于创建了两个子序列，返回<span class="hljs-number"> 2 </span>。可以证明需要划分的最少子序列数目就是<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3], k = 1<br>输出：2<br>解释：<br>可以将 nums 划分为两个子序列 [1,2] 和 [3] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 1 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 3 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 0 </span>。<br>由于创建了两个子序列，返回<span class="hljs-number"> 2 </span>。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,4,5], k = 0<br>输出：3<br>解释：<br>可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。<br>第一个子序列中最大值和最小值的差值是<span class="hljs-number"> 2 </span>-<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 0 </span>。<br>第二个子序列中最大值和最小值的差值是<span class="hljs-number"> 4 </span>-<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 0 </span>。<br>第三个子序列中最大值和最小值的差值是<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 0 </span>。<br>由于创建了三个子序列，返回<span class="hljs-number"> 3 </span>。可以证明需要划分的最少子序列数目就是<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>排序后贪心，维护一个组内的最大最小值；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">partitionArray</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums.sort()<br>        res = []<br> <br>        now_min = nums[<span class="hljs-number">0</span>]<br>        now_max = nums[<span class="hljs-number">0</span>]<br>        tmp = [nums[<span class="hljs-number">0</span>]]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            now_min = <span class="hljs-built_in">min</span>(now_min, nums[i])<br>            now_max = <span class="hljs-built_in">max</span>(now_max, nums[i])<br>            chazhi = <span class="hljs-built_in">abs</span>(now_max-now_min)<br>            <br>            <span class="hljs-keyword">if</span> chazhi &lt;= k:<br>                tmp.append(nums[i])<br>            <span class="hljs-keyword">else</span>:<br>                res.append(tmp)<br>                tmp = [nums[i]]<br>                now_min = nums[i]<br>                now_max = nums[i]<br>        <br>        res.append(tmp)<br>        <span class="hljs-comment"># print(res)</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第三题：2295-替换数组中的元素【难度：1445】"><a href="#第三题：2295-替换数组中的元素【难度：1445】" class="headerlink" title="第三题：2295.替换数组中的元素【难度：1445】"></a>第三题：2295.替换数组中的元素【难度：1445】</h1><p><a href="https://leetcode.cn/problems/replace-elements-in-an-array/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，它包含 <code>n</code> 个 <strong>互不相同</strong> 的正整数。请你对这个数组执行 <code>m</code> 个操作，在第 <code>i</code> 个操作中，你需要将数字 <code>operations[i][0]</code> 替换成 <code>operations[i][1]</code> 。</p><p>题目保证在第 <code>i</code> 个操作中：</p><ul><li><code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li><code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><p>请你返回执行完所有操作后的数组。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,4,6]</span>, operations = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[4,7]</span>,<span class="hljs-comment">[6,1]</span>]</span><br>输出：<span class="hljs-comment">[3,2,7,1]</span><br>解释：我们对 nums 执行以下操作：<br>- 将数字 1 替换为 3 。nums 变为 <span class="hljs-comment">[3,2,4,6]</span> 。<br>- 将数字 4 替换为 7 。nums 变为 <span class="hljs-comment">[3,2,7,6]</span> 。<br>- 将数字 6 替换为 1 。nums 变为 <span class="hljs-comment">[3,2,7,1]</span> 。<br>返回最终数组 <span class="hljs-comment">[3,2,7,1]</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2]</span>, operations = <span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,1]</span>,<span class="hljs-comment">[3,2]</span>]</span><br>输出：<span class="hljs-comment">[2,1]</span><br>解释：我们对 nums 执行以下操作：<br>- 将数字 1 替换为 3 。nums 变为 <span class="hljs-comment">[3,2]</span> 。<br>- 将数字 2 替换为 1 。nums 变为 <span class="hljs-comment">[3,1]</span> 。<br>- 将数字 3 替换为 2 。nums 变为 <span class="hljs-comment">[2,1]</span> 。<br>返回最终数组 <span class="hljs-comment">[2,1]</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == operations.length</code></li><li><code>1 &lt;= n, m &lt;= 10^5</code></li><li><code>nums</code> 中所有数字 <strong>互不相同</strong> 。</li><li><code>operations[i].length == 2</code></li><li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10^6</code></li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">arrayChange</span>(<span class="hljs-params">self, nums, operations</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type operations: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        d = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            d[nums[i]] = [nums[i], nums[i], i]<br>        <br>        <span class="hljs-comment"># print(d)</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(operations)):<br>            old, new = operations[i][<span class="hljs-number">0</span>], operations[i][<span class="hljs-number">1</span>]<br>            tmp_list = d[old]<br>            <br>            d[old] = [new, tmp_list[<span class="hljs-number">1</span>], tmp_list[<span class="hljs-number">2</span>]]<br>            d[new] = d[old]<br>            <span class="hljs-keyword">del</span> d[old]<br>        <br>        tmp_res = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>            tmp_res.append([value[<span class="hljs-number">0</span>], value[<span class="hljs-number">2</span>]])<br>        tmp_res.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])<br>        <span class="hljs-comment"># print(tmp_res)</span><br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_res)):<br>            res.append(tmp_res[i][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>297场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1283)+t2(1658)+t3(1886)；</p><p>这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧；</p><p>第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><p>第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><p>第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2303-计算应缴税款总额【难度：1283】"><a href="#第一题：2303-计算应缴税款总额【难度：1283】" class="headerlink" title="第一题：2303.计算应缴税款总额【难度：1283】"></a>第一题：2303.计算应缴税款总额【难度：1283】</h1><p><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10^-5</code> 的结果将被视作正确答案。</p><p>示例1：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：brackets = [[<span class="hljs-number">3</span>,<span class="hljs-number">50</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">12</span>,<span class="hljs-number">25</span>]], income = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">2.65000</span><br>解释：<br>前 $3 的税率为 <span class="hljs-number">50</span>% 。需要支付税款 $3 * <span class="hljs-number">50</span>% = $1<span class="hljs-number">.50</span> 。<br>接下来 $7 - $3 = $4 的税率为 <span class="hljs-number">10</span>% 。需要支付税款 $4 * <span class="hljs-number">10</span>% = $0<span class="hljs-number">.40</span> 。<br>最后 $10 - $7 = $3 的税率为 <span class="hljs-number">25</span>% 。需要支付税款 $3 * <span class="hljs-number">25</span>% = $0<span class="hljs-number">.75</span> 。<br>需要支付的税款总计 $1<span class="hljs-number">.50</span> + $0<span class="hljs-number">.40</span> + $0<span class="hljs-number">.75</span> = $2<span class="hljs-number">.65</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">输入：brackets = [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">25</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">50</span>]], income = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">0.25000</span><br>解释：<br>前 $1 的税率为 <span class="hljs-number">0</span>% 。需要支付税款 $1 * <span class="hljs-number">0</span>% = $0 。<br>剩下 $1 的税率为 <span class="hljs-number">25</span>% 。需要支付税款 $1 * <span class="hljs-number">25</span>% = $0<span class="hljs-number">.25</span> 。<br>需要支付的税款总计 $0 + $0<span class="hljs-number">.25</span> = $0<span class="hljs-number">.25</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：brackets = <span class="hljs-string">[[2,50]]</span>, income = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0.00000</span><br>解释：<br>没有收入，无需纳税，需要支付的税款总计 $<span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= brackets.length &lt;= 100</code></li><li><code>1 &lt;= upperi &lt;= 1000</code></li><li><code>0 &lt;= percenti &lt;= 100</code></li><li><code>0 &lt;= income &lt;= 1000</code></li><li><code>upperi</code> 按递增顺序排列</li><li><code>upperi</code> 中的所有值 互不相同</li><li>最后一个税级的上限大于等于 <code>income</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculateTax</span>(<span class="hljs-params">self, brackets, income</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type brackets: List[List[int]]</span><br><span class="hljs-string">        :type income: int</span><br><span class="hljs-string">        :rtype: float</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brackets)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            brackets[i][<span class="hljs-number">0</span>] = brackets[i][<span class="hljs-number">0</span>] - brackets[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>    <br>        <span class="hljs-comment"># print(brackets)</span><br>        res = <span class="hljs-number">0</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(brackets)):<br>            <span class="hljs-keyword">if</span> income &gt;= brackets[i][<span class="hljs-number">0</span>]:<br>                res +=  ((brackets[i][<span class="hljs-number">0</span>] * brackets[i][<span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span>) / <span class="hljs-number">100</span>)<br>                income -= brackets[i][<span class="hljs-number">0</span>]<br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <br>                res +=  ((income * brackets[i][<span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span>) / <span class="hljs-number">100</span>)<br>                i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2304-网格中的最小路径代价【难度：1658】"><a href="#第二题：2304-网格中的最小路径代价【难度：1658】" class="headerlink" title="第二题：2304.网格中的最小路径代价【难度：1658】"></a>第二题：2304.网格中的最小路径代价【难度：1658】</h1><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意</strong>： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价。</p><p>示例1：</p><p><img src="/images/2022-06-19-16-46-14.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]<br>输出：17<br>解释：最小代价的路径是<span class="hljs-number"> 5 </span>-&gt;<span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 1 </span>。<br>- 路径途经单元格值之和<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br>- 从<span class="hljs-number"> 5 </span>移动到<span class="hljs-number"> 0 </span>的代价为<span class="hljs-number"> 3 </span>。<br>- 从<span class="hljs-number"> 0 </span>移动到<span class="hljs-number"> 1 </span>的代价为<span class="hljs-number"> 8 </span>。<br>路径总代价为<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 17 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]<br>输出：6<br>解释：<br>最小代价的路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 3 </span>。 <br>- 路径途经单元格值之和<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>。 <br>- 从<span class="hljs-number"> 2 </span>移动到<span class="hljs-number"> 3 </span>的代价为<span class="hljs-number"> 1 </span>。 <br>路径总代价为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li><li><code>moveCost.length == m * n</code></li><li><code>moveCost[i].length == n</code></li><li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathCost</span>(<span class="hljs-params">self, grid, moveCost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type moveCost: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        m, n = <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        base = grid[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):  <span class="hljs-comment"># 遍历m行</span><br>            new_base = [<span class="hljs-number">1e99</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># n个</span><br>            <span class="hljs-comment"># 下面是一个从当前n个状态（base，用j代表）到下n个状态（用k表示）的转移，从上一行的n个转移到下一行的n个，每个地方取最优的dp</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    new_base[k] = <span class="hljs-built_in">min</span>(new_base[k], base[j]+grid[i][k]+moveCost[grid[i-<span class="hljs-number">1</span>][j]][k])  <span class="hljs-comment"># 选一个所有状态转移里最小的</span><br>            <br>            base = new_base<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(base)<br></code></pre></td></tr></table></figure><h1 id="第三题：2305-公平分发饼干【难度：1886】"><a href="#第三题：2305-公平分发饼干【难度：1886】" class="headerlink" title="第三题：2305.公平分发饼干【难度：1886】"></a>第三题：2305.公平分发饼干【难度：1886】</h1><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cookies = [8,15,10,20,8], k = 2<br>输出：31<br>解释：一种最优方案是 [8,15,8] 和 [10,20] 。<br>- 第<span class="hljs-number"> 1 </span>个孩子分到 [8,15,8] ，总计<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 31 </span>块饼干。<br>- 第<span class="hljs-number"> 2 </span>个孩子分到 [10,20] ，总计<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 20 </span>=<span class="hljs-number"> 30 </span>块饼干。<br>分发的不公平程度为 max(31,30) =<span class="hljs-number"> 31 </span>。<br>可以证明不存在不公平程度小于<span class="hljs-number"> 31 </span>的分发方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cookies = [6,1,3,2,2,4,1,2], k = 3<br>输出：7<br>解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。<br>- 第<span class="hljs-number"> 1 </span>个孩子分到 [6,1] ，总计<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>块饼干。 <br>- 第<span class="hljs-number"> 2 </span>个孩子分到 [3,2,2] ，总计<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 7 </span>块饼干。<br>- 第<span class="hljs-number"> 3 </span>个孩子分到 [4,1,2] ，总计<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 7 </span>块饼干。<br>分发的不公平程度为 max(7,7,7) =<span class="hljs-number"> 7 </span>。<br>可以证明不存在不公平程度小于<span class="hljs-number"> 7 </span>的分发方案。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= cookies.length &lt;= 8</code></li><li><code>1 &lt;= cookies[i] &lt;= 10^5</code></li><li><code>2 &lt;= k &lt;= cookies.length</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 超时解法27/36</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">distributeCookies</span>(<span class="hljs-params">self, cookies, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cookies: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">1e99</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">n, x, padding_len</span>):<br>            <span class="hljs-comment">#n为待转换的十进制数，x为机制，取值为2-16</span><br>            a=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>]<br>            b=[]<br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                s=n//x  <span class="hljs-comment"># 商</span><br>                y=n%x  <span class="hljs-comment"># 余数</span><br>                b=b+[y]<br>                <span class="hljs-keyword">if</span> s==<span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">break</span><br>                n=s<br>            b.reverse()<br>            tmp = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> b:<br>                tmp.append(a[i])<br>            <span class="hljs-keyword">return</span> tmp + [<span class="hljs-number">0</span>] * (padding_len - <span class="hljs-built_in">len</span>(tmp))<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k**<span class="hljs-built_in">len</span>(cookies)):<br>            tmp = f(i, k, <span class="hljs-built_in">len</span>(cookies))<br>            d = defaultdict(<span class="hljs-built_in">int</span>)<br>            tmp_max = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp)):<br>                d[tmp[i]] += cookies[i]<br>            <br>            <span class="hljs-comment"># print(d)</span><br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(d) != k:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                tmp_max = <span class="hljs-built_in">max</span>([x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> d.values()])<br><br>            res = <span class="hljs-built_in">min</span>(res, tmp_max)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>位运算</tag>
      
      <tag>矩阵</tag>
      
      <tag>回溯</tag>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>298场LeetCode周赛</title>
    <link href="/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1427)+t2(1646)+t3(1871)；</p><p>近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧；</p><p>第一题：小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><p>第二题：思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><p>第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：5242-兼具大小写的最好英文字母【难度：1427】"><a href="#第一题：5242-兼具大小写的最好英文字母【难度：1427】" class="headerlink" title="第一题：5242.兼具大小写的最好英文字母【难度：1427】"></a>第一题：5242.兼具大小写的最好英文字母【难度：1427】</h1><p><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> 更好 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 后 出现。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;lEeTcOdE&quot;</span><br>输出：<span class="hljs-string">&quot;E&quot;</span><br>解释：<br>字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;arRAzFif&quot;</span><br>输出：<span class="hljs-string">&quot;R&quot;</span><br>解释：<br>字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。<br>注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;AbCdEfGhIjK&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：<br>不存在大写和小写形式都出现的字母。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写和大写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">greatestLetter</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        res = []<br>        d = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            d[s[i]] = <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>            <span class="hljs-keyword">if</span> d.get(key.upper()) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> d.get(key.lower()) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                res += key.upper()<br>        <br>        res.sort()<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res):<br>            <span class="hljs-keyword">return</span> res[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第二题：5218-个位数字为-K-的整数之和【难度：1646】"><a href="#第二题：5218-个位数字为-K-的整数之和【难度：1646】" class="headerlink" title="第二题：5218.个位数字为 K 的整数之和【难度：1646】"></a>第二题：5218.个位数字为 K 的整数之和【难度：1646】</h1><p><a href="https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p><ul><li>每个整数个位数字都是 <code>k</code> 。</li><li>所有整数之和是 <code>num</code> 。</li></ul><p>返回该多重集的最小大小，如果不存在这样的多重集，返回 <code>-1</code> 。</p><p>注意：</p><ul><li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。</li><li><code>个位数字</code> 是数字最右边的数位。</li></ul><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 58, k = 9<br>输出：2<br>解释：<br>多重集 [9,49] 满足题目条件，和为<span class="hljs-number"> 58 </span>且每个整数的个位数字是<span class="hljs-number"> 9 </span>。<br>另一个满足条件的多重集是 [19,39] 。<br>可以证明<span class="hljs-number"> 2 </span>是满足题目条件的多重集的最小长度。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 37, k = 2<br>输出：-1<br>解释：个位数字为<span class="hljs-number"> 2 </span>的整数无法相加得到<span class="hljs-number"> 37 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">0</span>, k = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">0</span><br>解释：空多重集的和为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= num &lt;= 3000</code></li><li><code>0 &lt;= k &lt;= 9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumNumbers</span>(<span class="hljs-params">self, num, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <br>        <span class="hljs-keyword">if</span> k != <span class="hljs-number">0</span>:<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                cnt = -<span class="hljs-number">1</span><br>                <br>            res = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">if</span> cnt == <span class="hljs-number">1</span>:<br>                        <span class="hljs-keyword">break</span><br>                num -= k<br>                res += <span class="hljs-number">1</span><br>                <br>            <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span> <br>            <span class="hljs-keyword">return</span> res<br>        <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num != <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> num % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】"><a href="#第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】" class="headerlink" title="第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】"></a>第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】</h1><p><a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p><p>请你返回 <code>s</code> 的 <strong>最长</strong> 子序列，且该子序列对应的 <strong>二进制</strong> 数字小于等于 <code>k</code> 。</p><p>注意：</p><ul><li>子序列可以有 <strong>前导 0</strong> 。</li><li>空字符串视为 <code>0</code> 。</li><li><code>子序列</code> 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li></ul><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;1001010&quot;, k = 5<br>输出：5<br>解释：s 中小于等于<span class="hljs-number"> 5 </span>的最长子序列是 &quot;00010&quot; ，对应的十进制数字是<span class="hljs-number"> 2 </span>。<br>注意 &quot;00100&quot; 和 &quot;00101&quot; 也是可行的最长子序列，十进制分别对应<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 5 </span>。<br>最长子序列的长度为<span class="hljs-number"> 5 </span>，所以返回<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：s = &quot;00101001&quot;, k = 1<br>输出：6<br>解释：&quot;000001&quot; 是 s 中小于等于<span class="hljs-number"> 1 </span>的最长子序列，对应的十进制数字是<span class="hljs-number"> 1 </span>。<br>最长子序列的长度为<span class="hljs-number"> 6 </span>，所以返回<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestSubsequence</span>(<span class="hljs-params">self, s, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        summ = <span class="hljs-number">0</span><br>        remove = <span class="hljs-number">0</span><br>        s = s[::-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">if</span> summ &gt;= k:<br>                    remove += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> summ + (<span class="hljs-number">1</span> &lt;&lt; i) &gt; k:<br>                        remove += <span class="hljs-number">1</span><br>                    summ += (<span class="hljs-number">1</span> &lt;&lt; i)  <span class="hljs-comment"># 左移i位置，优先加小位置的</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) - remove<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>294场LeetCode周赛</title>
    <link href="/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 <code>from decimal import Decimal</code>，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG；</p><p>第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><p>第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><p>第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2278-字母在字符串中的百分比"><a href="#第一题：2278-字母在字符串中的百分比" class="headerlink" title="第一题：2278.字母在字符串中的百分比"></a>第一题：2278.字母在字符串中的百分比</h1><p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：s = <span class="hljs-string">&quot;foobar&quot;</span>, letter = <span class="hljs-string">&quot;o&quot;</span><br>输出：<span class="hljs-number">33</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;o&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">2</span> / <span class="hljs-number">6</span> * <span class="hljs-number">100</span><span class="hljs-meta">%</span> = <span class="hljs-number">33</span><span class="hljs-meta">%</span> ，向下取整，所以返回 <span class="hljs-number">33</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">输入：s = <span class="hljs-string">&quot;jjjj&quot;</span>, letter = <span class="hljs-string">&quot;k&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>等于字母 <span class="hljs-string">&#x27;k&#x27;</span> 的字符在 s 中占到的百分比是 <span class="hljs-number">0</span><span class="hljs-comment">% ，所以返回 0 。</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">percentageLetter</span>(<span class="hljs-params">self, s, letter</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type letter: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span>  <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == letter:<br>                cnt += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt * <span class="hljs-number">100</span> // <span class="hljs-built_in">len</span>(s)<br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        res = (cnt * 1.0 / len(s) ) * 100</span><br><span class="hljs-string">        r = int(str(res).split(&#x27;.&#x27;)[0])</span><br><span class="hljs-string">        return r</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2279-装满石头的背包的最大数量"><a href="#第二题：2279-装满石头的背包的最大数量" class="headerlink" title="第二题：2279.装满石头的背包的最大数量"></a>第二题：2279.装满石头的背包的最大数量</h1><p><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 <strong>任意</strong> 背包中放置。</p><p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大</strong> 数量。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2<br>输出：3<br>解释：<br>1 块石头放入背包<span class="hljs-number"> 0 </span>，1 块石头放入背包<span class="hljs-number"> 1 </span>。<br>每个背包中的石头总数是 [2,3,4,4] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和 背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，可能存在其他放置石头的方案同样能够得到<span class="hljs-number"> 3 </span>这个结果。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100<br>输出：3<br>解释：<br>8 块石头放入背包<span class="hljs-number"> 0 </span>，2 块石头放入背包<span class="hljs-number"> 2 </span>。<br>每个背包中的石头总数是 [10,2,2] 。<br>背包<span class="hljs-number"> 0 </span>、背包<span class="hljs-number"> 1 </span>和背包<span class="hljs-number"> 2 </span>都装满石头。<br>总计<span class="hljs-number"> 3 </span>个背包装满石头，所以返回<span class="hljs-number"> 3 </span>。<br>可以证明不存在超过<span class="hljs-number"> 3 </span>个背包装满石头的情况。<br>注意，不必用完所有的额外石头。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == capacity.length == rocks.length</code></li><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li><li><code>1 &lt;= capacity[i] &lt;= 10^9</code></li><li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li><li><code>1 &lt;= additionalRocks &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumBags</span>(<span class="hljs-params">self, capacity, rocks, additionalRocks</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type capacity: List[int]</span><br><span class="hljs-string">        :type rocks: List[int]</span><br><span class="hljs-string">        :type additionalRocks: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cha = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(capacity)):<br>            cha.append(capacity[i]-rocks[i])<br>        <br>        cha.sort()<br><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cha)):<br>            <span class="hljs-keyword">if</span> cha[i] &lt;= additionalRocks:<br>                cnt += <span class="hljs-number">1</span><br>                additionalRocks -= cha[i]<br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：2280-表示一个折线图的最少线段数"><a href="#第三题：2280-表示一个折线图的最少线段数" class="headerlink" title="第三题：2280.表示一个折线图的最少线段数"></a>第三题：2280.表示一个折线图的最少线段数</h1><p><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [day_i, price_i]</code> 表示股票在 <code>day_i</code> 的价格为 <code>price_i</code> 。<strong>折线图</strong> 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><img src="/images/2022-05-25-00-57-12.png"></p><p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong> 。</p><p>示例1：</p><p><img src="/images/2022-05-25-00-58-50.png"></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs erlang">输入：stockPrices = [[<span class="hljs-number">1</span>,<span class="hljs-number">7</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">8</span>,<span class="hljs-number">1</span>]]<br>输出：<span class="hljs-number">3</span><br>解释：<br>上图为输入对应的图，横坐标表示日期，纵坐标表示价格。<br>以下 <span class="hljs-number">3</span> 个线段可以表示折线图：<br>- 线段 1 （红色）从 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 2 （蓝色）从 <span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 。<br>- 线段 3 （绿色）从 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> 到 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> ，经过 <span class="hljs-params">(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)</span> ，<span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>)</span> 和 <span class="hljs-params">(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>)</span> 。<br>可以证明，无法用少于 3 条线段表示这个折线图。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-05-25-00-59-13.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：stockPrices = <span class="hljs-comment">[<span class="hljs-comment">[3,4]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[7,8]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出：1<br>解释：<br>如上图所示，折线图可以用一条线段表示。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= stockPrices.length &lt;= 10^5</code></li><li><code>stockPrices[i].length == 2</code></li><li><code>1 &lt;= day_i, price_i &lt;= 10^9</code></li><li>所有 <code>day_i</code> 互不相同 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumLines</span>(<span class="hljs-params">self, stockPrices: <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>]]</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stockPrices) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        stockPrices.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <span class="hljs-comment"># print(stockPrices)</span><br>        k = <span class="hljs-number">0</span><br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(stockPrices)):<br>            tmp = Decimal(stockPrices[i][<span class="hljs-number">1</span>] - stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) / Decimal((stockPrices[i][<span class="hljs-number">0</span>] - stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]))<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            prev = Decimal(stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - stockPrices[i-<span class="hljs-number">2</span>][<span class="hljs-number">1</span>])/ Decimal(stockPrices[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - stockPrices[i-<span class="hljs-number">2</span>][<span class="hljs-number">0</span>])<br><br>            <span class="hljs-keyword">if</span> prev == tmp:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                res += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>数学</tag>
      
      <tag>几何</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>293场LeetCode周赛</title>
    <link href="/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh</p><p>第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><p>第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><p>第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p>第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了；</p><span id="more"></span><h1 id="第一题：5234-移除字母异位词后的结果数组"><a href="#第一题：5234-移除字母异位词后的结果数组" class="headerlink" title="第一题：5234.移除字母异位词后的结果数组"></a>第一题：5234.移除字母异位词后的结果数组</h1><p><a href="https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p><p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 <strong>删除</strong> <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p><ol><li><code>0 &lt; i &lt; words.length</code></li><li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li></ol><p>只要可以选出满足条件的下标，就一直执行这个操作。</p><p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>&quot;dacb&quot;</code> 是 <code>&quot;abdc&quot;</code> 的一个字母异位词。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;baba&quot;</span>,<span class="hljs-string">&quot;bbaa&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]<br>输出：[<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>]<br>解释：<br>获取结果数组的方法之一是执行下述步骤：<br>- 由于 words[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;bbaa&quot;</span> 和 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;baba&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">2</span> 并删除 words[<span class="hljs-number">2</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;baba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>- 由于 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;baba&quot;</span> 和 words[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;abba&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">1</span> 并删除 words[<span class="hljs-number">1</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>- 由于 words[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;cd&quot;</span> 和 words[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;cd&quot;</span> 是字母异位词，选择下标 <span class="hljs-number">2</span> 并删除 words[<span class="hljs-number">2</span>] 。<br>  现在 words = [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 。<br>无法再执行任何操作，所以 [<span class="hljs-string">&quot;abba&quot;</span>,<span class="hljs-string">&quot;cd&quot;</span>] 是最终答案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>]<br>输出：[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-string">&quot;e&quot;</span>]<br>解释：<br><span class="hljs-built_in">words</span> 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeAnagrams</span>(<span class="hljs-params">self, words</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type words: List[str]</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        i = <span class="hljs-number">1</span><br>        res = []<br>        init_cnt = Counter(words[<span class="hljs-number">0</span>])<br>        res.append(words[<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(words):<br>            <span class="hljs-keyword">if</span> Counter(words[i]) == init_cnt:<br>                i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                init_cnt = Counter(words[i])<br>                res.append(words[i])<br>                i += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：6064-不含特殊楼层的最大连续楼层数"><a href="#第二题：6064-不含特殊楼层的最大连续楼层数" class="headerlink" title="第二题：6064.不含特殊楼层的最大连续楼层数"></a>第二题：6064.不含特殊楼层的最大连续楼层数</h1><p><a href="https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p><p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示  Alice 指定用于放松的特殊楼层。</p><p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：bottom = 2, top = 9, special = [4,6]<br>输出：3<br>解释：下面列出的是不含特殊楼层的连续楼层范围：<br>- (2, 3) ，楼层数为<span class="hljs-number"> 2 </span>。<br>- (5, 5) ，楼层数为<span class="hljs-number"> 1 </span>。<br>- (7, 9) ，楼层数为<span class="hljs-number"> 3 </span>。<br>因此，返回最大连续楼层数<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：<span class="hljs-built_in">bottom</span> = <span class="hljs-number">6</span>, <span class="hljs-built_in">top</span> = <span class="hljs-number">8</span>, special = [<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]<br>输出：<span class="hljs-number">0</span><br>解释：每层楼都被规划为特殊楼层，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示</p><ul><li><code>1 &lt;= special.length &lt;= 10^5</code></li><li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10^9</code></li><li><code>special</code> 中的所有值 互不相同</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxConsecutive</span>(<span class="hljs-params">self, bottom, top, special</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bottom: int</span><br><span class="hljs-string">        :type top: int</span><br><span class="hljs-string">        :type special: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        special.append(bottom-<span class="hljs-number">1</span>)<br>        special.append(top+<span class="hljs-number">1</span>)<br>        special.sort()<br>        <br>        <span class="hljs-built_in">print</span>(special)<br>        res = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(special)):<br>            res = <span class="hljs-built_in">max</span>(res, special[i]-special[i-<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6065-按位与结果大于零的最长组合"><a href="#第三题：6065-按位与结果大于零的最长组合" class="headerlink" title="第三题：6065.按位与结果大于零的最长组合"></a>第三题：6065.按位与结果大于零的最长组合</h1><p><a href="https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>对数组 <code>nums</code> 执行 <strong>按位与</strong> 相当于对数组 <code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p><ul><li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li><li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li></ul><p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p><p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [16,17,71,62,12,24,14]<br>输出：4<br>解释：组合 [16,17,62,24] 的按位与结果是<span class="hljs-number"> 16 </span>&amp;<span class="hljs-number"> 17 </span>&amp;<span class="hljs-number"> 62 </span>&amp;<span class="hljs-number"> 24 </span>=<span class="hljs-number"> 16 </span>&gt;<span class="hljs-number"> 0 </span>。<br>组合长度是<span class="hljs-number"> 4 </span>。<br>可以证明不存在按位与结果大于<span class="hljs-number"> 0 </span>且长度大于<span class="hljs-number"> 4 </span>的组合。<br>注意，符合长度最大的组合可能不止一种。<br>例如，组合 [62,12,24,14] 的按位与结果是<span class="hljs-number"> 62 </span>&amp;<span class="hljs-number"> 12 </span>&amp;<span class="hljs-number"> 24 </span>&amp;<span class="hljs-number"> 14 </span>=<span class="hljs-number"> 8 </span>&gt;<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [8,8]<br>输出：2<br>解释：最长组合是 [8,8] ，按位与结果<span class="hljs-number"> 8 </span>&amp;<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 8 </span>&gt;<span class="hljs-number"> 0 </span>。<br>组合长度是<span class="hljs-number"> 2 </span>，所以返回<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= candidates.length &lt;= 10^5</code></li><li><code>1 &lt;= candidates[i] &lt;= 10^7</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p><img src="/images/2022-05-16-10-17-08.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestCombination</span>(<span class="hljs-params">self, candidates</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        candidates.sort()<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">convert_to_bin</span>(<span class="hljs-params">num, pad=<span class="hljs-number">31</span></span>):<br>            tmp_list = []<br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                tmp_list.append(num&amp;<span class="hljs-number">1</span>)<br>                num &gt;&gt;= <span class="hljs-number">1</span><br>            <br>            tmp_list.reverse()<br>            tmp_list = [<span class="hljs-number">0</span>] * (pad-<span class="hljs-built_in">len</span>(tmp_list)) + tmp_list<br>            <br>            <span class="hljs-keyword">return</span> tmp_list<br>        <br>        a = []<br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(candidates)):<br>            a.append(convert_to_bin(candidates[i]))<br>            <span class="hljs-comment"># print(candidates[i], convert_to_bin(candidates[i]))</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a[<span class="hljs-number">0</span>])):<br>            tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(a)):<br>                <span class="hljs-keyword">if</span> a[i][j] == <span class="hljs-number">1</span>:<br>                    tmp += <span class="hljs-number">1</span><br>            res = <span class="hljs-built_in">max</span>(res, tmp)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>HARD</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>292场LeetCode周赛</title>
    <link href="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 <code>22222</code> 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 <code>@lru_cache(1000*1000)</code> 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg</p><p>第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p>第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a>，<strong>注意这个题的优化剪枝！</strong></p><span id="more"></span><h1 id="第一题：6056-字符串中最大的-3-位相同数字"><a href="#第一题：6056-字符串中最大的-3-位相同数字" class="headerlink" title="第一题：6056.字符串中最大的 3 位相同数字"></a>第一题：6056.字符串中最大的 3 位相同数字</h1><p><a href="https://leetcode.cn/problems/largest-3-same-digit-number-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p><ul><li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li><li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li></ul><p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li><strong>子字符串</strong> 是字符串中的一个连续字符序列。</li><li><code>num</code> 或优质整数中可能存在 <strong>前导零</strong> 。</li></ul><p>示例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-string">&quot;6777133339&quot;</span><br>输出：<span class="hljs-string">&quot;777&quot;</span><br>解释：<span class="hljs-built_in">num</span> 中存在两个优质整数：<span class="hljs-string">&quot;777&quot;</span> 和 <span class="hljs-string">&quot;333&quot;</span> 。<br><span class="hljs-string">&quot;777&quot;</span> 是最大的那个，所以返回 <span class="hljs-string">&quot;777&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：num <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2300019&quot;</span><br>输出：<span class="hljs-string">&quot;000&quot;</span><br>解释：<span class="hljs-string">&quot;000&quot;</span> 是唯一一个优质整数。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：num <span class="hljs-operator">=</span> <span class="hljs-string">&quot;42352338&quot;</span><br>输出：<span class="hljs-string">&quot;&quot;</span><br>解释：不存在长度为 <span class="hljs-number">3</span> 且仅由一个唯一数字组成的整数。因此，不存在优质整数。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= num.length &lt;= 1000</code></li><li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>另外来说的话，三个数是一样的，水仙花数hh！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestGoodInteger</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num)-<span class="hljs-number">2</span>):<br>            tmp = num[i:i+<span class="hljs-number">3</span>]<br>            <span class="hljs-keyword">if</span> tmp[<span class="hljs-number">0</span>] == tmp[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> tmp[<span class="hljs-number">1</span>] == tmp[<span class="hljs-number">2</span>]:<br>                res = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">int</span>(tmp), res)<br>        <br>        <span class="hljs-keyword">if</span> res == -<span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">3</span> - <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(res))) * <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-built_in">str</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：6057-统计值等于子树平均值的节点数"><a href="#第二题：6057-统计值等于子树平均值的节点数" class="headerlink" title="第二题：6057.统计值等于子树平均值的节点数"></a>第二题：6057.统计值等于子树平均值的节点数</h1><p><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵二叉树的根节点 <code>root</code> ，找出并返回满足要求的节点数，要求节点的值等于其 <strong>子树</strong> 中值的 <strong>平均值</strong> 。</p><p>注意：</p><ul><li><code>n</code> 个元素的平均值可以由 <code>n</code> 个元素 <strong>求和</strong> 然后再除以 <code>n</code> ，并 <strong>向下舍入</strong> 到最近的整数。</li><li><code>root</code> 的 <strong>子树</strong> 由 <code>root</code> 和它的所有后代组成。</li></ul><p>示例 1：</p><p><img src="/images/2022-05-08-21-27-52.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [4,8,5,0,1,null,6]<br>输出：5<br>解释：<br>对值为<span class="hljs-number"> 4 </span>的节点：子树的平均值 (4 +<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 1 </span>+ 6) /<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 24 </span>/<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 4 </span>。<br>对值为<span class="hljs-number"> 5 </span>的节点：子树的平均值 (5 + 6) /<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 11 </span>/<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>。<br>对值为<span class="hljs-number"> 0 </span>的节点：子树的平均值<span class="hljs-number"> 0 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 0 </span>。<br>对值为<span class="hljs-number"> 1 </span>的节点：子树的平均值<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 1 </span>。<br>对值为<span class="hljs-number"> 6 </span>的节点：子树的平均值<span class="hljs-number"> 6 </span>/<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 6 </span>。<br></code></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/images/2022-05-08-21-28-58.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1]<br>输出：1<br>解释：对值为<span class="hljs-number"> 1 </span>的节点：子树的平均值<span class="hljs-number"> 1 </span>/<span class="hljs-number"> 1 </span>= 1。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>写一个函数是 <code>count_mean</code> 然后再在dfs中把这个套进去！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.cnt = <span class="hljs-number">0</span><br>        self.val_sum = <span class="hljs-number">0</span><br>        self.res = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">averageOfSubtree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Optional[TreeNode]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">count_mean</span>(<span class="hljs-params">root</span>):  <span class="hljs-comment"># 统计一个子树的均值</span><br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            self.val_sum += root.val<br>            self.cnt += <span class="hljs-number">1</span><br>            count_mean(root.left)<br>            count_mean(root.right)<br>        <br>        <br>        <span class="hljs-comment"># 外面再套一层dfs？</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <br>            self.val_sum = <span class="hljs-number">0</span><br>            self.cnt = <span class="hljs-number">0</span><br>            count_mean(root)<br>            <span class="hljs-keyword">if</span> self.val_sum/self.cnt == root.val:<br>                self.res += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(self.cnt)</span><br>            <span class="hljs-comment"># print(self.val_sum)</span><br>            dfs(root.left)<br>            dfs(root.right)<br>        <br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.res<br></code></pre></td></tr></table></figure><h1 id="第三题：6058-统计打字方案数"><a href="#第三题：6058-统计打字方案数" class="headerlink" title="第三题：6058.统计打字方案数"></a>第三题：6058.统计打字方案数</h1><p><a href="https://leetcode.cn/problems/count-number-of-texts/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 在给 Bob 用手机打字。数字到字母的 <strong>对应</strong> 如下图所示。</p><p><img src="/images/2022-05-08-21-36-14.png"></p><p>为了 <strong>打出</strong> 一个字母，Alice 需要 <strong>按</strong> 对应字母 <code>i</code> 次，<code>i</code> 是该字母在这个按键上所处的位置。</p><ul><li>比方说，为了按出字母 <code>&#39;s&#39;</code> ，Alice 需要按 <code>&#39;7&#39;</code> 四次。类似的， Alice 需要按 <code>&#39;5&#39;</code> 两次得到字母  <code>&#39;k&#39;</code> 。</li><li>注意，数字 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 不映射到任何字母，所以 Alice <strong>不</strong> 使用它们。</li></ul><p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 <strong>按键的字符串信息</strong> 。</p><ul><li>比方说，Alice 发出的信息为 <code>&quot;bob&quot;</code> ，Bob 将收到字符串 <code>&quot;2266622&quot;</code> 。</li></ul><p>给你一个字符串 <code>pressedKeys</code> ，表示 Bob 收到的字符串，请你返回 Alice <strong>总共可能发出多少种文字信息</strong> 。</p><p>由于答案可能很大，将它对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">pressedKeys</span> = <span class="hljs-string">&quot;22233&quot;</span><br>输出：<span class="hljs-number">8</span><br>解释：<br>Alice 可能发出的文字信息包括：<br><span class="hljs-string">&quot;aaadd&quot;</span>, <span class="hljs-string">&quot;abdd&quot;</span>, <span class="hljs-string">&quot;badd&quot;</span>, <span class="hljs-string">&quot;cdd&quot;</span>, <span class="hljs-string">&quot;aaae&quot;</span>, <span class="hljs-string">&quot;abe&quot;</span>, <span class="hljs-string">&quot;bae&quot;</span> 和 <span class="hljs-string">&quot;ce&quot;</span> 。<br>由于总共有 <span class="hljs-number">8</span> 种可能的信息，所以我们返回 <span class="hljs-number">8</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;<br>输出：82876089<br>解释：<br>总共有<span class="hljs-number"> 2082876103 </span>种 Alice 可能发出的文字信息。<br>由于我们需要将答案对<span class="hljs-number"> 109 </span>+<span class="hljs-number"> 7 </span>取余，所以我们返回<span class="hljs-number"> 2082876103 </span>% (109 + 7) =<span class="hljs-number"> 82876089 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= pressedKeys.length &lt;= 10^5</code></li><li><code>pressedKeys</code> 只包含数字 <code>&#39;2&#39;</code> 到 <code>&#39;9&#39;</code> 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p><img src="/images/2022-05-08-21-43-04.png"></p><p>另外在代码实现上，发现直接初始化所有的这种类似于离线的操作可能会超时，所以来说的话还是写了一版动态的思路，参照之前的经验，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countTexts</span>(<span class="hljs-params">self, pressedKeys</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type pressedKeys: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">        # 写法1，方法应该没问题，但是初始化的时候太耗时了，可能就被边界卡了</span><br><span class="hljs-string">        if len(pressedKeys) == 0:</span><br><span class="hljs-string">            return 0</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        max_len = len(pressedKeys) + 5</span><br><span class="hljs-string">        MOD = 10**9 + 7</span><br><span class="hljs-string"></span><br><span class="hljs-string">        # 这个过程有点太耗时了，这里可能要换一种动态的写法，因为太多位置是没用的了？</span><br><span class="hljs-string">        # 非7，9的递推方程</span><br><span class="hljs-string">        f_1 = [0] * max_len  # 写不写成for好像没区别</span><br><span class="hljs-string">        f_1[1], f_1[2], f_1[3] = 1, 2, 4</span><br><span class="hljs-string">        # 7，9的递推方程</span><br><span class="hljs-string">        f_2 = [0] * max_len</span><br><span class="hljs-string">        f_2[1], f_2[2], f_2[3], f_2[4] = 1, 2, 4, 8</span><br><span class="hljs-string">        # 简化为一个循环</span><br><span class="hljs-string">        for i in range(4, max_len):</span><br><span class="hljs-string">            f_1[i] = f_1[i-1] + f_1[i-2] + f_1[i-3]</span><br><span class="hljs-string">            if i != 4:</span><br><span class="hljs-string">                f_2[i] = f_2[i-1] + f_2[i-2] + f_2[i-3] + f_2[i-4]</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        # 开始分组统计</span><br><span class="hljs-string">        res = 1</span><br><span class="hljs-string">        pressedKeys += &#x27;#&#x27;  # 哨兵</span><br><span class="hljs-string">        now_str = pressedKeys[0]</span><br><span class="hljs-string">        cnt = 1</span><br><span class="hljs-string">        i = 1</span><br><span class="hljs-string">        while i &lt; len(pressedKeys):</span><br><span class="hljs-string">            if pressedKeys[i] == now_str:</span><br><span class="hljs-string">                cnt += 1</span><br><span class="hljs-string">            else:</span><br><span class="hljs-string">                if now_str == &#x27;7&#x27; or now_str == &#x27;9&#x27;:</span><br><span class="hljs-string">                    res *= f_2[cnt] % MOD</span><br><span class="hljs-string">                else:</span><br><span class="hljs-string">                    res *= f_1[cnt] % MOD</span><br><span class="hljs-string">                cnt = 1</span><br><span class="hljs-string">                now_str = pressedKeys[i]</span><br><span class="hljs-string">            i += 1</span><br><span class="hljs-string"></span><br><span class="hljs-string">        return res % MOD</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 写法2，把写法1的方法转成动态的，或者相对更加记忆化一点</span><br>        f_1 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]  <span class="hljs-comment"># 角标直接对应上</span><br>        f_2 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>]<br>        i = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">1</span><br>        pressedKeys += <span class="hljs-string">&#x27;#&#x27;</span><br>        now_str = pressedKeys[<span class="hljs-number">0</span>]<br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(pressedKeys):<br>            <span class="hljs-keyword">if</span> pressedKeys[i] == now_str:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> now_str == <span class="hljs-string">&#x27;7&#x27;</span> <span class="hljs-keyword">or</span> now_str == <span class="hljs-string">&#x27;9&#x27;</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        res *= f_2[cnt]<br>                    <span class="hljs-keyword">except</span>:<br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(f_2), cnt+<span class="hljs-number">1</span>):<br>                            <span class="hljs-comment"># 注，这里实际上不推荐append的写法，最好是初始化一个很长的，往里填</span><br>                            f_2.append(f_2[j-<span class="hljs-number">1</span>] + f_2[j-<span class="hljs-number">2</span>] + f_2[j-<span class="hljs-number">3</span>] + f_2[j-<span class="hljs-number">4</span>])<br>                        res *= f_2[cnt]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        res *= f_1[cnt]<br>                    <span class="hljs-keyword">except</span>:<br>                        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(f_1), cnt+<span class="hljs-number">1</span>):<br>                            f_1.append(f_1[j-<span class="hljs-number">1</span>] + f_1[j-<span class="hljs-number">2</span>] + f_1[j-<span class="hljs-number">3</span>])<br>                        res *= f_1[cnt]<br>                cnt = <span class="hljs-number">1</span><br>                now_str = pressedKeys[i]<br>            i += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> res % (<span class="hljs-number">10</span>**<span class="hljs-number">9</span> + <span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h1 id="第四题：6059-检查是否有合法括号字符串路径"><a href="#第四题：6059-检查是否有合法括号字符串路径" class="headerlink" title="第四题：6059.检查是否有合法括号字符串路径"></a>第四题：6059.检查是否有合法括号字符串路径</h1><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p><ul><li>字符串是 <code>()</code> 。</li><li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li><li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li></ul><p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p><ul><li>路径开始于左上角格子 <code>(0, 0)</code> 。</li><li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li><li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li><li>路径经过的格子组成的括号字符串是 <strong>合法</strong> 的。</li></ul><p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="/images/2022-05-08-21-49-28.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>],[<span class="hljs-string">&quot;)&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>],[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>],[<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;(&quot;</span>,<span class="hljs-string">&quot;)&quot;</span>]]<br>输出：true<br>解释：上图展示了两条路径，它们都是合法括号字符串路径。<br>第一条路径得到的合法字符串是 <span class="hljs-string">&quot;()(())&quot;</span> 。<br>第二条路径得到的合法字符串是 <span class="hljs-string">&quot;((()))&quot;</span> 。<br>注意可能有其他的合法括号字符串路径。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-05-08-21-50-00.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：两条可行路径分别得到 <span class="hljs-string">&quot;))(&quot;</span> 和 <span class="hljs-string">&quot;)((&quot;</span> 。由于它们都不是合法括号字符串，我们返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>grid[i][j]</code> 要么是 <code>&#39;(&#39;</code> ，要么是 <code>&#39;)&#39;</code> 。</li></ul><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a></p><p>在优化剪枝上，一种是 <code>@lru_cache(1000*1000)</code> 靠着编译器来优化，另外一种是记录visited数组，类似于下面图里写的意思，还有就是说匹配上的括号长度一定是 <strong>偶数</strong> 的：</p><p><img src="/images/2022-05-08-21-56-39.png"></p><p>这个题还遇到很多玄学问题，就是说两个优化都加上就过不了，但是只留其中一个优化就可以。。。dfs结构还是比较简单的！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.flag = <span class="hljs-literal">False</span><br>        self.already_true = &#123;&#125;<br>        self.grid = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasValidPath</span>(<span class="hljs-params">self, grid:<span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[str]]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 只能往下，或者往右移动</span><br>        dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>        n = <span class="hljs-built_in">len</span>(grid)<br>        m = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        self.grid = grid  <span class="hljs-comment"># n,m实际上也可以搞到self.里去</span><br><br>        <span class="hljs-keyword">if</span> (n+m) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><span class="hljs-meta">        @lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, y:<span class="hljs-built_in">int</span>, left_kh_cnt:<span class="hljs-built_in">int</span>, n:<span class="hljs-built_in">int</span>, m:<span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> left_kh_cnt &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> <br><br>            <span class="hljs-comment"># 剪枝条件是，路径上某个位置，在相同left_kh_cnt条件下，是否出现过了</span><br>            <span class="hljs-comment"># 这里原理上的解释是</span><br>            <span class="hljs-keyword">if</span> self.already_true.get((x,y,left_kh_cnt)) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                self.already_true[(x,y,left_kh_cnt)] = <span class="hljs-literal">True</span><br>                <span class="hljs-comment"># print(&quot;self.already_true: &quot;, self.already_true)</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <br><br>            <span class="hljs-keyword">if</span> x == n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y == m-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> left_kh_cnt == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 恰好匹配</span><br>                self.flag = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">return</span> <br>            <br><br>            <span class="hljs-comment"># 1. 先写dfs逻辑，剩下逻辑随之适配</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; n <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; m: <br>                    <span class="hljs-keyword">if</span> self.grid[nx][ny] == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                        dfs(nx, ny, left_kh_cnt+<span class="hljs-number">1</span>, n, m)<br>                    <span class="hljs-keyword">else</span>:<br>                        dfs(nx, ny, left_kh_cnt-<span class="hljs-number">1</span>, n, m)<br><br>        <span class="hljs-keyword">if</span> self.grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> self.grid[-<span class="hljs-number">1</span>][-<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;(&#x27;</span>:<br>            dfs(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, n, m)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> self.flag<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
      <tag>哈希表</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~</p><p>另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~</p><p><a href="https://c.runoob.com/front-end/854/">菜鸟工具在线正则表达式验证工具</a></p><span id="more"></span><p>菜鸟工具在线正则表达式验证工具:<a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><h1 id="正则总结"><a href="#正则总结" class="headerlink" title="正则总结"></a>正则总结</h1><h2 id="匹配数字相关"><a href="#匹配数字相关" class="headerlink" title="匹配数字相关"></a>匹配数字相关</h2><p><code>\d</code> 是匹配一个数字（0到9），在程序实现上一般需要再用 <code>\</code> 转义一下，即 <code>\\d</code></p><p>如果要匹配多个数字的话，就使用 <code>\\d+</code>，这里 <code>+</code> 代表一个或者多个</p><p>如果要匹配小数，中间带着小数点 <code>.</code> 的话，就是 <code>\\d+.\\d+</code>，注意这里还没有加入正负号的匹配</p><h2 id="加号-与乘号"><a href="#加号-与乘号" class="headerlink" title="加号 + 与乘号 *"></a>加号 <code>+</code> 与乘号 <code>*</code></h2><p><code>*</code> 表示匹配前面的字符0个或多个</p><p><code>+</code> 表示前面的字符1个或多个</p><h2 id="问号"><a href="#问号" class="headerlink" title="问号 ?"></a>问号 <code>?</code></h2><p>直接跟在表达式后面，表示匹配前面的一次或者零次，类似于{0, 1}的用法，<code>[+-]&#123;0,1&#125;\\d+.\\d+</code> 和  <code>[+-]?\\d+.\\d+</code> 应该是等价的意思，匹配前面有没有+-这些符号</p><h2 id="指数符-和-dollar符"><a href="#指数符-和-dollar符" class="headerlink" title="指数符^ 和 dollar符 $"></a>指数符<code>^</code> 和 dollar符 <code>$</code></h2><p><code>^</code> 用来匹配起始位置，<code>$</code> 用来匹配结束位置，配合使用一般用作检验，比如检验一段文本是否只包含数字 <code>^[0-9]*$</code></p><p>如果 <code>^</code> 使用在中括号中，则有一种not的感觉</p><h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号 ()"></a>小括号 <code>()</code></h2><p>小括号起到了一种组的概念，首先可以按照顺序使用 <code>\\1</code>，<code>\\2</code> 进行访问匹配，例如在html&#x2F;xml标签的匹配中，可以用 <code>&lt;(div)&gt;[^&lt;]*&lt;/\\1&gt;</code> 来进行匹配div标签，这样中间 <code>[^&lt;]*</code> 的意思就是匹配不是 <code>&lt;</code> 的任意字符，后边的 <code>&lt;/\\1&gt;</code> 能够自动对应到尾部标签去；注意这样的可能存在的嵌套关系匹配替换，可以每次循环迭代把内层的不断替换成一些特殊字符或者空，直到匹配不到为止；</p><p><img src="/images/2022-05-06-15-11-31.png"></p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bnf">text: <span class="hljs-attribute">&lt;div&gt;</span><span class="hljs-attribute">&lt;font color=&#x27;red&#x27;&gt;</span>hello, world<span class="hljs-attribute">&lt;/font&gt;</span><span class="hljs-attribute">&lt;div&gt;</span>tmp2<span class="hljs-attribute">&lt;/div&gt;</span><span class="hljs-attribute">&lt;/div&gt;</span><br><br>re: <span class="hljs-attribute">&lt;(div)&gt;</span>[^<span class="hljs-attribute">&lt;]*&lt;/\1&gt;</span><br><br>result: <span class="hljs-attribute">&lt;div&gt;</span>tmp2<span class="hljs-attribute">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure><h2 id="中括号-与竖线"><a href="#中括号-与竖线" class="headerlink" title="中括号 [] 与竖线 |"></a>中括号 <code>[]</code> 与竖线 <code>|</code></h2><p>中括号用来匹配单个字符，是否属于中括号中的一个字符 <code>[0-9]</code> <code>[A-Z]</code> 这样都也是可以的，注意如果待正则匹配的内容中已经具有中括号（其他括号也是同理），需要用 <code>\[</code> 把其他待匹配的做一个转义的感觉</p><p>竖线 <code>|</code> 就是一个或的意思，虽然不知道为什么要和中括号写在一个类别hhh，感觉使用场景上来说还是很灵活的</p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号 {}"></a>大括号 <code>&#123;&#125;</code></h2><p>匹配出现几次那种感觉，例如 <code>\\d&#123;1,3&#125;</code> 就是匹配出现一段文本中1次到3次的数字，这里还可以补充一下问号 <code>?</code> 的作用，有一种最小匹配的感觉</p><p><img src="/images/2022-05-06-15-33-31.png"></p><p><img src="/images/2022-05-06-15-33-47.png"></p><p><font color="red">好了，1+1&#x3D;2学会（废）了！开始搞题！</font></p><h1 id="BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断"><a href="#BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断" class="headerlink" title="BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断"></a>BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断</h1><p><a href="http://bjutacm.openjudge.cn/lianxi/lq17I/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>于是由于各种各样的原因, 出现了一个叹号。</p><p>我们都已经看到了工具下载及比赛规则的地址是 <a href="http://172.21.17.211/">http://172.21.17.211/</a></p><p>下面你就来判断一下一个网址是否符合 <a href="http://a.b.c.d/">http://a.b.c.d/</a> 的格式吧。 (a, b, c, d 均为长度在 [1, 5] 且由数字 0-9 构成的字符串)</p><p>输入<br>一行字符串。 长度小于50。</p><p>输出<br>如果输入符合要求。 输出 “Yes”。<br>否则输出 “No” 。</p><p>(输出不含引号)</p><p>样例输入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">172.21</span>.<span class="hljs-number">17.211</span>/<br></code></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Yes</span><br></code></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题对自己影响是真的大，当年蓝桥预选赛靠着这个题在大一上从毫无基础的小白就到学校预选赛的前30名，用C语言一条规则一条规则的适配，AC的那一刻真是最难忘的会议之一~</p><p>现在再来做这个题的话，过了这么多年了，发现用非常简单的正则就能写出来，也就把题总结在这里了~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;http://[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;/&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    input_str = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>())<br>    tmp_str = re.sub(pattern, <span class="hljs-string">&#x27;&#x27;</span>, input_str)<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tmp_str) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Yes&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65.有效数字"></a>65.有效数字</h1><p><a href="https://leetcode.cn/problems/valid-number/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></p><p>部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;0&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;e&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;.&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题要分两部分考虑，首先考虑单独表示一个整数或者小数，然后再考虑科学计数法的内容，科学计数法就是 <code>e-5</code> 或者 <code>e10</code> 这样的</p><p>单独考虑整数： <code>[+-]&#123;0,1&#125;\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代）， <code>&#123;0,1&#125;</code>，<code>\\d+</code> 匹配整数；</p><p>考虑小数，情况1： <code>[+-]&#123;0,1&#125;\\d+\\.\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代），后面是 <code>x.x</code> 形式的小数；</p><p>考虑小数，情况2： <code>[+-]&#123;0,1&#125;\\d+\\.</code><br>解释：后面是 <code>x.</code> 形式的小数；</p><p>考虑小数，情况3： <code>[+-]&#123;0,1&#125;\\.\\d+</code><br>解释：后面是 <code>.x</code> 形式的小数；</p><p>然后考虑科学计数法，即 <strong>从e开始后面的位置</strong> ，情况有： </p><p><code>[eE][+-]?×</code> -&gt; 不能带小数点，因为不能是e2.5次方这样的，所以正则的写法为 <code>([eE][+-]?\\d+)?</code> ，这里只能匹配一次，所以要把整体的带上括号</p><p><font color="red">※</font>合并上述内容，前边的必须有，科学计数法不一定要有：</p><p><code>(([+-]?\\d+)|([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>这里还有个坑的内容，例如对于 <code>3.</code> 这种case，如果把整数的匹配写在前面，那么只会优先匹配到 <code>3</code> 了，所以要把小数写在前面，整数写在后面</p><p><code>(([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+)|([+-]?\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>补充还有个坑的地方，就是说 <code>1+3</code> 这种case，在后面的话小数部分应该写成 <code>([eE][+-]?\\d+)?</code> ，而不能写成多一个问号 <code>([eE]?[+-]?\\d+)?</code> 只有出现了e或者E，才能让+-出现0或1次</p><p>非转义的final写法： <code>(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?</code></p><p>代码如下所示，这里的注意点是</p><ol><li><code>re.compile(ur&#39;&#39;)</code> 就可以不用转义各个字符了，转义还是个考虑的重点问题；</li><li>替换成一个特殊字符 <code>#</code> ，最后可以用这个特殊字符做一些判断，避免单个 <code>e</code> 一类的问题；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isNumber</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">import</span> re<br>        <br>        pattern = re.<span class="hljs-built_in">compile</span>(u<span class="hljs-string">r&#x27;(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?&#x27;</span>)  <span class="hljs-comment"># 这里不用转义了</span><br>        tmp_s = re.sub(pattern, <span class="hljs-string">&quot;#&quot;</span>, s)<br>        <br>        <span class="hljs-keyword">if</span> tmp_s != <span class="hljs-string">&#x27;#&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="591-标签验证器"><a href="#591-标签验证器" class="headerlink" title="591.标签验证器"></a>591.标签验证器</h1><p><a href="https://leetcode.cn/problems/tag-validator/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p><ol><li>代码必须被 <strong>合法的闭合标签包围</strong> 。否则，代码是无效的。</li><li><strong>闭合标签</strong> （不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code> 。其中，<code>&lt;TAG_NAME&gt;</code> 是起始标签，<code>&lt;/TAG_NAME&gt;</code> 是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是 <strong>合法的</strong> 。</li><li><strong>合法的</strong> <code>TAG_NAME</code> <strong>仅含有大写字母</strong>，长度在范围 [1,9] 之间。否则，该 <code>TAG_NAME</code> 是不合法的。</li><li><strong>合法的</strong> <code>TAG_CONTENT</code> 可以包含其他 <strong>合法的闭合标签</strong> ，<strong>cdata</strong> （请参考规则7）和任意字符（注意参考规则1）除了不匹配的 <code>&lt;</code> 、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code> <strong>是不合法的</strong> 。</li><li>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li><li>一个 <code>&lt;</code> ，如果你找不到一个后续的 <code>&gt;</code> 与之匹配，是不合法的。并且当你找到一个 <code>&lt;</code> 或 <code>&lt;/</code> 时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。</li><li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。CDATA_CONTENT 的范围被定义成 <code>&lt;![CDATA[</code> <strong>和后续的第一个</strong> <code>]]&gt;</code> 之间的字符。</li><li><code>CDATA_CONTENT</code> 可以包含 <strong>任意字符</strong> 。cdata 的功能是阻止验证器解析 <code>CDATA_CONTENT</code> ，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为 <strong>常规字符</strong> 。</li></ol><p>合法代码的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml">输入: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>输出: True<br><br>解释: <br><br>代码被包含在了闭合的标签内： <span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span> 和 <span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span> 。<br><br>TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 <br><br>即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。<br><br>所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。<br><br><br>输入: &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>输出: True<br><br>解释:<br><br>我们首先将代码分割为： start_tag|tag_content|end_tag 。<br><br>start_tag -&gt; &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>end_tag -&gt; &quot;<span class="hljs-tag">&lt;/<span class="hljs-name">DIV</span>&gt;</span>&quot;<br><br>tag_content 也可被分割为： text1|cdata|text2 。<br><br>text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;<br><br>cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>]&gt;&quot;<br><br>text2 -&gt; &quot;]]&gt;&gt;]&quot;<br><br><br>start_tag 不是 &quot;<span class="hljs-tag">&lt;<span class="hljs-name">DIV</span>&gt;</span>&gt;&gt;&quot; 的原因参照规则 6 。<br>cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。<br></code></pre></td></tr></table></figure><p>不合法代码的例子：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bnf">输入: &quot;<span class="hljs-attribute">&lt;A&gt;</span>  <span class="hljs-attribute">&lt;B&gt;</span> <span class="hljs-attribute">&lt;/A&gt;</span>   <span class="hljs-attribute">&lt;/B&gt;</span>&quot;<br>输出: False<br>解释: 不合法。如果 &quot;<span class="hljs-attribute">&lt;A&gt;</span>&quot; 是闭合的，那么 &quot;<span class="hljs-attribute">&lt;B&gt;</span>&quot; 一定是不匹配的，反之亦然。<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  div tag is not closed  <span class="hljs-attribute">&lt;DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  unmatched <span class="hljs-attribute">&lt;  &lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span> closed tags with invalid tag name  <span class="hljs-attribute">&lt;b&gt;</span>123<span class="hljs-attribute">&lt;/b&gt;</span> <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span> unmatched tags with invalid tag name  <span class="hljs-attribute">&lt;/1234567890&gt;</span> and <span class="hljs-attribute">&lt;CDATA[[]]&gt;</span>  <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br><br>输入: &quot;<span class="hljs-attribute">&lt;DIV&gt;</span>  unmatched start tag <span class="hljs-attribute">&lt;B&gt;</span>  and unmatched end tag <span class="hljs-attribute">&lt;/C&gt;</span>  <span class="hljs-attribute">&lt;/DIV&gt;</span>&quot;<br>输出: False<br></code></pre></td></tr></table></figure><p>注意:</p><ul><li>为简明起见，你可以假设输入的代码（包括提到的 <strong>任意字符</strong> ）只包含 <code>数字</code>, <code>字母</code>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题还是挺难的，也是一种正则表达式的练习吧，总之对正则表达式又熟了一分，想法和题解就写在代码的注释里了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, code</span>):<br><br>        <span class="hljs-comment"># 使用正则表达式偷鸡了，正好作为一个正则表达式题目的练习了</span><br>        <span class="hljs-keyword">import</span> re<br><br>        <span class="hljs-comment"># 去掉CDATA字段变化为空，注意由于&#x27;[&#x27;括号字符在正则表达式中具有特殊的含义，所以要&#x27;\&#x27;字符完成转义</span><br>        <span class="hljs-comment"># 【badcase4】CDATA必须被标签包含</span><br>        <span class="hljs-comment"># 【badcase5】.*?和.*的区别？</span><br>        code_remove_cdata = re.sub(<span class="hljs-string">r&quot;&lt;!\[CDATA\[.*?\]\]&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code)<br>        <br>        <span class="hljs-comment"># 【badcase2】如果全是CDATA匹配到的就返回False</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(code_remove_cdata) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span><br>        <span class="hljs-comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span><br>        prev = code_remove_cdata<br>        code_remove_cdata_tag = re.sub(<span class="hljs-string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code_remove_cdata)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata: &quot;</span>, code_remove_cdata)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)<br><br>        <span class="hljs-comment"># 一直正则替换</span><br>        <span class="hljs-keyword">while</span> prev != code_remove_cdata_tag:  <br>            prev = code_remove_cdata_tag<br>            <span class="hljs-comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span><br>            <span class="hljs-comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span><br>            code_remove_cdata_tag = re.sub(<span class="hljs-string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="hljs-string">&quot;#&quot;</span>, code_remove_cdata_tag)<br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)<br>        <br>        <span class="hljs-keyword">if</span> code_remove_cdata_tag == <span class="hljs-string">&quot;#&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br><span class="hljs-comment"># if __name__ == &#x27;__main__&#x27;:</span><br><br><span class="hljs-comment">#     s = Solution()</span><br><span class="hljs-comment">#     code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span><br><br><span class="hljs-comment">#     # badcase1</span><br><span class="hljs-comment">#     # &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;  -&gt;  [^&lt;]*的问题，要求中甲不能匹配&lt;</span><br><br><span class="hljs-comment">#     # badcase2</span><br><span class="hljs-comment">#     # &quot;&lt;![CDATA[wahaha]]]&gt;&lt;![CDATA[]&gt; wahaha]]&gt;&quot; -&gt; 如果经过第一步处理后就空了，那就要返回False</span><br><br><span class="hljs-comment">#     # badcase3</span><br><span class="hljs-comment">#     # &quot;&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt;&quot; 要输出False</span><br><br><span class="hljs-comment">#     # badcase4</span><br><span class="hljs-comment">#     # &quot;&lt;![CDATA[ABC]]&gt;&lt;TAG&gt;sometext&lt;/TAG&gt;&quot;  CDATA必须被标签包含</span><br><br><span class="hljs-comment">#     # badcase5，.*和.*?还是有区别的，</span><br><span class="hljs-comment">#     # &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span><br><span class="hljs-comment">#     # 如果是.*匹配（贪婪匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span><br><span class="hljs-comment">#     # 如果是.*?匹配（最小匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;DIV&gt; &lt;A&gt;  #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span><br><br><br><span class="hljs-comment">#     print(&quot;output res: &quot;, s.isValid(code))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>273-283场LeetCode周赛总结</title>
    <link href="/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>273-283场LeetCode周赛综述&amp;总结：</p><p>LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢；</p><p>温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~</p><p>另外这里相对整理一下需要数据结构&#x2F;特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容；</p><p>总结来看主要有这些操作：</p><p>【前后缀和】【数学&amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;构造】【链表】【二分】【字符串】【水题】</p><span id="more"></span><h1 id="前后缀和"><a href="#前后缀和" class="headerlink" title="前后缀和"></a>前后缀和</h1><blockquote><p>前后缀和大概是因为每次都要统计相同的位置，那么就是每次在基础上做累加的操作来避免每次对于相同位置的统计；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><h1 id="数学-amp-找规律"><a href="#数学-amp-找规律" class="headerlink" title="数学&amp;找规律"></a>数学&amp;找规律</h1><blockquote><p>数学和找规律的题一般都要现场推，自己动手模拟下看看，也没什么太多复盘的思路，每次遇到的感觉都不会太一样；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><strong>283场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">2195.向数组中追加 K 个整数</a>，暴力哈希的思路还是比较好像，但实际上不能这样，还要往后补的思路，总结数学题来说就是每次现场推就行了，复盘的时候不用想的太明白；</p><h1 id="哈希表mapping"><a href="#哈希表mapping" class="headerlink" title="哈希表mapping"></a>哈希表mapping</h1><blockquote><p>哈希表是个简化时间复杂度的好东西，万物皆可哈希hhhh；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>275场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/">2135.统计追加字母可以获得的单词数</a>，这个题主要就是哈希表的思想，一方面来说 <strong>重排</strong> 这个事情可以在最开始的时候把大家都重排了这样一种预处理得到，另一方面来说set起到判重的作用，差一个字符上就是截断的拼接问题 <code>word[:i] + word[i+1:]</code> 这样可以把第i位的字符忽略掉，还是很难的这个题，这么看来说275场周赛的三个题都好难啊；</p><p><strong>277场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">2150.找出数组中的所有孤独数字</a>，这个题哈希表也太明显了，甚至有些情况够不上平常周赛第一题，第二题的难度，包装的也比较简单，其实可以算在水题里了；</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><blockquote><p>贪心的事情，不用想的那么明白哈哈哈哈；</p></blockquote><p><strong>274场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/destroying-asteroids/">2126.摧毁小行星</a>，这个题算是很简单的第三题啊，274场周赛没有实时做，不然来说的话应该是一个靠前三题能rank前1000内的比赛，就是直接暴力贪心就可以了，中间带一个简单的排序，名言之贪心的事情不用搞那么明白！；</p><p><strong>276场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">2139.得到目标值的最少行动次数</a>，从大往小贪心就可以了，如果是偶数就除，如果是奇数就减就行了；</p><p><strong>279场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">2165.重排数字的最小值</a>，这个题分正数负数贪心就可以了，前导0还是个约束条件；</p><p><strong>280场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">2170.使数组变成交替数组的最少操作数</a>，第二题还是不能想太复杂了，奇数偶数位，选出分别两边出现最多的，但是 <strong>不能相等的</strong>，当时把自己坑惨了啊，还是要仔细读题，读歪了那可真是掉沟里了；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><p><font color="red">※</font><strong>281场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/construct-string-with-repeat-limit/">2182.构造限制重复的字符串</a>，这个题真的难，不是特殊情况下一定不要往原地交换的思路想，要想往新构造的思路想，剩下就是贪心和随缘的面向答案编程了；</p><h1 id="Counter计数"><a href="#Counter计数" class="headerlink" title="Counter计数"></a>Counter计数</h1><blockquote><p>Counter是个很常用的数据结构，任何涉及到统计的的题目都可能会用到这个，不知道在其他语言Counter的对应是什么；</p></blockquote><p><font color="red">※</font><strong>275场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/">2133.检查是否每一行每一列都包含全部整数</a>，是个比较难的第一题，甚至感觉很多情况下难度超过了第二题，一方面是对一行&#x2F;一列取Counter计数的时候，应该是 <code>第i行：Counter(matrix[i])</code> 和 <code>第i列：Counter([matrix[x][i] for x in range(n)])</code>，另一方面来说Counter是可以加减，还有相比较的，这个是个很方便的特性不知道在其他语言里怎么使用这个内容，这个题的特色点在于只要遍历一次主对角线做Counter，就可以涵盖所有情况了；</p><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p>282场周赛第2题 <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/">2186.使两字符串互为字母异位词的最少步骤数</a>，经典Counter加减，莽过去！；</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>主要看题目是否本身暗含了一种窗口的思想在里面；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><blockquote><p>主要是简化实现上的操作，比如把环变成数组，还有就是针对起始位置还有终点位置的特殊处理；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p><strong>276场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">2138.将字符串拆分为若干长度为 k 的组</a>，也是水题但是可以通过哨兵补齐的思想，这样最后切分起来就很容易了，看了下当时的代码，不知道为什么当时能写那么复杂。。。；</p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><blockquote><p>一般按照题目来，跟着题目操作就可以；</p></blockquote><p><strong>273场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120.执行所有后缀指令</a>，使用 <code>[1:]</code> 不断截断，然后按照操作要求来模拟就行，这种题感觉也是不能着急，争取能在5分钟内完成第二题和第一题，要爆一下手速，第二题一般不会太难，不要太考虑时间复杂度的事情，想到方法基本就差不多了；</p><p><strong>274场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">2125.银行中的激光束数量</a>，感觉是题目理解相对比较长的第二题，第二题可能存在题面复杂类的问题，但是通过这个题来看不能着急读题，读完题最好一遍能理解题意，尽快做出来；</p><p><strong>280场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-operations-to-obtain-zero/">2169. 得到 0 的操作数</a>，两边来回减，按照题目的要求模拟就可以了；</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>还是要多刷，包括普通dp，区间dp等等，跟一波wls了；</p></blockquote><p><font color="red">※</font><strong>276场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">2140.解决智力问题</a>，这个题dp还是相对能看出来的？每个位置是选和不选两种状态，但是这个题只能让自己觉得自己智力有问题，dp第三题还是难，看来276和275场周赛是把自己给虐了，这个题要存 <strong>截止到当前位置的状态值！</strong></p><h1 id="状态压缩（2-n那种类型的题目）"><a href="#状态压缩（2-n那种类型的题目）" class="headerlink" title="状态压缩（2^n那种类型的题目）"></a>状态压缩（2^n那种类型的题目）</h1><blockquote><p>看数据范围有可能可以看出来是不是这类型的题目，特点就是每个状态下验证合理性的感觉吧；</p></blockquote><p><font color="red">※</font><strong>277场周赛第4题</strong> <a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">2151.基于陈述统计最多好人数</a>，还是比较难的，首先看数据范围如果是8，15这样比较小的数，那可能就要想能不能往2^n这种方向上做一做，这个题的关键思路还是当时室友给的，就是说：只需要判断假定所有说真话的人是否和条件有冲突就可以了，这种2^n很多情况都是判断每种情况是否合理的;</p><h1 id="设计-amp-构造"><a href="#设计-amp-构造" class="headerlink" title="设计&amp;构造"></a>设计&amp;构造</h1><blockquote><p>设计构造题目比较思路型，可能也是面试常考的题目，包括LRU也是设计类题目；</p></blockquote><p><strong>279场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/design-bitset/">2166.设计位集</a>，依照时间复杂度把一些能简化时间复杂度的操作转化为全局的，在 <code>__init__</code> 的时候设计全局变量，然后后边依照这个全局变量简化时间复杂度即可，设计的时候来说边设计应该就是能想到的；</p><p><font color="red">※</font><strong>283场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">2196.根据描述创建二叉树</a>，这种设计的题，要把每个节点做成一个哈希，然后用哈希再往里插入就可以了，构造的题目好像要用这种哈希是比较普遍的思路；</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表题还没在周赛见过太多，这个题是比较水的链表题；</p></blockquote><p><strong>281场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/">2181.合并零之间的节点</a>，链表模拟操作，操作过去就行了；</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><blockquote><p>二分边界情况判断，最后是left还是right是真的难，二分也可以做在每个情况下，O(n)的合理性验证吧；</p></blockquote><p><font color="red">※</font><strong>282场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">2187.完成旅途的最少时间</a>，自己想的时候没有看出来哪里可以二分，在大佬的提醒下二分验证每个时刻，O(n)判断judge是否合理，实际上有点像2^n那种题的验证思路了；</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote><p>字符串题目还是很多的，一方面要会a-z A-Z这种ord chr的转化，另外一方面也要自己多练习一些正则的题目；</p></blockquote><p><font color="red">※</font><strong>283场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">2194.Excel 表中某个范围内的单元格</a>，本来是个简单的二维遍历问题，但是居然不知道python怎么遍历字符。。。查了下是 <code>ord()</code> 把字符转数字, <code>chr()</code> 把数字转字符，这个还是要记住的，特别是一些a-z，A-Z的遍历题目；</p><h1 id="水题"><a href="#水题" class="headerlink" title="水题"></a>水题</h1><p><strong>273场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">2119.反转两次的数字</a>，稍微操作一下就可以完成这个模拟操作了，第一题千万注意的就是不要急躁，耐下心来一遍把题读完，然后2分钟之内刷出来；</p><p><strong>274场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">2124.检查是否所有 A 都在 B 之前</a>，标准水题，这种题感觉要半分钟读题，一分半内手速搞定暴力出来；</p><p><strong>277场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">2148.元素计数</a>，能看出来是和最大最小比就很容易了，读题还是要细心呀；</p><p><strong>277场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">2149.按符号重排数组</a>，甚至比很多第一题还简单，是相对比较简单的第二题了，直接拆成两个，不做原地操作就还是很简单的；</p><p><strong>279场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">2164.对奇偶下标分别排序</a>，这个题虽然是水题，但是可以学习python奇数偶数 <strong>下标位置</strong> 取值方法，<code>nums[::2]</code>取偶数，<code>nums[1:;2]</code>取奇数；</p><p><strong>281场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/">2180.统计各位数字之和为偶数的整数个数</a>，水题，写个judge函数搞过去就可以了；</p><p><strong>282场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/">2185.统计包含给定前缀的字符串</a>，python有 <code>str.startswith()</code> 函数，用这个就可以了；</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>291场LeetCode周赛</title>
    <link href="/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题；</p><p>感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙</p><p>第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><p>第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了；</p><p>第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了；</p><span id="more"></span><p>希望下次前1000名来得快一点，这次确实是题简单了</p><p><img src="/images/2022-05-02-09-13-42.png"></p><h1 id="第一题：6047-移除指定数字得到的最大结果"><a href="#第一题：6047-移除指定数字得到的最大结果" class="headerlink" title="第一题：6047.移除指定数字得到的最大结果"></a>第一题：6047.移除指定数字得到的最大结果</h1><p><a href="https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个表示某个正整数的字符串 <code>number</code> 和一个字符 <code>digit</code> 。</p><p>从 <code>number</code> 中 <strong>恰好</strong> 移除 <strong>一个</strong> 等于 <code>digit</code> 的字符后，找出并返回按 <strong>十进制</strong> 表示 <strong>最大</strong> 的结果字符串。生成的测试用例满足 <code>digit</code> 在 <code>number</code> 中出现至少一次。</p><p>示例1：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;123&quot;</span>, digit = <span class="hljs-string">&quot;3&quot;</span><br>输出：<span class="hljs-string">&quot;12&quot;</span><br>解释：<span class="hljs-string">&quot;123&quot;</span> 中只有一个 <span class="hljs-string">&#x27;3&#x27;</span> ，在移除 <span class="hljs-string">&#x27;3&#x27;</span> 之后，结果为 <span class="hljs-string">&quot;12&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;1231&quot;</span>, digit = <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-string">&quot;231&quot;</span><br>解释：可以移除第一个 <span class="hljs-string">&#x27;1&#x27;</span> 得到 <span class="hljs-string">&quot;231&quot;</span> 或者移除第二个 <span class="hljs-string">&#x27;1&#x27;</span> 得到 <span class="hljs-string">&quot;123&quot;</span> 。<br>由于 <span class="hljs-number">231</span> &gt; <span class="hljs-number">123</span> ，返回 <span class="hljs-string">&quot;231&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">输入：<span class="hljs-built_in">number</span> = <span class="hljs-string">&quot;551&quot;</span>, digit = <span class="hljs-string">&quot;5&quot;</span><br>输出：<span class="hljs-string">&quot;51&quot;</span><br>解释：可以从 <span class="hljs-string">&quot;551&quot;</span> 中移除第一个或者第二个 <span class="hljs-string">&#x27;5&#x27;</span> 。<br>两种方案的结果都是 <span class="hljs-string">&quot;51&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= number.length &lt;= 100</code></li><li><code>number</code> 由数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 组成</li><li><code>digit</code> 是 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 中的一个数字</li><li><code>digit</code> 在 <code>number</code> 中出现至少一次</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeDigit</span>(<span class="hljs-params">self, number, digit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type number: str</span><br><span class="hljs-string">        :type digit: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(number)):<br>            <span class="hljs-keyword">if</span> number[i] == digit:<br>                tmp_list = <span class="hljs-string">&#x27;&#x27;</span>.join(number[:i] + number[i+<span class="hljs-number">1</span>:])<br>                res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">int</span>(tmp_list))<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：6048-必须拿起的最小连续卡牌数"><a href="#第二题：6048-必须拿起的最小连续卡牌数" class="headerlink" title="第二题：6048.必须拿起的最小连续卡牌数"></a>第二题：6048.必须拿起的最小连续卡牌数</h1><p><a href="https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p><p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cards = [<span class="hljs-number">3,4,2,3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">4</span><br>解释：拿起卡牌 [<span class="hljs-number">3,4,2,3</span>] 将会包含一对值为 <span class="hljs-number">3</span> 的匹配卡牌。注意，拿起 [<span class="hljs-number">4,2,3,4</span>] 也是最优方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：cards = [<span class="hljs-number">1,0,5,3</span>]<br>输出：-<span class="hljs-number">1</span><br>解释：无法找出含一对匹配卡牌的一组连续卡牌。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= cards.length &lt;= 10^5</code></li><li><code>0 &lt;= cards[i] &lt;= 10^6</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了，还是比较好想到这个思路的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCardPickup</span>(<span class="hljs-params">self, cards</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cards: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>        tmp_dict = defaultdict(<span class="hljs-built_in">list</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cards)):<br>            tmp_dict[cards[i]].append(i)<br>        <br>        <span class="hljs-comment"># print(tmp_dict)</span><br>        res = <span class="hljs-number">1e9</span><br>        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> tmp_dict.values():<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(value) &lt; <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(value)-<span class="hljs-number">1</span>):<br>                res = <span class="hljs-built_in">min</span>(res, value[j+<span class="hljs-number">1</span>]-value[j])<br>        <br>        <span class="hljs-keyword">if</span> res != <span class="hljs-number">1e9</span>:<br>            <span class="hljs-keyword">return</span> res+ <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h1 id="第三题：6049-含最多-K-个可整除元素的子数组"><a href="#第三题：6049-含最多-K-个可整除元素的子数组" class="headerlink" title="第三题：6049.含最多 K 个可整除元素的子数组"></a>第三题：6049.含最多 K 个可整除元素的子数组</h1><p><a href="https://leetcode.cn/problems/k-divisible-elements-subarrays/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>p</code> ，找出并返回满足要求的不同的子数组数，要求子数组中最多 <code>k</code> 个可被 <code>p</code> 整除的元素。</p><p>如果满足下述条件之一，则认为数组 <code>nums1</code> 和 <code>nums2</code> 是 <strong>不同</strong> 数组：</p><ul><li>两数组长度 <strong>不同</strong> ，或者</li><li>存在 <strong>至少</strong> 一个下标 <code>i</code> 满足 <code>nums1[i] != nums2[i]</code> 。</li></ul><p><strong>子数组</strong> 定义为：数组中的连续元素组成的一个 <strong>非空</strong> 序列。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[2,3,3,2,2]</span>, k = <span class="hljs-number">2</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">11</span><br>解释：<br>位于下标 <span class="hljs-number">0</span>、<span class="hljs-number">3</span> 和 <span class="hljs-number">4</span> 的元素都可以被 <span class="hljs-selector-tag">p</span> = <span class="hljs-number">2</span> 整除。<br>共计 <span class="hljs-number">11</span> 个不同子数组都满足最多含 k = <span class="hljs-number">2</span> 个可以被 <span class="hljs-number">2</span> 整除的元素：<br><span class="hljs-selector-attr">[2]</span>、<span class="hljs-selector-attr">[2,3]</span>、<span class="hljs-selector-attr">[2,3,3]</span>、<span class="hljs-selector-attr">[2,3,3,2]</span>、<span class="hljs-selector-attr">[3]</span>、<span class="hljs-selector-attr">[3,3]</span>、<span class="hljs-selector-attr">[3,3,2]</span>、<span class="hljs-selector-attr">[3,3,2,2]</span>、<span class="hljs-selector-attr">[3,2]</span>、<span class="hljs-selector-attr">[3,2,2]</span> 和 <span class="hljs-selector-attr">[2,2]</span> 。<br>注意，尽管子数组 <span class="hljs-selector-attr">[2]</span> 和 <span class="hljs-selector-attr">[3]</span> 在 nums 中出现不止一次，但统计时只计数一次。<br>子数组 <span class="hljs-selector-attr">[2,3,3,2,2]</span> 不满足条件，因为其中有 <span class="hljs-number">3</span> 个元素可以被 <span class="hljs-number">2</span> 整除。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,2,3,4], k = 4, p = 1<br>输出：10<br>解释：<br>nums 中的所有元素都可以被 p =<span class="hljs-number"> 1 </span>整除。<br>此外，nums 中的每个子数组都满足最多<span class="hljs-number"> 4 </span>个元素可以被<span class="hljs-number"> 1 </span>整除。<br>因为所有子数组互不相同，因此满足所有限制条件的子数组总数为<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 200</li><li>1 &lt;&#x3D; nums[i], p &lt;&#x3D; 200</li><li>1 &lt;&#x3D; k &lt;&#x3D; nums.length</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>另外还想说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j&#x3D;i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countDistinct</span>(<span class="hljs-params">self, nums, k, p</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type p: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># preprocess</span><br>        cnt_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] % p == <span class="hljs-number">0</span>:<br>                cnt_list.append(<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                cnt_list.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># print(&quot;cnt_list: &quot;, cnt_list)</span><br>            <br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-comment"># from collections import defaultdict</span><br>        hash_set = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, <span class="hljs-built_in">len</span>(nums)):<br>                tmp_list = nums[i:j+<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">if</span> hash_set.get(<span class="hljs-built_in">tuple</span>(tmp_list)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    <span class="hljs-keyword">continue</span><br>                hash_set[<span class="hljs-built_in">tuple</span>(tmp_list)] = <span class="hljs-number">1</span><br>                tmp = <span class="hljs-built_in">sum</span>(cnt_list[i:j+<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">if</span> tmp &lt;= k:<br>                    res += <span class="hljs-number">1</span><br>                <br>                <br>                <br>                <span class="hljs-comment"># print(tmp_list)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第四题：6050-字符串的总引力"><a href="#第四题：6050-字符串的总引力" class="headerlink" title="第四题：6050.字符串的总引力"></a>第四题：6050.字符串的总引力</h1><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p><ul><li>例如，<code>&quot;abbca&quot;</code> 的引力为 <code>3</code> ，因为其中有 3 个不同字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 。</li></ul><p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> 。</p><p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，自己举的例子是下边这个图这样，这样能按照每个字符，来统计每个字符的贡献度：</p><p>非重复情况：<br><img src="/images/2022-05-02-10-28-47.png"></p><p>重复情况：<br><img src="/images/2022-05-02-10-29-13.png"></p><p>另外还想再次说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j&#x3D;i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><p>正确解答方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appealSum</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 一种每个字符贡献度的思想，还是很有特点的</span><br>        res = <span class="hljs-number">0</span><br>        char_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> char_dict.get(s[i]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                res += (i + <span class="hljs-number">1</span>) * (<span class="hljs-built_in">len</span>(s)-i)<br>            <span class="hljs-keyword">else</span>:<br>                res += (i - char_dict[s[i]]) * (<span class="hljs-built_in">len</span>(s) - i)<br>            char_dict[s[i]] = i<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这里也额外把自己当时写的暴力方法附上，一位缩减了时间复杂度，实际上像个小丑哈哈哈哈哈哈哈哈，dp了但没完全dp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">appealSum</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        d1 = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            d1[i] = &#123;s[i]: <span class="hljs-number">1</span>&#125;<br>            res += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init: &quot;</span>, d1)<br>        <br>        <br>        res_d = &#123;&#125;<br>        <br>        <span class="hljs-comment"># 这里感觉是一个base基础上的dp，每次要取几位，有点不像平常的遍历思路1</span><br>        <span class="hljs-comment"># 现在要开始每次取两位</span><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(s)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-l+<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># base</span><br>                base = s[i:i+l-<span class="hljs-number">1</span>]<br>                <span class="hljs-comment"># print(&quot;base: &quot;, base)</span><br>                <br>                <span class="hljs-comment"># now（要不要给他加一个标识？）</span><br>                tmp_s = s[i:i+l]<br>                <span class="hljs-comment"># print(&quot;tmp_s: &quot;, tmp_s)</span><br>                <br>                <span class="hljs-comment"># 增量</span><br>                upper = tmp_s[<span class="hljs-built_in">len</span>(base):]<br>                <span class="hljs-comment"># print(&quot;upper: &quot;, upper)</span><br>                <br>                <span class="hljs-comment"># 查看upper在不在</span><br>                <span class="hljs-keyword">if</span> d1[i].get(upper) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <span class="hljs-comment"># 不在，这样是一种累加的</span><br>                    d1[i][tmp_s] = d1[i][base] + <span class="hljs-number">1</span><br>                    d1[i][upper] = <span class="hljs-number">1</span><br>                    res += d1[i][tmp_s]<br>                <span class="hljs-keyword">else</span>:<br>                    d1[i][tmp_s] = d1[i][base]<br>                    res += d1[i][tmp_s]<br>                    <br>                    <span class="hljs-comment"># continue</span><br>                    <span class="hljs-comment"># res += d1[i][upper]</span><br>                    <span class="hljs-comment"># d1[i][upper] = d1[i][upper] + 1</span><br>                    <span class="hljs-comment"># continue</span><br>                <br>        <span class="hljs-comment"># print(d1)</span><br>        <br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
      <tag>哈希表</tag>
      
      <tag>字典树</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>枚举</tag>
      
      <tag>哈希函数</tag>
      
      <tag>滚动哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>687.最长同值路径-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>687.最长同值路径（中等）</p><p>题目大意：</p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">题目链接</a></p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p>示例1：</p><p><img src="/images/2022-04-30-10-51-58.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[5,4,5,1,1,5]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-04-30-10-52-12.png"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：root = <span class="hljs-string">[1,4,5,4,4,5]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>比较经典能看出来是 <code>树中子结构dfs/dp的题目</code>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>对于这个题目来说，子结构下的返回值可能会有none的情况，另外也需要全局比较，总结来说和124题目比较像，如果再做到这题的话不知道能不能做出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    典型树中子结构搜索的题目</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_res = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestUnivaluePath</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 1. 先写dfs递归函数</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            <span class="hljs-comment"># 3. 子结构搜索任务要用后序遍历，这里写递归两次</span><br>            left = dfs(root.left)<br>            right = dfs(root.right)<br><br>            <span class="hljs-comment"># 4. 写全局的那个逻辑，全局结构要把左右都考虑上</span><br>            tmp_res = <span class="hljs-number">0</span>  <span class="hljs-comment"># 路径长度，所以这里是0开始</span><br>            <span class="hljs-keyword">if</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val:<br>                tmp_res += left<br>            <span class="hljs-keyword">if</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val:<br>                tmp_res += right<br>            self.max_res = <span class="hljs-built_in">max</span>(self.max_res, tmp_res)<br><br>            <span class="hljs-comment"># 2. 对于树中的子结构搜索任务，写返回值，看看不同种情况下子结构该怎么返回</span><br>            <span class="hljs-keyword">if</span> (root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val) <span class="hljs-keyword">and</span> (root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val):<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> root.left <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.left.val:<br>                <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> root.right <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root.val == root.right.val:<br>                <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 为什么是return1，只能暂时理解为每个的base都是1了</span><br>        <br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>543.二叉树的直径-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>543.二叉树的直径（简单）</p><p>题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目链接</a></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例：<br>给定二叉树</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">    <span class="hljs-number">1</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">2</span>   <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span>     <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>    <br><br></code></pre></td></tr></table></figure><p>返回 <strong>3</strong>，它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>题目中给出了一个提示，就是说 <strong>这条路径可能穿过也可能不穿过根节点</strong>，那么换句话说，每个节点都有可能是 <strong>路径的根节点</strong>，这样应该可以判断出是经典的 <strong>树形子结构dfs&#x2F;dp题目</strong>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>这个题目来说，坑点在于不是节点数目，而是边数目的表示，最后需要加减个1一般通过调试就可以完成了，然后路径上的话一般子结构返回值就是 <code>1+xxx</code> 这样的；另外想说的是这个题居然是简单题，和124本质上没有什么区别啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_len = -<span class="hljs-number">1e9</span>  <span class="hljs-comment"># 这里要新定义一个？</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">diameterOfBinaryTree</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>            max_left_len = dfs(root.left)<br>            max_right_len = dfs(root.right)<br><br>            self.max_len = <span class="hljs-built_in">max</span>(self.max_len, <span class="hljs-number">1</span> + max_left_len + max_right_len)<br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(max_left_len, max_right_len)  <span class="hljs-comment"># 子结构的加上根</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_len - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>124.二叉树中的最大路径和-python</title>
    <link href="/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/"/>
    <url>/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>124.二叉树中的最大路径和（困难）</p><p>题目大意：<strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">题目链接</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>示例1：</p><p><img src="/images/2022-04-30-10-00-18.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-04-30-10-00-43.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>树中节点数目范围是 [1, 3 * 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>经典的树形子结构dp题目，这个题带了一个最大路径和，这块是要有一个全局的变量，每个子结构的值要和这个全局的值来比取最大值；</p><p>树里的子结构，一般思路就是<strong>后序遍历</strong>的思想，把每个节点当做根节点，然后求出这个点左右和这个点的值加起来，和全局的来比；而其中比较关键的是在此之前，每个地方的递归出口，也就是后序遍历的出口要把子结构的值给返回回去，而这种路径的话，子结构实际上只能往左边或者右边，也就是<code>root.val + max(left_val, right_val)</code>，其中两边的val需要通过递归来完成返回</p><p>总结来说，一般的套路是如下几个步骤：</p><ol><li>写 <code>from function tools import lru_cache</code> ，在dfs函数前加上 <code>@lru_cache(1000*1000)</code> 的修饰，这样可以一定程度上减小时间占用（在笔试题目中可能会有奇效hh）；</li><li>写入口，入口一般有两种情况，像是笔试题目的话可能是 <code>def dfs(left, right)</code> 这样的，像是leetcode题目的话，可能就是 <code>def dfs(root)</code>；</li><li>写出口返回值，一般来说就是子结构的值，如果是像这个题一样树中路径的话，就是当前节点加上左边或者右边的；</li><li>写后续遍历的递归部分，将两边的子结构传入dfs函数中，来进一步往深度优先寻找；</li><li>写全局比较，这个步骤不一定存在，但是如果把每个节点像这个题一样当做“中转节点”的话，那就要和全局的值比较一下；</li><li>写递归出口条件，一般来说就是 <code>root is None</code> 或者 <code>left &gt;= right</code>这类的条件；</li></ol><p>这个模式感觉还挺套路的，几乎子结构或者带着树中路径的题目都可以这么做，也算是积累到一种做法吧，相似题目包括：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a><br><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://www.nowcoder.com/test/28665343/summary">001场笔试练习 第四题.最优二叉树</a></p><p>通过上边的总结来说，这个题目基本已经可以做出来了，需要注意的是这个题目中可能有负数存在，路径上带上负数还不如不带这条路径，子结构返回的时候需要注意一下</p><p>补充：</p><p>543.二叉树直径 easy: <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><p>124.二叉树中的最大路径和 hard: <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><p>这两个题感觉是很像的，但是不太像树形dp，就像是在树里的dfs一样，感觉最主要的思路就是子结构</p><ul><li><p>在写dfs函数的时候，先写返回值，返回值是左右两个子结构中最大的一个加上当前节点的值；；这里说是子结构是因为他的父节点如果选了左边的就不能选右边的（题目特性决定）；；代表这个根作为子结构的条件下最大值</p></li><li><p>然后写结束条件，一般就是root is None的时候</p></li><li><p>然后写递归的两边，基本就是把root.left和root.right传进去</p></li><li><p>然后写全局的，全局的就是 当前+左子结构+右子结构，然后和现有比取最大的；；；代表按这个根作为真实根的情况下条件的最大值</p></li></ul><p>最后return回全局的这个最大的</p><p>树里子结构的dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.max_res = -<span class="hljs-number">1e9</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPathSum</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            left_max_val = dfs(root.left) <span class="hljs-comment"># 往左子树走，以左子树为根的最大子结构</span><br>            right_max_val = dfs(root.right)  <span class="hljs-comment"># 往右子树走，右子树的最大子结构</span><br><br>            tmp_value = root.val + left_max_val + right_max_val  <span class="hljs-comment"># 以root为根的最大子结构</span><br>            self.max_res = <span class="hljs-built_in">max</span>(self.max_res, tmp_value)<br>            <br>            <span class="hljs-comment"># 这个return是单一子结构的return，子结构下不能同时往左又往右走，只能选择一边，子结构的！！！</span><br>            <span class="hljs-keyword">if</span> root.val + <span class="hljs-built_in">max</span>([<span class="hljs-number">0</span>, left_max_val, right_max_val]) &gt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">return</span> root.val + <span class="hljs-built_in">max</span>([<span class="hljs-number">0</span>, left_max_val, right_max_val]) <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        dfs(root)<br>        <span class="hljs-keyword">return</span> self.max_res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001场笔试练习</title>
    <link href="/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    <url>/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz；</p><p>笔试题目选择：<a href="https://www.nowcoder.com/test/28665343/summary">美团2021校招笔试-编程题(通用编程试题,第10场)</a></p><p>笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题&#x2F;面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6&#x2F;10，还加上了一个@lru_cache(1000*1000)；</p><span id="more"></span><h1 id="第一题：淘汰分数"><a href="#第一题：淘汰分数" class="headerlink" title="第一题：淘汰分数"></a>第一题：淘汰分数</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。</p><p>但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。</p><p>显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。</p><p>数据范围：1 ≤ n ≤ 50000，1 ≤ x ≤ y ≤ n<br>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入第一行仅包含三个正整数<span class="hljs-built_in">n</span>,x,y，分别表示参赛的人数和晋级淘汰人数区间。(<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">50000</span>,<span class="hljs-number">1</span>&lt;=x,y&lt;=<span class="hljs-built_in">n</span>)<br>输入第二行包含<span class="hljs-built_in">n</span>个整数，中间用空格隔开，表示从<span class="hljs-number">1</span>号选手到<span class="hljs-built_in">n</span>号选手的成绩。(<span class="hljs-number">1</span>&lt;=|a_i|&lt;=<span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输出仅包含一个整数，如果不存在这样的m，则输出<span class="hljs-string">-1</span>，否则输出符合条件的最小的值。<br></code></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题好像出的case比较弱，做的时候直接用前后缀偷鸡了，实际上可能需要考虑同分数的情况，所以自己的前后缀做法实际上是有问题的，不过既然偷过了，就先不管了哈哈哈，就当他是笔试题和leetcode的不同了；</p><p>笔试题模板就用类似这样的，写成leetcode的写法，也会相对比较熟练了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, x, y, scores</span>):<br>        scores.sort()<br>        pre = <span class="hljs-number">0</span><br>        last = <span class="hljs-built_in">len</span>(scores)<br><br>        m = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(scores)):  <span class="hljs-comment"># 二分优化</span><br>            pre += <span class="hljs-number">1</span><br>            last -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> pre &gt;= x <span class="hljs-keyword">and</span> pre &lt;= y <span class="hljs-keyword">and</span> last &gt;= x <span class="hljs-keyword">and</span> last &lt;= y:<br>                m = scores[i]<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">return</span> m<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n, x, y = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>))<br>    scores = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># mock区域</span><br>    <span class="hljs-comment"># n = 6</span><br>    <span class="hljs-comment"># x = 2</span><br>    <span class="hljs-comment"># y = 3</span><br>    <span class="hljs-comment"># scores = [1, 2, 3, 4, 5, 6]</span><br>    <br><br>    res = s.func(n, x, y, scores)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第二题：正则序列"><a href="#第二题：正则序列" class="headerlink" title="第二题：正则序列"></a>第二题：正则序列</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><font color="red">我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序</font></p><p>有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。</p><p>请问他最少用多少次操作可以把这个序列变成正则序列？</p><p>数据范围： 1 ≤ n ≤ 20000，0 ≤ abs(s_i) ≤ 10000<br>进阶：时间复杂度O(n)，空间复杂度O(n)  <strong>注：这里实际上是不是写错了，时间复杂度没法做到O(n)吧</strong></p><p>输入例子1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">5<br>-1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 10 </span>100<br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">103<br></code></pre></td></tr></table></figure><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题也太简单了，感觉甚至不如平常周赛第一题的包装后的难度，排个序然后对位相减就可以，O(nlogn)的解法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, nums</span>):<br>        nums.sort()<br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            res += <span class="hljs-built_in">abs</span>(nums[i] - (i+<span class="hljs-number">1</span>))<br><br>        <span class="hljs-keyword">return</span> res<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>))<br>    nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># mock区域</span><br>    <span class="hljs-comment"># n = 5</span><br>    <span class="hljs-comment"># nums = [-1, 2, 3, 10, 100]</span><br>    <br>    res = s.func(n, nums)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h1 id="第三题：公司食堂"><a href="#第三题：公司食堂" class="headerlink" title="第三题：公司食堂"></a>第三题：公司食堂</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；</p><p><font color="red">当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；</font></p><p>无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。</p><p>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">第一行输入一个整数T（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>T&lt;<span class="hljs-operator">=</span><span class="hljs-number">10</span>），表示数据组数。<br><br>每组数据占四行，第一行输入一个整数N（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>N&lt;<span class="hljs-operator">=</span><span class="hljs-number">500000</span>）；<br><br>第二行输入一个长度为N且仅包含数字<span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；<br><br>第三行输入一个整数M（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>M&lt;<span class="hljs-operator">=</span><span class="hljs-number">2</span>N且保证排队的每个人进入食堂时都有可供选择的餐桌）；<br><br>第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">每组数据输出占M行，第i行输出一个整数j（<span class="hljs-number">1</span>&lt;<span class="hljs-operator">=</span>j&lt;<span class="hljs-operator">=</span>N），表示排在第i的人将选择左起第j张餐桌用餐。<br></code></pre></td></tr></table></figure><p>输入示例1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>5<br>01102<br>6<br>MFMMFF<br></code></pre></td></tr></table></figure><p>输入示例2：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>1<br>3<br>4<br>4<br></code></pre></td></tr></table></figure><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>感觉是个模拟题，本来以为笔试会经常出这种模拟题的，但是从今年来看好像不是这样啊。<strong>当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐</strong> 这感觉是一个提示，提示使用优先队列做模拟；</p><p>现在来看这个题好像一下想过去也不是能秒做的题目，但是感觉那天状态比较好吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, sitdown_peoples, m, gender</span>):<br>        res_list = []<br>        have_zero_count = <span class="hljs-number">0</span><br>        have_one_count = <span class="hljs-number">0</span><br>        have_two_count = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">import</span> heapq<br>        mapping = &#123;<span class="hljs-number">0</span>: [], <span class="hljs-number">1</span>: [], <span class="hljs-number">2</span>: []&#125;  <span class="hljs-comment"># 每个list是priority queue（heapq）</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(sitdown_peoples)):<br>            mapping[sitdown_peoples[i]].append(i)<br>        <span class="hljs-comment"># heapify一下，优先队列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>            heapq.heapify(mapping[i])<br><br>        <span class="hljs-comment"># print(&quot;after mapping: &quot;, mapping)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(gender)):<br>            <span class="hljs-keyword">if</span> gender[i] == <span class="hljs-string">&#x27;M&#x27;</span>:<br>                <span class="hljs-comment"># 男员工会优先选择有一个人的地方坐，如果都有了就去坐两个空的</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping[<span class="hljs-number">1</span>]) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 优先选择有一个人的地方坐</span><br>                    <span class="hljs-comment"># 坐在这里</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">1</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">2</span>], tmp_idx)<br><br>                <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 去坐两个空的</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">0</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">1</span>], tmp_idx)<br><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 女员工会优先选择都空的地方坐，如果没有了才会和别人拼桌</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(mapping[<span class="hljs-number">0</span>]) != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 优先选择没有人的地方</span><br>                    <span class="hljs-comment"># 坐在这里</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">0</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">1</span>], tmp_idx)<br><br>                <span class="hljs-keyword">else</span>: <span class="hljs-comment"># 去坐有人的</span><br>                    tmp_idx = heapq.heappop(mapping[<span class="hljs-number">1</span>])<br>                    res_list.append(tmp_idx)<br>                    <span class="hljs-comment"># 修改状态</span><br>                    heapq.heappush(mapping[<span class="hljs-number">2</span>], tmp_idx)<br><br>        <span class="hljs-keyword">return</span> res_list<br><br>        <br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    t = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t):<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>        sitdown_peoples = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>()))<br>        sitdown_peoples = [<span class="hljs-built_in">int</span>(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> sitdown_peoples]<br>        m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>        gender = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, <span class="hljs-built_in">input</span>()))<br><br><br>        <span class="hljs-comment"># print(&quot;n: &quot;, n)</span><br>        <span class="hljs-comment"># print(&quot;sitdown_peoples: &quot;, sitdown_peoples)</span><br>        <span class="hljs-comment"># print(&quot;m: &quot;, m)</span><br>        <span class="hljs-comment"># print(&quot;gender: &quot;, gender)</span><br><br>        res_list = s.func(n, sitdown_peoples, m, gender)<br>        <span class="hljs-comment"># print(&quot;res_list: &quot;, res_list)</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res_list)):<br>            <span class="hljs-built_in">print</span>(res_list[i]+<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="第四题：最优二叉树II"><a href="#第四题：最优二叉树II" class="headerlink" title="第四题：最优二叉树II"></a>第四题：最优二叉树II</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。</p><p>输入描述：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">第一行输入一个整数<span class="hljs-built_in">N</span>（<span class="hljs-number">1</span>&lt;=<span class="hljs-built_in">N</span>&lt;=<span class="hljs-number">300</span>），表示二叉树的节点数。<br>第二行输入<span class="hljs-built_in">N</span>个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过<span class="hljs-number">1000</span>的正整数。<br></code></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">输出一个整数，表示最优二叉树的总开销。<br></code></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">45<br></code></pre></td></tr></table></figure><p>例子说明1：</p><p><img src="/images/2022-04-29-00-25-01.png"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">最优二叉树如图所示，总开销为7<span class="hljs-number">*1</span>+6<span class="hljs-number">*5</span>+5<span class="hljs-number">*1</span>+1<span class="hljs-number">*3</span>=45。<br></code></pre></td></tr></table></figure><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题后来看了答案，好像是要区间dp的做法，但是区间dp感觉就是完全未知的领域了，树上的操作感觉实在是太多了，包括还有线段树一类的，说到这里也什么时候找个线段树的模板，以备之后套用吧</p><p>这个题也可以用树形dp直接暴力，而且这里学到一个lru_cache，对于笔试题感觉是一种偷鸡的操作，让本来只能过2&#x2F;10的测试用例瞬间变到过6&#x2F;10 ~ 7&#x2F;10了，感觉就是dfs中的一个笔试偷鸡操作？应该所有dfs都可以用吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functiontools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-meta">@lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>():<br>    <span class="hljs-comment"># do sth</span><br></code></pre></td></tr></table></figure><p>这个题暂时只学习了下dfs暴力的方法了，和子结构树形dp很像，但是和leetcode那边的区别是这里的输入是一个数组，所以dfs的区间是 <code>(0, n)</code> 这种感觉，然后dfs的含义感觉就是把 <code>i</code> 作为<strong>子结构</strong>的根节点，然后i这个位置乘父亲的，再加上左边和右边的，就完成了一次内部的递归，此外，在内部递归中要遍历每个 <code>i</code> 位置，即每次（包括dfs下去的子层）都要把这个地方当做根节点试一下，最后记录一个局部子结构的ret最优作为返回值，而 <code>(0, n)</code> 这个子结构实际上就是父结构了，另外每次要把 <code>parent_value</code> 往下传下去；</p><p>子结构dp，LeetCode相似题目：</p><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a></p><p>如下代码可以通过6&#x2F;10 ~ 7&#x2F;10组测试用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#encoding:utf-8</span><br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self, n, values</span>):<br>        <span class="hljs-comment"># 输出的values是一个global的数组，这里lru_cache大幅优化效率</span><br><span class="hljs-meta">        @lru_cache(<span class="hljs-params"><span class="hljs-number">1000</span>*<span class="hljs-number">1000</span></span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">left, right, parent_val</span>):<br><br>            <span class="hljs-comment"># 3. 写出口，这里等于的话，就0</span><br>            <span class="hljs-keyword">if</span> left &gt;= right:<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>            <span class="hljs-comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span><br>            res = <span class="hljs-number">1e9</span><br><br>            <span class="hljs-comment"># 2. 递归这个left,right区间下的最优子结构</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(left, right):<br>                left_val = dfs(left, i, values[i])<br>                right_val = dfs(i+<span class="hljs-number">1</span>, right, values[i])<br>                res = <span class="hljs-built_in">min</span>(res, values[i] * parent_val + left_val + right_val)<br><br><br>            <span class="hljs-comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span><br>            <span class="hljs-keyword">return</span> res<br><br>        <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># init solution    </span><br>    s = Solution()<br><br>    <span class="hljs-comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span><br>    n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>().strip())<br>    <span class="hljs-keyword">global</span> values<br>    values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().strip().split(<span class="hljs-string">&quot; &quot;</span>)))<br><br>    <span class="hljs-comment"># print(&quot;n: &quot;, n)</span><br>    <span class="hljs-comment"># print(&quot;values: &quot;, values)</span><br>    <br><br>    <span class="hljs-comment"># 调用以及output</span><br>    res = s.func(n, values)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试练习-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode2022春季战队赛</title>
    <link href="/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/"/>
    <url>/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>比赛综述&amp;总结：</p><p>这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了，</p><p>另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的</p><span id="more"></span><h1 id="第一题：LCP-55-采集果实"><a href="#第一题：LCP-55-采集果实" class="headerlink" title="第一题：LCP 55.采集果实"></a>第一题：LCP 55.采集果实</h1><p><a href="https://leetcode-cn.com/problems/PTXy4P/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。</p><p>在新手村中，各位勇者需要采集一些果实来制作药剂。<code>time[i]</code> 表示勇者每次采集 <code>1～limit</code> 颗第 <code>i</code> 种类型的果实需要的时间（即每次最多可以采集 <code>limit</code> 颗果实）。</p><p>当前勇者需要完成「采集若干批果实」的任务， <code>fruits[j] = [type, num]</code> 表示第 <code>j</code> 批需要采集 <code>num</code> 颗 <code>type</code> 类型的果实。采集规则如下：</p><ul><li>按 <code>fruits</code> 给定的顺序<strong>依次</strong>采集每一批次</li><li>采集完当前批次的果实才能开始采集下一批次</li><li>勇者完成当前批次的采集后将<strong>清空背包</strong>（即多余的果实将清空）</li></ul><p>请计算并返回勇者完成采集任务最少需要的时间。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3<br><br>输出：10<br><br>解释：<br>由于单次最多采集<span class="hljs-number"> 3 </span>颗<br>第<span class="hljs-number"> 0 </span>批需要采集<span class="hljs-number"> 2 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 1 </span>次，耗时为 2*1=2<br>第<span class="hljs-number"> 1 </span>批需要采集<span class="hljs-number"> 4 </span>颗第<span class="hljs-number"> 1 </span>类型果实，需要采集<span class="hljs-number"> 2 </span>次，耗时为 3*2=6<br>第<span class="hljs-number"> 2 </span>批需要采集<span class="hljs-number"> 1 </span>颗第<span class="hljs-number"> 2 </span>类型果实，需要采集<span class="hljs-number"> 1 </span>次，耗时为 2*1=2<br>返回总耗时 2+6+2=10<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [1], fruits = [[0,3],[0,5]], limit = 2<br><br>输出：5<br><br>解释：<br>由于单次最多采集<span class="hljs-number"> 2 </span>颗<br>第<span class="hljs-number"> 0 </span>批需要采集<span class="hljs-number"> 3 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 2 </span>次，耗时为 1*2=2<br>第<span class="hljs-number"> 1 </span>批需要采集<span class="hljs-number"> 5 </span>颗第<span class="hljs-number"> 0 </span>类型果实，需要采集<span class="hljs-number"> 3 </span>次，耗时为 1*3=3<br>需按照顺序依次采集，返回 2+3=5<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; time.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; time[i] &lt;&#x3D; 100</li><li>1 &lt;&#x3D; fruits.length &lt;&#x3D; 10^3</li><li>0 &lt;&#x3D; fruits[i][0] &lt; time.length</li><li>1 &lt;&#x3D; fruits[i][1] &lt; 10^3</li><li>1 &lt;&#x3D; limit &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题一上来就让人读题困难了，简单概括来说就是一个套角标，然后看看是否能整除，除完了向上取整吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getMinimumTime</span>(<span class="hljs-params">self, time, fruits, limit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type time: List[int]</span><br><span class="hljs-string">        :type fruits: List[List[int]]</span><br><span class="hljs-string">        :type limit: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(fruits)):<br>            <span class="hljs-keyword">if</span> fruits[i][<span class="hljs-number">1</span>] % limit != <span class="hljs-number">0</span>:<br>                res += ((fruits[i][<span class="hljs-number">1</span>]//limit) + <span class="hljs-number">1</span>) * time[fruits[i][<span class="hljs-number">0</span>]]<br>            <span class="hljs-keyword">else</span>:<br>                 res += (fruits[i][<span class="hljs-number">1</span>]//limit) * time[fruits[i][<span class="hljs-number">0</span>]]<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：LCP-56-信物传送"><a href="#第二题：LCP-56-信物传送" class="headerlink" title="第二题：LCP 56.信物传送"></a>第二题：LCP 56.信物传送</h1><p><a href="https://leetcode-cn.com/problems/6UEx57/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。</p><p>本次试炼场地设有若干传送带，<code>matrix[i][j]</code> 表示第 <code>i</code> 行 <code>j</code> 列的传送带运作方向，<code>&quot;^&quot;,&quot;v&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;</code> 这四种符号分别表示 <strong>上</strong>、<strong>下</strong>、<strong>左</strong>、<strong>右</strong> 四个方向。信物会随传送带的方向移动。勇者<strong>每一次</strong>施法操作，可<strong>临时</strong>变更一处传送带的方向，在物品经过后传送带恢复原方向。</p><p><img src="/images/2022-04-23-20-10-49.png"></p><p>通关信物初始位于坐标 <code>start</code> 处，勇者需要将其移动到坐标 <code>end</code> 处，请返回勇者施法操作的最少次数。</p><p>注意：</p><ul><li><code>start</code> 和 <code>end</code> 的格式均为 <code>[i,j]</code></li></ul><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;v^&lt;&quot;</span>,<span class="hljs-string">&quot;&lt;&gt;&lt;&quot;</span>], start = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], end = [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]<br><br>输出：<span class="hljs-number">1</span><br><br>解释：<br>如上图所示<br>当信物移动到 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 时，勇者施法一次将 [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>] 的传送方向 ^ 从变更为 &lt;<br>从而信物移动到 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]，后续到达 end 位置<br>因此勇者最少需要施法操作 <span class="hljs-number">1</span> 次<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">输入：matrix = [<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;&gt;&gt;v&quot;</span>,<span class="hljs-string">&quot;^&lt;&lt;&quot;</span>], <span class="hljs-built_in">start</span> = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-keyword">end</span> = [<span class="hljs-title">1</span>,<span class="hljs-title">1</span>]</span><br><br>输出：<span class="hljs-number">0</span><br><br>解释：勇者无需施法，信物将自动传送至 <span class="hljs-function"><span class="hljs-keyword">end</span> 位置</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：matrix = [<span class="hljs-string">&quot;&gt;^^&gt;&quot;</span>,<span class="hljs-string">&quot;&lt;^v&gt;&quot;</span>,<span class="hljs-string">&quot;^v^&lt;&quot;</span>], start = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], end = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>matrix</code> 中仅包含 <code>&#39;^&#39;、&#39;v&#39;、&#39;&lt;&#39;、&#39;&gt;&#39;</code></li><li><code>0 &lt; matrix.length &lt;= 100</code></li><li><code>0 &lt; matrix[i].length &lt;= 100</code></li><li><code>0 &lt;= start[0],end[0] &lt; matrix.length</code></li><li><code>0 &lt;= start[1],end[1] &lt; matrix[i].length</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉有平常周赛里相对难一点第三题的感觉，比赛的时候没有想到太好的做法就直接超级暴力了，赛后看只过了2&#x2F;32个测试用例，这也是这个比赛没法面向答案编程的难度吧hhhh</p><p>实际上要用bfs+dp的做法来做，当时能想到bfs，但是还是忽略和dp结合到一起了</p><p>这个题不需要记录vis了，就是说只把更小的入队，也好像不能纯优先队列，因为有些地方有好几个方向能走到，另外不用优先队列也可以做，但是用优先队列好像耗时会快一些</p><p>优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span><br>dp = [[<span class="hljs-number">1e9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br><br><span class="hljs-comment"># 状态初始化</span><br>sx, sy = start<br><span class="hljs-keyword">import</span> heapq<br>pq = []<br>heapq.heappush(pq, (<span class="hljs-number">0</span>, [sx, sy]))  <span class="hljs-comment"># 优先队列</span><br>dp[sx][sy] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(pq) != <span class="hljs-number">0</span>:<br>tmp = heapq.heappop(pq)<br>x, y = tmp[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nx = x + dx[i]<br>ny = y + dy[i]<br><span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 这里不用设置visited数组是关键</span><br><span class="hljs-keyword">if</span> (matrix[x][y] == <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;v&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&gt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dp[x][y] &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y]<br>heapq.heappush(pq, (tmp[<span class="hljs-number">0</span>], [nx, ny]))<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">if</span> dp[x][y] + <span class="hljs-number">1</span> &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y] + <span class="hljs-number">1</span><br>heapq.heappush(pq, (tmp[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, [nx, ny]))<br><br><span class="hljs-keyword">return</span> dp[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>非优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br><span class="hljs-comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span><br>dp = [[<span class="hljs-number">1e9</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br><br><span class="hljs-comment"># 状态初始化</span><br>sx, sy = start<br>queue = [[sx, sy]]<br>dp[sx][sy] = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span>:<br>x, y = queue[<span class="hljs-number">0</span>]<br>queue = queue[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nx = x + dx[i]<br>ny = y + dy[i]<br><span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 这里不用设置visited数组是关键</span><br><span class="hljs-keyword">if</span> (matrix[x][y] == <span class="hljs-string">&#x27;^&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;v&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&lt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (matrix[x][y] == <span class="hljs-string">&#x27;&gt;&#x27;</span> <span class="hljs-keyword">and</span> i == <span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> dp[x][y] &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y]<br>queue.append([nx, ny])<br><span class="hljs-keyword">else</span>:<br><span class="hljs-keyword">if</span> dp[x][y] + <span class="hljs-number">1</span> &lt; dp[nx][ny]:<br><span class="hljs-comment"># 只有更小的才入队，貌似不是优先队列也行</span><br>dp[nx][ny] = dp[x][y] + <span class="hljs-number">1</span><br>queue.append([nx, ny])<br><br><span class="hljs-keyword">return</span> dp[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><p>比赛时候的超时做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">conveyorBelt</span>(<span class="hljs-params">self, matrix, start, end</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type matrix: List[str]</span><br><span class="hljs-string">:type start: List[int]</span><br><span class="hljs-string">:type end: List[int]</span><br><span class="hljs-string">:rtype: int</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br><br>record = [[[-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br>visited = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(matrix))]<br>total_vis = <span class="hljs-number">0</span><br>target_vis = <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) * <span class="hljs-built_in">len</span>(matrix)<br><br><span class="hljs-comment"># 第一次从start开始走，把所有能走到的位置都标记上，如果走到了end则跳出并且输出0</span><br><span class="hljs-comment"># x纵向，y横向</span><br>sx, sy = start<br>nx, ny = sx, sy<br><br><span class="hljs-keyword">while</span> visited[nx][ny] == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]):<br><span class="hljs-comment"># 如果走到了end则跳出，并且输出0</span><br><span class="hljs-keyword">if</span> nx == end[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> ny == end[<span class="hljs-number">1</span>]:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 标记访问过的</span><br>visited[nx][ny] = <span class="hljs-number">1</span><br>total_vis += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修改状态</span><br>record[nx][ny][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>record[nx][ny][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 按照当前的格子走</span><br><span class="hljs-keyword">if</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>ny = ny + <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>ny = ny - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;^&#x27;</span>:<br>nx = nx - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;v&#x27;</span>:<br>nx = nx + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># print(&quot;total_vis: &quot;, total_vis)</span><br><span class="hljs-comment"># print(&quot;target_vis: &quot;, target_vis)</span><br><span class="hljs-comment"># print(&quot;record: &quot;, record)</span><br><br><span class="hljs-comment"># 暴力走</span><br>now_status = <span class="hljs-number">0</span><br>jilu_i = <span class="hljs-number">0</span><br>jilu_j = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> total_vis != target_vis:<br><span class="hljs-comment"># 找到一个与now_status相邻的位置</span><br>break_flag = <span class="hljs-literal">False</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(jilu_i, <span class="hljs-built_in">len</span>(matrix)):<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(jilu_j, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])):<br>can_flag = <span class="hljs-literal">False</span><br><span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果还没有访问过</span><br><span class="hljs-comment"># 如果临近的可达状态有上一个now_status的</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>nnx = i + dx[k]<br>nny = j + dy[k]<br><span class="hljs-keyword">if</span> nnx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nnx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> nny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> record[nnx][nny][<span class="hljs-number">0</span>] == now_status:  <span class="hljs-comment"># </span><br>can_flag = <span class="hljs-literal">True</span><br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> can_flag:<br>break_flag = <span class="hljs-literal">True</span><br><span class="hljs-keyword">break</span><br><span class="hljs-keyword">if</span> break_flag:<br><span class="hljs-keyword">break</span><br><br><span class="hljs-keyword">if</span> break_flag:  <span class="hljs-comment"># 还能找到</span><br><br>jilu_i = i<br>jilu_j = j<br><br>nx, ny = i, j<br><span class="hljs-keyword">while</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; <span class="hljs-built_in">len</span>(matrix) <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> visited[nx][ny] == <span class="hljs-number">0</span>:<br><span class="hljs-comment"># 修改状态</span><br>record[nx][ny][<span class="hljs-number">0</span>] = now_status + <span class="hljs-number">1</span><br>record[nx][ny][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 增加</span><br>visited[i][j] = <span class="hljs-number">1</span><br>total_vis += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 按照当前的格子走</span><br><span class="hljs-keyword">if</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br>ny = ny + <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>ny = ny - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;^&#x27;</span>:<br>nx = nx - <span class="hljs-number">1</span><br><span class="hljs-keyword">elif</span> matrix[nx][ny] == <span class="hljs-string">&#x27;v&#x27;</span>:<br>nx = nx + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># print(record)</span><br><span class="hljs-comment"># print(&quot;=============&quot;)</span><br><br><br><br><span class="hljs-keyword">else</span>:<br>now_status += <span class="hljs-number">1</span>  <span class="hljs-comment"># 再多一跳才能跳到的</span><br><br><span class="hljs-keyword">return</span> record[end[<span class="hljs-number">0</span>]][end[<span class="hljs-number">1</span>]][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>289场LeetCode周赛</title>
    <link href="/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了；</p><p>第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… <a href="http://bjutacm.openjudge.cn/lianxi/193E/">吃饭时的怪癖</a></p><p>好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh</p><p>第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><p>第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2&#x2F;3也都是medium但是难很多；</p><p>第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6070-计算字符串的数字和"><a href="#第一题：6070-计算字符串的数字和" class="headerlink" title="第一题：6070.计算字符串的数字和"></a>第一题：6070.计算字符串的数字和</h1><p><a href="https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p><p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p><ol><li>将 <code>s</code> <strong>拆分</strong> 成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li><li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>&quot;346&quot;</code> 会替换为 <code>&quot;13&quot;</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li><li>合并 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li></ol><p>返回在完成所有轮操作后的 <code>s</code> 。</p><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：s = <span class="hljs-string">&quot;11111222223&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;135&quot;</span><br>解释：<br>- 第一轮，将 s 分成：<span class="hljs-string">&quot;111&quot;</span>、<span class="hljs-string">&quot;112&quot;</span>、<span class="hljs-string">&quot;222&quot;</span> 和 <span class="hljs-string">&quot;23&quot;</span> 。<br>  接着，计算每一组的数字和：<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">1</span> = <span class="hljs-number">3</span>、<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span>、<span class="hljs-number">2</span> + <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">6</span> 和 <span class="hljs-number">2</span> + <span class="hljs-number">3</span> = <span class="hljs-number">5</span> 。 <br>  这样，s 在第一轮之后变成 <span class="hljs-string">&quot;3&quot;</span> + <span class="hljs-string">&quot;4&quot;</span> + <span class="hljs-string">&quot;6&quot;</span> + <span class="hljs-string">&quot;5&quot;</span> = <span class="hljs-string">&quot;3465&quot;</span> 。<br>- 第二轮，将 s 分成：<span class="hljs-string">&quot;346&quot;</span> 和 <span class="hljs-string">&quot;5&quot;</span> 。<br>  接着，计算每一组的数字和：<span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">6</span> = <span class="hljs-number">13</span> 、<span class="hljs-number">5</span> = <span class="hljs-number">5</span> 。<br>  这样，s 在第二轮之后变成 <span class="hljs-string">&quot;13&quot;</span> + <span class="hljs-string">&quot;5&quot;</span> = <span class="hljs-string">&quot;135&quot;</span> 。 <br>现在，s.<span class="hljs-built_in">length</span> &lt;= k ，所以返回 <span class="hljs-string">&quot;135&quot;</span> 作为答案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm">输入：s = <span class="hljs-string">&quot;00000000&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;000&quot;</span><br>解释：<br>将 <span class="hljs-string">&quot;000&quot;</span>, <span class="hljs-string">&quot;000&quot;</span>, <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;00&quot;</span>.<br>接着，计算每一组的数字和：<span class="hljs-number">0</span> + <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 、<span class="hljs-number">0</span> + <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 和 <span class="hljs-number">0</span> + <span class="hljs-number">0</span> = <span class="hljs-number">0</span> 。 <br>s 变为 <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> + <span class="hljs-string">&quot;0&quot;</span> = <span class="hljs-string">&quot;000&quot;</span> ，其长度等于 k ，所以返回 <span class="hljs-string">&quot;000&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li><li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">digitSum</span>(<span class="hljs-params">self, s, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(s) &gt; k:<br>            tmp_list = []<br>            ttmp_list = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                ttmp_list.append(s[i])<br>                <span class="hljs-keyword">if</span> (i+<span class="hljs-number">1</span>) % k == <span class="hljs-number">0</span>:<br>                    tmp_list.append(ttmp_list)<br>                    ttmp_list = []<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ttmp_list):<br>                tmp_list.append(ttmp_list)<br>            <span class="hljs-comment"># print(tmp_list)</span><br>            tttmp_list = []<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br>                tsum = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list[i])):<br>                    tsum += <span class="hljs-built_in">int</span>(tmp_list[i][j])<br>                tttmp_list.append(<span class="hljs-built_in">str</span>(tsum))<br>            s = <span class="hljs-string">&#x27;&#x27;</span>.join(tttmp_list)<br>        <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><h1 id="第二题：6071-完成所有任务需要的最少轮数"><a href="#第二题：6071-完成所有任务需要的最少轮数" class="headerlink" title="第二题：6071.完成所有任务需要的最少轮数"></a>第二题：6071.完成所有任务需要的最少轮数</h1><p><a href="https://leetcode-cn.com/problems/minimum-rounds-to-complete-all-tasks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p><p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回 <code>-1</code></p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：tasks = [2,2,3,3,2,4,4,4,4,4]<br>输出：4<br>解释：要想完成所有任务，一个可能的计划是：<br>- 第一轮，完成难度级别为<span class="hljs-number"> 2 </span>的<span class="hljs-number"> 3 </span>个任务。 <br>- 第二轮，完成难度级别为<span class="hljs-number"> 3 </span>的<span class="hljs-number"> 2 </span>个任务。 <br>- 第三轮，完成难度级别为<span class="hljs-number"> 4 </span>的<span class="hljs-number"> 3 </span>个任务。 <br>- 第四轮，完成难度级别为<span class="hljs-number"> 4 </span>的<span class="hljs-number"> 2 </span>个任务。 <br>可以证明，无法在少于<span class="hljs-number"> 4 </span>轮的情况下完成所有任务，所以答案为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：tasks = [2,3,3]<br>输出：-1<br>解释：难度级别为<span class="hljs-number"> 2 </span>的任务只有<span class="hljs-number"> 1 </span>个，但每一轮执行中，只能选择完成<span class="hljs-number"> 2 </span>个或者<span class="hljs-number"> 3 </span>个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= tasks.length &lt;= 10^5</code></li><li><code>1 &lt;= tasks[i] &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2&#x2F;3也都是medium但是难很多；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumRounds</span>(<span class="hljs-params">self, tasks</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type tasks: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>        cnt_tasks = Counter(tasks)<br>        <span class="hljs-built_in">print</span>(cnt_tasks)  <span class="hljs-comment"># Counter(&#123;4: 5, 2: 3, 3: 2&#125;)</span><br><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt_tasks.items():<br>            <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 中间跳出</span><br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br>            t_value = value<br>            cnt_nums = t_value // <span class="hljs-number">3</span><br>            t_value -= cnt_nums * <span class="hljs-number">3</span><br>            <br>            <span class="hljs-keyword">if</span> t_value == <span class="hljs-number">1</span>:<br>                cnt_nums = cnt_nums - <span class="hljs-number">1</span> + <span class="hljs-number">2</span>  <span class="hljs-comment"># 去掉一次搞3，然后搞两次2</span><br>            <span class="hljs-keyword">elif</span> t_value == <span class="hljs-number">2</span>:<br>                cnt_nums += <span class="hljs-number">1</span><br>                t_value -= <span class="hljs-number">2</span><br>            <span class="hljs-comment"># print(t_value)</span><br>            res += cnt_nums<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6072-转角路径的乘积中最多能有几个尾随零"><a href="#第三题：6072-转角路径的乘积中最多能有几个尾随零" class="headerlink" title="第三题：6072.转角路径的乘积中最多能有几个尾随零"></a>第三题：6072.转角路径的乘积中最多能有几个尾随零</h1><p><a href="https://leetcode-cn.com/problems/maximum-trailing-zeros-in-a-cornered-path/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p><p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p><p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p><p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p><p>注意：</p><ul><li><strong>水平</strong> 移动是指向左或右移动。</li><li><strong>竖直</strong> 移动是指向上或下移动。</li></ul><p>示例1：</p><p><img src="/images/2022-04-18-18-31-09.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]<br>输出：3<br>解释：左侧的图展示了一条有效的转角路径。<br>其乘积为<span class="hljs-number"> 15 </span>*<span class="hljs-number"> 20 </span>*<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 10 </span>=<span class="hljs-number"> 18000 </span>，共计<span class="hljs-number"> 3 </span>个尾随零。<br>可以证明在这条转角路径的乘积中尾随零数目最多。<br><br>中间的图不是一条有效的转角路径，因为它有不止一个弯。<br>右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-04-18-18-31-15.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[4,3,2],[7,6,1],[8,8,8]]</span><br>输出：<span class="hljs-number">0</span><br>解释：网格如上图所示。<br>不存在乘积含尾随零的转角路径。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10^5</code></li><li><code>1 &lt;= m * n &lt;= 10^5</code></li><li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxTrailingZeros</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_five</span>(<span class="hljs-params">num</span>):<br>            cnt = <span class="hljs-number">0</span> <br>            <span class="hljs-keyword">while</span> num%<span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                num /= <span class="hljs-number">5</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> cnt<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_num_two</span>(<span class="hljs-params">num</span>):<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> num%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                num /= <span class="hljs-number">2</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> cnt<br><br>        <span class="hljs-comment"># 从上到下的前缀矩阵，从下到上的前缀矩阵</span><br>        grid_up_to_down_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        grid_down_to_up_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 第一行</span><br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] = get_num_two(grid[i][j])<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] = get_num_five(grid[i][j])<br><br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] = get_num_two(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j])<br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] = get_num_five(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>][j])<br><br>                <span class="hljs-keyword">else</span>:<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] = grid_up_to_down_prefix[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>] + get_num_two(grid[i][j])<br>                    grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] = grid_up_to_down_prefix[i-<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + get_num_five(grid[i][j])<br><br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-i][j][<span class="hljs-number">0</span>] + get_num_two(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j])<br>                    grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-i][j][<span class="hljs-number">1</span>] + get_num_five(grid[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j])<br><br>        <span class="hljs-comment"># 从左到右的前缀矩阵，从右到左的前缀矩阵</span><br>        grid_left_to_right_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        grid_right_to_left_prefix = [[[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 第一列</span><br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>] = get_num_two(grid[i][j])<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>] = get_num_five(grid[i][j])<br><br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = get_num_two(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>])<br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = get_num_five(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>])<br><br>                <span class="hljs-keyword">else</span>:<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>] = grid_left_to_right_prefix[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + get_num_two(grid[i][j])<br>                    grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>] = grid_left_to_right_prefix[i][j-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + get_num_five(grid[i][j])<br><br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j][<span class="hljs-number">0</span>] = grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-j][<span class="hljs-number">0</span>] + get_num_two(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j])<br>                    grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j][<span class="hljs-number">1</span>] = grid_right_to_left_prefix[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-j][<span class="hljs-number">1</span>] + get_num_five(grid[i][<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])-<span class="hljs-number">1</span>-j])<br><br>        <span class="hljs-comment"># for i in range(len(grid)):</span><br>        <span class="hljs-comment">#     for j in range(len(grid[0])):</span><br>        <span class="hljs-comment">#         print(grid_right_to_left_prefix[i][j])</span><br>        <span class="hljs-comment">#     print(&quot;\n&quot;)</span><br><br><br>        <span class="hljs-comment"># 从上往下走，从下往上走同时</span><br>        max_zero_last = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br><br>                <span class="hljs-comment"># 上往下，然后往右看</span><br>                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] + grid_left_to_right_prefix[i][-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - grid_left_to_right_prefix[i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] + grid_left_to_right_prefix[i][-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - grid_left_to_right_prefix[i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br><br>                <span class="hljs-comment"># 下往上，然后往右看</span><br>                cnt_num_2 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] + grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] - grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] + grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] - grid_left_to_right_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br>                <br>                <span class="hljs-comment"># 上往下，然后往左看</span><br>                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="hljs-number">0</span>] + grid_right_to_left_prefix[i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - grid_right_to_left_prefix[i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="hljs-number">1</span>] + grid_right_to_left_prefix[i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - grid_right_to_left_prefix[i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br><br>                <span class="hljs-comment"># 下往上，然后往左看</span><br>                cnt_num_2 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>] + grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] - grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">0</span>]<br>                cnt_num_5 = grid_down_to_up_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>] + grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] - grid_right_to_left_prefix[<span class="hljs-built_in">len</span>(grid)-<span class="hljs-number">1</span>-i][j][<span class="hljs-number">1</span>]<br>                max_zero_last = <span class="hljs-built_in">max</span>(max_zero_last, <span class="hljs-built_in">min</span>(cnt_num_2, cnt_num_5))<br>        <br>        <span class="hljs-keyword">return</span> max_zero_last<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>哈希表</tag>
      
      <tag>矩阵</tag>
      
      <tag>前缀和</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>288场LeetCode周赛</title>
    <link href="/2022/04/11/algorithms/leetcode-weekly-contest/288%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/04/11/algorithms/leetcode-weekly-contest/288%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>上一周清明节扫墓鸽了一周，这周又回来了~ 周中尝试做了一个笔试题找了下思路的手感，然后发现leetcode说不定隔一阵做一次手感会更好哈哈哈。这次的前三个题感觉都是很快就有思路的，然后感觉自己做的顺手程度和代码的变量命名关系很大，如果变量命名的很顺利，那说明这次周赛可能就会很顺利了；</p><p>另外来说的话周赛确实要总结下数据结构，感觉前三题都是各种数据结构几乎差不多就能做出来了，而且要熟悉各个数据结构的时间复杂度，像这次的第三题实际上堆的想法是在脑子里一闪而过的，但是没有深思考下去就放弃了，有点可惜；</p><p>这次还积累到一个很坑的地方，就是除【1e9+7】和除【1000000007还有除10**9+7】可能是有精度问题的！！！最后比赛结束后才因为精度问题把这个题改过了做出来，实在是太坑了，或者说可能要用int把1e9+7转一下吧</p><p>第一题：比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的；</p><p>第二题：加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧；</p><p>第三题：根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：2231-按奇偶性交换后的最大数字"><a href="#第一题：2231-按奇偶性交换后的最大数字" class="headerlink" title="第一题：2231.按奇偶性交换后的最大数字"></a>第一题：2231.按奇偶性交换后的最大数字</h1><p><a href="https://leetcode-cn.com/problems/largest-number-after-digit-swaps-by-parity/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个正整数 <code>num</code> 。你可以交换 <code>num</code> 中 <strong>奇偶性</strong> 相同的任意两位数字（即，都是奇数或者偶数）。</p><p>返回交换 <strong>任意</strong> 次之后 <code>num</code> 的 <strong>最大</strong> 可能值。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 1234<br>输出：3412<br>解释：交换数字<span class="hljs-number"> 3 </span>和数字<span class="hljs-number"> 1 </span>，结果得到<span class="hljs-number"> 3214 </span>。<br>交换数字<span class="hljs-number"> 2 </span>和数字<span class="hljs-number"> 4 </span>，结果得到<span class="hljs-number"> 3412 </span>。<br>注意，可能存在其他交换序列，但是可以证明<span class="hljs-number"> 3412 </span>是最大可能值。<br>注意，不能交换数字<span class="hljs-number"> 4 </span>和数字<span class="hljs-number"> 1 </span>，因为它们奇偶性不同。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 65875<br>输出：87655<br>解释：交换数字<span class="hljs-number"> 8 </span>和数字<span class="hljs-number"> 6 </span>，结果得到<span class="hljs-number"> 85675 </span>。<br>交换数字<span class="hljs-number"> 5 </span>和数字<span class="hljs-number"> 7 </span>，结果得到<span class="hljs-number"> 87655 </span>。<br>注意，可能存在其他交换序列，但是可以证明<span class="hljs-number"> 87655 </span>是最大可能值。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= num &lt;= 10^9</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">largestInteger</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(num))<br>        <br>        tmp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]  <span class="hljs-comment"># 记录角标奇偶性</span><br>        oushu = []<br>        jishu = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(nums[i]) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                tmp[i] = <span class="hljs-number">0</span><br>                oushu.append(<span class="hljs-built_in">int</span>(nums[i]))<br>            <span class="hljs-keyword">else</span>:<br>                tmp[i] = <span class="hljs-number">1</span><br>                jishu.append(<span class="hljs-built_in">int</span>(nums[i]))<br>        <br>        <br>        <span class="hljs-comment"># 贪心</span><br>        k = <span class="hljs-number">0</span><br>        jishu.sort(reverse=<span class="hljs-literal">True</span>)<br>        <br>        j = <span class="hljs-number">0</span><br>        oushu.sort(reverse=<span class="hljs-literal">True</span>)<br>        <br>        <br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> tmp[i] == <span class="hljs-number">0</span>:<br>                res.append(oushu[j])<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                res.append(jishu[k])<br>                k += <span class="hljs-number">1</span><br>        res = [<span class="hljs-built_in">str</span>(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res]<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(res))<br></code></pre></td></tr></table></figure><h1 id="第二题：2232-向表达式添加括号后的最小结果"><a href="#第二题：2232-向表达式添加括号后的最小结果" class="headerlink" title="第二题：2232.向表达式添加括号后的最小结果"></a>第二题：2232.向表达式添加括号后的最小结果</h1><p><a href="https://leetcode-cn.com/problems/minimize-result-by-adding-parentheses-to-expression/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>expression</code> ，格式为 <code>&quot;&lt;num1&gt;+&lt;num2&gt;&quot;</code> ，其中 <code>&lt;num1&gt;</code> 和 <code>&lt;num2&gt;</code> 表示正整数。</p><p>请你向 <code>expression</code> 中添加一对括号，使得在添加之后， <code>expression</code> 仍然是一个有效的数学表达式，并且计算后可以得到 <strong>最小</strong> 可能值。左括号 <strong>必须</strong> 添加在 <code>&#39;+&#39;</code> 的左侧，而右括号必须添加在 <code>&#39;+&#39;</code> 的右侧。</p><p>返回添加一对括号后形成的表达式 <code>expression</code> ，且满足 <code>expression</code> 计算得到 <strong>最小</strong> 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。</p><p>生成的输入满足：<code>expression</code> 的原始值和添加满足要求的任一对括号之后 <code>expression</code> 的值，都符合 32-bit 带符号整数范围。</p><p>示例1：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;247+38&quot;</span><br>输出：<span class="hljs-string">&quot;2(47+38)&quot;</span><br>解释：表达式计算得到 <span class="hljs-number">2</span> * (<span class="hljs-number">47</span> + <span class="hljs-number">38</span>) = <span class="hljs-number">2</span> * <span class="hljs-number">85</span> = <span class="hljs-number">170</span> 。<br>注意 <span class="hljs-string">&quot;2(4)7+38&quot;</span> 不是有效的结果，因为右括号必须添加在 <span class="hljs-string">&#x27;+&#x27;</span> 的右侧。<br>可以证明 <span class="hljs-number">170</span> 是最小可能值。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：expression = &quot;12+34&quot;<br>输出：&quot;1(2+3)4&quot;<br>解释：表达式计算得到<span class="hljs-number"> 1 </span>* (2 + 3) *<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 1 </span>*<span class="hljs-number"> 5 </span>*<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 20 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mel">输入：<span class="hljs-keyword">expression</span> = <span class="hljs-string">&quot;999+999&quot;</span><br>输出：<span class="hljs-string">&quot;(999+999)&quot;</span><br>解释：表达式计算得到 <span class="hljs-number">999</span> + <span class="hljs-number">999</span> = <span class="hljs-number">1998</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= expression.length &lt;= 10</code></li><li><code>expression</code> 仅由数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 和 <code>&#39;+&#39;</code> 组成</li><li><code>expression</code> 由数字开始和结束</li><li><code>expression</code> 恰好仅含有一个 <code>&#39;+&#39;</code>.</li><li><code>expression</code> 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimizeResult</span>(<span class="hljs-params">self, expression</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type expression: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 遍历每个可添加位置，然后找一个最小的</span><br>        <br>        <br>        expression_list = expression.split(<span class="hljs-string">&#x27;+&#x27;</span>)<br>        left_list = <span class="hljs-built_in">list</span>(expression_list[<span class="hljs-number">0</span>])<br>        right_list = <span class="hljs-built_in">list</span>(expression_list[<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># print(left_list)</span><br>        <span class="hljs-comment"># print(right_list)</span><br>        <br>        <br>        tmp_res = -<span class="hljs-number">1</span><br>        min_res = <span class="hljs-number">1e9</span><br>        <br>        <br>        <span class="hljs-comment"># left</span><br>        <span class="hljs-comment"># 哨兵</span><br>        left_res = <span class="hljs-number">0</span><br>        right_res = <span class="hljs-built_in">len</span>(right_list)-<span class="hljs-number">1</span><br>        min_res = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list)) + <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list))<br>        <br>        <br>        <br>        <span class="hljs-comment"># min_res = min(min_res, int(&#x27;&#x27;.join(left_list[:1])) * (int(&#x27;&#x27;.join(left_list[1:])) + int(&#x27;&#x27;.join(right_list))))</span><br>        <span class="hljs-comment"># min_res = min(min_res, (int(&#x27;&#x27;.join(left_list)) + int(&#x27;&#x27;.join(right_list[:len(right_list)-1]))) * int(&#x27;&#x27;.join(right_list[len(right_list)-1:])))</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(left_list)):  <span class="hljs-comment"># i代表插在前边</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(right_list)):  <span class="hljs-comment"># j代表插在后边</span><br>                <span class="hljs-comment"># if i != 0 and j != len(right_list) - 1:</span><br>                    <br>                pre = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[:i])) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[:i])) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>                inter = (<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(left_list[i:])) + <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[:j+<span class="hljs-number">1</span>])))<br>                last = <span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[j+<span class="hljs-number">1</span>:])) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(right_list[j+<span class="hljs-number">1</span>:])) <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br><br><br>                tmp_res = pre * inter * last<br><br>                <span class="hljs-keyword">if</span> tmp_res &lt; min_res:<br>                    min_res = tmp_res<br>                    left_res = i<br>                    right_res = j<br>                    <br>                        <br>                    <span class="hljs-comment"># min_res = min(min_res, tmp_res)</span><br>                  <br>                    <br>                    <span class="hljs-comment"># print(left_list[:i])</span><br>                    <span class="hljs-comment"># print(left_list[i:])</span><br>                    <span class="hljs-comment"># print(right_list[:j+1])</span><br>                    <span class="hljs-comment"># print(right_list[j+1:])</span><br>                    <span class="hljs-comment"># assert False</span><br>        <span class="hljs-comment"># print(left_res, right_res)</span><br>        <br>        left_list.insert(left_res, <span class="hljs-string">&#x27;(&#x27;</span>)<br>        right_list.insert(right_res+<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;)&#x27;</span>)<br>        res_list = left_list + [<span class="hljs-string">&#x27;+&#x27;</span>] + right_list<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(res_list)    <br></code></pre></td></tr></table></figure><h1 id="第三题：2233-K-次增加后的最大乘积"><a href="#第三题：2233-K-次增加后的最大乘积" class="headerlink" title="第三题：2233.K 次增加后的最大乘积"></a>第三题：2233.K 次增加后的最大乘积</h1><p><a href="https://leetcode-cn.com/problems/maximum-product-after-k-increments/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>k</code> 。每次操作，你可以选择 <code>nums</code> 中 <strong>任一</strong> 元素并将它 <strong>增加</strong> <code>1</code> 。</p><p>请你返回 <strong>至多</strong> <code>k</code> 次操作后，能得到的 <code>nums</code> 的 <strong>最大乘积</strong> 。由于答案可能很大，请你将答案对 <code>10^9 + 7</code> 取余后返回。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,4], k = 5<br>输出：20<br>解释：将第一个数增加<span class="hljs-number"> 5 </span>次。<br>得到 nums = [5, 4] ，乘积为<span class="hljs-number"> 5 </span>*<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 20 </span>。<br>可以证明<span class="hljs-number"> 20 </span>是能得到的最大乘积，所以我们返回<span class="hljs-number"> 20 </span>。<br>存在其他增加 nums 的方法，也能得到最大乘积。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,3,3,2], k = 2<br>输出：216<br>解释：将第二个数增加<span class="hljs-number"> 1 </span>次，将第四个数增加<span class="hljs-number"> 1 </span>次。<br>得到 nums = [6, 4, 3, 3] ，乘积为<span class="hljs-number"> 6 </span>*<span class="hljs-number"> 4 </span>*<span class="hljs-number"> 3 </span>*<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 216 </span>。<br>可以证明<span class="hljs-number"> 216 </span>是能得到的最大乘积，所以我们返回<span class="hljs-number"> 216 </span>。<br>存在其他增加 nums 的方法，也能得到最大乘积。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length, k &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧；</p><p>自己的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># test = [43, 57, 60, 70, 72, 84, 86, 92]</span><br>        <span class="hljs-comment"># ttt_1 = 1</span><br>        <span class="hljs-comment"># for i in range(len(test)):</span><br>        <span class="hljs-comment">#     ttt_1 *= (test[i] % (1e9+7))</span><br>        <span class="hljs-comment"># print(&quot;ttt_1: &quot;, ttt_1%(1e9+7))</span><br>        <br>        c = <span class="hljs-number">1000000007</span> <span class="hljs-comment"># 这里换成1e9 + 7就过不了</span><br>        <br>        <span class="hljs-comment"># 平均了乘积最大，好像有前缀和那感觉</span><br>        nums.sort()  <span class="hljs-comment"># 从小到大排序</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;nums: &quot;</span>, nums)<br>        tmp_idx = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &lt; nums[i+<span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 这里还是有问题？</span><br>                <span class="hljs-comment"># print(&quot;k: &quot;, k)</span><br>                <span class="hljs-comment"># print(&quot;(nums[i+1] - nums[i]) * i: &quot;, (nums[i+1] - nums[i]) * (i+1))</span><br>                <span class="hljs-keyword">if</span> k &gt; (nums[i+<span class="hljs-number">1</span>] - nums[i]) * (i+<span class="hljs-number">1</span>):<br>                    k -= (nums[i+<span class="hljs-number">1</span>] - nums[i]) * (i+<span class="hljs-number">1</span>)<br>                    nums[i] = nums[i+<span class="hljs-number">1</span>]<br>                    <br>                <span class="hljs-keyword">else</span>:<br>                    tmp_idx = i<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(&quot;first nums: &quot;, nums)</span><br>        <span class="hljs-comment"># print(&quot;tmp_idx: &quot;, tmp_idx)</span><br>        <span class="hljs-comment"># print(&quot;k:&quot;, k)</span><br>        <br>        <span class="hljs-keyword">if</span> tmp_idx == -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 把剩余的k均匀展开到各个地方</span><br>            bias = k // <span class="hljs-built_in">len</span>(nums)  <span class="hljs-comment"># 每个能增加几</span><br>            k -= bias * <span class="hljs-built_in">len</span>(nums)<br>            <span class="hljs-comment"># print((nums[0] + bias + 1)**k)</span><br>            <span class="hljs-comment"># print((nums[0] + bias)**(len(nums) - k))</span><br>            <br>            <span class="hljs-comment"># res = ((nums[-1] + bias + 1)**k)  *  ((nums[-1] + bias)**(len(nums) - k))</span><br>            <span class="hljs-comment"># 下边两行替代</span><br>            res = <span class="hljs-number">1</span><br>            a1 = (nums[-<span class="hljs-number">1</span>] + bias + <span class="hljs-number">1</span>)<br>            a2 = (nums[-<span class="hljs-number">1</span>] + bias)<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                res  = ((res % c) * (a1 % c)) % c<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums) - k):<br>                res  = ((res % c) * (a2 % c)) % c<br>            <br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># print(&quot;nums: &quot;, nums)</span><br>            <span class="hljs-comment"># print(&quot;nums[tmp_idx+1:]: &quot;, nums[tmp_idx+1:])</span><br>            res = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tmp_idx+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>                res = ((res%c) * (nums[i]%c)) % c<br>            <br>            t_nums = copy.deepcopy(nums[:tmp_idx+<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># print(&quot;t_nums: &quot;, t_nums)</span><br>            <br>            bias = k // <span class="hljs-built_in">len</span>(t_nums)  <span class="hljs-comment"># 每个能增加几</span><br>            k -= bias * <span class="hljs-built_in">len</span>(t_nums)<br>            <br>            t_res =  <span class="hljs-number">1</span><br>            a1 = (t_nums[-<span class="hljs-number">1</span>] + bias + <span class="hljs-number">1</span>)<br>            a2 = (t_nums[-<span class="hljs-number">1</span>] + bias)<br>            <span class="hljs-comment"># t_res = ((t_nums[-1] + bias + 1)**k)  *  ((t_nums[-1] + bias)**(len(t_nums) - k))</span><br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k):<br>                t_res  = ((t_res % c) * (a1 % c)) % c<br>            <span class="hljs-keyword">for</span> kl <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(t_nums) - k):<br>                t_res  = ((t_res % c) * (a2 % c)) % c<br>            <br>            res = ((res%c) * (t_res%c)) % c<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(res)<br></code></pre></td></tr></table></figure><p>抄大佬的堆的思路：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumProduct</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        c = <span class="hljs-number">1000000007</span> <span class="hljs-comment"># 这里换成1e9 + 7就过不了</span><br>        <span class="hljs-keyword">import</span> heapq<br>        heapq.heapify(nums)<br>        <br>        <span class="hljs-comment"># 直接暴力模拟，k &lt; 10^5</span><br>        <span class="hljs-keyword">while</span> k &gt; <span class="hljs-number">0</span>:<br>            tmp = heapq.heappop(nums)<br>            heapq.heappush(nums, tmp+<span class="hljs-number">1</span>)<br>            k -= <span class="hljs-number">1</span><br>        <br>        res = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            res = ((res%c) * (nums[i]%c)) % c<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>286场LeetCode周赛</title>
    <link href="/2022/03/27/algorithms/leetcode-weekly-contest/286%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/27/algorithms/leetcode-weekly-contest/286%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周周赛久违的在常规时间里做出三题了，感觉还是要先仔细读题然后多想一想常用的数据结构和思路吧，像这次的第二题就很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加；另外这次周赛感觉又在面向答案编程了，自己的思考总是不太全面就开始做题，中间各种边界情况和极端情况就会忽略，笔试比较好用但是面试就不好说了，还是要加强下自己的一次AC准确率！</p><p>第一题：比较简单，但是又忘记了 <code>set</code> 是可以直接相减的了，还用了个 <code>Counter</code> 搞来搞去整了半天，有点过于耗费时间了；</p><p>第二题：看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！</p><p>第三题：数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 <code>10 11 12 13</code> ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 <code>9*</code>次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：5268-找出两数组的不同"><a href="#第一题：5268-找出两数组的不同" class="headerlink" title="第一题：5268.找出两数组的不同"></a>第一题：5268.找出两数组的不同</h1><p><a href="https://leetcode-cn.com/problems/find-the-difference-of-two-arrays/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，请你返回一个长度为 <code>2</code> 的列表 <code>answer</code> ，其中：</p><ul><li><code>answer[0]</code> 是 <code>nums1</code> 中所有 <strong>不</strong> 存在于 <code>nums2</code> 中的 <strong>不同</strong> 整数组成的列表。</li><li><code>answer[1]</code> 是 <code>nums2</code> 中所有 <strong>不</strong> 存在于 <code>nums1</code> 中的 <strong>不同</strong> 整数组成的列表。</li></ul><p><strong>注意</strong>：列表中的整数可以按 <strong>任意</strong> 顺序返回。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3]</span>, nums2 = <span class="hljs-comment">[2,4,6]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[4,6]</span>]</span><br>解释：<br>对于 nums1 ，nums1<span class="hljs-comment">[1]</span> = 2 出现在 nums2 中下标 0 处，然而 nums1<span class="hljs-comment">[0]</span> = 1 和 nums1<span class="hljs-comment">[2]</span> = 3 没有出现在 nums2 中。因此，answer<span class="hljs-comment">[0]</span> = <span class="hljs-comment">[1,3]</span>。<br>对于 nums2 ，nums2<span class="hljs-comment">[0]</span> = 2 出现在 nums1 中下标 1 处，然而 nums2<span class="hljs-comment">[1]</span> = 4 和 nums2<span class="hljs-comment">[2]</span> = 6 没有出现在 nums2 中。因此，answer<span class="hljs-comment">[1]</span> = <span class="hljs-comment">[4,6]</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,3]</span>, nums2 = <span class="hljs-comment">[1,1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[]</span>]</span><br>解释：<br>对于 nums1 ，nums1<span class="hljs-comment">[2]</span> 和 nums1<span class="hljs-comment">[3]</span> 没有出现在 nums2 中。由于 nums1<span class="hljs-comment">[2]</span> == nums1<span class="hljs-comment">[3]</span> ，二者的值只需要在 answer<span class="hljs-comment">[0]</span> 中出现一次，故 answer<span class="hljs-comment">[0]</span> = <span class="hljs-comment">[3]</span>。<br>nums2 中的每个整数都在 nums1 中出现，因此，answer<span class="hljs-comment">[1]</span> = <span class="hljs-comment">[]</span> 。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 1000</li><li>-1000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单，但是又忘记了 <code>set</code> 是可以直接相减的了，还用了个 <code>Counter</code> 搞来搞去整了半天，有点过于耗费时间了；</p><p>方法1（比赛时方法，现在看起来有点蠢hhh）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDifference</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nums1 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1))<br>        nums2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums2))<br>        <br>        cnt1 = Counter(nums1) - Counter(nums2)<br>        cnt2 = Counter(nums2) - Counter(nums1)<br>        <br>        <span class="hljs-built_in">print</span>(cnt1)<br>        <span class="hljs-built_in">print</span>(cnt2)<br>        <br>        res = []<br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt1.items():<br>            tmp.append(key)<br>        res.append(tmp)<br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> cnt2.items():<br>            tmp.append(key)<br>        res.append(tmp)<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>方法2（set方法，只需一行233333）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findDifference</span>(<span class="hljs-params">self, nums1, nums2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums1: List[int]</span><br><span class="hljs-string">        :type nums2: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums1) - <span class="hljs-built_in">set</span>(nums2)), <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(nums2) - <span class="hljs-built_in">set</span>(nums1))]<br></code></pre></td></tr></table></figure><h1 id="第二题：5236-美化数组的最少删除数"><a href="#第二题：5236-美化数组的最少删除数" class="headerlink" title="第二题：5236.美化数组的最少删除数"></a>第二题：5236.美化数组的最少删除数</h1><p><a href="https://leetcode-cn.com/problems/minimum-deletions-to-make-array-beautiful/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，如果满足下述条件，则认为数组 <code>nums</code> 是一个 <strong>美丽数组</strong> ：</p><ul><li><code>nums.length</code> 为偶数</li><li>对所有满足 <code>i % 2 == 0</code> 的下标 <code>i</code> ，<code>nums[i] != nums[i + 1]</code> 均成立</li></ul><p>注意，空数组同样认为是美丽数组。</p><p>你可以从 <code>nums</code> 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 <strong>不变</strong> 。</p><p>返回使 <code>nums</code> 变为美丽数组所需删除的 <strong>最少</strong> 元素数目。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2,3,5]</span><br>输出：1<br>解释：可以删除 nums<span class="hljs-comment">[0]</span> 或 nums<span class="hljs-comment">[1]</span> ，这样得到的 nums = <span class="hljs-comment">[1,2,3,5]</span> 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2,2,3,3]</span><br>输出：2<br>解释：可以删除 nums<span class="hljs-comment">[0]</span> 和 nums<span class="hljs-comment">[5]</span> ，这样得到的 nums = <span class="hljs-comment">[1,2,2,3]</span> 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDeletion</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        res = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        idx_res = <span class="hljs-number">0</span><br>        idx_nums = <span class="hljs-number">0</span><br>        <br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> idx_res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-string">&quot;&quot;&quot; 如果是偶数位了，就直接贪心选 &quot;&quot;&quot;</span><br>                res[idx_res] = nums[i]<br>                idx_res += <span class="hljs-number">1</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> idx_res % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                <span class="hljs-string">&quot;&quot;&quot; 如果是奇数位，选一个离得比较远的 &quot;&quot;&quot;</span><br>                <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(nums):<br>                    <span class="hljs-keyword">if</span> nums[i] != res[idx_res-<span class="hljs-number">1</span>]:<br>                        <span class="hljs-keyword">break</span><br>                    i += <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-comment"># print(nums[i], res[idx_res-1])</span><br>                <span class="hljs-keyword">try</span>:<br>                    res[idx_res] = nums[i]<br>                    idx_res += <span class="hljs-number">1</span><br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">except</span>:<br>                    <span class="hljs-keyword">break</span><br>            <br>            <span class="hljs-comment"># print(&quot;out: &quot;, i)</span><br>                <br><br>        <span class="hljs-keyword">if</span> idx_res % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>            idx_res -= <span class="hljs-number">1</span><br>            <br>            <br>        <span class="hljs-comment"># print(res[:idx_res])</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) - idx_res<br></code></pre></td></tr></table></figure><h1 id="第三题：5253-找到指定长度的回文数"><a href="#第三题：5253-找到指定长度的回文数" class="headerlink" title="第三题：5253.找到指定长度的回文数"></a>第三题：5253.找到指定长度的回文数</h1><p><a href="https://leetcode-cn.com/problems/find-palindrome-with-fixed-length/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>queries</code> 和一个 <strong>正</strong> 整数 <code>intLength</code> ，请你返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是长度为 <code>intLength</code> 的 <strong>正回文数</strong> 中第 <code>queries[i]</code> 小的数字，如果不存在这样的回文数，则为 <code>-1</code>。</p><p><strong>回文数</strong> 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：queries = [1,2,3,4,5,90], intLength = 3<br>输出：[101,111,121,131,141,999]<br>解释：<br>长度为<span class="hljs-number"> 3 </span>的最小回文数依次是：<br>101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...<br>第<span class="hljs-number"> 90 </span>个长度为<span class="hljs-number"> 3 </span>的回文数是<span class="hljs-number"> 999 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">输入：queries</span> <span class="hljs-string">=</span> [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]<span class="hljs-string">,</span> <span class="hljs-string">intLength</span> <span class="hljs-string">=</span> <span class="hljs-number">4</span><br><span class="hljs-string">输出：[1111,1331,1551]</span><br><span class="hljs-string">解释：</span><br><span class="hljs-string">长度为</span> <span class="hljs-number">4</span> <span class="hljs-string">的前</span> <span class="hljs-number">6</span> <span class="hljs-string">个回文数是：</span><br><span class="hljs-number">1001</span><span class="hljs-string">,</span> <span class="hljs-number">1111</span><span class="hljs-string">,</span> <span class="hljs-number">1221</span><span class="hljs-string">,</span> <span class="hljs-number">1331</span><span class="hljs-string">,</span> <span class="hljs-number">1441</span> <span class="hljs-string">和</span> <span class="hljs-number">1551</span> <span class="hljs-string">。</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= queries.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= queries[i] &lt;= 10^9</code></li><li><code>1 &lt;= intLength &lt;= 15</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 <code>10 11 12 13</code> ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 <code>9*</code>次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">kthPalindrome</span>(<span class="hljs-params">self, queries, intLength</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type queries: List[int]</span><br><span class="hljs-string">        :type intLength: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        <span class="hljs-keyword">if</span> intLength == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                res.append(queries[i])<br>            <span class="hljs-comment"># print(res)</span><br>            <span class="hljs-comment"># return res</span><br>        <span class="hljs-keyword">elif</span> intLength == <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                tmp = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">str</span>(queries[i]) + <span class="hljs-built_in">str</span>(queries[i]))<br>                res.append(tmp)<br>            <span class="hljs-comment"># print(res)</span><br>            <span class="hljs-comment"># return res</span><br>        <br>        <span class="hljs-comment"># elif intLength == 3:</span><br>        <span class="hljs-comment">#     for i in range(len(queries)):</span><br>        <span class="hljs-comment">#         a = queries[i] // 10 + 1</span><br>        <span class="hljs-comment">#         b = queries[i] % 10 - 1</span><br>        <span class="hljs-comment">#         if b == -1:</span><br>        <span class="hljs-comment">#             b = 9</span><br>        <span class="hljs-comment">#         if a == 10:</span><br>        <span class="hljs-comment">#             a = 9</span><br>        <span class="hljs-comment">#         tmp = int(str(a) + str(b) + str(a))   </span><br>        <span class="hljs-comment">#         res.append(tmp)</span><br>        <span class="hljs-comment">#     # print(res)</span><br>        <span class="hljs-comment">#     # return res</span><br>        <span class="hljs-keyword">else</span>:      <br>            ttmp = intLength // <span class="hljs-number">2</span>  <span class="hljs-comment"># 整除2</span><br>            <span class="hljs-keyword">if</span> intLength % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 要求偶数位，那就是第i个ttmp位数</span><br>                base_idx = <span class="hljs-number">10</span> ** (ttmp - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                    half = <span class="hljs-built_in">str</span>(base_idx + queries[i])<br>                    res.append(<span class="hljs-built_in">int</span>(half + half[::-<span class="hljs-number">1</span>]))<br>                <span class="hljs-comment"># return res</span><br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 奇数位的，先确定中间的</span><br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>                    mid = <span class="hljs-built_in">str</span>((queries[i] - <span class="hljs-number">1</span>) % <span class="hljs-number">10</span>)<br>                    <span class="hljs-comment"># print(mid)</span><br>                    base_idx = <span class="hljs-number">10</span> ** (ttmp - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>  <span class="hljs-comment"># 多少位数在前边</span><br>                    <br>                    <span class="hljs-keyword">if</span> queries[i] % <span class="hljs-number">10</span> != <span class="hljs-number">0</span>:<br>                        offset = (queries[i] // <span class="hljs-number">10</span>) + <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        offset = (queries[i] // <span class="hljs-number">10</span>)<br>                    <br>                    <br>                    <br>                    half = <span class="hljs-built_in">str</span>(base_idx + offset)<br>                    <span class="hljs-comment"># print(half)</span><br>                    res.append(<span class="hljs-built_in">int</span>(half+mid+half[::-<span class="hljs-number">1</span>]))<br>            <br>                <span class="hljs-comment"># return res</span><br>        <br>        max_tmp = (<span class="hljs-number">10</span> ** intLength) - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(res)):<br>            <span class="hljs-keyword">if</span> res[i] &gt; max_tmp:<br>                res[i] = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录服务器conda虚拟环境导出</title>
    <link href="/2022/03/23/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BA/"/>
    <url>/2022/03/23/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>某些场景下需要进行虚拟环境迁移，或者使用其他人的虚拟环境，这种时候如果能够完整导出别人的虚拟环境，在自己的环境下直接下载同步就很方便。</p><span id="more"></span><p>Reference:</p><blockquote><p><a href="https://blog.csdn.net/shunaoxi2313/article/details/92003710">https://blog.csdn.net/shunaoxi2313/article/details/92003710</a></p></blockquote><h1 id="原机器A的导出准备"><a href="#原机器A的导出准备" class="headerlink" title="原机器A的导出准备"></a>原机器A的导出准备</h1><p>通过如下命令，可以查看当前conda的可用环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda info --envs<br><span class="hljs-meta prompt_"># </span><span class="language-bash">conda environments:</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">base                  *  /home/abc/miniconda3</span><br></code></pre></td></tr></table></figure><p>导出当前的conda环境（注意，这样导出貌似只会导出使用conda命令安装的内容，如果需要导出pip则还需要其他步骤），这里直接在base环境下（如果要导出别的，就conda activate venv1这类的之后再导出就可以）。导出后会在目录下生成一个py36.yaml文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda env export &gt; py36.yaml<br></code></pre></td></tr></table></figure><p><strong>注意</strong>如果导出base环境的话，在目标机器上可能会提示已存在base环境（而且base环境无法删除）。所以如果导出base环境最好先复制一下，再导出base环境的复制品，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda create -n h1_abc_base --clone base<br>Source:      /home/abc/miniconda3<br>Destination: /home/abc/miniconda3/envs/h1_abc_base<br>The following packages cannot be cloned out of the root environment:<br> - defaults/linux-64::conda-4.9.2-py36h06a4308_0<br>Packages: 84<br>Files: 35464<br><br>Preparing transaction: done<br>Verifying transaction: done<br>Executing transaction: / Enabling nb_conda_kernels...<br>Status: enabled<br>done<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># To activate this environment, use</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">#     $ conda activate h1_abc_base</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># To deactivate an active environment, use</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment">#     $ conda deactivate</span></span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) abc@h1:~$ conda activate h1_abc_base<br>(h1_abc_base) abc@h1:~$ conda env export &gt; h1_abc_base.yaml<br></code></pre></td></tr></table></figure><p>完成上述步骤后，查看了一下h1_abc_base.yaml文件，其中已经包含了pip安装的一些内容，不过为了以防万一还是也把pip的内容导出一遍，如下所示，会生成requirements.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">(h1_abc_base) abc@h1:~$ pip freeze &gt; h1_abc_base_requirements.txt<br></code></pre></td></tr></table></figure><h1 id="目标机器B的迁移"><a href="#目标机器B的迁移" class="headerlink" title="目标机器B的迁移"></a>目标机器B的迁移</h1><p>下载目标机器A最终生成的 <code>h1_abc_base.yaml</code> 与 <code>h1_abc_base_requirements.txt</code>，复制到目标机器的个人conda&#x2F;miniconda目录下 <code>/data/sdb1/lyx/</code></p><p>首先执行如下操作，导入conda环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:/data/sdb1/lyx$ conda env create -f h1_abc_base.yaml<br><br>...<br><br>Successfully built docopt jieba pyrouge sklearn termcolor textrank4zh<br>Installing collected packages: jmespath, numpy, cached-property, botocore, werkzeug, threadpoolctl, scipy, s3transfer, protobuf, markdown, joblib, h5py, grpcio, yarg, torch, termcolor, tensorboard, scikit-learn, regex, pytz, networkx, keras-preprocessing, keras-applications, jieba, gast, docopt, dill, boto3, astor, absl-py, textrank4zh, tensorflow, tensorboardx, sklearn, rouge, pytorch-pretrained-bert, pyrouge, pipreqs, pandas, multiprocess, emoji<br>Successfully installed absl-py-0.11.0 astor-0.8.1 boto3-1.17.68 botocore-1.20.69 cached-property-1.5.2 dill-0.3.3 docopt-0.6.2 emoji-1.2.0 gast-0.4.0 grpcio-1.33.2 h5py-3.1.0 jieba-0.42.1 jmespath-0.10.0 joblib-0.17.0 keras-applications-1.0.8 keras-preprocessing-1.1.2 markdown-3.3.3 multiprocess-0.70.11.1 networkx-2.5.1 numpy-1.16.0 pandas-1.1.4 pipreqs-0.4.10 protobuf-3.14.0 pyrouge-0.1.3 pytorch-pretrained-bert-0.6.2 pytz-2020.4 regex-2021.4.4 rouge-1.0.0 s3transfer-0.4.2 scikit-learn-0.23.2 scipy-1.5.4 sklearn-0.0 tensorboard-1.12.2 tensorboardx-2.1 tensorflow-1.12.0 termcolor-1.1.0 textrank4zh-0.3 threadpoolctl-2.1.0 torch-1.1.0 werkzeug-1.0.1 yarg-0.1.9<br></code></pre></td></tr></table></figure><p>其次执行如下操作，安装pip的包的版本（不一定要做）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:/data/sdb1/lyx$ conda activate h1_abc_base<br>(h1_abc_base) lyx@h5:/data/sdb1/lyx$ pip install -r h1_abc_base_requirements.txt <br></code></pre></td></tr></table></figure><p><strong>注意目前的安装操作还是需要在线环境才能安装的，离线安装的时候可能需要在导出环境配置文件的同时把下载环境的那些文件也都一起导出来，未来如果有需求的时候再进一步研究了！</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">(h1_abc_base) lyx<span class="hljs-variable">@h5</span><span class="hljs-symbol">:/data/sdb1/lyx</span><span class="hljs-variable">$ </span>python<br><span class="hljs-title class_">Python</span> <span class="hljs-number">3.6</span>.<span class="hljs-number">12</span> |<span class="hljs-title class_">Anaconda</span>, <span class="hljs-title class_">Inc</span>.| (default, <span class="hljs-title class_">Sep</span>  <span class="hljs-number">8</span> <span class="hljs-number">2020</span>, <span class="hljs-number">23</span><span class="hljs-symbol">:</span><span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">56</span>) <br>[<span class="hljs-title class_">GCC</span> <span class="hljs-number">7.3</span>.<span class="hljs-number">0</span>] on linux<br><span class="hljs-title class_">Type</span> <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; <span class="hljs-keyword">import</span> torch<br>&gt;&gt;&gt; torch.cuda.is_available()<br><span class="hljs-title class_">True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python-ACM模式的输入输出</title>
    <link href="/2022/03/23/algorithms/python-ACM%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/03/23/algorithms/python-ACM%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>在笔试环节做题的时候，题目大多数情况会是以ACM模式的输入输出构造，</p><span id="more"></span><p>Reference: <a href="https://blog.csdn.net/mmmmonkeyfei/article/details/118863773">https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</a></p><h1 id="各种类型情况总结"><a href="#各种类型情况总结" class="headerlink" title="各种类型情况总结"></a>各种类型情况总结</h1><p>TODO</p><h1 id="PTA的平台可以用python交，POJ用python交不了"><a href="#PTA的平台可以用python交，POJ用python交不了" class="headerlink" title="PTA的平台可以用python交，POJ用python交不了"></a>PTA的平台可以用python交，POJ用python交不了</h1><h2 id="example1-POJ2524：并查集题目"><a href="#example1-POJ2524：并查集题目" class="headerlink" title="example1: POJ2524：并查集题目"></a>example1: POJ2524：并查集题目</h2><p><a href="http://poj.org/problem?id=2524">题目链接</a></p><p>除了数据输入输出的提醒以外，也还提醒了以前很多在C语言算法题的时候，用的数组都可以用哈希表替代</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这里是哈希表</span><br>par = &#123;&#125;<br>vis = &#123;&#125;<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_root</span>(<span class="hljs-params">a</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">找根（找部落）</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">if</span> par[a] != a:<br>par[a] = get_root(par[a])<br><span class="hljs-keyword">return</span> par[a]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">merge</span>(<span class="hljs-params">a, b</span>):<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">把p2往p1聚类</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>p1 = get_root(a)<br>p2 = get_root(b)<br><span class="hljs-keyword">if</span> p1 != p2:<br>par[p2] = p1<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>js = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>))<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> m == <span class="hljs-number">0</span>:<br><span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># 这里重置了</span><br>vis = &#123;&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br>par[i] = i<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&quot; &quot;</span>))<br>merge(a, b)<br><br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>):<br><span class="hljs-keyword">if</span> vis.get(get_root(i)) == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">continue</span><br><span class="hljs-keyword">else</span>:<br>count += <span class="hljs-number">1</span><br>vis[get_root(i)] = <span class="hljs-number">1</span><br><br>js += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Case %d: %d\n&quot;</span>  % (js, count), end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="example2-尝试输入输出字符串，GPLT轮着输出几次"><a href="#example2-尝试输入输出字符串，GPLT轮着输出几次" class="headerlink" title="example2-尝试输入输出字符串，GPLT轮着输出几次"></a>example2-尝试输入输出字符串，GPLT轮着输出几次</h2><p><a href="https://pintia.cn/problem-sets/994805046380707840/problems/994805113036587008">题目链接</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">output_gplt</span>(<span class="hljs-params">self, s</span>):<br>        cnt_dict = Counter(s)<br>        return_list = []<br>        cnt_g = cnt_dict.get(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_p = cnt_dict.get(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;P&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_l = cnt_dict.get(<span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-number">0</span>)<br>        cnt_t = cnt_dict.get(<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-number">0</span>) + cnt_dict.get(<span class="hljs-string">&#x27;T&#x27;</span>, <span class="hljs-number">0</span>)<br><br><br>        <span class="hljs-keyword">while</span> cnt_g != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_p != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_l != <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> cnt_t != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> cnt_g != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;G&#x27;</span>)<br>                cnt_g -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_p != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;P&#x27;</span>)<br>                cnt_p -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_l != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;L&#x27;</span>)<br>                cnt_l -= <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">if</span> cnt_t != <span class="hljs-number">0</span>:<br>                return_list.append(<span class="hljs-string">&#x27;T&#x27;</span>)<br>                cnt_t -= <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(return_list)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    s = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>())<br>    res = Solution().output_gplt(s)<br>    <span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h2 id="example3"><a href="#example3" class="headerlink" title="example3-"></a>example3-</h2>]]></content>
    
    
    
    <tags>
      
      <tag>LeetCode-python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>285场LeetCode周赛</title>
    <link href="/2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>被周末临时开会打断的一次周赛，有点烦hhh。总结来说这次周赛给的教训第一个应该就是好好读题？好好读题理解题意后再开始做，反而会比一上来突然来个想法就做顺利很多，在每个想法开始前要有个大概的实现难度预估和通过可能性预估，一般来说周赛前三个题仔细思考下，合理性分析下，感觉还都是可以做出来的，思路其实绕来绕去大部分还是那些，比较需要构思好再写吧！</p><p>第一题：比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序；</p><p>第二题：这个题自己想到的是一种模拟的思想，但是模拟过去后 <code>RRRRS</code> 这种情况，自己的操作后会变成 <code>RRRSS</code> ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 <code>LLLL</code> ，后缀去掉 <code>RRRR</code> ，最后中间的不是 <code>S</code> 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法；</p><p>第三题：原来 <code>2^n</code> 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 <code>20-32</code> 以内，就可以暴力遍历 <code>2^20~30</code> 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6027-统计数组中峰和谷的数量"><a href="#第一题：6027-统计数组中峰和谷的数量" class="headerlink" title="第一题：6027.统计数组中峰和谷的数量"></a>第一题：6027.统计数组中峰和谷的数量</h1><p><a href="https://leetcode-cn.com/problems/count-hills-and-valleys-in-an-array/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。如果两侧距 <code>i</code> 最近的不相等邻居的值均小于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中，某个峰的一部分。类似地，如果两侧距 <code>i</code> 最近的不相等邻居的值均大于 <code>nums[i]</code> ，则下标 <code>i</code> 是 <code>nums</code> 中某个谷的一部分。对于相邻下标 <code>i</code> 和 <code>j</code> ，如果 <code>nums[i] == nums[j]</code> ， 则认为这两下标属于 <strong>同一个</strong> 峰或谷。</p><p>注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 <strong>都</strong> 存在不相等邻居。</p><p>返回 <code>nums</code> 中峰和谷的数量。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,4,1,1,6,5]<br>输出：3<br>解释：<br>在下标<span class="hljs-number"> 0 </span>：由于<span class="hljs-number"> 2 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 0 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 1 </span>：4 的最近不相等邻居是<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 1 </span>。由于<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 2 </span>且<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 1 </span>，下标<span class="hljs-number"> 1 </span>是一个峰。<br>在下标<span class="hljs-number"> 2 </span>：1 的最近不相等邻居是<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>。由于<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 4 </span>且<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 6 </span>，下标<span class="hljs-number"> 2 </span>是一个谷。<br>在下标<span class="hljs-number"> 3 </span>：1 的最近不相等邻居是<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>。由于<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 4 </span>且<span class="hljs-number"> 1 </span>&lt;<span class="hljs-number"> 6 </span>，下标<span class="hljs-number"> 3 </span>符合谷的定义，但需要注意它和下标<span class="hljs-number"> 2 </span>是同一个谷的一部分。<br>在下标<span class="hljs-number"> 4 </span>：6 的最近不相等邻居是<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 5 </span>。由于<span class="hljs-number"> 6 </span>&gt;<span class="hljs-number"> 1 </span>且<span class="hljs-number"> 6 </span>&gt;<span class="hljs-number"> 5 </span>，下标<span class="hljs-number"> 4 </span>是一个峰。<br>在下标<span class="hljs-number"> 5 </span>：由于<span class="hljs-number"> 5 </span>的右侧不存在不相等邻居，所以下标<span class="hljs-number"> 5 </span>既不是峰也不是谷。<br>共有<span class="hljs-number"> 3 </span>个峰和谷，所以返回<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [6,6,5,5,4,1]<br>输出：0<br>解释：<br>在下标<span class="hljs-number"> 0 </span>：由于<span class="hljs-number"> 6 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 0 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 1 </span>：由于<span class="hljs-number"> 6 </span>的左侧不存在不相等邻居，所以下标<span class="hljs-number"> 1 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 2 </span>：5 的最近不相等邻居是<span class="hljs-number"> 6 </span>和<span class="hljs-number"> 4 </span>。由于<span class="hljs-number"> 5 </span>&lt;<span class="hljs-number"> 6 </span>且<span class="hljs-number"> 5 </span>&gt;<span class="hljs-number"> 4 </span>，下标<span class="hljs-number"> 2 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 3 </span>：5 的最近不相等邻居是<span class="hljs-number"> 6 </span>和<span class="hljs-number"> 4 </span>。由于<span class="hljs-number"> 5 </span>&lt;<span class="hljs-number"> 6 </span>且<span class="hljs-number"> 5 </span>&gt;<span class="hljs-number"> 4 </span>，下标<span class="hljs-number"> 3 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 4 </span>：4 的最近不相等邻居是<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 1 </span>。由于<span class="hljs-number"> 4 </span>&lt;<span class="hljs-number"> 5 </span>且<span class="hljs-number"> 4 </span>&gt;<span class="hljs-number"> 1 </span>，下标<span class="hljs-number"> 4 </span>既不是峰也不是谷。<br>在下标<span class="hljs-number"> 5 </span>：由于<span class="hljs-number"> 1 </span>的右侧不存在不相等邻居，所以下标<span class="hljs-number"> 5 </span>既不是峰也不是谷。<br>共有<span class="hljs-number"> 0 </span>个峰和谷，所以返回<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>3 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序；</p><p>下边这个代码实际上冗余了很多；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countHillValley</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        tmp_nums = []<br>        tmp = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> tmp == -<span class="hljs-number">1</span>:<br>                tmp = nums[i]<br>                tmp_nums.append(nums[i])<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> nums[i] == tmp:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">else</span>:<br>                    tmp = nums[i]<br>                    tmp_nums.append(nums[i])<br>        <br>        <span class="hljs-built_in">print</span>(tmp_nums)<br>        <br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(tmp_nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 找到左边不相等的</span><br>            <br>            t1 = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> tmp_nums[j] != tmp_nums[i]:<br>                    t1 = tmp_nums[j]<br>                    <span class="hljs-keyword">break</span><br>                    <br>            t2 = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(tmp_nums)):<br>                <span class="hljs-keyword">if</span> tmp_nums[j] != tmp_nums[i]:<br>                    t2 = tmp_nums[j]<br>                    <span class="hljs-keyword">break</span><br>                    <br>            <span class="hljs-built_in">print</span>(tmp_nums[i], t1, t2)<br>            <br>            <span class="hljs-keyword">if</span> (tmp_nums[i] &gt; t1 <span class="hljs-keyword">and</span> tmp_nums[i] &gt; t2 <span class="hljs-keyword">and</span> t1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t2 != -<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> (tmp_nums[i] &lt; t1 <span class="hljs-keyword">and</span> tmp_nums[i] &lt; t2 <span class="hljs-keyword">and</span> t1 != -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> t2 != -<span class="hljs-number">1</span>):<br>                cnt +=<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：6028-统计道路上的碰撞次数"><a href="#第二题：6028-统计道路上的碰撞次数" class="headerlink" title="第二题：6028.统计道路上的碰撞次数"></a>第二题：6028.统计道路上的碰撞次数</h1><p><a href="https://leetcode-cn.com/problems/count-collisions-on-a-road/submissions/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>在一条无限长的公路上有 <code>n</code> 辆汽车正在行驶。汽车按从左到右的顺序按从 <code>0</code> 到 <code>n - 1</code> 编号，每辆车都在一个 <strong>独特的</strong> 位置。</p><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>directions</code> ，长度为 <code>n</code> 。<code>directions[i]</code> 可以是 <code>&#39;L&#39;</code> 、 <code>&#39;R&#39;</code> 或 <code>&#39;S&#39;</code> 分别表示第 <code>i</code> 辆车是向 <strong>左</strong> 、向 <strong>右</strong> 或者 <strong>停留</strong> 在当前位置。每辆车移动时 <strong>速度相同</strong> 。</p><p>碰撞次数可以按下述方式计算：</p><ul><li>当两辆移动方向 相反 的车相撞时，碰撞次数加 <code>2</code> 。</li><li>当一辆移动的车和一辆静止的车相撞时，碰撞次数加 <code>1</code> 。</li></ul><p>碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。</p><p>返回在这条道路上发生的 <strong>碰撞总次数</strong> 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：directions = &quot;RLRSLL&quot;<br>输出：5<br>解释：<br>将会在道路上发生的碰撞列出如下：<br>- 车<span class="hljs-number"> 0 </span>和车<span class="hljs-number"> 1 </span>会互相碰撞。由于它们按相反方向移动，碰撞数量变为<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 2 </span>。<br>- 车<span class="hljs-number"> 2 </span>和车<span class="hljs-number"> 3 </span>会互相碰撞。由于<span class="hljs-number"> 3 </span>是静止的，碰撞数量变为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 3 </span>。<br>- 车<span class="hljs-number"> 3 </span>和车<span class="hljs-number"> 4 </span>会互相碰撞。由于<span class="hljs-number"> 3 </span>是静止的，碰撞数量变为<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>- 车<span class="hljs-number"> 4 </span>和车<span class="hljs-number"> 5 </span>会互相碰撞。在车<span class="hljs-number"> 4 </span>和车<span class="hljs-number"> 3 </span>碰撞之后，车<span class="hljs-number"> 4 </span>会待在碰撞位置，接着和车<span class="hljs-number"> 5 </span>碰撞。碰撞数量变为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 5 </span>。<br>因此，将会在道路上发生的碰撞总次数是<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：directions <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LLRR&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：<br>不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= directions.length &lt;= 10^5</code></li><li><code>directions[i]</code> 的值为 <code>&#39;L&#39;</code> 、<code>&#39;R&#39;</code> 或 <code>&#39;S&#39;</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题自己想到的是一种模拟的思想，但是模拟过去后 <code>RRRRS</code> 这种情况，自己的操作后会变成 <code>RRRSS</code> ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 <code>LLLL</code> ，后缀去掉 <code>RRRR</code> ，最后中间的不是 <code>S</code> 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countCollisions</span>(<span class="hljs-params">self, directions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type directions: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># directions += &#x27;R&#x27;  # 哨兵</span><br>        <br>        init_status = [[i, i, <span class="hljs-string">&#x27;S&#x27;</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(directions))]  <span class="hljs-comment"># 第几个车，第几个车移动后，这个车的移动方向是</span><br>        <br>        new_status = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(init_status)):<br>            <span class="hljs-keyword">if</span> directions[i] == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                new_status.append([init_status[i][<span class="hljs-number">0</span>], init_status[i][<span class="hljs-number">0</span>]-<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;L&#x27;</span>])<br>            <span class="hljs-keyword">elif</span> directions[i] == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                new_status.append([init_status[i][<span class="hljs-number">0</span>], init_status[i][<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;R&#x27;</span>])<br>            <span class="hljs-keyword">elif</span> directions[i] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                new_status.append(init_status[i])<br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_status)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">1</span>] &gt;= new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:<br>                <span class="hljs-comment"># 这两个会撞上，判断两个状态</span><br>                <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;S&#x27;</span> <span class="hljs-keyword">and</span> new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;S&#x27;</span> <span class="hljs-keyword">and</span> new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] != new_status[i][<span class="hljs-number">2</span>]:<br>                    <span class="hljs-comment"># print(&quot;2: &quot;, new_status[i], new_status[i+1])</span><br>                    res += <span class="hljs-number">2</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># print(&quot;1: &quot;, new_status[i], new_status[i+1])</span><br>                    res += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># 汇总成之前的，不应该是之前的</span><br>                new_status[i] = init_status[i]<br>                new_status[i][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>                new_status[i+<span class="hljs-number">1</span>] = init_status[i+<span class="hljs-number">1</span>]<br>                new_status[i+<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>                <span class="hljs-comment"># print(&quot;i, new_status: &quot;, i, new_status)</span><br>                <br><span class="hljs-comment">#         # 还需要再过一遍</span><br><span class="hljs-comment">#         # 正着过</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(new_status)):<br>            <span class="hljs-keyword">if</span> new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-keyword">and</span> new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                res += <span class="hljs-number">1</span><br>                new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(new_status)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;R&#x27;</span> <span class="hljs-keyword">and</span> new_status[i][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;S&#x27;</span>:<br>                res += <span class="hljs-number">1</span><br>                new_status[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;S&#x27;</span><br>  <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：6029-射箭比赛中的最大得分"><a href="#第三题：6029-射箭比赛中的最大得分" class="headerlink" title="第三题：6029.射箭比赛中的最大得分"></a>第三题：6029.射箭比赛中的最大得分</h1><p><a href="https://leetcode-cn.com/problems/maximum-points-in-an-archery-competition/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下：</p><ol><li>Alice 先射 <code>numArrows</code> 支箭，然后 Bob 也射 <code>numArrows</code> 支箭。</li><li>分数按下述规则计算：<ol><li>箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。</li><li>箭靶上每个区域都对应一个得分 <code>k</code>（范围是 <code>0</code> 到 <code>11</code>），Alice 和 Bob 分别在得分 <code>k</code> 区域射中 <code>ak</code> 和 <code>bk</code> 支箭。如果 <code>ak &gt;= bk</code> ，那么 Alice 得 <code>k</code> 分。如果 <code>ak &lt; bk</code> ，则 Bob 得 <code>k</code> 分</li><li>如果 <code>ak == bk == 0</code> ，那么无人得到 <code>k</code> 分。</li></ol></li></ol><ul><li>例如，Alice 和 Bob 都向计分为 <code>11</code> 的区域射 <code>2</code> 支箭，那么 Alice 得 <code>11</code> 分。如果 Alice 向计分为 <code>11</code> 的区域射 <code>0</code> 支箭，但 Bob 向同一个区域射 <code>2</code> 支箭，那么 Bob 得 <code>11</code> 分。</li></ul><p>给你整数 <code>numArrows</code> 和一个长度为 <code>12</code> 的整数数组 <code>aliceArrows</code> ，该数组表示 Alice 射中 <code>0</code> 到 <code>11</code> 每个计分区域的箭数量。现在，Bob 想要尽可能 <strong>最大化</strong> 他所能获得的总分。</p><p>返回数组 <code>bobArrows</code> ，该数组表示 Bob 射中 <code>0</code> 到 <code>11</code> <strong>每个</strong> 计分区域的箭数量。且 <code>bobArrows</code> 的总和应当等于 <code>numArrows</code> 。</p><p>如果存在多种方法都可以使 Bob 获得最大总分，返回其中 <strong>任意一种</strong> 即可。</p><p>示例1：</p><p><img src="/images/2022-03-20-23-45-26.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]<br>输出：[0,0,0,0,1,1,0,0,1,2,3,1]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 8 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 11 </span>=<span class="hljs-number"> 47 </span>。<br>可以证明 Bob 无法获得比<span class="hljs-number"> 47 </span>更高的分数。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/_posts/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-03-20-23-45-58.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：numArrows = <span class="hljs-number">3</span>, aliceArrows = [<span class="hljs-number">0,0,1,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,2</span>]<br>输出：[<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">0,0,0,0</span>,<span class="hljs-number">1,1,1,0</span>]<br>解释：上表显示了比赛得分情况。<br>Bob 获得总分 <span class="hljs-number">8</span> + <span class="hljs-number">9</span> + <span class="hljs-number">10</span> = <span class="hljs-number">27</span> 。<br>可以证明 Bob 无法获得比 <span class="hljs-number">27</span> 更高的分数。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= numArrows &lt;= 10^5</code></li><li><code>aliceArrows.length == bobArrows.length == 12</code></li><li><code>0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows</code></li><li><code>sum(aliceArrows[i]) == numArrows</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>原来 <code>2^n</code> 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 <code>20-32</code> 以内，就可以暴力遍历 <code>2^20~30</code> 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumBobPoints</span>(<span class="hljs-params">self, numArrows, aliceArrows</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type numArrows: int</span><br><span class="hljs-string">        :type aliceArrows: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_score = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 直接暴力枚举，11种二进制转状态，判断在哪些状态能得分（是合理的）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(aliceArrows)):<br>            tmp_bin = []<br>            tmp = i<br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                tmp_bin.append(tmp&amp;<span class="hljs-number">1</span>)<br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>            tmp_bin += [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aliceArrows)-<span class="hljs-built_in">len</span>(tmp_bin))]<br>            <br>            <span class="hljs-comment"># 1代表要在这些位置上击败alice，然后做合理性判断就行了</span><br>            flag = <span class="hljs-literal">True</span><br>            cnt = <span class="hljs-number">0</span><br>            tmp_score = <span class="hljs-number">0</span><br>            tmp_list = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(aliceArrows)):<br>                <span class="hljs-keyword">if</span> tmp_bin[j] == <span class="hljs-number">1</span>:<br>                    cnt += aliceArrows[j] + <span class="hljs-number">1</span><br>                    tmp_score += j<br>                    tmp_list.append(aliceArrows[j] + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">else</span>:<br>                    tmp_list.append(<span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 这里判断合理性</span><br>            <span class="hljs-keyword">if</span> cnt &lt;= numArrows:<br>                <span class="hljs-keyword">if</span> tmp_score &gt; max_score:<br>                    max_score= tmp_score<br>                    res = tmp_list<br>                    res[<span class="hljs-number">0</span>] = numArrows - <span class="hljs-built_in">sum</span>(res)<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>位运算</tag>
      
      <tag>栈</tag>
      
      <tag>枚举</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2044.统计按位或能得到最大值的子集数目-python</title>
    <link href="/2022/03/15/algorithms/leetcode-python/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE-python/"/>
    <url>/2022/03/15/algorithms/leetcode-python/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE-python/</url>
    
    <content type="html"><![CDATA[<p>2044.统计按位或能得到最大值的子集数目（中等）</p><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p><p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/">题目链接</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 <strong>按位或</strong> 可能得到的 <strong>最大值</strong> ，并返回按位或能得到最大值的 <strong>不同非空子集的数目</strong> 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 <code>a</code> 是数组 <code>b</code> 的一个 <strong>子集</strong> 。如果选中的元素下标位置不一样，则认为两个子集 <strong>不同</strong> 。</p><p>对数组 <code>a</code> 执行 <strong>按位或</strong> ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 <strong>0</strong> 开始）。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,1]</span><br>输出：2<br>解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：<br>- <span class="hljs-comment">[3]</span><br>- <span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [2,2,2]<br>输出：7<br>解释：[2,2,2] 的所有非空子集的按位或都可以得到<span class="hljs-number"> 2 </span>。总共有<span class="hljs-number"> 23 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 7 </span>个子集。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[3,2,1,5]</span><br>输出：6<br>解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：<br>- <span class="hljs-comment">[3,5]</span><br>- <span class="hljs-comment">[3,1,5]</span><br>- <span class="hljs-comment">[3,2,5]</span><br>- <span class="hljs-comment">[3,2,1,5]</span><br>- <span class="hljs-comment">[2,5]</span><br>- <span class="hljs-comment">[2,1,5]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 16</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>典型的 <code>2^n</code> 暴力遍历题目，题目里给的提示 <code>16</code> 也代表了这个意思， <code>2^16 = 65536</code>；</p><p>如果是每日一题的话就先不用回溯搞了，回溯好像是dfs分为取和不取的两个分支往下dfs，写起来稍微有点麻烦；</p><p>大佬的提醒下不用做什么哈希表了，在迭代判断的过程中直接记录 <code>max</code> ，然后出现新的更大的 <code>refresh</code> 掉那个 <code>cnt</code> 、没出现新的然后等于 <code>max</code> 的直接 <code>cnt+=1</code> 这样就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countMaxOrSubsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_or = <span class="hljs-number">0</span><br>        max_or_count = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(nums)):<br>            tmp = i<br>            tmp_list = []<br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                tmp_list.append(tmp&amp;<span class="hljs-number">1</span>)<br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>            tmp_list += [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-built_in">len</span>(tmp_list))]<br>            <span class="hljs-comment"># print(tmp_list)  # 1是选择，0是不选择</span><br><br>            tmp_or = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp_list)):<br>                <span class="hljs-keyword">if</span> tmp_list[j] == <span class="hljs-number">1</span>:<br>                    tmp_or |= nums[j]  <span class="hljs-comment"># 按位或简单写法</span><br>            <span class="hljs-keyword">if</span> tmp_or &gt; max_or:<br>                max_or = tmp_or<br>                max_or_count = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> tmp_or == max_or:<br>                max_or_count += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> max_or_count<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>589.N叉树的前序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>589.N叉树的前序遍历（简单）</p><p>题目大意：</p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">题目链接</a></p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>前序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p>示例1：</p><p><img src="/images/2022-03-14-21-13-50.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-03-14-21-14-19.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>节点总数在范围 <code>[0, 10^4]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^4</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>这个题要是用递归的话那是绝对的简单题，N叉树就感觉把所有children走一遍就行了，和二叉树的前序遍历递归完全是一个模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_preorder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            res.append(root.val)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> root.children:<br>                dfs_preorder(ch)     <br>        dfs_preorder(root)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h2><p>N叉树的前序遍历和后序遍历的迭代法本质就是栈的应用，前序遍历是每次弹出来就加，而后序遍历要在每次加的基础上最后reverse一下</p><p>在自己设定好栈顶和栈底的基础上，按照操作来就可以了，手写模拟下很快就能找到规律</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">preorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 前序遍历用栈实现非递归</span><br>        res = []<br>        stack = []<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(root)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack):<br>            tmp = stack[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 左边是栈顶，右边是栈底</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            res.append(tmp.val)<br>            <span class="hljs-comment"># tmp.children是一个list，倒序入栈，这个还是相对好像的吧</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp.children)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> tmp.children[i] <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    stack.insert(<span class="hljs-number">0</span>, tmp.children[i])  <span class="hljs-comment"># 在位置0insert</span><br>                    <span class="hljs-comment"># print([a.val for a in stack])</span><br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>590.N叉树的后序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>590.N叉树的后序遍历（简单）</p><p>题目大意：</p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>后序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">题目链接</a></p><p>给定一个 n 叉树的根节点  <code>root</code> ，返回 其节点值的 <strong>后序遍历</strong> 。</p><p>n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p>示例1：</p><p><img src="/images/2022-03-14-21-13-50.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-03-14-21-14-19.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>节点总数在范围 <code>[0, 10^4]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 10^4</code></li><li>n 叉树的高度小于或等于 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法1：递归"><a href="#解法1：递归" class="headerlink" title="解法1：递归"></a>解法1：递归</h2><p>这个题写完内部的dfs函数居然忘了调用了哈哈哈，很简单和二叉树的一样就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_postorder</span>(<span class="hljs-params">root</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> root.children:<br>                dfs_postorder(ch)<br>            res.append(root.val)<br>        dfs_postorder(root)  <span class="hljs-comment"># 居然是因为忘写了这句话</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h2 id="解法2：迭代"><a href="#解法2：迭代" class="headerlink" title="解法2：迭代"></a>解法2：迭代</h2><p>使用了前序遍历迭代的思想，自己写一写模拟就好，最后需要reverse过来，也就是 <code>t_list = t_list[::-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">postorder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 迭代，这里可以借助前序遍历</span><br>        res = []<br>        stack = []<br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            stack.append(root)<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(stack):<br>            tmp = stack[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 左边栈顶，右边栈底</span><br>            stack = stack[<span class="hljs-number">1</span>:]<br>            res.append(tmp.val)<br>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> tmp.children:<br>                <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    stack.insert(<span class="hljs-number">0</span>, ch)<br>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>429.N叉树的层序遍历-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-python/</url>
    
    <content type="html"><![CDATA[<p>429.N叉树的层序遍历（中等）</p><p>题目大意：</p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">题目链接</a></p><p>给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p><p>示例1：</p><p><img src="/images/2022-03-14-21-02-01.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,3,2,4,null,5,6]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[3,2,4]</span>,<span class="hljs-comment">[5,6]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-03-14-21-02-42.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>],[<span class="hljs-number">14</span>]]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>层序遍历本质上是广度优先，广度优先本质上就是bfs（？好像在说废话hhh）</p><p>这个题需要特别注意下把层序遍历 <code>append</code> 成这个嵌套的样子 <code>[[], [], []] </code> ，这里的思路是每次记录下当前层的数目，然后在 <code>pop-appendtail</code> 的时候只把当前层这么多个的给 <code>pop</code> 出来，使用一个中间的 <code>tmp_ans</code> 来存储每层，然后一层一层的 <code>append</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># Definition for a Node.</span><br><span class="hljs-string">class Node(object):</span><br><span class="hljs-string">    def __init__(self, val=None, children=None):</span><br><span class="hljs-string">        self.val = val</span><br><span class="hljs-string">        self.children = children</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">levelOrder</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: Node</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = []<br>        queue = []  <span class="hljs-comment"># 左出，右进</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            queue.append(root)<br><br>        <span class="hljs-comment"># 层序遍历代码写成一体化的，因为层序遍历还要兼顾层级的输出</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue):<br>            <span class="hljs-comment"># 每次都把当前这一层走完，然后append</span><br>            tmp_ans = []<br>            now_level_len = <span class="hljs-built_in">len</span>(queue)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(now_level_len):  <span class="hljs-comment"># 只是为了执行这么多次</span><br>                tmp_q = queue[<span class="hljs-number">0</span>]<br>                queue = queue[<span class="hljs-number">1</span>:]<br>                tmp_ans.append(tmp_q.val)<br>                <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> tmp_q.children:<br>                    queue.append(ch)<br>            res.append(tmp_ans)<br><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23.合并K个升序链表-python</title>
    <link href="/2022/03/14/algorithms/leetcode-python/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/03/14/algorithms/leetcode-python/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>23.合并K个升序链表（困难）</p><p>题目大意：</p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">题目链接</a></p><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例1：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：链表数组如下：<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>将它们合并到一个有序链表中得到。<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：lists = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：lists = <span class="hljs-string">[[]]</span><br>输出：[]<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 <strong>升序</strong> 排列</li><li><code>lists[i].length 的总和不超过 10^4</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉实际真的明白了什么是优先队列，什么是堆的思想。python这个 <code>heapq</code> 是真的神，如果用正数就是小根堆，如果是用负数就可以转化为大根堆了！</p><p>只要先用 <code>heapq</code> 存储成一个堆，然后不断 <code>heappop()</code>就可以了，这里推荐堆的命名可以直接用 <code>heap</code>；</p><p>另注，这个题实际上有很多做法，但这个做法是最为简单的了，其他还需要进一步探究；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type lists: List[ListNode]</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">import</span> heapq  <span class="hljs-comment"># 优先队列</span><br>        heap = []<br>        <span class="hljs-keyword">for</span> i, t_list <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lists):<br>            head = t_list<br>            <span class="hljs-keyword">while</span> head <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                heapq.heappush(heap, head.val)<br>                head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-comment"># 尾插法</span><br>        return_head = ListNode(val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>)<br>        p = return_head<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(heap) != <span class="hljs-number">0</span>:<br>            tmp = heapq.heappop(heap)<br>            p.<span class="hljs-built_in">next</span> = ListNode(val=tmp)<br>            p = p.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> return_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>HARD</tag>
      
      <tag>链表</tag>
      
      <tag>分治</tag>
      
      <tag>归并排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>284场LeetCode周赛</title>
    <link href="/2022/03/13/algorithms/leetcode-weekly-contest/284%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/13/algorithms/leetcode-weekly-contest/284%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周三个题还是相对友善一点点的：第一题读题有些困难hhh读好了一些角标标记的操作就可以了；第二题感觉一下想过去就是个哈希表记录，感觉也是状态好才能现场写出来吧；第三题需要考虑很多种case是个比较细节的题，感觉还是模拟为主。总结来说这周还都属于是一下想过去有思路的题，希望未来能进一步保持啊啊啊啊啊；</p><p>第一题：角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 <code>abs</code> 就可以了；</p><p>第二题：一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）；</p><p>第三题：这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 <code>nums</code> 的长度是 <code>10^5</code> 的时候就感觉可以模拟了，然后 <code>k</code> 比这个大就说明可能会有一部分相对特殊的case；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6031-找出数组中的所有-K-近邻下标"><a href="#第一题：6031-找出数组中的所有-K-近邻下标" class="headerlink" title="第一题：6031.找出数组中的所有 K 近邻下标"></a>第一题：6031.找出数组中的所有 K 近邻下标</h1><p><a href="https://leetcode-cn.com/problems/find-all-k-distant-indices-in-an-array/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和两个整数 <code>key</code> 和 <code>k</code> 。<strong>K 近邻下标</strong> 是 <code>nums</code> 中的一个下标 <code>i</code> ，并满足至少存在一个下标 <code>j</code> 使得 <code>|i - j| &lt;= k</code> 且 <code>nums[j] == key</code> 。</p><p>以列表形式返回按 <strong>递增顺序</strong> 排序的所有 K 近邻下标。</p><p>示例1：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">5</span>], key = <span class="hljs-number">9</span>, k = <span class="hljs-number">1</span><br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>解释：因此，nums[<span class="hljs-number">2</span>] == key 且 nums[<span class="hljs-number">5</span>] == key 。<br>- 对下标 <span class="hljs-number">0</span> ，|<span class="hljs-type">0</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&gt; k</span> 且 |<span class="hljs-type">0</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&gt; k</span> ，所以不存在 j 使得 |<span class="hljs-type">0</span> - j| <span class="hljs-type">&lt;= k</span> 且 nums[j] == key 。所以 <span class="hljs-number">0</span> 不是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">1</span> ，|<span class="hljs-type">1</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">1</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">2</span> ，|<span class="hljs-type">2</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">2</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">3</span> ，|<span class="hljs-type">3</span> - <span class="hljs-number">2</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">2</span>] == key ，所以 <span class="hljs-number">3</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">4</span> ，|<span class="hljs-type">4</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">4</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">5</span> ，|<span class="hljs-type">5</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">5</span> 是一个 K 近邻下标。<br>- 对下标 <span class="hljs-number">6</span> ，|<span class="hljs-type">6</span> - <span class="hljs-number">5</span>| <span class="hljs-type">&lt;= k</span> 且 nums[<span class="hljs-number">5</span>] == key ，所以 <span class="hljs-number">6</span> 是一个 K 近邻下标。<br>因此，按递增顺序返回 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,2,2,2,2]</span>, key = 2, k = 2<br>输出：<span class="hljs-comment">[0,1,2,3,4]</span><br>解释：对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums<span class="hljs-comment">[j]</span> == key ，所以每个下标都是一个 K 近邻下标。 <br>因此，返回 <span class="hljs-comment">[0,1,2,3,4]</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>key</code> 是数组 <code>nums</code> 中的一个整数</li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 <code>abs</code> 就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findKDistantIndices</span>(<span class="hljs-params">self, nums, key, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        tmp = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i] == key:<br>                tmp.append(i)<br>        <span class="hljs-built_in">print</span>(tmp)<br><br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(tmp)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">abs</span>(i - tmp[j]) &lt;= k:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i, j: &quot;</span>, i,j)<br>                    res.append(i)<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：5203-统计可以提取的工件"><a href="#第二题：5203-统计可以提取的工件" class="headerlink" title="第二题：5203.统计可以提取的工件"></a>第二题：5203.统计可以提取的工件</h1><p><a href="https://leetcode-cn.com/problems/count-artifacts-that-can-be-extracted/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>存在一个 <code>n x n</code> 大小、下标从 <strong>0</strong> 开始的网格，网格中埋着一些工件。给你一个整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的二维整数数组 <code>artifacts</code> ，<code>artifacts</code> 描述了矩形工件的位置，其中 <code>artifacts[i] = [r1i, c1i, r2i, c2i]</code> 表示第 <code>i</code> 个工件在子网格中的填埋情况：</p><ul><li><code>(r1i, c1i)</code> 是第 <code>i</code> 个工件 <strong>左上</strong> 单元格的坐标，且</li><li><code>(r2i, c2i)</code> 是第 <code>i</code> 个工件 <strong>右下</strong> 单元格的坐标。</li></ul><p>你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。</p><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dig</code> ，其中 <code>dig[i] = [ri, ci]</code> 表示你将会挖掘单元格 <code>(ri, ci)</code> ，返回你可以提取的工件数目。</p><p>生成的测试用例满足：</p><ul><li>不存在重叠的两个工件。</li><li>每个工件最多只覆盖 <code>4</code> 个单元格。</li><li><code>dig</code> 中的元素互不相同。</li></ul><p>示例1：</p><p><img src="/images/2022-03-13-22-25-47.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, artifacts = <span class="hljs-string">[[0,0,0,0],[0,1,1,1]]</span>, dig = <span class="hljs-string">[[0,0],[0,1]]</span><br>输出：<span class="hljs-number">1</span><br>解释： <br>不同颜色表示不同的工件。挖掘的单元格用 <span class="hljs-string">&#x27;D&#x27;</span> 在网格中进行标记。<br>有 <span class="hljs-number">1</span> 个工件可以提取，即红色工件。<br>蓝色工件在单元格 (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) 的部分尚未裸露出来，所以无法提取该工件。<br>因此，返回 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><p><img src="/images/2022-03-13-22-26-06.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">2</span>, artifacts = <span class="hljs-string">[[0,0,0,0],[0,1,1,1]]</span>, dig = <span class="hljs-string">[[0,0],[0,1],[1,1]]</span><br>输出：<span class="hljs-number">2</span><br>解释：红色工件和蓝色工件的所有部分都裸露出来（用 <span class="hljs-string">&#x27;D&#x27;</span> 标记），都可以提取。因此，返回 <span class="hljs-number">2</span> 。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= artifacts.length, dig.length &lt;= min(n^2, 10^5)</code></li><li><code>artifacts[i].length == 4</code></li><li><code>dig[i].length == 2</code></li><li><code>0 &lt;= r1i, c1i, r2i, c2i, ri, ci &lt;= n - 1</code></li><li><code>r1i &lt;= r2i</code></li><li><code>c1i &lt;= c2i</code></li><li>不存在重叠的两个工件</li><li>每个工件 <strong>最多</strong> 只覆盖 <code>4</code> 个单元格</li><li><code>dig</code> 中的元素互不相同</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">digArtifacts</span>(<span class="hljs-params">self, n, artifacts, dig</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type artifacts: List[List[int]]</span><br><span class="hljs-string">        :type dig: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 哈希表记录每个地方的状态</span><br>        <br>        <span class="hljs-comment"># 要用mark吗，还是说看起来直接暴力就行了</span><br>        reverse_mapping = &#123;&#125;<br>        d = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(artifacts))]<br>        m = [[-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(artifacts)):<br>            r1, c1, r2 ,c2 = artifacts[i]<br>            d[i] = <span class="hljs-number">0</span>  <span class="hljs-comment"># mapping</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(r1, r2+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(c1, c2+<span class="hljs-number">1</span>):<br>                    m[j][k] = <span class="hljs-number">1</span><br>                    <span class="hljs-comment"># 反向mapping，这个工件属于第几个</span><br>                    reverse_mapping[(j, k)] = i  <span class="hljs-comment"># jk角标的地方属于第i个工件</span><br>                    d[i] += <span class="hljs-number">1</span><br>        <span class="hljs-comment">#print(&quot;d: &quot;, d)</span><br>        <span class="hljs-comment">#print(&quot;m: &quot;, m)</span><br>        <span class="hljs-comment">#print(&quot;reverse_mapping: &quot;, reverse_mapping)</span><br>    <br>    <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(dig)):<br>            r, c = dig[i]<br>            <span class="hljs-comment"># 先判断这个地方是不是有</span><br>            <span class="hljs-keyword">if</span> m[r][c] == <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># 再判断是第几个零件</span><br>                index = reverse_mapping[(r, c)]<br>                <span class="hljs-comment"># 减去第几个零件</span><br>                d[index] -= <span class="hljs-number">1</span><br>                <br>                m[r][c] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 挖掉</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">continue</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-comment">#print(d)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(d)):<br>            <span class="hljs-keyword">if</span> d[i] == <span class="hljs-number">0</span>:<br>                res += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：5227-K-次操作后最大化顶端元素"><a href="#第三题：5227-K-次操作后最大化顶端元素" class="headerlink" title="第三题：5227.K 次操作后最大化顶端元素"></a>第三题：5227.K 次操作后最大化顶端元素</h1><p><a href="https://leetcode-cn.com/problems/maximize-the-topmost-element-after-k-moves/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，它表示一个 <strong>栈</strong> ，其中 <code>nums[0]</code> 是栈顶的元素。</p><p>每一次操作中，你可以执行以下操作 <strong>之一</strong> ：</p><ul><li>如果栈非空，那么 <strong>删除</strong> 栈顶端的元素。</li><li>如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，<strong>添加</strong> 回栈顶，这个元素成为新的栈顶元素。</li></ul><p>同时给你一个整数 <code>k</code> ，它表示你总共需要执行操作的次数。</p><p>请你返回 <strong>恰好</strong> 执行 <code>k</code> 次操作以后，栈顶元素的 <strong>最大值</strong> 。如果执行完 <code>k</code> 次操作以后，栈一定为空，请你返回 <code>-1</code> 。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [5,2,2,4,0,6], k = 4<br>输出：5<br>解释：<br>4 次操作后，栈顶元素为<span class="hljs-number"> 5 </span>的方法之一为：<br>- 第<span class="hljs-number"> 1 </span>次操作：删除栈顶元素<span class="hljs-number"> 5 </span>，栈变为 [2,2,4,0,6] 。<br>- 第<span class="hljs-number"> 2 </span>次操作：删除栈顶元素<span class="hljs-number"> 2 </span>，栈变为 [2,4,0,6] 。<br>- 第<span class="hljs-number"> 3 </span>次操作：删除栈顶元素<span class="hljs-number"> 2 </span>，栈变为 [4,0,6] 。<br>- 第<span class="hljs-number"> 4 </span>次操作：将<span class="hljs-number"> 5 </span>添加回栈顶，栈变为 [5,4,0,6] 。<br>注意，这不是最后栈顶元素为<span class="hljs-number"> 5 </span>的唯一方式。但可以证明，4 次操作以后<span class="hljs-number"> 5 </span>是能得到的最大栈顶元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [2], k = 1<br>输出：<span class="hljs-string">-1</span><br>解释：<br>第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。<br>由于 1 次操作后无法得到一个非空的栈，所以我们返回 <span class="hljs-string">-1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i], k &lt;= 10^9</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 <code>nums</code> 的长度是 <code>10^5</code> 的时候就感觉可以模拟了，然后 <code>k</code> 比这个大就说明可能会有一部分相对特殊的case；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumTop</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        <br>        jilu_remove = []<br>        now_max = -<span class="hljs-number">1</span><br>        cnt_op = <span class="hljs-number">0</span><br>        index = <span class="hljs-number">0</span><br>        res = -<span class="hljs-number">1</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):  <span class="hljs-comment">#</span><br>            <span class="hljs-keyword">if</span> cnt_op == k - <span class="hljs-number">1</span>:<br>                <span class="hljs-comment"># 判断是再拿一个的高，还是把加回去的高</span><br>                <span class="hljs-keyword">try</span>:<br>                    nayige = nums[index+<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">except</span>:<br>                    nayige = -<span class="hljs-number">1</span><br>                <br>                cnt_op += <span class="hljs-number">1</span><br>                res = <span class="hljs-built_in">max</span>(now_max, nayige)<br>                <br>            <br>            <span class="hljs-keyword">elif</span> cnt_op &lt; k:  <span class="hljs-comment"># 代表还能操作</span><br>                jilu_remove.append(nums[index])<br>                <span class="hljs-keyword">if</span> nums[index] &gt; now_max:<br>                    now_max = nums[index]<br>                index += <span class="hljs-number">1</span><br>                cnt_op += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>        <br>        <br>        <span class="hljs-comment"># 最后还有可能出现还剩很多的情况，因为len(nums)比k小，到时候要判断情况的</span><br>        left_times = k - cnt_op<br>        jilu_remove.sort(reverse=<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_times: &quot;</span>, left_times)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;jilu_remove: &quot;</span>, jilu_remove)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;res: &quot;</span>, res)<br>        <br>        <br>        <span class="hljs-comment"># 当剩余操作次数为left_times时</span><br>        left_times %= (<span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(nums))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_times: &quot;</span>, left_times)<br>        <br>        <span class="hljs-keyword">if</span> left_times &lt;= <span class="hljs-built_in">len</span>(nums) <span class="hljs-keyword">and</span> left_times != <span class="hljs-number">0</span>:<br>            res = now_max<br>        <br>        <br>        <span class="hljs-keyword">if</span> left_times &gt; <span class="hljs-built_in">len</span>(nums):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> left_times % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:  <span class="hljs-comment"># 奇数</span><br>                    res = now_max<br>                <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 偶数</span><br>                    <span class="hljs-keyword">try</span>:<br>                        res = jilu_remove[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">except</span>:<br>                        res = -<span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">else</span>:<br>                res = now_max<br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2055.蜡烛之间的盘子-python</title>
    <link href="/2022/03/08/algorithms/leetcode-python/2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90-python/"/>
    <url>/2022/03/08/algorithms/leetcode-python/2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90-python/</url>
    
    <content type="html"><![CDATA[<p>2055.蜡烛之间的盘子（中等）</p><p>每日一题的话就不在这里完整粘贴题目的题面了，换用自己的想法写法说一说</p><p>这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/plates-between-candles/">题目链接</a></p><p>题目大意：</p><p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，它只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> ，其中 <code>&#39;*&#39;</code> 表示一个 <strong>盘子</strong> ，<code>&#39;|&#39;</code> 表示一支 <strong>蜡烛</strong> 。</p><p>同时给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [lefti, righti]</code> 表示 <strong>子字符串</strong> <code>s[lefti...righti]</code> <strong>（包含左右端点的字符）</strong>。对于每个查询，你需要找到 <strong>子字符串中</strong> 在 <strong>两支蜡烛之间</strong> 的盘子的 数目 。如果一个盘子在 <strong>子字符串中</strong> 左边和右边 <strong>都</strong> 至少有一支蜡烛，那么这个盘子满足在 <strong>两支蜡烛之间</strong> 。</p><ul><li>比方说，<code>s = &quot;||**||**|*&quot;</code> ，查询 <code>[3, 8]</code> ，表示的是子字符串 <code>&quot;*||**|&quot;</code> 。子字符串中在两支蜡烛之间的盘子数目为 <code>2</code> ，子字符串中右边两个盘子在它们左边和右边 <strong>都</strong> 至少有一支蜡烛。</li></ul><p>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例1：<br><img src="/images/2022-03-08-21-16-07.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;**|**|***|&quot;</span>, queries = [[<span class="hljs-number">2</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>解释：<br>- queries[<span class="hljs-number">0</span>] 有两个盘子在蜡烛之间。<br>- queries[<span class="hljs-number">1</span>] 有三个盘子在蜡烛之间。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-03-08-21-16-18.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;***|**|*****|**||**|*&quot;</span>, queries = [[<span class="hljs-number">1</span>,<span class="hljs-number">17</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">14</span>,<span class="hljs-number">17</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">11</span>],[<span class="hljs-number">15</span>,<span class="hljs-number">16</span>]]<br>输出：[<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<br>- queries[<span class="hljs-number">0</span>] 有 <span class="hljs-number">9</span> 个盘子在蜡烛之间。<br>- 另一个查询没有盘子在蜡烛之间。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> 。</li><li><code>1 &lt;= queries.length &lt;= 10^5</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= left_i &lt;= right_i &lt; s.length</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">platesBetweenCandles</span>(<span class="hljs-params">self, s, queries</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type queries: List[List[int]]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 经典前缀题目思路</span><br>        <span class="hljs-comment"># 先遍历两边，找到每个位置的左边和右边第一次碰到蜡烛的位置</span><br>        <span class="hljs-comment"># 然后再看前缀和，截止到当前位置处，出现过几个*了</span><br>        left_candle_idx = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        right_candle_idx = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        plate_prefix_sum = [-<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br><br><br>        <span class="hljs-comment"># 先正着走一遍，找到每个index位置处左边的那个candle的角标</span><br>        left = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                left = i<br>                left_candle_idx[i] = i<br>            <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                left_candle_idx[i] = left<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;left_candle_idx: &quot;</span>, left_candle_idx)<br><br><br>        <span class="hljs-comment"># 倒着走一遍，找到每个index位置处右边的那个candle的角标</span><br>        right = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;|&#x27;</span>:<br>                right = i<br>                right_candle_idx[i] = i<br>            <span class="hljs-keyword">else</span>:<br>                right_candle_idx[i] = right<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;right_candle_idx: &quot;</span>, right_candle_idx)<br><br>        <span class="hljs-comment"># 正着走找prefix</span><br>        prefix = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                prefix += <span class="hljs-number">1</span><br>            plate_prefix_sum[i] = prefix<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;plate_prefix_sum: &quot;</span>, plate_prefix_sum)<br><br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(queries)):<br>            l, r = queries[i][<span class="hljs-number">0</span>], queries[i][<span class="hljs-number">1</span>]<br>            <span class="hljs-comment"># 特殊处理</span><br>            <span class="hljs-keyword">if</span> l == r:<br>                res.append(<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">continue</span><br><br>            tmp = plate_prefix_sum[left_candle_idx[r]]-plate_prefix_sum[right_candle_idx[l]]<br>            <span class="hljs-comment"># 这里可能还会有异常，一下不好想感觉只能通过case看一下</span><br>            res.append(tmp) <span class="hljs-keyword">if</span> tmp &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> res.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode每日一题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>98.验证二叉搜索树-python</title>
    <link href="/2022/03/07/algorithms/leetcode-python/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-python/"/>
    <url>/2022/03/07/algorithms/leetcode-python/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>98.验证二叉搜索树（中等）</p><p>题目大意：</p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例1：<br><img src="/images/2022-03-07-22-56-46.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-03-07-23-10-32.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-literal">false</span><br>解释：根节点的值是 <span class="hljs-number">5</span> ，但是右子节点的值是 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目范围在 <code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：自己称为上界下界法"><a href="#解法一：自己称为上界下界法" class="headerlink" title="解法一：自己称为上界下界法"></a>解法一：自己称为上界下界法</h2><p>该种方法不需要用到额外的变量那种感觉， 开始从一个最小和一个最大开始作为入口，然后递归的判断每个节点是不是在是不是在这个范围内即可</p><p>（二叉搜索树的性质：各个节点的<code>val</code>都不能相同）</p><p>对于根节点，其肯定包含在最开始的上界&#x2F;下界内，然后就开始递归，根的左子树必须在<code>(最小, 根的val)</code>开区间内，右子树必须在<code>(根的val, 最大)</code>开区间内</p><p>另外注意，因为是判断的题，最后要返回一个<code>bool</code>的值，所以自递归的时候每个地方也要返回一个<code>True/False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 上界-下界法</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">root, lower, upper</span>):<br><br>            <span class="hljs-comment"># 出口条件    </span><br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-comment"># False的条件</span><br>            <span class="hljs-keyword">if</span> root.val &lt;= lower <span class="hljs-keyword">or</span> root.val &gt;= upper:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-comment"># 左子树的值应该在lower，root.val开区间之间</span><br>            <br>            <span class="hljs-keyword">if</span> dfs(root.left, lower, root.val) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>            <span class="hljs-comment"># 右子树的值应该在root.val，upper开区间之间</span><br>            <span class="hljs-keyword">if</span> dfs(root.right, root.val, upper) <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">return</span> dfs(root, -<span class="hljs-number">1e15</span>, <span class="hljs-number">1e15</span>)<br></code></pre></td></tr></table></figure><h2 id="解法二：全局变量法"><a href="#解法二：全局变量法" class="headerlink" title="解法二：全局变量法"></a>解法二：全局变量法</h2><p>二叉搜索树本质上就是中序遍历要是递增的，所以使用中序遍历的思想搞一个自递归的函数就差不多了</p><p>同样是注意，因为自递归的，每个地方要有个<code>bool</code>类的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.pre_val = -<span class="hljs-number">1e15</span>  <span class="hljs-comment"># 写在这里的当做全局变量了</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValidBST</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # 这里使用二叉树中序遍历的思想，把这个函数制作为一个自递归的</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 出口</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">if</span> self.isValidBST(root.left) <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>: <span class="hljs-comment"># 中序的基础上要有返回值</span><br>            <span class="hljs-keyword">if</span> root.val &gt; self.pre_val:<br>                self.pre_val = root.val<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">return</span> self.isValidBST(root.right)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39.组合总和-python</title>
    <link href="/2022/03/07/algorithms/leetcode-python/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-python/"/>
    <url>/2022/03/07/algorithms/leetcode-python/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>39.组合总和（中等）</p><p>题目大意：</p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><figure class="highlight plaintext"><figcaption><span>中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs candidates```"><br>对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。<br><br>&lt;!--more--&gt;<br><br># 题目<br><br>给你一个 **无重复元素** 的整数数组 ```candidates``` 和一个目标整数 ```target``` ，找出 ```candidates``` 中可以使数字和为目标数 ```target``` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。<br><br>```candidates``` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 <br><br>对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。<br><br>示例1：<br></code></pre></td></tr></table></figure><p>输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和 3 可以形成一组候选，2 + 2 + 3 &#x3D; 7 。注意 2 可以使用多次。<br>7 也是一个候选， 7 &#x3D; 7 。<br>仅有这两种组合。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br>示例2：<br></code></pre></td></tr></table></figure><p>输入: candidates &#x3D; [2,3,5], target &#x3D; 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br>示例3：<br></code></pre></td></tr></table></figure><p>输入: candidates &#x3D; [2], target &#x3D; 1<br>输出: []</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>提示：<br>- ```1 &lt;= candidates.length &lt;= <span class="hljs-number">30</span>```<br>- ```1 &lt;= candidates[i] &lt;= <span class="hljs-number">200</span>```<br>- ```candidate``` 中的每个元素都 **互不相同**<br>- ```1 &lt;= target &lt;= <span class="hljs-number">500</span>```<br><br># 分析和解答<br><br>这个题是个经典的回溯题，首先想一个dfs的构造：<br><br>- 每次要把现在的now_sum传进去，代表dfs到每一层的时候现在加到多少了，用来进行出口条件的判断；<br>- 每次要判断一个位置选还是不选，这样的话假设一个数组长度是n，每次要把现在到第几个n传递下去，而因为是dfs，每次不需要传递i+<span class="hljs-number">1</span>，还是可以传递i的；<br>- 每次要把list给加上，代表dfs的时候，现在选了哪些了，然后在第一个条件如果到出口的话，就要把list append进去；<br><br>```dfs```的开始状态，按照这个思路就是```0，<span class="hljs-number">0</span>，[]```，然后出口条件如果等于则append列表，如果大于则```return```，之后走新的```dfs```条件，每次i从当前的```now_idx```取到```n```，每个状态都生成一个分支，这里可以进行一个剪枝，如果超过了就```break```掉，然后这样的话就可以开展第一轮```dfs```了，先把选这个```i```位置处的```append```进去，然后用```copy.deepcopy()```传一下到下一层，然后再```list = list[:-<span class="hljs-number">1</span>]```把这个去除掉<br><br>**另外特别注意，这个题的数组需要先排序一下，否则循环剪枝那里可能后边还有更小的就<span class="hljs-keyword">break</span>了不会被放进来了**<br><br>```python<br>res = []<br><span class="hljs-title">def dfs(now_sum, now_idx, now_list):</span><br><span class="hljs-title">    if now_sum == target:</span><br>        res.append(now_list)<br><span class="hljs-title">    if now_sum &gt; target:</span><br>        <span class="hljs-keyword">return</span><br>    <br><span class="hljs-title">    for i in range(now_idx, len(candidates)):</span><br><span class="hljs-title">        if now_sum + candidates[i] &gt; target:</span><br>            <span class="hljs-keyword">break</span><br>        now_list.append(candidates[i])<br>        dfs(now_sum + candidates[i], i, copy.deepcopy(now_list))  # 注意这里要deepcopy<br><span class="hljs-title">        now_list = now_list[:</span>-<span class="hljs-number">1</span>]  # 截断下<br></code></pre></td></tr></table></figure><p>当时写的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">combinationSum</span>(<span class="hljs-params">self, candidates, target</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type candidates: List[int]</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        candidates.sort()  <span class="hljs-comment"># 先排个序</span><br>        res = []<br>        <span class="hljs-comment"># 递归要找出口，一个条件一个条件的加入到参数中</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">now_sum, tmp_list, now_idx</span>):<br>            <span class="hljs-keyword">if</span> now_sum == target:<br>                <span class="hljs-comment"># 需要解决一个去重问题，多加一个位标记，代表只能从后边的开始选了，比如说开始选择了3之后，就不能再开始选前边的2了</span><br>                res.append(tmp_list)<br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> now_sum &gt; target:  <span class="hljs-comment"># 加爆了，不满足return</span><br>                <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(now_idx, <span class="hljs-built_in">len</span>(candidates)):<br>                    <span class="hljs-keyword">if</span> now_sum + candidates[i] &lt;= target:<br>                        tmp_list.append(candidates[i])<br>                        dfs(now_sum + candidates[i], copy.deepcopy(tmp_list), i)  <span class="hljs-comment"># 下一次这个now_idx只能从当前的i之后开始了，这样解决重复问题</span><br>                        tmp_list = tmp_list[:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 回溯</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br><br>        dfs(<span class="hljs-number">0</span>, [], <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>283场LeetCode周赛</title>
    <link href="/2022/03/07/algorithms/leetcode-weekly-contest/283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/03/07/algorithms/leetcode-weekly-contest/283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次感觉就是从头卡到尾哈哈哈，每个题或多或少都卡了一下，感觉近几次做题真的思想越来越僵化了，也可能和太久没写代码了有关吧，2月轻松了一个月，3月开始真的忙碌了hhh，等哪天闲下来要完整总结下做题用到的一些常用结构了；</p><p>看了下有写笔记的是273到283，算上新年鸽了一次正好十次，感觉可以十次总结下，之后找时间先写个新的博客~</p><p>第一题：上来就不顺了下，要考虑python怎么做这种字符串的操作，查了一下才知道<code>ord()</code>可以把字母转化为ASCII表，然后再用<code>chr()</code>把ASCII字符转换回串，然后实际上是一个简单的二重循环遍历；</p><p>第二题：这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了，之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了，中间写起来细节感觉很多，还是被坑了不少的。另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？；</p><p>第三题：好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping），开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个，但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了；</p><p>第四题：鸽了鸽了；</p><span id="more"></span><h1 id="第一题：2194-Excel表中某个范围内的单元格"><a href="#第一题：2194-Excel表中某个范围内的单元格" class="headerlink" title="第一题：2194.Excel表中某个范围内的单元格"></a>第一题：2194.Excel表中某个范围内的单元格</h1><p><a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>Excel 表中的一个单元格 <code>(r, c)</code> 会以字符串 <code>&quot;&lt;col&gt;&lt;row&gt;&quot;</code> 的形式进行表示，其中：</p><ul><li><code>&lt;col&gt;</code> 即单元格的列号 <code>c</code> 。用英文字母表中的 <strong>字母</strong> 标识。<ul><li>例如，第 <code>1</code> 列用 <code>&#39;A&#39;</code> 表示，第 <code>2</code> 列用 <code>&#39;B&#39;</code> 表示，第 <code>3</code> 列用 <code>&#39;C&#39;</code> 表示，以此类推。</li></ul></li><li><code>&lt;row&gt;</code> 即单元格的行号 <code>r</code> 。第 <code>r</code> 行就用 整数 <code>r</code> 标识。</li></ul><p>给你一个格式为 <code>&quot;&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;&quot;</code> 的字符串 <code>s</code> ，其中 <code>&lt;col1&gt;</code> 表示 <code>c1</code> 列，<code>&lt;row1&gt;</code> 表示 <code>r1</code> 行，<code>&lt;col2&gt;</code> 表示 <code>c2</code> 列，<code>&lt;row2&gt;</code> 表示 <code>r2</code> 行，并满足 <code>r1 &lt;= r2</code> 且 <code>c1 &lt;= c2</code> 。</p><p>找出所有满足 <code>r1 &lt;= x &lt;= r2</code> 且 <code>c1 &lt;= y &lt;= c2</code> 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 <strong>字符串</strong> 表示，并以 <strong>非递减</strong> 顺序排列（先按列排，再按行排）。</p><p>示例1：<br><img src="/images/2022-03-07-19-17-22.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;K1:L2&quot;</span><br>输出：[<span class="hljs-string">&quot;K1&quot;</span>,<span class="hljs-string">&quot;K2&quot;</span>,<span class="hljs-string">&quot;L1&quot;</span>,<span class="hljs-string">&quot;L2&quot;</span>]<br>解释：<br>上图显示了列表中应该出现的单元格。<br>红色箭头指示单元格的出现顺序。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-03-07-19-19-50.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;A1:F1&quot;</span><br>输出：[<span class="hljs-string">&quot;A1&quot;</span>,<span class="hljs-string">&quot;B1&quot;</span>,<span class="hljs-string">&quot;C1&quot;</span>,<span class="hljs-string">&quot;D1&quot;</span>,<span class="hljs-string">&quot;E1&quot;</span>,<span class="hljs-string">&quot;F1&quot;</span>]<br>解释：<br>上图显示了列表中应该出现的单元格。 <br>红色箭头指示单元格的出现顺序。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>s.length == 5</code></li><li><code>&#39;A&#39; &lt;= s[0] &lt;= s[3] &lt;= &#39;Z&#39;</code></li><li><code>&#39;1&#39; &lt;= s[1] &lt;= s[4] &lt;= &#39;9&#39;</code></li><li><code>s</code> 由大写英文字母、数字、和 <code>&#39;:&#39;</code> 组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p><code>ord(&quot;a&quot;)</code>是把一个字符转化为ASCII码表示，例如该句会输出<code>97</code></p><p><code>chr(97)</code>是把一个ASCII码（或者也不一定，就是数字）转化为字符表示，例如该句会输出<code>a</code></p><p>知道上边两个操作后怎么遍历就不是难事了，代码如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cellsInRange</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s_1 = s[<span class="hljs-number">0</span>]<br>        n_1 = s[<span class="hljs-number">1</span>]<br>        s_2 = s[<span class="hljs-number">3</span>]<br>        n_2 = s[<span class="hljs-number">4</span>]<br>        <br>        res = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">ord</span>(s_1), <span class="hljs-built_in">ord</span>(s_2)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(n_1), <span class="hljs-built_in">int</span>(n_2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-comment"># print(chr(i))</span><br>                <span class="hljs-comment"># print(str(j))</span><br>                res.append(<span class="hljs-string">&quot;&quot;</span>.join([<span class="hljs-built_in">chr</span>(i), <span class="hljs-built_in">str</span>(j)])) <br>                <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：6017-向数组中追加K个整数"><a href="#第二题：6017-向数组中追加K个整数" class="headerlink" title="第二题：6017.向数组中追加K个整数"></a>第二题：6017.向数组中追加K个整数</h1><p><a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你向 nums 中追加 k 个 未 出现在 nums 中的、<strong>互不相同</strong> 的 <strong>正</strong> 整数，并使结果数组的元素和 <strong>最小</strong> 。</p><p>返回追加到 <code>nums</code> 中的 <code>k</code> 个整数之和。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,4,25,10,25], k = 2<br>输出：5<br>解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>。<br>nums 最终元素和为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 25 </span>+<span class="hljs-number"> 10 </span>+<span class="hljs-number"> 25 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 70 </span>，这是所有情况中的最小值。<br>所以追加到数组中的两个整数之和是<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>，所以返回<span class="hljs-number"> 5 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [5,6], k = 6<br>输出：25<br>解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是<span class="hljs-number"> 1 </span>、2 、3 、4 、7 和<span class="hljs-number"> 8 </span>。<br>nums 最终元素和为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 6 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 36 </span>，这是所有情况中的最小值。<br>所以追加到数组中的两个整数之和是<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 25 </span>，所以返回<span class="hljs-number"> 25 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i], k &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了</p><p>之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了</p><p>中间写起来细节感觉很多，还是被坑了不少的。</p><p>另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimalKSum</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        orig_k = k<br>        <span class="hljs-comment"># res = sum(nums)</span><br>        res = <span class="hljs-number">0</span><br>        nums.append(<span class="hljs-number">0</span>)<br>        nums.sort()<br>        <span class="hljs-comment"># print(nums)</span><br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            tmp = nums[i] - nums[i-<span class="hljs-number">1</span>]  - <span class="hljs-number">1</span>  <span class="hljs-comment"># 差</span><br>            <span class="hljs-comment"># print(tmp)</span><br>            <span class="hljs-keyword">if</span> k &gt; tmp:<br>                <span class="hljs-comment"># 求和tmp个</span><br>                <span class="hljs-keyword">if</span> (nums[i] - <span class="hljs-number">1</span>) &gt;= nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:  <br>                    res += (((nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) +  (nums[i] - <span class="hljs-number">1</span>)) * tmp) // <span class="hljs-number">2</span><br>                    <span class="hljs-comment"># print(&#x27;a&#x27;, nums[i-1] + 1, nums[i] - 1)</span><br>                    k -= tmp<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 求和k个</span><br>                res += (((nums[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>) +  (nums[i-<span class="hljs-number">1</span>] + k)) * k) // <span class="hljs-number">2</span><br>                <span class="hljs-comment"># print(&#x27;b&#x27;, nums[i-1] + 1,nums[i-1] + k)</span><br>                k -= tmp<br>                <span class="hljs-keyword">break</span><br>          <br>        <span class="hljs-comment"># print(res)</span><br>        <span class="hljs-comment"># print(k)</span><br>        <span class="hljs-keyword">if</span> k &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 某些问题？</span><br>            <span class="hljs-comment"># 如果全部中间不够了</span><br>            res += (<span class="hljs-built_in">max</span>(nums) + <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(nums) + k) * k // <span class="hljs-number">2</span><br>            <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：2196-根据描述创建二叉树"><a href="#第三题：2196-根据描述创建二叉树" class="headerlink" title="第三题：2196.根据描述创建二叉树"></a>第三题：2196.根据描述创建二叉树</h1><p><a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 descriptions ，其中 descriptions[i] &#x3D; [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外：</p><ul><li>如果 isLefti &#x3D;&#x3D; 1 ，那么 childi 就是 parenti 的左子节点。</li><li>如果 isLefti &#x3D;&#x3D; 0 ，那么 childi 就是 parenti 的右子节点。</li></ul><p>请你根据 <code>descriptions</code> 的描述来构造二叉树并返回其 <strong>根节点</strong> 。</p><p>测试用例会保证可以构造出 <strong>有效</strong> 的二叉树。</p><p>示例1：<br><img src="/images/2022-03-07-19-40-30.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：descriptions = <span class="hljs-comment">[<span class="hljs-comment">[20,15,1]</span>,<span class="hljs-comment">[20,17,0]</span>,<span class="hljs-comment">[50,20,1]</span>,<span class="hljs-comment">[50,80,0]</span>,<span class="hljs-comment">[80,19,1]</span>]</span><br>输出：<span class="hljs-comment">[50,20,80,15,17,19]</span><br>解释：根节点是值为 50 的节点，因为它没有父节点。<br>结果二叉树如上图所示。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-03-07-19-41-17.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：descriptions = <span class="hljs-comment">[<span class="hljs-comment">[1,2,1]</span>,<span class="hljs-comment">[2,3,0]</span>,<span class="hljs-comment">[3,4,1]</span>]</span><br>输出：<span class="hljs-comment">[1,2,null,null,3,4]</span><br>解释：根节点是值为 1 的节点，因为它没有父节点。 <br>结果二叉树如上图所示。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= descriptions.length &lt;= 10^4</code></li><li><code>descriptions[i].length == 3</code></li><li><code>1 &lt;= parenti, childi &lt;= 10^5</code></li><li><code>0 &lt;= isLefti &lt;= 1</code></li><li><code>descriptions</code> 所描述的二叉树是一棵有效二叉树</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping）</p><p>开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个</p><p>但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了；</p><p>两轮，第一轮存节点+直接建树，然后第二轮找root作为返回；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">createBinaryTree</span>(<span class="hljs-params">self, descriptions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type descriptions: List[List[int]]</span><br><span class="hljs-string">        :rtype: Optional[TreeNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">pre_insert</span>(<span class="hljs-params">root, item</span>):<br>            <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-keyword">if</span> root.val == item[<span class="hljs-number">0</span>]:<br>                <span class="hljs-comment"># pre_insert(root, )</span><br>                <span class="hljs-keyword">if</span> item[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                    root.left = TreeNode(val=item[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">else</span>:<br>                    root.right = TreeNode(val=item[<span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <br>            <span class="hljs-keyword">return</span> pre_insert(root.left, item) <span class="hljs-keyword">or</span> pre_insert(root.right, item)<br>        <br>        <br>        mapping = &#123;&#125;<br>        have_father = &#123;&#125;<br>        root = <span class="hljs-literal">None</span><br>        <br>        <span class="hljs-keyword">for</span> i, des <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(descriptions):<br>            <br>            <span class="hljs-keyword">if</span> mapping.get(des[<span class="hljs-number">0</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                mapping[des[<span class="hljs-number">0</span>]] = TreeNode(val=des[<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">if</span> mapping.get(des[<span class="hljs-number">1</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>                mapping[des[<span class="hljs-number">1</span>]] = TreeNode(val=des[<span class="hljs-number">1</span>])<br>            <br>            <span class="hljs-comment"># 边记录边建树</span><br>            <span class="hljs-keyword">if</span> des[<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                mapping[des[<span class="hljs-number">0</span>]].left = mapping[des[<span class="hljs-number">1</span>]]  <br>            <span class="hljs-keyword">else</span>:<br>                mapping[des[<span class="hljs-number">0</span>]].right = mapping[des[<span class="hljs-number">1</span>]]<br>            <br>            have_father[des[<span class="hljs-number">1</span>]] = <span class="hljs-literal">True</span><br>        <br>        <br>        <span class="hljs-comment"># print(have_father)</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i, des <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(descriptions):<br>            <span class="hljs-keyword">if</span> have_father.get(des[<span class="hljs-number">0</span>]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> mapping[des[<span class="hljs-number">0</span>]]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
      <tag>贪心</tag>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-触控板左右滑动失效问题</title>
    <link href="/2022/02/28/macOS%E5%8F%8ALinux-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/28/macOS%E5%8F%8ALinux-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>需求：某些场景下（其实感觉是插拔HDMI线外接显示器的时候），可能出现触控板手势左右滑动失效的问题；</p><span id="more"></span><h1 id="解决办法-killall-Dock"><a href="#解决办法-killall-Dock" class="headerlink" title="解决办法 killall Dock"></a>解决办法 killall Dock</h1><p>在网上查到的解决办法，可在终端执行如下命令，即可通过类似一种自动重启的方法解决这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">killall Dock<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>282场LeetCode周赛</title>
    <link href="/2022/02/27/algorithms/leetcode-weekly-contest/282%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/27/algorithms/leetcode-weekly-contest/282%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>又是光速做完前两个题，然后盯着第三题发呆的一周周赛，第三题这次用到的思路是二分，感觉还是要多刷题多积累，可能需要找个时间复盘一下做题常用到的思路了吧哈哈哈，现在感觉思路有点打不开了，可能要阶段性总结梳理下吧，这样避免下有些想法太极端了~</p><p>第一题：这个题python有<code>str.startswtih()</code>函数，用这个返回值的<code>True</code>和<code>False</code>直接加就行了；</p><p>第二题：一眼看过去都有点没看懂这个题，后来感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了；</p><p>第三题：这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了；</p><p>第四题：鸽了鸽了；</p><span id="more"></span><h1 id="第一题：6008-统计包含给定前缀的字符串"><a href="#第一题：6008-统计包含给定前缀的字符串" class="headerlink" title="第一题：6008.统计包含给定前缀的字符串"></a>第一题：6008.统计包含给定前缀的字符串</h1><p><a href="https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串数组 <code>words</code> 和一个字符串 <code>pref</code> 。</p><p>返回 <code>words</code> 中以 <code>pref</code> 作为 <strong>前缀</strong> 的字符串的数目。</p><p>字符串 <code>s</code> 的 <strong>前缀</strong> 就是  <code>s</code> 的任一前导连续字符串。</p><p>示例1：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;pay&quot;</span>,<span class="hljs-string">&quot;attention&quot;</span>,<span class="hljs-string">&quot;practice&quot;</span>,<span class="hljs-string">&quot;attend&quot;</span>], pref = <span class="hljs-string">&quot;at&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：以 <span class="hljs-string">&quot;at&quot;</span> 作为前缀的字符串有两个，分别是：<span class="hljs-string">&quot;attention&quot;</span> 和 <span class="hljs-string">&quot;attend&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">输入：<span class="hljs-built_in">words</span> = [<span class="hljs-string">&quot;leetcode&quot;</span>,<span class="hljs-string">&quot;win&quot;</span>,<span class="hljs-string">&quot;loops&quot;</span>,<span class="hljs-string">&quot;success&quot;</span>], pref = <span class="hljs-string">&quot;code&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：不存在以 <span class="hljs-string">&quot;code&quot;</span> 作为前缀的字符串。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li><li><code>words[i]</code> 和 <code>pref</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>直接调用python的<code>str.startswith(pref)</code>函数就可以，这里或许可以借机复习下Trie树的数据结构，每个节点由一个mapping的词典和<code>is_last</code>标记组成，第一次插入一个单词的时候就是不断创造mapping里边嵌套的mapping，中间的节点is_last都是False，最后的一个节点is_last设置成True；之后插入第二个单词的时候就有一种寻迹的感觉了，如果已经有了就不用重复插入；</p><p>p.s.没想到这题和某top10排名大佬代码一模一样哈哈哈，奇怪的开心点增加了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">prefixCount</span>(<span class="hljs-params">self, words, pref</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type words: List[str]</span><br><span class="hljs-string">        :type pref: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:<br>            <span class="hljs-keyword">if</span> word.startswith(pref):<br>               res += <span class="hljs-number">1</span> <br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2186-使两字符串互为字母异位词的最少步骤数"><a href="#第二题：2186-使两字符串互为字母异位词的最少步骤数" class="headerlink" title="第二题：2186.使两字符串互为字母异位词的最少步骤数"></a>第二题：2186.使两字符串互为字母异位词的最少步骤数</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个字符串 <code>s</code> 和 <code>t</code> 。在一步操作中，你可以给 <code>s</code> 或者 <code>t</code> 追加 <strong>任一字符</strong> 。</p><p>返回使 <code>s</code> 和 <code>t</code> 互为 <strong>字母异位词</strong> 所需的最少步骤数。</p><p><strong>字母异位词</strong> 指字母相同但是顺序不同（或者相同）的字符串。</p><p>示例1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coats&quot;</span><br>输出：<span class="hljs-number">7</span><br>解释：<br>- 执行 <span class="hljs-number">2</span> 步操作，将 <span class="hljs-string">&quot;as&quot;</span> 追加到 s = <span class="hljs-string">&quot;leetcode&quot;</span> 中，得到 s = <span class="hljs-string">&quot;leetcodeas&quot;</span> 。<br>- 执行 <span class="hljs-number">5</span> 步操作，将 <span class="hljs-string">&quot;leede&quot;</span> 追加到 <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coats&quot;</span> 中，得到 <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;coatsleede&quot;</span> 。<br><span class="hljs-string">&quot;leetcodeas&quot;</span> 和 <span class="hljs-string">&quot;coatsleede&quot;</span> 互为字母异位词。<br>总共用去 <span class="hljs-number">2</span> + <span class="hljs-number">5</span> = <span class="hljs-number">7</span> 步。<br>可以证明，无法用少于 <span class="hljs-number">7</span> 步操作使这两个字符串互为字母异位词。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：s = <span class="hljs-string">&quot;night&quot;</span>, <span class="hljs-built_in">t</span> = <span class="hljs-string">&quot;thing&quot;</span><br>输出：<span class="hljs-number">0</span><br>解释：给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length, t.length &lt;= 2 * 10^5</code></li><li><code>s</code> 和 <code>t</code> 由小写英文字符组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看到这个题就想着要拟合测试样例，感觉能拟合测试样例可能就差不多能做出来了，然后看到第二个样例感觉就是比较明显的Counter了，感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSteps</span>(<span class="hljs-params">self, s, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type t: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        s_counter = Counter(s)<br>        t_counter = Counter(t)<br>        <span class="hljs-comment"># print(s_counter)</span><br>        <span class="hljs-comment"># print(t_counter)</span><br>        <br>        s_t_counter = s_counter - t_counter<br>        t_s_counter = t_counter - s_counter<br>        <br>        <span class="hljs-comment"># print(&quot;s_t_counter:&quot;, s_t_counter)</span><br>        <span class="hljs-comment"># print(&quot;t_s_counter:&quot;, t_s_counter)</span><br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> s_t_counter.items():<br>            res += value<br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> t_s_counter.items():<br>            res += value<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第三题：2187-完成旅途的最少时间"><a href="#第三题：2187-完成旅途的最少时间" class="headerlink" title="第三题：2187.完成旅途的最少时间"></a>第三题：2187.完成旅途的最少时间</h1><p><a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个数组 <code>time</code> ，其中 <code>time[i]</code> 表示第 <code>i</code> 辆公交车完成 <strong>一趟旅途</strong> 所需要花费的时间。</p><p>每辆公交车可以 <strong>连续</strong> 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 <strong>立马开始</strong> 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。</p><p>给你一个整数 <code>totalTrips</code> ，表示所有公交车 <strong>总共</strong> 需要完成的旅途数目。请你返回完成 <strong>至少</strong> <code>totalTrips</code> 趟旅途需要花费的 <strong>最少</strong> 时间。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [1,2,3], totalTrips = 5<br>输出：3<br>解释：<br>- 时刻 t =<span class="hljs-number"> 1 </span>，每辆公交车完成的旅途数分别为 [1,0,0] 。<br>  已完成的总旅途数为<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 0 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 1 </span>。<br>- 时刻 t =<span class="hljs-number"> 2 </span>，每辆公交车完成的旅途数分别为 [2,1,0] 。<br>  已完成的总旅途数为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 0 </span>=<span class="hljs-number"> 3 </span>。<br>- 时刻 t =<span class="hljs-number"> 3 </span>，每辆公交车完成的旅途数分别为 [3,1,1] 。<br>  已完成的总旅途数为<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 5 </span>。<br>所以总共完成至少<span class="hljs-number"> 5 </span>趟旅途的最少时间为<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：time = [2], totalTrips = 1<br>输出：2<br>解释：<br>只有一辆公交车，它将在时刻 t =<span class="hljs-number"> 2 </span>完成第一趟旅途。<br>所以完成<span class="hljs-number"> 1 </span>趟旅途的最少时间为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= time.length &lt;= 10^5</code></li><li><code>1 &lt;= time[i], totalTrips &lt;= 10^7</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了；</p><p>二分的过程细节需要把握下，就是 <code>right left = mid</code> 还是 <code>mid + 1</code> 还是 <code>mid - 1</code> 这类的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumTime</span>(<span class="hljs-params">self, time, totalTrips</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type time: List[int]</span><br><span class="hljs-string">        :type totalTrips: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">mid, time, totalTrips</span>):<br>            tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> time:<br>                tmp += mid // t<br>            <br>            <span class="hljs-keyword">if</span> tmp &gt;= totalTrips:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>        left = <span class="hljs-number">1</span><br>        right = <span class="hljs-built_in">min</span>(time) * totalTrips<br>        <br>        <span class="hljs-keyword">while</span> left &lt; right:<br>            mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>  <span class="hljs-comment"># 中间那个时间</span><br>            <span class="hljs-comment"># 判断中间那个时间是否可以完成</span><br>            <span class="hljs-keyword">if</span> judge(mid, time, totalTrips):<br>                right = mid<br>            <span class="hljs-keyword">else</span>:<br>                left = mid + <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> left<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>二分查找</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>281场LeetCode周赛</title>
    <link href="/2022/02/27/algorithms/leetcode-weekly-contest/281%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/27/algorithms/leetcode-weekly-contest/281%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>依旧是前两个题很简单，然后第三题直接卡到死的节奏，感觉近几次周赛第三题感觉都不是很好，可能需要阶段性的复习一下？</p><p>总结下来的话算法似乎都是在可以知道范围内的，比如这次题印象比较深的就是要正确理解题意或者说不要走到和题意错误的路上，有些题可能需要灵光一现用一些广泛用的Coutner、二分、前缀和、有限队列单调栈类的，有些题可能写着写着会有思路吧。</p><p>总之感觉刷题这个事还是要持续进行，总有瓶颈也总需要突破，冲！</p><p>第一题：看到<code>n &lt; 1000</code>感觉就直接暴力模拟就行了，模拟起来还是相对简单的，python对字符的操作太方便了；</p><p>第二题：一个链表的操作题，很简单就能搞定了，纯链表题现在感觉没有太难的；</p><p>第三题：这个题这次又卡的时间太长了，开始想的是排序后原地交换的思路，然后感觉就思维掉到一个坑里边了，一直在排序后原地交换一些细节条件里考虑来考虑去。后来大佬提醒说可以用Counter后排序贪心的思路，感觉这个思路一下就简单并且明确了；</p><p>第四题：鸽了鸽了。</p><span id="more"></span><h1 id="第一题：2180-统计各位数字之和为偶数的整数个数"><a href="#第一题：2180-统计各位数字之和为偶数的整数个数" class="headerlink" title="第一题：2180.统计各位数字之和为偶数的整数个数"></a>第一题：2180.统计各位数字之和为偶数的整数个数</h1><p><a href="https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个正整数 <code>num</code> ，请你统计并返回 <strong>小于或等于</strong> <code>num</code> 且各位数字之和为 <strong>偶数</strong> 的正整数的数目。</p><p>正整数的 <strong>各位数字之和</strong> 是其所有位上的对应数字相加的结果。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：num = 4<br>输出：2<br>解释：<br>只有<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 4 </span>满足小于等于<span class="hljs-number"> 4 </span>且各位数字之和为偶数。 <br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：num = <span class="hljs-number">30</span><br>输出：<span class="hljs-number">14</span><br>解释：<br>只有 <span class="hljs-number">14</span> 个整数满足小于等于 <span class="hljs-number">30</span> 且各位数字之和为偶数，分别是： <br><span class="hljs-number">2、4、6、8</span>、<span class="hljs-number">11、13、15、17</span>、<span class="hljs-number">19、20、22、24</span>、<span class="hljs-number">26</span> 和 <span class="hljs-number">28</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= num &lt;= 1000</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>考虑到数据范围的1000，直接暴力就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countEven</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">n</span>):<br>            res = <span class="hljs-number">0</span><br>            str_n = <span class="hljs-built_in">str</span>(n)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(str_n)):<br>                res += <span class="hljs-built_in">int</span>(str_n[i])<br>            <span class="hljs-keyword">return</span> res % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>        <br>        res = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> judge(i):<br>                res += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h1 id="第二题：2181-合并零之间的节点"><a href="#第二题：2181-合并零之间的节点" class="headerlink" title="第二题：2181.合并零之间的节点"></a>第二题：2181.合并零之间的节点</h1><p><a href="https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个链表的头节点 <code>head</code> ，该链表包含由 <code>0</code> 分隔开的一连串整数。链表的 <strong>开端</strong> 和 <strong>末尾</strong> 的节点都满足 <code>Node.val == 0</code> 。</p><p>对于每两个相邻的 &#96;&#96;&#96;0&#96;&#96; ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。</p><p>返回修改后链表的头节点 <code>head</code> 。</p><p>示例1：<br><img src="/images/2022-02-27-22-48-01.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：head = [0,3,1,0,4,5,2,0]<br>输出：[4,11]<br>解释：<br>上图表示输入的链表。修改后的链表包含：<br>- 标记为绿色的节点之和：3 +<span class="hljs-number"> 1 </span>= 4<br>- 标记为红色的节点之和：4 +<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>= 11<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-02-27-22-48-28.png"></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">输入：head = [0,1,0,3,0,2,2,0]<br>输出：[1,3,4]<br>解释：<br>上图表示输入的链表。修改后的链表包含：<br><span class="hljs-bullet">- </span>标记为绿色的节点之和：1 = 1<br><span class="hljs-bullet">- </span>标记为红色的节点之和：3 = 3<br><span class="hljs-bullet">- </span>标记为黄色的节点之和：2 + 2 = 4<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>列表中的节点数目在范围 <code>[3, 2 * 10^5]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><strong>不</strong> 存在连续两个 <code>Node.val == 0</code> 的节点</li><li>链表的 <strong>开端</strong> 和 <strong>末尾</strong> 节点都满足 <code>Node.val == 0</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看起来提示里很多条件都是避免特殊情况用的，链表题比较复杂的地方在于经常有一些很极端的case只能靠测试样例来debug，很难一次想到，这个题没有这个问题不过也需要注意下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeNodes</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: Optional[ListNode]</span><br><span class="hljs-string">        :rtype: Optional[ListNode]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        new_head = ListNode(val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span>)<br>        q = new_head<br><br>        tmp = <span class="hljs-number">0</span><br>        head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> head <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> head.val == <span class="hljs-number">0</span>:<br>                tmp_node = ListNode(val=tmp)<br>                q.<span class="hljs-built_in">next</span> = tmp_node<br>                q = q.<span class="hljs-built_in">next</span><br>                tmp = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">else</span>:<br>                tmp += head.val<br><br>            head = head.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> new_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h1 id="第三题：2182-构造限制重复的字符串"><a href="#第三题：2182-构造限制重复的字符串" class="headerlink" title="第三题：2182.构造限制重复的字符串"></a>第三题：2182.构造限制重复的字符串</h1><p><a href="https://leetcode-cn.com/problems/construct-string-with-repeat-limit/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>s</code> 和一个整数 <code>repeatLimit</code> ，用 <code>s</code> 中的字符构造一个新字符串 <code>repeatLimitedString</code> ，使任何字母 <strong>连续</strong> 出现的次数都不超过 <code>repeatLimit</code> 次。你不必使用 <code>s</code> 中的全部字符。</p><p>返回 <strong>字典序最大的</strong> <code>repeatLimitedString</code> 。</p><p>如果在字符串 <code>a</code> 和 <code>b</code> 不同的第一个位置，字符串 <code>a</code> 中的字母在字母表中出现时间比字符串 <code>b</code> 对应的字母晚，则认为字符串 <code>a</code> 比字符串 <code>b</code> <strong>字典序更大</strong> 。如果字符串中前 <code>min(a.length, b.length)</code> 个字符都相同，那么较长的字符串字典序更大。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;cczazcc&quot;</span>, repeatLimit = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">&quot;zzcccac&quot;</span><br>解释：使用 s 中的所有字符来构造 repeatLimitedString <span class="hljs-string">&quot;zzcccac&quot;</span>。<br>字母 &#x27;a&#x27; 连续出现至多 <span class="hljs-number">1</span> 次。<br>字母 &#x27;c&#x27; 连续出现至多 <span class="hljs-number">3</span> 次。<br>字母 &#x27;z&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。<br>因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。<br>该字符串是字典序最大的 repeatLimitedString ，所以返回 <span class="hljs-string">&quot;zzcccac&quot;</span> 。<br>注意，尽管 <span class="hljs-string">&quot;zzcccca&quot;</span> 字典序更大，但字母 &#x27;c&#x27; 连续出现超过 <span class="hljs-number">3</span> 次，所以它不是一个有效的 repeatLimitedString 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;aababab&quot;</span>, repeatLimit = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">&quot;bbabaa&quot;</span><br>解释：<br>使用 s 中的一些字符来构造 repeatLimitedString <span class="hljs-string">&quot;bbabaa&quot;</span>。 <br>字母 &#x27;a&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。 <br>字母 &#x27;b&#x27; 连续出现至多 <span class="hljs-number">2</span> 次。 <br>因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 <br>该字符串是字典序最大的 repeatLimitedString ，所以返回 <span class="hljs-string">&quot;bbabaa&quot;</span> 。 <br>注意，尽管 <span class="hljs-string">&quot;bbabaaa&quot;</span> 字典序更大，但字母 &#x27;a&#x27; 连续出现超过 <span class="hljs-number">2</span> 次，所以它不是一个有效的 repeatLimitedString 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; repeatLimit &lt;&#x3D; s.length &lt;&#x3D; 10^5</li><li><code>s</code>由小写英文字母组成</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题现场做的时候又做了好久好久，最后还是gg了，当时主要考虑的是一种排序后交换的思路，但是交换的思路最后就越换越乱，比如换完了后在那个位置的“指针”是否要++这样的；</p><p>后来大佬给了一种Counter计数排序后贪心的思路感觉能想到的话代码实现就比较简单了，每次取最头的元素，然后取够个数了后就交替取一个下一个，如果没有下一个就代表已经取不了了，这样实际上有一种类似于队列的小思想在里边</p><p>另外删除列表中的一个元素可以用<code>del tmp[i]</code>这样的操作来做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">repeatLimitedString</span>(<span class="hljs-params">self, s, repeatLimit</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type repeatLimit: int</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 还是要多锻炼多总结思路hhh</span><br>        <span class="hljs-comment"># 一种贪心算法的思想，Counter后排序，然后相对贪心一点的拿就行了</span><br>        <span class="hljs-comment"># 开始的思路想的是排序后有一种原地交换的感觉，但后来还是换着换着就乱了</span><br>        <br>        counter_s = Counter(s)<br>        <span class="hljs-comment"># print(counter_s)</span><br>        counter_s_list = <span class="hljs-built_in">sorted</span>([<span class="hljs-built_in">list</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> counter_s.items()], key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>])<br>        counter_s_list.reverse()<br>        <span class="hljs-comment"># print(counter_s_list)</span><br><br>        result = []<br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(counter_s_list):  <span class="hljs-comment"># 循环直到为空为止，这里不用循环变量i，直接用0就行了</span><br>            <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &lt;= repeatLimit:<br>                result.append(counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>])<br>                counter_s_list = counter_s_list[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">else</span>:<br>                result.append(counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * repeatLimit)<br>                counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -= repeatLimit<br>                <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 如果还有的话，如果此时列表就1个了，就结束，否则和下一个交换</span><br>                    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(counter_s_list) &gt; <span class="hljs-number">1</span>:<br>                        result.append(counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br>                        counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] -= <span class="hljs-number">1</span><br>                        <span class="hljs-keyword">if</span> counter_s_list[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:<br>                            <span class="hljs-comment"># counter_s_list = counter_s_list[:1] + counter_s_list[2:]  # 去掉，这里写的其实不够简化</span><br>                            <span class="hljs-keyword">del</span> counter_s_list[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br><br>        <br>        <span class="hljs-comment"># print(result)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(result)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>堆</tag>
      
      <tag>优先队列</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>链表</tag>
      
      <tag>计数</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>78.子集-python</title>
    <link href="/2022/02/21/algorithms/leetcode-python/78-%E5%AD%90%E9%9B%86-python/"/>
    <url>/2022/02/21/algorithms/leetcode-python/78-%E5%AD%90%E9%9B%86-python/</url>
    
    <content type="html"><![CDATA[<p>78.子集（中等）</p><p>题目大意：</p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p>示例1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：2-n遍历法"><a href="#解法一：2-n遍历法" class="headerlink" title="解法一：2^n遍历法"></a>解法一：2^n遍历法</h2><p>在某次周赛的时候积累到了这个思路，可以通过位运算的方法把0到n的二进制每个位的表示都提取出来，这样就可以实现每个位置选择&#x2F;不选择的2^n遍历法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 某次周赛积累到的2^n这种的遍历思路，可以实现暴力非递归</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_bits</span>(<span class="hljs-params">num</span>):<br>            l = []<br>            <span class="hljs-keyword">while</span> num &gt; <span class="hljs-number">0</span>:<br>                l.append(num&amp;<span class="hljs-number">1</span>)<br>                num &gt;&gt;= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> l<br><br>        ans = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>**<span class="hljs-built_in">len</span>(nums)):<br>            l = get_bits(i)<br>            tmp = []<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(l)):<br>                <span class="hljs-keyword">if</span> l[j] == <span class="hljs-number">1</span>:<br>                    tmp.append(nums[j])<br>            ans.append(tmp)<br>        <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><h2 id="解法二：dfs回溯法"><a href="#解法二：dfs回溯法" class="headerlink" title="解法二：dfs回溯法"></a>解法二：dfs回溯法</h2><p>dfs的方法在本质上也是针对每个位置的选择，不选择。所以每次carry到递归下一个轮次状态就是位置i，<strong>针对位置i的选择和不选择两条dfs分支</strong>。</p><p>另外在这个题里发现dfs的时候需要deepcopy复制一份，列表在dfs过程中不能指向相同的地址，否则一个改动了就全部改动了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">subsets</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 递归思路，这个题涉及到了python的深浅拷贝问题，在dfs向下一层的时候本质上是复制了状态，所以要拷贝</span><br>        res = []<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">i, tmp_list</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            :type i: int，代表当前到了dfs的第几层了</span><br><span class="hljs-string">            : type tmp_list: List[int]，代表当前带着哪些下到下一层了！！！！</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(nums):  <span class="hljs-comment"># 这类的递归一般用长度作为出口</span><br>                res.append(tmp_list)<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-comment"># 不取的dfs分支</span><br>            dfs(i+<span class="hljs-number">1</span>, copy.deepcopy(tmp_list))  <span class="hljs-comment"># 这里要传拷贝，否则会搞到一个分支上！！！</span><br>            <span class="hljs-comment"># 取的dfs分支</span><br>            tmp_list.append(nums[i])<br>            dfs(i+<span class="hljs-number">1</span>, copy.deepcopy(tmp_list))  <span class="hljs-comment"># 这里要传拷贝</span><br>            <br>        dfs(<span class="hljs-number">0</span>, [])<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19.删除链表的倒数第N个结点-python</title>
    <link href="/2022/02/21/algorithms/leetcode-python/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-python/"/>
    <url>/2022/02/21/algorithms/leetcode-python/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-python/</url>
    
    <content type="html"><![CDATA[<p>19.删除链表的倒数第 N 个结点（中等）</p><p>题目大意：</p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">题目链接</a></p><p>题目大意：给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>示例1：<br><img src="/images/2022-02-21-23-49-06.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>,<span class="hljs-number">5</span>], n = <span class="hljs-number">2</span><br>输出：[<span class="hljs-number">1,2,3,5</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, n = 1<br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2]</span>, n = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中结点的数目为 <code>sz</code></li><li><code>1 &lt;= sz &lt;= 30</code></li><li><code>0 &lt;= Node.val &lt;= 100</code></li><li><code>1 &lt;= n &lt;= sz</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这是一个经典的双指针题目了，保持pq指针之间的距离差是n，然后当p先到结尾后，把q.next那个地方删除了就可以。</p><p>这个题比较麻烦的地方在于很难一次性做对，需要自己构造一些相对极端的的case来测试下，例如只有一个节点的链表这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, next=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.next = next</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">removeNthFromEnd</span>(<span class="hljs-params">self, head, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 注意自己构造一些badcase的例子，来把所有特殊情况覆盖掉</span><br>        <span class="hljs-comment"># 双指针法，双指针之间的差距是n</span><br>        p = head<br>        q = head<br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; n:<br>            q = q.<span class="hljs-built_in">next</span><br>            i += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 让q指向最后一个不为None的，有一个异常情况是q已经是None了，应该删除头结点</span><br>        <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">while</span> q.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            p = p.<span class="hljs-built_in">next</span><br>            q = q.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-comment"># 删除p</span><br>        p.<span class="hljs-built_in">next</span> = p.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> head<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>101.对称二叉树-python</title>
    <link href="/2022/02/14/algorithms/leetcode-python/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-python/"/>
    <url>/2022/02/14/algorithms/leetcode-python/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>101.对称二叉树（简单）</p><p>题目大意：</p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">题目链接</a></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p>示例1：<br><img src="/images/2022-02-14-15-53-42.png"></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">输入<span class="hljs-built_in">：root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]<br>输出<span class="hljs-built_in">：true</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-02-14-15-53-53.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li>-100 &lt;&#x3D; Node.val &lt;&#x3D; 100</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这种题又和完全的自递归题目有些区别，需要再构造一个dfscheck的函数，来套一下递归。</p><p>这个<code>dfs_check()</code>函数的输入是两个root这样的感觉，先判断当前节点的左右是否相等，然后往下嵌套递归，判断当前节点的左的左和当前节点右的右，还有当前节点左的右和当前节点右的左是不是一样就行了，在前边要加入一些None的出口递归条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSymmetric</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs_check</span>(<span class="hljs-params">root1, root2</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            用于判断一个点的左右子树是否轴对称，首次输入两个都是这个树的根</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>            <span class="hljs-comment"># 当前节点的左右，然后递归下一层的左右！</span><br>            <span class="hljs-keyword">return</span> root1.val == root2.val <span class="hljs-keyword">and</span> dfs_check(root1.left, root2.right) <span class="hljs-keyword">and</span> dfs_check(root1.right, root2.left)<br><br>        <span class="hljs-keyword">return</span> dfs_check(root, root)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>617.合并二叉树-python</title>
    <link href="/2022/02/14/algorithms/leetcode-python/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-python/"/>
    <url>/2022/02/14/algorithms/leetcode-python/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>617.合并二叉树（简单）</p><p>题目大意：</p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">题目链接</a></p><p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p><strong>注意</strong>: 合并过程必须从两个树的根节点开始。</p><p>示例1：<br><img src="/images/2022-02-14-15-33-49.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root1</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>], <span class="hljs-attr">root2</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br>输出：[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root1 = <span class="hljs-comment">[1]</span>, root2 = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,2]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li><li>-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这个题有一种自递归的感觉，题目的初始Solution类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1, root2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root1: TreeNode</span><br><span class="hljs-string">        :type root2: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>rtype是一个TreeNode类型的，所以能有一种自递归的感觉，先建立TreeNode，然后</p><p>这种自递归的题还是可以先把主干写好了，再决定递归出口那样的感觉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><br><span class="hljs-comment"># class TreeNode(object):</span><br><span class="hljs-comment">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="hljs-comment">#         self.val = val</span><br><span class="hljs-comment">#         self.left = left</span><br><span class="hljs-comment">#         self.right = right</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTrees</span>(<span class="hljs-params">self, root1, root2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root1: TreeNode</span><br><span class="hljs-string">        :type root2: TreeNode</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 整个题目有一种自递归的感觉</span><br>        <span class="hljs-keyword">if</span> root1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root2<br>        <span class="hljs-keyword">if</span> root2 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> root1<br>        <br>        merged_node = TreeNode(val=root1.val + root2.val)<br>        merged_node.left = self.mergeTrees(root1.left, root2.left)<br>        merged_node.right = self.mergeTrees(root1.right, root2.right)<br><br>        <span class="hljs-keyword">return</span>  merged_node<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>280场LeetCode周赛</title>
    <link href="/2022/02/14/algorithms/leetcode-weekly-contest/280%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/14/algorithms/leetcode-weekly-contest/280%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这周做的状态和水平感觉都不是很好，第一个题做下去的时候就感觉不是很顺，第二个题直接就卡住了，感觉还是把第二题想的太简单或者说样例分析不太够？第三题直接没来得及看，最后复盘的时候感觉比赛有规定的时间内也不一定好想，和之前某一周ABCDE的前后缀和有点像，但是简单了一些；</p><p>第一题：一种模拟操作的感觉就行了？开始还以为要一些数学的操作，这种题如果告诉难度的话可能比较简单，但是如果不知道难度比较怕想到数学题上边去；</p><p>第二题：这个题当时做的时候直接就卡死了，卡了可以说一个多小时，还是样例可能误导了一种的感觉，最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了；</p><p>第三题：一种前缀和，或者说<strong>反向思路</strong>的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的；</p><p>第四题：鸽！</p><span id="more"></span><h1 id="第一题：2169-得到0的操作数"><a href="#第一题：2169-得到0的操作数" class="headerlink" title="第一题：2169.得到0的操作数"></a>第一题：2169.得到0的操作数</h1><p><a href="https://leetcode-cn.com/problems/count-operations-to-obtain-zero/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个 <strong>非负</strong> 整数 <code>num1</code> 和 <code>num2</code> 。</p><p>每一步 <strong>操作</strong> 中，如果 <code>num1 &gt;= num2</code> ，你必须用 <code>num1</code> 减 <code>num2</code> ；否则，你必须用 <code>num2</code> 减 <code>num1</code> 。</p><ul><li>例如， <code>num1 = 5</code> 且 <code>num2 = 4</code> ，应该用 <code>num1</code> 减 <code>num2</code> ，因此，得到 <code>num1 = 1</code> 和 <code>num2 = 4</code> 。然而，如果 <code>num1 = 4</code> 且 <code>num2 = 5</code> ，一步操作后，得到 <code>num1 = 4</code> 和 <code>num2 = 1</code> 。</li></ul><p>返回使 <code>num1 = 0</code> 或 <code>num2 = 0</code> 的 <strong>操作数</strong> 。</p><p>示例1：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>- 操作 <span class="hljs-number">1</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span> 。由于 <span class="hljs-symbol">num1</span> &lt; <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num2</span> 减 <span class="hljs-symbol">num1</span> 得到 <span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">3</span> - <span class="hljs-number">2</span> = <span class="hljs-number">1</span> 。<br>- 操作 <span class="hljs-number">2</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">2</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> &gt; <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 。<br>- 操作 <span class="hljs-number">3</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">1</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 。<br>此时 <span class="hljs-symbol">num1</span> = <span class="hljs-number">0</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">1</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-number">0</span> ，不需要再执行任何操作。<br>所以总操作数是 <span class="hljs-number">3</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：<span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span>, <span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span><br>输出：<span class="hljs-number">1</span><br>解释：<br>- 操作 <span class="hljs-number">1</span> ：<span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-symbol">num2</span> ，<span class="hljs-symbol">num1</span> 减 <span class="hljs-symbol">num2</span> 得到 <span class="hljs-symbol">num1</span> = <span class="hljs-number">10</span> - <span class="hljs-number">10</span> = <span class="hljs-number">0</span> 。<br>此时 <span class="hljs-symbol">num1</span> = <span class="hljs-number">0</span> ，<span class="hljs-symbol">num2</span> = <span class="hljs-number">10</span> 。由于 <span class="hljs-symbol">num1</span> == <span class="hljs-number">0</span> ，不需要再执行任何操作。<br>所以总操作数是 <span class="hljs-number">1</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= num1, num2 &lt;= 105</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始还以为需要一些数学的操作，没想到直接循环模拟就行了，注意python的两个数值交换可以使用如下代码直接交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">a, b = b, a<br></code></pre></td></tr></table></figure><p>看了一些题解说是可以用辗转相除法，不禁想到信安数学里学过为数不多的数论知识都还给老师了哈哈哈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countOperations</span>(<span class="hljs-params">self, num1, num2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num1: int</span><br><span class="hljs-string">        :type num2: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> num1 == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> num2 == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> num1 &lt; num2:<br>                num1, num2 = num2, num1<br>            <span class="hljs-keyword">if</span> num1 &gt;= num2:<br>                num1 = num1 - num2<br>            cnt += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># print(num1, num2)</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：2170-使数组变成交替数组的最少操作数"><a href="#第二题：2170-使数组变成交替数组的最少操作数" class="headerlink" title="第二题：2170.使数组变成交替数组的最少操作数"></a>第二题：2170.使数组变成交替数组的最少操作数</h1><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，该数组由 <code>n</code> 个正整数组成。</p><p>如果满足下述条件，则数组 nums 是一个 <strong>交替数组</strong> ：</p><ul><li><code>nums[i - 2] == nums[i]</code> ，其中 <code>2 &lt;= i &lt;= n - </code> 。</li><li><code>nums[i - 1] != nums[i]</code> ，其中 <code>1 &lt;= i &lt;= n - 1</code> 。</li></ul><p>在一步 <strong>操作</strong> 中，你可以选择下标 <code>i</code> 并将 <code>nums[i]</code> <strong>更改</strong> 为 <strong>任一</strong> 正整数。</p><p>返回使数组变成交替数组的 <strong>最少操作数</strong> 。</p><p>示例1：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[3,1,3,2,4,3]</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>使数组变成交替数组的方法之一是将该数组转换为 <span class="hljs-string">[3,1,3,1,3,1]</span> 。<br>在这种情况下，操作数为 <span class="hljs-number">3</span> 。<br>可以证明，操作数少于 <span class="hljs-number">3</span> 的情况下，无法使数组变成交替数组。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>输出：<span class="hljs-number">2</span><br>解释：<br>使数组变成交替数组的方法之一是将该数组转换为 [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>].<br>在这种情况下，操作数为 <span class="hljs-number">2</span> 。<br>注意，数组不能转换成 [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>] 。因为在这种情况下，nums[<span class="hljs-number">0</span>] == nums[<span class="hljs-number">1</span>]，不满足交替数组的条件。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉还是个很考思路的题，一旦有一些理解错或者路走歪了就容易做不出来了。</p><p>最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumOperations</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        oushu = [nums[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>)]<br>        jishu = [nums[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums), <span class="hljs-number">2</span>)]<br>        oushu_counter = Counter(oushu)<br>        jishu_counter = Counter(jishu)<br>        <br>        <br>        oushu_counter_value = <span class="hljs-built_in">sorted</span>(oushu_counter.items(), key=<span class="hljs-keyword">lambda</span> x: -x[<span class="hljs-number">1</span>])<br>        jishu_counter_value = <span class="hljs-built_in">sorted</span>(jishu_counter.items(), key=<span class="hljs-keyword">lambda</span> x: -x[<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># 三种情况</span><br>        <span class="hljs-keyword">if</span> oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] != jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]:<br>            max_num = oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(oushu_counter_value) &lt; <span class="hljs-number">2</span>:<br>                oushu_counter_value.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>             <br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(jishu_counter_value) &lt; <span class="hljs-number">2</span>:<br>                jishu_counter_value.append((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            <br>            <br>            max_num = <span class="hljs-built_in">max</span>(oushu_counter_value[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], oushu_counter_value[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] + jishu_counter_value[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(nums) - max_num<br></code></pre></td></tr></table></figure><h1 id="第三题：2171-拿出最少数目的魔法豆"><a href="#第三题：2171-拿出最少数目的魔法豆" class="headerlink" title="第三题：2171.拿出最少数目的魔法豆"></a>第三题：2171.拿出最少数目的魔法豆</h1><p><a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/comments/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个 正 整数数组 <code>beans</code> ，其中每个整数表示一个袋子里装的魔法豆的数目。</p><p>请你从每个袋子中 <strong>拿出</strong> 一些豆子（也可以 <strong>不拿出</strong> ），使得剩下的 <strong>非空</strong> 袋子中（即 <strong>至少</strong> 还有 一颗 魔法豆的袋子）魔法豆的数目 <strong>相等</strong> 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。</p><p>请你返回你需要拿出魔法豆的 <strong>最少数目</strong>。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：beans = [4,1,6,5]<br>输出：4<br>解释：<br>- 我们从有<span class="hljs-number"> 1 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 1 </span>颗魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,6,5]<br>- 然后我们从有<span class="hljs-number"> 6 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,4,5]<br>- 然后我们从有<span class="hljs-number"> 5 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 1 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[4,0,4,4]<br>总共拿出了<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>个魔法豆，剩下非空袋子中魔法豆的数目相等。<br>没有比取出<span class="hljs-number"> 4 </span>个魔法豆更少的方案。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：beans = [2,10,3,2]<br>输出：7<br>解释：<br>- 我们从有<span class="hljs-number"> 2 </span>个魔法豆的其中一个袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,3,2]<br>- 然后我们从另一个有<span class="hljs-number"> 2 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 2 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,3,0]<br>- 然后我们从有<span class="hljs-number"> 3 </span>个魔法豆的袋子中拿出<span class="hljs-number"> 3 </span>个魔法豆。<br>  剩下袋子中魔法豆的数目为：[0,10,0,0]<br>总共拿出了<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>个魔法豆，剩下非空袋子中魔法豆的数目相等。<br>没有比取出<span class="hljs-number"> 7 </span>个魔法豆更少的方案。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= beans.length &lt;= 105</code></li><li><code>1 &lt;= beans[i] &lt;= 105</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一眼看过去这种题目肯定是要排序的，后边发现只要排序+枚举就可以了，有一种反向思路的感觉</p><p>一种前缀和，或者说<strong>反向思路</strong>的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumRemoval</span>(<span class="hljs-params">self, beans</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type beans: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 第i个地方最多保留(n-i) * beans[i]个</span><br>        <br>        beans.sort()<br>        <br>        total = <span class="hljs-number">0</span><br>        max_save = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(beans)):<br>            total += beans[i]<br>            max_save = <span class="hljs-built_in">max</span>(max_save, (<span class="hljs-built_in">len</span>(beans)-i) * beans[i])<br>        <br>        <span class="hljs-keyword">return</span> total - max_save<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>哈希表</tag>
      
      <tag>前缀和</tag>
      
      <tag>计数</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>279场LeetCode周赛</title>
    <link href="/2022/02/07/algorithms/leetcode-weekly-contest/279%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/02/07/algorithms/leetcode-weekly-contest/279%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次手感还可以，在比赛时间做出了三个题，回看复盘的时候感觉当时状态可能确实好hhh，思路一路做下来没有中断的感觉。一些常见的操作包括filp一类的，还有就是下边这段代码可以直接取出来奇偶下标的！（实际是在280周赛复盘发现的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums[::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出偶数下标的value</span><br>nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出奇数下标的value</span><br></code></pre></td></tr></table></figure><p>还有个是index截断的重拼接可以使用下边这种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><p>第一题：印象比较深的是要把奇数偶数下标的分开拍，注意审题的感觉；</p><p>第二题：也是一个排序的思路，可以分大于0小于0两种情况分类讨论，还是很容易区分状态的；</p><p>第三题：一种设计题的思路，第一次很简单的做很快就超时了，超时后复盘发现可以用一些标识为来进行一些标志，有一个filp操作，标志出filp_status后，其他的操作都可以通过cnt直接O(1)的返回了，做题的时候状态比较好，感觉这个题还是没那么好想，也可能是做的时候根据badcase发现了优化思路吧；</p><p>第四题：鸽！</p><span id="more"></span><h1 id="第一题：2164-对奇偶下标分别排序"><a href="#第一题：2164-对奇偶下标分别排序" class="headerlink" title="第一题：2164.对奇偶下标分别排序"></a>第一题：2164.对奇偶下标分别排序</h1><p><a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。根据下述规则重排 <code>nums</code> 中的值：</p><ol><li>按 非递增 顺序排列 <code>nums</code> <strong>奇数下标</strong> 上的所有值。</li></ol><ul><li>举个例子，如果排序前 <code>nums = [4,1,2,3]</code> ，对奇数下标的值排序后变为 <code>[4,3,2,1]</code> 。奇数下标 <code>1</code> 和 <code>3</code> 的值按照非递增顺序重排。</li></ul><ol start="2"><li>按 非递减 顺序排列 <code>nums</code> <strong>偶数下标</strong> 上的所有值。</li></ol><ul><li>举个例子，如果排序前 <code>nums = [4,1,2,3]</code> ，对偶数下标的值排序后变为 <code>[2,1,4,3]</code> 。偶数下标 <code>0</code> 和 <code>2</code> 的值按照非递减顺序重排。</li></ul><p>返回重排 <code>nums</code> 的值之后形成的数组。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">4,1,2,3</span>]<br>输出：[<span class="hljs-number">2,3,4,1</span>]<br>解释：<br>首先，按非递增顺序重排奇数下标（<span class="hljs-number">1</span> 和 <span class="hljs-number">3</span>）的值。<br>所以，nums 从 [<span class="hljs-number">4,1,2,3</span>] 变为 [<span class="hljs-number">4,3,2,1</span>] 。<br>然后，按非递减顺序重排偶数下标（<span class="hljs-number">0</span> 和 <span class="hljs-number">2</span>）的值。<br>所以，nums 从 [<span class="hljs-number">4,1,2,3</span>] 变为 [<span class="hljs-number">2,3,4,1</span>] 。<br>因此，重排之后形成的数组是 [<span class="hljs-number">2,3,4,1</span>] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,1]</span><br>输出：<span class="hljs-comment">[2,1]</span><br>解释：<br>由于只有一个奇数下标和一个偶数下标，所以不会发生重排。<br>形成的结果数组是 <span class="hljs-comment">[2,1]</span> ，和初始数组一样。 <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>1 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题主要是审题，开始审题错了还被坑了一回，注意是奇偶数下标这样的。</p><p>然后就是280场周赛get到的一个技巧，用下边这个代码操作可以把奇数偶数间隔的取出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">nums[::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出偶数下标的value</span><br>nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]  <span class="hljs-comment"># 取出奇数下标的value</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sortEvenOdd</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        o_index = nums[::<span class="hljs-number">2</span>]<br>        j_index = nums[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>]<br>        o_index.sort()<br>        j_index.sort(key=<span class="hljs-keyword">lambda</span> x: -x)<br><br>        result = []<br>        j = <span class="hljs-number">0</span><br>        k = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                result.append(o_index[j])<br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                result.append(j_index[k])<br>                k += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第二题：2165-重排数字的最小值"><a href="#第二题：2165-重排数字的最小值" class="headerlink" title="第二题：2165.重排数字的最小值"></a>第二题：2165.重排数字的最小值</h1><p><a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数 <code>num</code> 。<strong>重排</strong> <code>num</code> 中的各位数字，使其值 <strong>最小化</strong> 且不含 <strong>任何</strong> 前导零。</p><p>返回不含前导零且值最小的重排数字。</p><p>注意，重排各位数字后，<code>num</code> 的符号不会改变。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：num = <span class="hljs-number">310</span><br>输出：<span class="hljs-number">103</span><br>解释：<span class="hljs-number">310</span> 中各位数字的可行排列有：<span class="hljs-number">013、031</span>、<span class="hljs-number">103、130、301</span>、<span class="hljs-number">310</span> 。<br>不含任何前导零且值最小的重排数字是 <span class="hljs-number">103</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：num = <span class="hljs-string">-7605</span><br>输出：<span class="hljs-string">-7650</span><br>解释：<span class="hljs-string">-7605</span> 中各位数字的部分可行排列为：<span class="hljs-string">-7650</span>、<span class="hljs-string">-6705</span>、<span class="hljs-string">-5076</span>、<span class="hljs-string">-0567</span>。<br>不含任何前导零且值最小的重排数字是 <span class="hljs-string">-7650</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>-10^15 &lt;= num &lt;= 10^15</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>要分开处理正数和负数的情况，然后贪心思路的感觉。在str和int类型之间来回转化。</p><p>如果是正数的处理要稍微复杂一点点，就是第一位不能以0起头，要选择一个不是0的index作为起头。</p><p>注意列表的拼接，可以使用如下的操作方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></table></figure><p>题目解答如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">smallestNumber</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        r_list = []<br><br>        <span class="hljs-keyword">if</span> num &lt; <span class="hljs-number">0</span>:<br>            s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(-num))<br>            s.sort(key=<span class="hljs-keyword">lambda</span> x: -<span class="hljs-built_in">int</span>(x))<br>            <span class="hljs-comment"># 选一个最大的（第一个就是），进行重组</span><br>            return_int = -<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;&#x27;</span>.join(s))<br>            <span class="hljs-comment"># print(return_int)</span><br>            <br>        <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># num &gt;= 0</span><br>            s = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">str</span>(num))<br>            s.sort()<br>            <br>            index = -<span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">int</span>(s[i]) != <span class="hljs-number">0</span>:<br>                    index = i<br>                    <span class="hljs-keyword">break</span><br>            <span class="hljs-built_in">print</span>(index)<br>            return_int = <span class="hljs-built_in">int</span>(s[index] + <span class="hljs-string">&#x27;&#x27;</span>.join(s[:index]) + <span class="hljs-string">&#x27;&#x27;</span>.join(s[index+<span class="hljs-number">1</span>:]))<br>            <span class="hljs-comment"># print(return_int)</span><br>    <br>        <span class="hljs-keyword">return</span> return_int<br></code></pre></td></tr></table></figure><h1 id="第三题：2166-设计位集"><a href="#第三题：2166-设计位集" class="headerlink" title="第三题：2166.设计位集"></a>第三题：2166.设计位集</h1><p><a href="https://leetcode-cn.com/problems/design-bitset/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>位集 Bitset</strong> 是一种能以紧凑形式存储位的数据结构。</p><p>请你实现 <code>Bitset</code> 类。</p><ul><li><code>Bitset(int size)</code> 用 <code>size</code> 个位初始化 Bitset ，所有位都是 <code>0</code> 。</li><li><code>void fix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>1</code> 。如果值已经是 <code>1</code> ，则不会发生任何改变。</li><li><code>void unfix(int idx)</code> 将下标为 <code>idx</code> 的位上的值更新为 <code>0</code> 。如果值已经是 <code>0</code> ，则不会发生任何改变。</li><li><code>void flip()</code> 翻转 Bitset 中每一位上的值。换句话说，所有值为 <code>0</code> 的位将会变成 <code>1</code> ，反之亦然。</li><li><code>boolean all()</code> 检查 Bitset 中 <strong>每一位</strong> 的值是否都是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>boolean one()</code> 检查 Bitset 中 是否 <strong>至少一位</strong> 的值是 <code>1</code> 。如果满足此条件，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li><li><code>int count()</code> 返回 Bitset 中值为 1 的位的 <strong>总数</strong> 。</li><li><code>String toString()</code> 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 <code>i</code> 个下标处的字符应该与 Bitset 中的第 <code>i</code> 位一致。</li></ul><p>示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">输入<br>[<span class="hljs-string">&quot;Bitset&quot;</span>, <span class="hljs-string">&quot;fix&quot;</span>, <span class="hljs-string">&quot;fix&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;all&quot;</span>, <span class="hljs-string">&quot;unfix&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;unfix&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;toString&quot;</span>]<br>[[<span class="hljs-number">5</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">1</span>], [], [], [<span class="hljs-number">0</span>], [], [], [<span class="hljs-number">0</span>], [], []]<br>输出<br>[null, null, null, null, false, null, null, true, null, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;01010&quot;</span>]<br><br>解释<br>Bitset bs = new Bitset(<span class="hljs-number">5</span>); <span class="hljs-regexp">//</span> bitset = <span class="hljs-string">&quot;00000&quot;</span>.<br>bs.fix(<span class="hljs-number">3</span>);     <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">3</span> 处的值更新为 <span class="hljs-number">1</span> ，此时 bitset = <span class="hljs-string">&quot;00010&quot;</span> 。<br>bs.fix(<span class="hljs-number">1</span>);     <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">1</span> 处的值更新为 <span class="hljs-number">1</span> ，此时 bitset = <span class="hljs-string">&quot;01010&quot;</span> 。<br>bs.flip();     <span class="hljs-regexp">//</span> 翻转每一位上的值，此时 bitset = <span class="hljs-string">&quot;10101&quot;</span> 。<br>bs.all();      <span class="hljs-regexp">//</span> 返回 False ，bitset 中的值不全为 <span class="hljs-number">1</span> 。<br>bs.unfix(<span class="hljs-number">0</span>);   <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">0</span> 处的值更新为 <span class="hljs-number">0</span> ，此时 bitset = <span class="hljs-string">&quot;00101&quot;</span> 。<br>bs.flip();     <span class="hljs-regexp">//</span> 翻转每一位上的值，此时 bitset = <span class="hljs-string">&quot;11010&quot;</span> 。<br>bs.one();      <span class="hljs-regexp">//</span> 返回 True ，至少存在一位的值为 <span class="hljs-number">1</span> 。<br>bs.unfix(<span class="hljs-number">0</span>);   <span class="hljs-regexp">//</span> 将 idx = <span class="hljs-number">0</span> 处的值更新为 <span class="hljs-number">0</span> ，此时 bitset = <span class="hljs-string">&quot;01010&quot;</span> 。<br>bs.count();    <span class="hljs-regexp">//</span> 返回 <span class="hljs-number">2</span> ，当前有 <span class="hljs-number">2</span> 位的值为 <span class="hljs-number">1</span> 。<br>bs.toString(); <span class="hljs-regexp">//</span> 返回 <span class="hljs-string">&quot;01010&quot;</span> ，即 bitset 的当前组成情况。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= size &lt;= 10^5</code></li><li><code>0 &lt;= idx &lt;= size - 1</code></li><li>至多调用 <code>fix</code>、<code>unfix</code>、<code>flip</code>、<code>all</code>、<code>one</code>、<code>count</code> 和 <code>toString</code> 方法 总共 <code>10^5</code> 次</li><li>至少调用 <code>all</code>、<code>one</code>、<code>count</code> 或 <code>toString</code> 方法一次</li><li>至多调用 <code>toString</code> 方法 <code>5</code> 次</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>要通过一个filp的操作把很多操作都变成O(1)的，</p><ul><li>fix和unfix的操作因为是数组角标的操作，所以是O(1)的，但是注意这个操作要根据filp的状态来决定</li><li>filp直接把self.filp_status修改了就行O(1)</li><li>all、one、count根据cnt值和filp_status共同确定也可以O(1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitset</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type size: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 都放在初始化里？</span><br>        self.bs = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<br>        self.cnt = <span class="hljs-number">0</span><br>        self.filp_status = <span class="hljs-number">0</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fix</span>(<span class="hljs-params">self, idx</span>):  <span class="hljs-comment"># 这个没的改了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type idx: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.bs[idx] != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">1</span><br>            self.cnt += <span class="hljs-number">1</span>    <br>        <span class="hljs-keyword">elif</span> self.filp_status == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.bs[idx] != <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">0</span><br>            self.cnt += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">unfix</span>(<span class="hljs-params">self, idx</span>):  <span class="hljs-comment"># 这个没的改了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type idx: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.bs[idx] == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.bs[idx] = <span class="hljs-number">0</span><br>            self.cnt -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> self.filp_status == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.bs[idx] != <span class="hljs-number">1</span>:<br>            self.bs[idx] = <span class="hljs-number">1</span><br>            self.cnt -= <span class="hljs-number">1</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flip</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 翻转了</span><br>        <span class="hljs-keyword">if</span> self.filp_status == <span class="hljs-number">0</span>:<br>            self.filp_status = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            self.filp_status = <span class="hljs-number">0</span><br>        self.cnt = <span class="hljs-built_in">len</span>(self.bs) - self.cnt<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">all</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cnt == <span class="hljs-built_in">len</span>(self.bs):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">one</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cnt &gt;= <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.cnt<br>        <br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.filp_status == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">str</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.bs])<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join([<span class="hljs-built_in">str</span>(<span class="hljs-built_in">abs</span>(<span class="hljs-number">1</span>-x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> self.bs])<br><br><span class="hljs-comment"># Your Bitset object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Bitset(size)</span><br><span class="hljs-comment"># obj.fix(idx)</span><br><span class="hljs-comment"># obj.unfix(idx)</span><br><span class="hljs-comment"># obj.flip()</span><br><span class="hljs-comment"># param_4 = obj.all()</span><br><span class="hljs-comment"># param_5 = obj.one()</span><br><span class="hljs-comment"># param_6 = obj.count()</span><br><span class="hljs-comment"># param_7 = obj.toString()</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>设计</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>277场LeetCode周赛</title>
    <link href="/2022/01/23/algorithms/leetcode-weekly-contest/277%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/23/algorithms/leetcode-weekly-contest/277%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>在大佬们的帮助下第一次周赛ak并进了前1000名还是很开心的hhh，前三个题是有史以来见过最水的周赛题，感觉全是easy难度的，最后一个题学习到了位运算的暴力遍历思路，而且还有一个题目特有的思想是只需要考虑说真话的人就行了，因为假的说话怎么都是有可能的，于是在假定所有说真话的人判断是否和条件有冲突就可以了。</p><p>另外突然感觉这次题目的前三题描述都好简单啊，喜欢这样的题，搞直接点行不行hhh</p><p>第一题：排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了；</p><p>第二题：自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了；</p><p>第三题：mapping就能解决，这种题还是很好想到mapping（哈希表）的；</p><p>第四题：感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了；</p><span id="more"></span><p><img src="/images/2022-01-24-00-09-08.png"></p><h1 id="第一题：5989-元素计数"><a href="#第一题：5989-元素计数" class="headerlink" title="第一题：5989.元素计数"></a>第一题：5989.元素计数</h1><p><a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> ，统计并返回在 <code>nums</code> 中同时具有一个严格较小元素和一个严格较大元素的元素数目。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [11,7,2,15]<br>输出：2<br>解释：元素<span class="hljs-number"> 7 </span>：严格较小元素是元素<span class="hljs-number"> 2 </span>，严格较大元素是元素<span class="hljs-number"> 11 </span>。<br>元素<span class="hljs-number"> 11 </span>：严格较小元素是元素<span class="hljs-number"> 7 </span>，严格较大元素是元素<span class="hljs-number"> 15 </span>。<br>总计有<span class="hljs-number"> 2 </span>个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [-3,3,3,90]<br>输出：2<br>解释：元素<span class="hljs-number"> 3 </span>：严格较小元素是元素 -3 ，严格较大元素是元素<span class="hljs-number"> 90 </span>。<br>由于有两个元素的值为<span class="hljs-number"> 3 </span>，总计有<span class="hljs-number"> 2 </span>个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">countElements</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cnt = <span class="hljs-number">0</span><br>        nums.sort()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; nums[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> nums[-<span class="hljs-number">1</span>] &gt; nums[i]:<br>                cnt += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第二题：5991-按符号重排数组"><a href="#第二题：5991-按符号重排数组" class="headerlink" title="第二题：5991.按符号重排数组"></a>第二题：5991.按符号重排数组</h1><p><a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，数组长度为 <strong>偶数</strong> ，由数目相等的正整数和负整数组成。</p><p>你需要 <strong>重排</strong> <code>nums</code> 中的元素，使修改后的数组满足下述条件：</p><ol><li>任意 <strong>连续</strong> 的两个整数 <strong>符号相反</strong></li><li>对于符号相同的所有整数，<strong>保留</strong> 它们在 <code>nums</code> 中的 <strong>顺序</strong> 。</li><li>重排后数组以正整数开头。</li></ol><p>重排元素满足上述条件后，返回修改后的数组。</p><p>示例1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [3,1,<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]<br>输出：[3,<span class="hljs-string">-2</span>,1,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]<br>解释：<br>nums 中的正整数是 [3,1,2] ，负整数是 [<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,<span class="hljs-string">-4</span>] 。<br>重排的唯一可行方案是 [3,<span class="hljs-string">-2</span>,1,<span class="hljs-string">-5</span>,2,<span class="hljs-string">-4</span>]，能满足所有条件。<br>像 [1,<span class="hljs-string">-2</span>,2,<span class="hljs-string">-5</span>,3,<span class="hljs-string">-4</span>]、[3,1,2,<span class="hljs-string">-2</span>,<span class="hljs-string">-5</span>,<span class="hljs-string">-4</span>]、[<span class="hljs-string">-2</span>,3,<span class="hljs-string">-5</span>,1,<span class="hljs-string">-4</span>,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 <br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,1]<br>输出：[1,<span class="hljs-string">-1</span>]<br>解释：<br>1 是 nums 中唯一一个正整数，<span class="hljs-string">-1</span> 是 nums 中唯一一个负整数。<br>所以 nums 重排为 [1,<span class="hljs-string">-1</span>] 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 2 * 105</code></li><li><code>nums.length</code> 是 <strong>偶数</strong></li><li><code>1 &lt;= |nums[i]| &lt;= 105</code></li><li><code>nums</code> 由 <strong>相等</strong> 数量的正整数和负整数组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rearrangeArray</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        nums_positive = []<br>        nums_negative = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> nums[i]  &gt; <span class="hljs-number">0</span>:<br>                nums_positive.append(nums[i])<br>            <span class="hljs-keyword">else</span>:<br>                nums_negative.append(nums[i])<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums_positive)):<br>            result.append(nums_positive[i])<br>            result.append(nums_negative[i])<br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第三题：5990-找出数组中的所有孤独数字"><a href="#第三题：5990-找出数组中的所有孤独数字" class="headerlink" title="第三题：5990.找出数组中的所有孤独数字"></a>第三题：5990.找出数组中的所有孤独数字</h1><p><a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 。如果数字 <code>x</code> 在数组中仅出现 <strong>一次</strong> ，且没有 <strong>相邻</strong> 数字（即，<code>x + 1</code> 和 <code>x - 1</code>）出现在数组中，则认为数字 <code>x</code> 是 <strong>孤独数字</strong> 。</p><p>返回 <code>nums</code> 中的 <strong>所有</strong> 孤独数字。你可以按 <strong>任何顺序</strong> 返回答案。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [10,6,5,8]<br>输出：[10,8]<br>解释：<br>-<span class="hljs-number"> 10 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 9 </span>和<span class="hljs-number"> 11 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 8 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 7 </span>和<span class="hljs-number"> 9 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 5 </span>不是一个孤独数字，因为<span class="hljs-number"> 6 </span>出现在 nums 中，反之亦然。<br>因此，nums 中的孤独数字是 [10, 8] 。<br>注意，也可以返回 [8, 10] 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,3,5,3]<br>输出：[1,5]<br>解释：<br>-<span class="hljs-number"> 1 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 5 </span>是一个孤独数字，因为它只出现一次，并且<span class="hljs-number"> 4 </span>和<span class="hljs-number"> 6 </span>没有在 nums 中出现。<br>-<span class="hljs-number"> 3 </span>不是一个孤独数字，因为它出现两次。<br>因此，nums 中的孤独数字是 [1, 5] 。<br>注意，也可以返回 [5, 1] 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>mapping就能解决，这种题还是很好想到mapping（哈希表）的；也或许题目中的任何顺序暗示了可以排序和mapping做吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findLonely</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = []<br>        mappings = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> mappings.get(nums[i]) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                mappings[nums[i]] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                mappings[nums[i]] += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mappings.items():<br>            <span class="hljs-comment"># 把孤独的加进来，用key</span><br>            <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> mappings.get(key-<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> mappings.get(key+<span class="hljs-number">1</span>) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                result.append(key)<br>        <br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第四题：5992-基于陈述统计最多好人数"><a href="#第四题：5992-基于陈述统计最多好人数" class="headerlink" title="第四题：5992.基于陈述统计最多好人数"></a>第四题：5992.基于陈述统计最多好人数</h1><p><a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>戏中存在两种角色：</p><ul><li><strong>好人</strong>：该角色只说真话。</li><li><strong>坏人</strong>：该角色可能说真话，也可能说假话。</li></ul><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>statements</code> ，大小为 <code>n x n</code> ，表示 <code>n</code> 个玩家对彼此角色的陈述。具体来说，<code>statements[i][j]</code> 可以是下述值之一：</p><ul><li><code>0</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>坏人</strong> 。</li><li><code>1</code> 表示 <code>i</code> 的陈述认为 <code>j</code> 是 <strong>好人</strong> 。</li><li><code>2</code> 表示 <code>i</code> 没有对 <code>j</code> 作出陈述。</li></ul><p>另外，玩家不会对自己进行陈述。形式上，对所有 <code>0 &lt;= i &lt; n</code> ，都有 <code>statements[i][i] = 2</code> 。</p><p>根据这 <code>n</code> 个玩家的陈述，返回可以认为是 <strong>好人</strong> 的 <strong>最大</strong> 数目。</p><p>示例1：<br><img src="/images/2022-01-24-00-43-36.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：statements = [[2,1,2],[1,2,2],[2,0,2]]<br>输出：2<br>解释：每个人都做一条陈述。<br>-<span class="hljs-number"> 0 </span>认为<span class="hljs-number"> 1 </span>是好人。<br>-<span class="hljs-number"> 1 </span>认为<span class="hljs-number"> 0 </span>是好人。<br>-<span class="hljs-number"> 2 </span>认为<span class="hljs-number"> 1 </span>是坏人。<br>以<span class="hljs-number"> 2 </span>为突破点。<br>- 假设<span class="hljs-number"> 2 </span>是一个好人：<br>    - 基于<span class="hljs-number"> 2 </span>的陈述，1 是坏人。<br>    - 那么可以确认<span class="hljs-number"> 1 </span>是坏人，2 是好人。<br>    - 基于<span class="hljs-number"> 1 </span>的陈述，由于<span class="hljs-number"> 1 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下会出现矛盾，所以假设无效。<br>        - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。<br>    - 在认为<span class="hljs-number"> 2 </span>是好人的情况下，这组玩家中只有一个好人。<br>- 假设<span class="hljs-number"> 2 </span>是一个坏人：<br>    - 基于<span class="hljs-number"> 2 </span>的陈述，由于<span class="hljs-number"> 2 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下，0 和<span class="hljs-number"> 1 </span>都是坏人。<br>            - 在认为<span class="hljs-number"> 2 </span>是坏人但说真话的情况下，这组玩家中没有一个好人。<br>        - 说假话。在这种情况下，1 是好人。<br>            - 由于<span class="hljs-number"> 1 </span>是好人，0 也是好人。<br>            - 在认为<span class="hljs-number"> 2 </span>是坏人且说假话的情况下，这组玩家中有两个好人。<br>在最佳情况下，至多有两个好人，所以返回<span class="hljs-number"> 2 </span>。<br>注意，能得到此结论的方法不止一种。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-01-24-00-43-46.png"></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：statements = [[2,0],[0,2]]<br>输出：1<br>解释：每个人都做一条陈述。<br>-<span class="hljs-number"> 0 </span>认为<span class="hljs-number"> 1 </span>是坏人。<br>-<span class="hljs-number"> 1 </span>认为<span class="hljs-number"> 0 </span>是坏人。<br>以<span class="hljs-number"> 0 </span>为突破点。<br>- 假设<span class="hljs-number"> 0 </span>是一个好人：<br>    - 基于与<span class="hljs-number"> 0 </span>的陈述，1 是坏人并说假话。<br>    - 在认为<span class="hljs-number"> 0 </span>是好人的情况下，这组玩家中只有一个好人。<br>- 假设<span class="hljs-number"> 0 </span>是一个坏人：<br>    - 基于<span class="hljs-number"> 0 </span>的陈述，由于<span class="hljs-number"> 0 </span>是坏人，那么他在陈述时可能：<br>        - 说真话。在这种情况下，0 和<span class="hljs-number"> 1 </span>都是坏人。<br>            - 在认为<span class="hljs-number"> 0 </span>是坏人但说真话的情况下，这组玩家中没有一个好人。<br>        - 说假话。在这种情况下，1 是好人。<br>            - 在认为<span class="hljs-number"> 0 </span>是坏人且说假话的情况下，这组玩家中只有一个好人。<br>在最佳情况下，至多有一个好人，所以返回<span class="hljs-number"> 1 </span>。 <br>注意，能得到此结论的方法不止一种。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == statements.length == statements[i].length</code></li><li><code>2 &lt;= n &lt;= 15</code></li><li><code>statements[i][j]</code> 的值为 <code>0</code>、<code>1</code> 或 <code>2</code></li><li><code>statements[i][i] == 2</code></li></ul><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maximumGood</span>(<span class="hljs-params">self, statements</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type statements: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        max_good_people = <span class="hljs-number">0</span><br>        n = <span class="hljs-built_in">len</span>(statements)<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge</span>(<span class="hljs-params">state, statements</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(state)):<br>                <span class="hljs-keyword">if</span> state[i] == <span class="hljs-number">1</span>:  <span class="hljs-comment"># 只判断是好人的情况</span><br>                    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                        <span class="hljs-keyword">if</span> i == j:<br>                            <span class="hljs-keyword">continue</span><br>                        <span class="hljs-keyword">if</span> statements[i][j] == <span class="hljs-number">2</span>:<br>                            <span class="hljs-keyword">continue</span><br>                        <span class="hljs-keyword">if</span> statements[i][j] != state[j]:<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>        <br>        <span class="hljs-comment"># 学到了，2^n种状态，用位运算遍历</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((<span class="hljs-number">2</span> ** n) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            now_good = <span class="hljs-number">0</span><br>            tmp = i<br>            state = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>            cnt = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">while</span> tmp &gt; <span class="hljs-number">0</span>:<br>                state[cnt] = tmp &amp; <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> state[cnt] == <span class="hljs-number">1</span>:<br>                    now_good += <span class="hljs-number">1</span><br>                tmp &gt;&gt;= <span class="hljs-number">1</span><br>                cnt += <span class="hljs-number">1</span><br>            flag = judge(state, statements)<br>            <span class="hljs-keyword">if</span> flag:<br>                max_good_people = <span class="hljs-built_in">max</span>(max_good_people, now_good)<br>        <br>        <span class="hljs-keyword">return</span> max_good_people<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
      <tag>HARD</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
      <tag>回溯</tag>
      
      <tag>计数</tag>
      
      <tag>枚举</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70场LeetCode双周赛</title>
    <link href="/2022/01/23/algorithms/leetcode-weekly-contest/70%E5%9C%BALeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/23/algorithms/leetcode-weekly-contest/70%E5%9C%BALeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>不常做双周赛的题目hhh，这次的bfs走迷宫一类的题目还是让人印象很深的，简单的dfs bfs模板还是要熟练些，这种题还是比全排列的那种深度优先更让人好理解一些；</p><p>第一题：贪心就可以，排个序后每买两个不买一个；</p><p>第二题：这个隐藏数组题目在时间复杂度上还是被坑了一下的，如果不看示例自己在TLE后能不能想到还是个问题，对于首位序列lower upper的问题，从示例总结出来的“对齐”思路很关键；</p><p>第三题：一个标准的bfs题目模板，题目给的排序约束条件既可以按照自己的方法先都走完后再拿出来排，也可能可以作为优先队列的约束条件，还要注意题目的step其实暗示了bfs而不是dfs；</p><p>第四题：咕咕咕</p><span id="more"></span><h1 id="第一题：5971-打折购买糖果的最小开销"><a href="#第一题：5971-打折购买糖果的最小开销" class="headerlink" title="第一题：5971.打折购买糖果的最小开销"></a>第一题：5971.打折购买糖果的最小开销</h1><p><a href="https://leetcode-cn.com/problems/minimum-cost-of-buying-candies-with-discount/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>一家商店正在打折销售糖果。每购买 <strong>两个</strong> 糖果，商店会 <strong>免费</strong> 送一个糖果。</p><p>免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 <strong>较小值</strong> 。</p><ul><li>比方说，总共有<code>4</code>个糖果，价格分别为<code>1</code>，<code>2</code>，<code>3</code>和<code>4</code>，一位顾客买了价格为<code>2</code>和<code>3</code>的糖果，那么他可以免费获得价格为<code>1</code>的糖果，但不能获得价格为<code>4</code>的糖果。</li></ul><p>给你一个下标从 <strong>0</strong> 开始的整数数组<code>cost</code>，其中<code>cost[i]</code>表示第<code>i</code>个糖果的价格，请你返回获得 <strong>所有</strong> 糖果的 <strong>最小</strong> 总开销。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [1,2,3]<br>输出：5<br>解释：我们购买价格为<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>的糖果，然后免费获得价格为<span class="hljs-number"> 1 </span>的糖果。<br>总开销为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 5 </span>。这是开销最小的 唯一 方案。<br>注意，我们不能购买价格为<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 3 </span>的糖果，并免费获得价格为<span class="hljs-number"> 2 </span>的糖果。<br>这是因为免费糖果的价格必须小于等于购买的<span class="hljs-number"> 2 </span>个糖果价格的较小值。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [6,5,7,9,2,2]<br>输出：23<br>解释：最小总开销购买糖果方案为：<br>- 购买价格为<span class="hljs-number"> 9 </span>和<span class="hljs-number"> 7 </span>的糖果<br>- 免费获得价格为<span class="hljs-number"> 6 </span>的糖果<br>- 购买价格为<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 2 </span>的糖果<br>- 免费获得价格为<span class="hljs-number"> 2 </span>的最后一个糖果<br>因此，最小总开销为<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 7 </span>+<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 23 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：cost = [5,5]<br>输出：10<br>解释：由于只有<span class="hljs-number"> 2 </span>个糖果，我们需要将它们都购买，而且没有免费糖果。<br>所以总最小开销为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= cost.length &lt;= 100</code></li><li><code>1 &lt;= cost[i] &lt;= 100</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>贪！ 排序后贪心就可以了，记得写的时候对于这个continue的位置还纠结了下，不过复盘来说应该会有不少种写法的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minimumCost</span>(<span class="hljs-params">self, cost</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type cost: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        cost = <span class="hljs-built_in">sorted</span>(cost, key=<span class="hljs-keyword">lambda</span> x: -x)<br>        cnt = <span class="hljs-number">0</span><br>        result = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(cost)):<br>            <span class="hljs-keyword">if</span> cnt != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> cnt % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                cnt = <span class="hljs-number">0</span><br>                <span class="hljs-keyword">continue</span><br>            result += cost[i]<br>            cnt += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第二题：5972-统计隐藏数组数目"><a href="#第二题：5972-统计隐藏数组数目" class="headerlink" title="第二题：5972.统计隐藏数组数目"></a>第二题：5972.统计隐藏数组数目</h1><p><a href="https://leetcode-cn.com/problems/count-the-hidden-sequences/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始且长度为 <code>n</code> 的整数数组 <code>differences</code> ，它表示一个长度为 <code>n + 1</code> 的 <strong>隐藏</strong> 数组 <strong>相邻</strong> 元素之间的 <strong>差值</strong> 。更正式的表述为：我们将隐藏数组记作 <code>hidden</code> ，那么 <code>differences[i] = hidden[i + 1] - hidden[i]</code> 。</p><p>同时给你两个整数 <code>lower</code> 和 <code>upper</code> ，它们表示隐藏数组中所有数字的值都在 闭 区间 <code>[lower, upper]</code> 之间。</p><ul><li>比方说，<code>differences = [1, -3, 4]</code> ，<code>lower = 1</code> ，<code>upper = 6</code> ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。<ul><li><code>[3, 4, 1, 5]</code> 和 <code>[4, 5, 2, 6]</code> 都是符合要求的隐藏数组。</li><li><code>[5, 6, 3, 7]</code> 不符合要求，因为它包含大于 6 的元素。</li><li><code>[1, 2, 3, 4]</code> 不符合要求，因为相邻元素的差值不符合给定数据。</li></ul></li></ul><p>请你返回 <strong>符合</strong> 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。</p><p>示例1：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stan">输入：differences = [<span class="hljs-number">1</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-keyword">lower</span> = <span class="hljs-number">1</span>, <span class="hljs-keyword">upper</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">2</span><br>解释：符合要求的隐藏数组为：<br>- [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>]<br>- [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>]<br>所以返回 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：differences = [3,<span class="hljs-string">-4</span>,5,1,<span class="hljs-string">-2</span>], lower = <span class="hljs-string">-4</span>, upper = 5<br>输出：4<br>解释：符合要求的隐藏数组为：<br>- [<span class="hljs-string">-3</span>, 0, <span class="hljs-string">-4</span>, 1, 2, 0]<br>- [<span class="hljs-string">-2</span>, 1, <span class="hljs-string">-3</span>, 2, 3, 1]<br>- [<span class="hljs-string">-1</span>, 2, <span class="hljs-string">-2</span>, 3, 4, 2]<br>- [0, 3, <span class="hljs-string">-1</span>, 4, 5, 3]<br>所以返回 4 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stan">输入：differences = [<span class="hljs-number">4</span>,-<span class="hljs-number">7</span>,<span class="hljs-number">2</span>], <span class="hljs-keyword">lower</span> = <span class="hljs-number">3</span>, <span class="hljs-keyword">upper</span> = <span class="hljs-number">6</span><br>输出：<span class="hljs-number">0</span><br>解释：没有符合要求的隐藏数组，所以返回 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; differences.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 105</li><li>-105 &lt;&#x3D; differences[i] &lt;&#x3D; 105</li><li>-105 &lt;&#x3D; lower &lt;&#x3D; upper &lt;&#x3D; 105</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始想到的是一种从lower开始全部遍历的策略，但是很容易的就超时了，后来从示例2发现可以使用一种“数学”方法，复盘认为最关键的内容就是要使用一种“对齐”的思想，这样就避免了把两边的情况都考虑上，只考虑一边就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfArrays</span>(<span class="hljs-params">self, differences, lower, upper</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type differences: List[int]</span><br><span class="hljs-string">        :type lower: int</span><br><span class="hljs-string">        :type upper: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # 看了一个示例后，感觉只算一遍，然后算一个max low就可以了吧</span><br><span class="hljs-string">        result = 0</span><br><span class="hljs-string">        for start_idx in range(lower, upper+1):</span><br><span class="hljs-string">            tmp_start_idx = start_idx</span><br><span class="hljs-string">            flag = True</span><br><span class="hljs-string">            for i in range(len(differences)):</span><br><span class="hljs-string">                tmp_start_idx += differences[i]</span><br><span class="hljs-string">                if not (tmp_start_idx &lt;= upper and tmp_start_idx &gt;= lower):</span><br><span class="hljs-string">                    flag = False </span><br><span class="hljs-string">                    break</span><br><span class="hljs-string">            if flag:</span><br><span class="hljs-string">                result += 1</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        return result</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = <span class="hljs-number">0</span><br>        tmp_start_idx = lower<br>        seq_max = lower<br>        seq_min = lower<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(differences)):<br>            tmp_start_idx += differences[i]<br>            seq_max = <span class="hljs-built_in">max</span>(seq_max, tmp_start_idx)<br>            seq_min = <span class="hljs-built_in">min</span>(seq_min, tmp_start_idx)<br><span class="hljs-comment">#         print(&quot;seq_max: &quot;, seq_max)</span><br><span class="hljs-comment">#         print(&quot;seq_min: &quot;, seq_min)</span><br><br>        d1 = upper - seq_max<br>        d2 = seq_min - lower<br>        <br>        <span class="hljs-comment"># 3种情况</span><br>        seq_max = seq_max + (lower - seq_min)<br>        seq_min = lower<br>        <br>        <span class="hljs-comment"># print(&quot;seq_max: &quot;, seq_max)</span><br>        <span class="hljs-comment"># print(&quot;seq_min: &quot;, seq_min)</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, upper - seq_max + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h1 id="第三题：5973-价格范围内最高排名的-K-样物品"><a href="#第三题：5973-价格范围内最高排名的-K-样物品" class="headerlink" title="第三题：5973.价格范围内最高排名的 K 样物品"></a>第三题：5973.价格范围内最高排名的 K 样物品</h1><p><a href="https://leetcode-cn.com/problems/k-highest-ranked-items-within-a-price-range/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>grid</code> ，它的大小为 <code>m x n</code> ，表示一个商店中物品的分布图。数组中的整数含义为：</p><ul><li><code>0</code> 表示无法穿越的一堵墙。</li><li><code>1</code> 表示可以自由通过的一个空格子。</li><li>所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。</li></ul><p>从一个格子走到上下左右相邻格子花费 <code>1</code> 步。</p><p>同时给你一个整数数组 <code>pricing</code> 和 <code>start</code> ，其中 <code>pricing = [low, high]</code> 且 <code>start = [row, col]</code> ，表示你开始位置为 <code>(row, col)</code> ，同时你只对物品价格在 闭区间 <code>[low, high]</code> 之内的物品感兴趣。同时给你一个整数 <code>k</code> 。</p><p>你想知道给定范围 <strong>内</strong> 且 <strong>排名最高</strong> 的 <code>k</code> 件物品的 <strong>位置</strong> 。排名按照优先级从高到低的以下规则制定：</p><ol><li>距离：定义为从 <code>start</code> 到一件物品的最短路径需要的步数（<strong>较近</strong> 距离的排名更高）。</li><li>价格：<strong>较低</strong> 价格的物品有更高优先级，但只考虑在给定范围之内的价格。</li><li>行坐标：<strong>较小</strong> 行坐标的有更高优先级。</li><li>列坐标：<strong>较小</strong> 列坐标的有更高优先级。</li></ol><p>请你返回给定价格内排名最高的 <code>k</code> 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 <code>k</code> 件物品，那么请将它们的坐标 <strong>全部</strong> 返回。</p><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>bfs的一个基础模板题，在写的时候先用了dfs结果超时了。复盘分析为什么使用bfs的原因，bfs可以保证每个地方step是一定递增1的，而不像dfs可能一个位置有多种走法。</p><p>后来看题解来说这个题实际上背后可能隐藏的是优先队列的思路，但是这块的内容确实还不太熟悉，什么时候先复习下大根堆小根堆的内容吧，滑动窗口那道hard题</p><h3 id="bfs正确题解代码49-x2F-49"><a href="#bfs正确题解代码49-x2F-49" class="headerlink" title="bfs正确题解代码49&#x2F;49"></a>bfs正确题解代码49&#x2F;49</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">highestRankedKItems</span>(<span class="hljs-params">self, grid, pricing, start, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type pricing: List[int]</span><br><span class="hljs-string">        :type start: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 过一个异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        <span class="hljs-comment"># 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <br>        x = start[<span class="hljs-number">0</span>]<br>        y = start[<span class="hljs-number">1</span>]<br>        vis[x][y] = <span class="hljs-number">1</span><br>        bfs_queue = []<br>        bfs_queue.append([x, y, <span class="hljs-number">0</span>, grid[x][y]])<br>        result = []<br>        <br>        <span class="hljs-comment"># 使用bfs的思路</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(bfs_queue) != <span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># 取队头并pop</span><br>            now_x, now_y, now_step, now_value = bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], bfs_queue[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>]<br>            <span class="hljs-keyword">if</span> now_value &gt;= pricing[<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> now_value &lt;= pricing[<span class="hljs-number">1</span>]:<br>                result.append(bfs_queue[<span class="hljs-number">0</span>])<br>            bfs_queue = bfs_queue[<span class="hljs-number">1</span>:]<br>            <br>            <span class="hljs-comment"># 把四个方向满足条件的加入到队列中</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = now_x + dx[i]<br>                ny = now_y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; m <span class="hljs-keyword">and</span> ny &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> vis[nx][ny] == <span class="hljs-number">0</span>:<br>                    vis[nx][ny] = <span class="hljs-number">1</span><br>                    bfs_queue.append([nx, ny, now_step+<span class="hljs-number">1</span>, grid[nx][ny]])<br>        <br>        <br>        <span class="hljs-comment"># dfs(x, y, 0)</span><br>        result.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">2</span>], x[<span class="hljs-number">3</span>], x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) &gt; k:<br>            <span class="hljs-keyword">return</span> [[result[x][<span class="hljs-number">0</span>], result[x][<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [[x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result]         <br></code></pre></td></tr></table></figure><h3 id="dfs超时版本题解代码15-x2F-49"><a href="#dfs超时版本题解代码15-x2F-49" class="headerlink" title="dfs超时版本题解代码15&#x2F;49"></a>dfs超时版本题解代码15&#x2F;49</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">highestRankedKItems</span>(<span class="hljs-params">self, grid, pricing, start, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :type pricing: List[int]</span><br><span class="hljs-string">        :type start: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 过一个异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(grid) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> []<br>        <br>        <span class="hljs-comment"># 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        vis = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        dx = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>        dy = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>        <br>        x = start[<span class="hljs-number">0</span>]<br>        y = start[<span class="hljs-number">1</span>]<br>        vis[x][y] = <span class="hljs-number">1</span><br>        <br>        result = []<br>        mappings = &#123;&#125;<br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y, step</span>):<br>            <span class="hljs-keyword">if</span> grid[x][y] &lt;= pricing[<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> grid[x][y] &gt;= pricing[<span class="hljs-number">0</span>]:<br>                <span class="hljs-keyword">if</span> mappings.get((x, y)) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                    mappings[(x, y)] = [step, grid[x][y]]<br>                <span class="hljs-keyword">else</span>:<br>                    tmp_list = mappings[(x, y)]<br>                    <span class="hljs-keyword">if</span> step &lt; tmp_list[<span class="hljs-number">0</span>]:<br>                        mappings[(x, y)] = [step, grid[x][y]]<br>                <br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> nx &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nx &lt; m <span class="hljs-keyword">and</span> ny &gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ny &lt; n <span class="hljs-keyword">and</span> grid[nx][ny] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> vis[nx][ny] == <span class="hljs-number">0</span>:<br>                    vis[nx][ny] = <span class="hljs-number">1</span><br>                    dfs(nx, ny, step+<span class="hljs-number">1</span>)<br>                    vis[nx][ny] = <span class="hljs-number">0</span><br>        <br>        dfs(x, y, <span class="hljs-number">0</span>)<br>        <br>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> mappings.items():            <br>            result.append([key[<span class="hljs-number">0</span>], key[<span class="hljs-number">1</span>], value[<span class="hljs-number">0</span>], value[<span class="hljs-number">1</span>]])<br>        <br>        <br>        result.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">2</span>], x[<span class="hljs-number">3</span>], x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]))<br>        <br>        <span class="hljs-comment"># print(result)</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(result) &gt; k:<br>            <span class="hljs-keyword">return</span> [[result[x][<span class="hljs-number">0</span>], result[x][<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k)]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> [[x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>]] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>219.存在重复元素II-python</title>
    <link href="/2022/01/20/algorithms/leetcode-python/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II-python/"/>
    <url>/2022/01/20/algorithms/leetcode-python/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II-python/</url>
    
    <content type="html"><![CDATA[<p>219.存在重复元素II（简单）</p><p>题目大意：</p><p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，判断数组中是否存在两个<strong>不同的索引</strong><code>i</code>和<code>j</code>，满足<code>nums[i] == nums[j]</code>且<code>abs(i - j) &lt;= k</code>。如果存在，返回<code>true</code>；否则，返回<code>false</code>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">题目链接</a></p><p>题目大意：</p><p>给你一个整数数组<code>nums</code>和一个整数<code>k</code>，判断数组中是否存在两个<strong>不同的索引</strong><code>i</code>和<code>j</code>，满足<code>nums[i] == nums[j]</code>且<code>abs(i - j) &lt;= k</code>。如果存在，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">1</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">k</span> = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 105</li><li>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109</li><li>0 &lt;&#x3D; k &lt;&#x3D; 105</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>用一个字典判断就行，这样每次更新最后出现的状态，O(n)时间复杂度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">containsNearbyDuplicate</span>(<span class="hljs-params">self, nums, k</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        temp_dict = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">if</span> temp_dict.get(nums[i]) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">if</span> i - temp_dict.get(nums[i]) &lt;= k:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            temp_dict[nums[i]] = i  <span class="hljs-comment"># 每次强制更新为最后的，这样方便找最近的</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>160.相交链表-python</title>
    <link href="/2022/01/17/algorithms/leetcode-python/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/01/17/algorithms/leetcode-python/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>160.相交链表（简单）</p><p>题目大意：</p><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p>进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a></p><p>给你两个单链表的头节点<code>headA</code>和<code>headB</code>，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回<code>null</code>。</p><p>图示两个链表在节点<code>c1</code>开始相交：</p><p><img src="/images/2022-01-17-16-20-00.png"></p><p>题目数据 保证 整个链式结构中不存在环。</p><p>注意，函数返回结果后，链表必须 保持其原始结构 。</p><p>自定义评测：</p><p>评测系统 的输入如下（你设计的程序 不适用 此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为<code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在<code>listA</code>中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在<code>listB</code>中（从头节点开始）跳到交叉节点的节点数</li></ul><p>评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。</p><p>示例1：<br><img src="/images/2022-01-17-16-28-41.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：intersectVal = <span class="hljs-number">8</span>, listA = [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>], listB = [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">2</span>, skipB = <span class="hljs-number">3</span><br>输出：Intersected at &#x27;<span class="hljs-number">8</span>&#x27;<br>解释：相交节点的值为 <span class="hljs-number">8</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-keyword">A</span> 为 [<span class="hljs-number">4,1,8,4</span>,<span class="hljs-number">5</span>]，链表 B 为 [<span class="hljs-number">5,6,1,8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]。<br>在 <span class="hljs-keyword">A</span> 中，相交节点前有 <span class="hljs-number">2</span> 个节点；在 B 中，相交节点前有 <span class="hljs-number">3</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-01-17-16-28-58.png"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：intersectVal = <span class="hljs-number">2</span>, listA = [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">1</span><br>输出：<span class="hljs-symbol">Intersected</span> at <span class="hljs-string">&#x27;2&#x27;</span><br>解释：相交节点的值为 <span class="hljs-number">2</span> （注意，如果两个链表相交则不能为 <span class="hljs-number">0</span>）。<br>从各自的表头开始算起，链表 <span class="hljs-symbol">A</span> 为 [<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]，链表 <span class="hljs-symbol">B</span> 为 [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]。<br>在 <span class="hljs-symbol">A</span> 中，相交节点前有 <span class="hljs-number">3</span> 个节点；在 <span class="hljs-symbol">B</span> 中，相交节点前有 <span class="hljs-number">1</span> 个节点。<br></code></pre></td></tr></table></figure><p>示例3：<br><img src="/images/2022-01-17-16-29-05.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：<span class="hljs-built_in">int</span>ersectVal = <span class="hljs-number">0</span>, listA = [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>], listB = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>], skipA = <span class="hljs-number">3</span>, skipB = <span class="hljs-number">2</span><br>输出：<span class="hljs-literal">null</span><br>解释：从各自的表头开始算起，链表 A 为 [<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>]，链表 B 为 [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>]。<br>由于这两个链表不相交，所以 <span class="hljs-built_in">int</span>ersectVal 必须为 <span class="hljs-number">0</span>，而 skipA 和 skipB 可以是任意值。<br>这两个链表不相交，因此返回 <span class="hljs-literal">null</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>listA</code>中节点数目为<code>m</code></li><li><code>listB</code>中节点数目为<code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 104</code></li><li><code>1 &lt;= Node.val &lt;= 105</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果<code>listA</code>和<code>listB</code>没有交点，<code>intersectVal</code>为<code>0</code></li><li>如果<code>listA</code>和<code>listB</code>有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在面试的时候曾经被问过，判断两个链表是否有交有很多种方法，如果只是判断是否有交的话，最简单的方法就是两个链表都分别走到结尾处，如果结尾处是一样的，那么就判断两个链表在之前一定有交了；</p><p>这个题要求判断并找到两个链表相交的位置，一种非常简单的思路是把每个地方都存到一个字典里，这样找一下就行了，但是题目的附加要求是O(1)的时间复杂度，所以说不能这么做；</p><p>下边这个图也是看了题解后才明白的，这样最多走a+b这个长度的次数，两个走的长度是一样的，如果有交集则必定能相交！</p><p><img src="/images/2022-01-17-16-16-56.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">getIntersectionNode</span>(<span class="hljs-params">self, headA, headB</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head1, head1: ListNode</span><br><span class="hljs-string">        :rtype: ListNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> headA <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> headB <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 循环结束的两种条件，一种是pq交到一个位置了，另外一种就是pq都是null，所以都是</span><br>        <span class="hljs-comment"># 只走一遍就可以了，a+b的长度</span><br>        p = headA<br>        q = headB<br>        <span class="hljs-keyword">while</span> p != q:<br>            <span class="hljs-keyword">if</span> p <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                p = headB<br>            <span class="hljs-keyword">else</span>:<br>                p = p.<span class="hljs-built_in">next</span><br>            <span class="hljs-keyword">if</span> q <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                q = headA<br>            <span class="hljs-keyword">else</span>:<br>                q = q.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> p<br></code></pre></td></tr></table></figure><p>复习单链表的一个写法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>136.只出现一次的数字-python</title>
    <link href="/2022/01/17/algorithms/leetcode-python/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-python/"/>
    <url>/2022/01/17/algorithms/leetcode-python/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-python/</url>
    
    <content type="html"><![CDATA[<p>136.只出现一次的数字（简单）</p><p>题目大意：</p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong>：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/single-number/">题目链接</a></p><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><strong>说明</strong>：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>简单的位运算题目，因为题目说了其余每个元素都出现了两次，所以用xor就行了，真值表上异是1，同是0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">singleNumber</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        return_num = nums[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            return_num ^= nums[i]  <span class="hljs-comment"># 异或</span><br>        <br>        <span class="hljs-keyword">return</span> return_num<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>104.二叉树的最大深度-python</title>
    <link href="/2022/01/16/algorithms/leetcode-python/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-python/"/>
    <url>/2022/01/16/algorithms/leetcode-python/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-python/</url>
    
    <content type="html"><![CDATA[<p>104.二叉树的最大深度（简单）</p><p>题目大意：</p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">题目链接</a></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树<code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度3。</p><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>这个题是一个典型的”自递归“系列的题目，首先复习一下树节点的写法（建议每个二叉树的题目都复习一下）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=-<span class="hljs-number">1</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>复习Solution的写法和题解，注意这个maxDepth函数，他的返回值是一个int，代表直接调用这个函数就要得到最终答案的depth返回值，所以感觉是一个自递归的题目了，这种的递归dfs还是很好写的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, root</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(self.maxDepth(root.left), self.maxDepth(root.right))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>275场LeetCode周赛</title>
    <link href="/2022/01/16/algorithms/leetcode-weekly-contest/275%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/16/algorithms/leetcode-weekly-contest/275%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前两个题实际上说感觉还没有那么容易想，第三个题的话感觉简化的思路是需要复盘梳理的，另外只能说Counter永远的神哈哈哈哈</p><p>第一题：这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用<code>matrix[i]</code>，而取矩阵的某一列没有什么很好的思路，可以用<code>[matrix[x][j] for x in range(n)]</code>，这里的<code>j</code>代表第<code>j</code>列；</p><p>第二题：比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可；</p><p>第三题：只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set&#x2F;dict&#x2F;Counter中，这样可以O(1)的判断是否存在；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：2133-检查是否每一行每一列都包含全部整数"><a href="#第一题：2133-检查是否每一行每一列都包含全部整数" class="headerlink" title="第一题：2133.检查是否每一行每一列都包含全部整数"></a>第一题：2133.检查是否每一行每一列都包含全部整数</h1><p><a href="https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>对一个大小为<code>n x n</code>的矩阵而言，如果其每一行和每一列都包含从<code>1</code>到<code>n</code>的<strong>全部</strong>整数（含<code>1</code>和<code>n</code>），则认为该矩阵是一个<strong>有效</strong>矩阵。</p><p>给你一个大小为<code>n x n</code>的整数矩阵<code>matrix</code>，请你判断矩阵是否为一个有效矩阵：如果是，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[3,1,2],[2,3,1]]</span><br>输出：<span class="hljs-literal">true</span><br>解释：在此例中，n = <span class="hljs-number">3</span> ，每一行和每一列都包含数字 <span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3</span> 。<br>因此，返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,1,1],[1,2,3],[1,2,3]]</span><br>输出：<span class="hljs-literal">false</span><br>解释：在此例中，n = <span class="hljs-number">3</span> ，但第一行和第一列不包含数字 <span class="hljs-number">2</span> 和 <span class="hljs-number">3</span> 。<br>因此，返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= matrix[i][j] &lt;= n</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用<code>matrix[i]</code>，而取矩阵的某一列没有什么很好的思路，可以用<code>[matrix[x][j] for x in range(n)]</code>，这里的<code>j</code>代表第<code>j</code>列；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkValid</span>(<span class="hljs-params">self, matrix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type matrix: List[List[int]]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>      <br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # tle</span><br><span class="hljs-string">        n = len(matrix)</span><br><span class="hljs-string">        target = [i+1 for i in range(n)]</span><br><span class="hljs-string">        target_count = Counter(target)</span><br><span class="hljs-string">        for i in range(n):</span><br><span class="hljs-string">            for j in range(n):</span><br><span class="hljs-string">                tmp_counter1 = Counter(matrix[i])</span><br><span class="hljs-string">                tmp_counter2 = Counter([matrix[x][j] for x in range(n)])</span><br><span class="hljs-string">                if not (tmp_counter1 == target_count and tmp_counter2 == target_count):</span><br><span class="hljs-string">                    return False</span><br><span class="hljs-string">        return True</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>    <br>        <span class="hljs-comment"># 只判断对角线就够了？</span><br>        n = <span class="hljs-built_in">len</span>(matrix)<br>        target = [i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        target_count = Counter(target)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            tmp_counter1 = Counter(matrix[i])<br>            tmp_counter2 = Counter([matrix[x][i] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (tmp_counter1 == target_count <span class="hljs-keyword">and</span> tmp_counter2 == target_count):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2134-最少交换次数来组合所有的1-II"><a href="#第二题：2134-最少交换次数来组合所有的1-II" class="headerlink" title="第二题：2134.最少交换次数来组合所有的1 II"></a>第二题：2134.最少交换次数来组合所有的1 II</h1><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>交换</strong>定义为选中一个数组中的两个<strong>互不相同</strong>的位置并交换二者的值。</p><p><strong>环形</strong>数组是一个数组，可以认为<strong>第一个</strong>元素和<strong>最后一个</strong>元素<strong>相邻</strong>。</p><p>给你一个<strong>二进制环形</strong>数组<code>nums</code>，返回在<strong>任意位置</strong>将数组中的所有<code>1</code>聚集在一起需要的最少交换次数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,0,1,1,0,0]<br>输出：1<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[0,0,1,1,1,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[0,1,1,1,0,0,0] 交换<span class="hljs-number"> 1 </span>次。<br>[1,1,0,0,0,0,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>无法在交换<span class="hljs-number"> 0 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 1 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [0,1,1,1,0,0,1,1,0]<br>输出：2<br>解释：这里列出一些能够将所有<span class="hljs-number"> 1 </span>聚集在一起的方案：<br>[1,1,1,0,0,0,0,1,1] 交换<span class="hljs-number"> 2 </span>次（利用数组的环形特性）。<br>[1,1,1,1,1,0,0,0,0] 交换<span class="hljs-number"> 2 </span>次。<br>无法在交换<span class="hljs-number"> 0 </span>次或<span class="hljs-number"> 1 </span>次的情况下将数组中的所有<span class="hljs-number"> 1 </span>聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 2 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [1,1,0,0,1]<br>输出：0<br>解释：得益于数组的环形特性，所有的<span class="hljs-number"> 1 </span>已经聚集在一起。<br>因此，需要的最少交换次数为<span class="hljs-number"> 0 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>nums[i]</code>为<code>0</code>或者<code>1</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可；</p><p>另外注意，这种环形的可以通过补充在最后边来进行简易的实现，取模的思路有点麻烦了，python语言还有其专门使用的extend函数；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minSwaps</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 处理出一个初始化的目标状态</span><br>        target_counter = Counter(nums)<br>        <span class="hljs-keyword">del</span> target_counter[<span class="hljs-number">0</span>]<br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(target_counter[<span class="hljs-number">1</span>]):<br>            nums.append(nums[cnt])<br>            cnt += <span class="hljs-number">1</span><br>        <br>        min_swaps = target_counter[<span class="hljs-number">1</span>]<br>        init_counter = Counter(nums[<span class="hljs-number">0</span>: (target_counter[<span class="hljs-number">1</span>])])<br>        min_swaps = <span class="hljs-built_in">min</span>(min_swaps, (init_counter-target_counter)[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># print(init_counter)</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)-target_counter[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>):<br>            init_counter -= Counter([nums[i-<span class="hljs-number">1</span>]])<br>            init_counter += Counter([nums[i+target_counter[<span class="hljs-number">1</span>]-<span class="hljs-number">1</span>]])<br>            <span class="hljs-comment"># print(init_counter)</span><br>            min_swaps = <span class="hljs-built_in">min</span>(min_swaps, (init_counter-target_counter)[<span class="hljs-number">0</span>])<br>            <br>        <br>        <span class="hljs-keyword">return</span> min_swaps<br></code></pre></td></tr></table></figure><h1 id="第三题：2135-统计追加字母可以获得的单词数"><a href="#第三题：2135-统计追加字母可以获得的单词数" class="headerlink" title="第三题：2135.统计追加字母可以获得的单词数"></a>第三题：2135.统计追加字母可以获得的单词数</h1><p><a href="https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从<strong>0</strong>开始的字符串数组<code>startWords</code>和<code>targetWords</code>。每个字符串都仅由<strong>小写英文字母</strong>组成。</p><p>对于<code>targetWords</code>中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次<strong>转换操作</strong>，得到的结果与当前<code>targetWords</code>字符串相等。</p><p><strong>转换操作</strong>如下面两步所述：</p><ol><li><strong>追加</strong>任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。</li></ol><ul><li>例如，如果字符串为<code>&quot;abc&quot;</code>，那么字母<code>&#39;d&#39;</code>、<code>&#39;e&#39;</code>或<code>&#39;y&#39;</code>都可以加到该字符串末尾，但<code>&#39;a&#39;</code>就不行。如果追加的是<code>&#39;d&#39;</code>，那么结果字符串为<code>&quot;abcd&quot;</code>。</li></ul><ol start="2"><li><strong>重排</strong>新字符串中的字母，可以按<strong>任意</strong>顺序重新排布字母。</li></ol><ul><li>例如，<code>&quot;abcd&quot;</code>可以重排为<code>&quot;acbd&quot;</code>、<code>&quot;bacd&quot;</code>、<code>&quot;cbda&quot;</code>，以此类推。注意，它也可以重排为<code>&quot;abcd&quot;</code>自身。</li></ul><p>找出<code>targetWords</code>中有多少字符串能够由<code>startWords</code>中的<strong>任一</strong>字符串执行上述转换操作获得。返回<code>targetWords</code>中这类<strong>字符串的数目</strong>。</p><p>注意：你仅能验证<code>targetWords</code>中的字符串是否可以由<code>startWords</code>中的某个字符串经执行操作获得。<code>startWords</code>中的字符串在这一过程中 不 发生实际变更。</p><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set&#x2F;dict&#x2F;Counter中，这样可以O(1)的判断是否存在；</p><p>其中感觉也有用到一种反向的思维，目标单词是startWord加上一个字母，所以startWord是目标单词减去一个字母，这样的话可能更容易想到是用一个set&#x2F;dict&#x2F;Counter来进行查找了；</p><p>还是很值得复盘的一个题目，感觉字母排序也是一个需要复盘的点；</p><p>TLE超时版本代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordCount</span>(<span class="hljs-params">self, startWords, targetWords</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type startWords: List[str]</span><br><span class="hljs-string">        :type targetWords: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # TLE</span><br><span class="hljs-string">        result_cnt = 0</span><br><span class="hljs-string">        none_counter = Counter(&quot;&quot;)</span><br><span class="hljs-string">        counter_start_words = [Counter(x) for x in startWords]</span><br><span class="hljs-string">        counter_target_words = [Counter(x) for x in targetWords]</span><br><span class="hljs-string">        for i in range(len(counter_target_words)):</span><br><span class="hljs-string">            flag = 0</span><br><span class="hljs-string">            for j in range(len(counter_start_words)):</span><br><span class="hljs-string">                # 剪枝</span><br><span class="hljs-string">                if len(targetWords[i]) - len(counter_start_words[j]) != 1:</span><br><span class="hljs-string">                    continue</span><br><span class="hljs-string">                if len([key for key in (counter_start_words[j] - counter_target_words[i]).keys()]) != 0:</span><br><span class="hljs-string">                    continue</span><br><span class="hljs-string">                </span><br><span class="hljs-string">                tmp_counter = counter_target_words[i] - counter_start_words[j]    </span><br><span class="hljs-string">                # 必须只有一个键，且这个键值为1，且这个不出现在原来的counter_target_words[i]中</span><br><span class="hljs-string">                key_list = [key for key in tmp_counter.keys()]</span><br><span class="hljs-string">                if len(key_list) == 1 and tmp_counter[key_list[0]] == 1 and counter_start_words[j].get(key_list[0]) is None:</span><br><span class="hljs-string">                    flag = 1</span><br><span class="hljs-string">                    break                    </span><br><span class="hljs-string">            if flag == 1:</span><br><span class="hljs-string">                result_cnt += 1</span><br><span class="hljs-string">        return result_cnt</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        set_start_words = [<span class="hljs-built_in">set</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> startWords]<br>        set_target_words = [<span class="hljs-built_in">set</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> targetWords]<br>        result_cnt = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(targetWords)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(startWords)):<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(targetWords[i]) - <span class="hljs-built_in">len</span>(startWords[j]) != <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">list</span>(set_target_words[i].symmetric_difference(set_start_words[j]))) == <span class="hljs-number">1</span>:<br>                    <span class="hljs-built_in">print</span>(set_target_words[i], set_start_words[j])<br>                    result_cnt += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> result_cnt<br><br></code></pre></td></tr></table></figure><p>修改后的不超时代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordCount</span>(<span class="hljs-params">self, startWords, targetWords</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type startWords: List[str]</span><br><span class="hljs-string">        :type targetWords: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        set_start_words = <span class="hljs-built_in">set</span>([<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(startWord))) <span class="hljs-keyword">for</span> startWord <span class="hljs-keyword">in</span> startWords])<br>        sorted_target_words = [<span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">list</span>(targetWord))) <span class="hljs-keyword">for</span> targetWord <span class="hljs-keyword">in</span> targetWords]<br>        counter_sorted_target_words = Counter(sorted_target_words)<br><br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> targetWord, value <span class="hljs-keyword">in</span> counter_sorted_target_words.items():<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(targetWord)):<br>                tmp_s = targetWord[:i] + targetWord[i+<span class="hljs-number">1</span>:]<br>                <span class="hljs-keyword">if</span> tmp_s <span class="hljs-keyword">in</span> set_start_words:<br>                    cnt += value<br>                    <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
      <tag>矩阵</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>276场LeetCode周赛</title>
    <link href="/2022/01/16/algorithms/leetcode-weekly-contest/276%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/16/algorithms/leetcode-weekly-contest/276%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前两题难度还是比较低的，第三题的话感觉dp这个思路还值得复盘研究一下，常见的一维dp数组感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值；</p><p>第一题：简单字符串模拟，有一些mod的使用，熟练度的题目；</p><p>第二题：从大到小贪心就行了，最后一次直接 +&#x3D; target - 1；</p><p>第三题：一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用<code>max()</code>而TLE，所以在优化方向上应该也找到后边一种思路的优化方向；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：5980-将字符串拆分为若干长度为k的组"><a href="#第一题：5980-将字符串拆分为若干长度为k的组" class="headerlink" title="第一题：5980.将字符串拆分为若干长度为k的组"></a>第一题：5980.将字符串拆分为若干长度为k的组</h1><p><a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串<code>s</code>可以按下述步骤划分为若干长度为<code>k</code>的组：</p><ul><li>第一组由字符串中的前<code>k</code>个字符组成，第二组由接下来的<code>k</code>个字符串组成，依此类推。每个字符都能够成为<strong>某一个</strong>组的一部分。</li><li>对于最后一组，如果字符串剩下的字符<strong>不足</strong><code>k</code>个，需使用字符<code>fill</code>来补全这一组字符。</li></ul><p>注意，在去除最后一个组的填充字符<code>fill</code>（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是<code>s</code>。</p><p>给你一个字符串<code>s</code>，以及每组的长度<code>k</code>和一个用于填充的字符<code>fill</code>，按上述步骤处理之后，返回一个字符串数组，该数组表示<code>s</code>分组后<strong>每个组的组成情况</strong>。</p><p>示例1：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：s = <span class="hljs-string">&quot;abcdefghi&quot;</span>, k = <span class="hljs-number">3</span>, fill = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>]<br>解释：<br>前 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;abc&quot;</span> ，形成第一组。<br>接下来 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;def&quot;</span> ，形成第二组。<br>最后 <span class="hljs-number">3</span> 个字符是 <span class="hljs-string">&quot;ghi&quot;</span> ，形成第三组。<br>由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。<br>因此，形成 <span class="hljs-number">3</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：s = <span class="hljs-string">&quot;abcdefghij&quot;</span>, k = <span class="hljs-number">3</span>, fill = <span class="hljs-string">&quot;x&quot;</span><br>输出：[<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;def&quot;</span>,<span class="hljs-string">&quot;ghi&quot;</span>,<span class="hljs-string">&quot;jxx&quot;</span>]<br>解释：<br>与前一个例子类似，形成前三组 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span> 和 <span class="hljs-string">&quot;ghi&quot;</span> 。<br>对于最后一组，字符串中仅剩下字符 <span class="hljs-string">&#x27;j&#x27;</span> 可以用。为了补全这一组，使用填充字符 <span class="hljs-string">&#x27;x&#x27;</span> 两次。<br>因此，形成 <span class="hljs-number">4</span> 组，分别是 <span class="hljs-string">&quot;abc&quot;</span>、<span class="hljs-string">&quot;def&quot;</span>、<span class="hljs-string">&quot;ghi&quot;</span> 和 <span class="hljs-string">&quot;jxx&quot;</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 仅由小写英文字母组成</li><li>1 &lt;&#x3D; k &lt;&#x3D; 100</li><li>fill 是一个小写英文字母</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>简单的字符串模拟，需要比较熟练地使用mod</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">divideString</span>(<span class="hljs-params">self, s, k, fill</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type k: int</span><br><span class="hljs-string">        :type fill: str</span><br><span class="hljs-string">        :rtype: List[str]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        return_list = []<br>        <br>        s_list = <span class="hljs-built_in">list</span>(s)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s_list) % k != <span class="hljs-number">0</span>:<br>            s_list += [fill <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k - <span class="hljs-built_in">len</span>(s_list) % k)]<br>        <span class="hljs-built_in">print</span>(s_list)<br>        <br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s_list):<br>            return_list.append(<span class="hljs-string">&quot;&quot;</span>.join(s_list[i: i+k]))<br>            i += k<br>        <span class="hljs-keyword">return</span> return_list<br></code></pre></td></tr></table></figure><h1 id="第二题：5194-得到目标值的最少行动次数"><a href="#第二题：5194-得到目标值的最少行动次数" class="headerlink" title="第二题：5194.得到目标值的最少行动次数"></a>第二题：5194.得到目标值的最少行动次数</h1><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>你正在玩一个整数游戏。从整数<code>1</code>开始，期望得到整数<code>target</code>。</p><p>在一次行动中，你可以做下述两种操作之一：</p><ul><li>递增，将当前整数的值加 1（即，<code>x = x + 1</code>）。</li><li>加倍，使当前整数的值翻倍（即，<code>x = 2 * x</code>）。</li></ul><p>在整个游戏过程中，你可以使用<strong>递增</strong>操作<strong>任意</strong>次数。但是只能使用<strong>加倍</strong>操作 至多<code>maxDoubles</code>次。</p><p>给你两个整数<code>target</code>和<code>maxDoubles</code>，返回从 1 开始得到<code>target</code>需要的最少行动次数。</p><p>示例1：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">输入：<span class="hljs-keyword">target</span> = <span class="hljs-number">5</span>, maxDoubles = <span class="hljs-number">0</span><br>输出：<span class="hljs-number">4</span><br>解释：一直递增 <span class="hljs-number">1</span> 直到得到 <span class="hljs-keyword">target</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 19, maxDoubles = 2<br>输出：7<br>解释：最初，x =<span class="hljs-number"> 1 </span>。<br>递增<span class="hljs-number"> 3 </span>次，x =<span class="hljs-number"> 4 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 8 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 9 </span>。<br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 18 </span>。<br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 19 </span>。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：target = 10, maxDoubles = 4<br>输出：4<br>解释：<br>最初，x =<span class="hljs-number"> 1 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 2 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 4 </span>。 <br>递增<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 5 </span>。 <br>加倍<span class="hljs-number"> 1 </span>次，x =<span class="hljs-number"> 10 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; target &lt;&#x3D; 109</li><li>0 &lt;&#x3D; maxDoubles &lt;&#x3D; 100</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>贪心，还是比较容易看出来的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minMoves</span>(<span class="hljs-params">self, target, maxDoubles</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type target: int</span><br><span class="hljs-string">        :type maxDoubles: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> maxDoubles != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> target != <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> target % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:<br>                target -= <span class="hljs-number">1</span><br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                target //= <span class="hljs-number">2</span><br>                cnt += <span class="hljs-number">1</span><br>                maxDoubles -= <span class="hljs-number">1</span><br>        <br>        cnt += target - <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：5982-解决智力问题"><a href="#第三题：5982-解决智力问题" class="headerlink" title="第三题：5982.解决智力问题"></a>第三题：5982.解决智力问题</h1><p><a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从<strong>0</strong>开始的二维整数数组<code>questions</code>，其中<code>questions[i] = [pointsi, brainpoweri]</code>。</p><p>这个数组表示一场考试里的一系列题目，你需要<strong>按顺序</strong>（也就是从问题<code>0</code>开始依次解决），针对每个问题选择<strong>解决</strong>或者<strong>跳过</strong>操作。解决问题<code>i</code>将让你<strong>获得</strong><code>pointsi</code>的分数，但是你将<strong>无法</strong>解决接下来的<code>brainpoweri</code>个问题（即只能跳过接下来的<code>brainpoweri</code>个问题）。如果你跳过问题<code>i</code>，你可以对下一个问题决定使用哪种操作。</p><ul><li>比方说，给你<code>questions = [[3, 2], [4, 3], [4, 4], [2, 5]]</code>：<ul><li>如果问题<code>0</code>被解决了， 那么你可以获得<code>3</code>分，但你不能解决问题<code>1</code>和<code>2</code>。</li><li>如果你跳过问题<code>0</code>，且解决问题<code>1</code>，你将获得<code>4</code>分但是不能解决问题<code>2</code>和<code>3</code>。</li></ul></li></ul><p>请你返回这场考试里你能获得的<strong>最高</strong>分数。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[3,2],[4,3],[4,4],[2,5]]<br>输出：5<br>解释：解决问题<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>得到最高分。<br>- 解决问题<span class="hljs-number"> 0 </span>：获得<span class="hljs-number"> 3 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 1 </span>和 2<br>- 解决问题<span class="hljs-number"> 3 </span>：获得<span class="hljs-number"> 2 </span>分<br>总得分为：3 +<span class="hljs-number"> 2 </span>=<span class="hljs-number"> 5 </span>。没有别的办法获得<span class="hljs-number"> 5 </span>分或者多于<span class="hljs-number"> 5 </span>分。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]<br>输出：7<br>解释：解决问题<span class="hljs-number"> 1 </span>和<span class="hljs-number"> 4 </span>得到最高分。<br>- 跳过问题 0<br>- 解决问题<span class="hljs-number"> 1 </span>：获得<span class="hljs-number"> 2 </span>分，但接下来<span class="hljs-number"> 2 </span>个问题都不能解决。<br>- 不能解决问题<span class="hljs-number"> 2 </span>和 3<br>- 解决问题<span class="hljs-number"> 4 </span>：获得<span class="hljs-number"> 5 </span>分<br>总得分为：2 +<span class="hljs-number"> 5 </span>=<span class="hljs-number"> 7 </span>。没有别的办法获得<span class="hljs-number"> 7 </span>分或者多于<span class="hljs-number"> 7 </span>分。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; questions.length &lt;&#x3D; 105</li><li>questions[i].length &#x3D;&#x3D; 2</li><li>1 &lt;&#x3D; pointsi, brainpoweri &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>题目的名字好有意思哈哈哈哈，这是按时解决一下我的智力问题吗23333</p><p>一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用<code>max()</code>而TLE，所以在优化方向上应该也找到后边一种思路的优化方向；</p><p>TLE的写法，这里dp数组存储的是每个状态的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mostPoints</span>(<span class="hljs-params">self, questions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type questions: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        questions.reverse()<br>        dp = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> questions]  <span class="hljs-comment"># 每个位置上先初始化</span><br>        <br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(questions)):  <span class="hljs-comment"># 每个位置有选得到和选不到两种状态的dp</span><br>            <span class="hljs-keyword">if</span> i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 选和不选两种状态</span><br>                <span class="hljs-comment"># 选的话</span><br>                tmp_choose = questions[i][<span class="hljs-number">0</span>] + <span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>:i-questions[i][<span class="hljs-number">1</span>]])<br>                <span class="hljs-comment"># 不选的话</span><br>                tmp_not_choose = <span class="hljs-built_in">max</span>(dp[i-questions[i][<span class="hljs-number">1</span>]: i])<br>                dp[i] = <span class="hljs-built_in">max</span>(tmp_choose, tmp_not_choose)<br>                <br>                <span class="hljs-comment"># print(dp)</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><p>优化后的写法， 这里dp数组存储的是截止到这个状态的，下图是思路：<br><img src="/images/2022-01-16-21-16-46.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mostPoints</span>(<span class="hljs-params">self, questions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type questions: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> questions]<br>        questions.reverse()<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(questions)):<br>            <span class="hljs-keyword">if</span> i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># 越界了的状态，维护不断增加的dp</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], questions[i][<span class="hljs-number">0</span>])<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 没有越界的话，因为不断增加</span><br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], questions[i][<span class="hljs-number">0</span>] + dp[i - questions[i][<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>])<br>        <br>        <span class="hljs-comment"># print(max(dp))</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(questions) - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记3-Docker常用命令-狂神视频</title>
    <link href="/2022/01/08/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/08/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>Docker的常用命令，主要分为镜像和容器两个部分，也是Docker学习的基础</p><p>这里的命令如果对基础linux有了解，或者对screen系列命令有了解感觉还是很熟悉的，就是感觉要多用或者结合项目才能真正的记住</p><span id="more"></span><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker version  # 显示docker的版本信息<br>docker info  # 显示docker更加详细的信息，sys级别系统信息，包括镜像和容器的数量等<br>docker 命令 --help  # 万能命令，帮助命令<br>docker --help<br></code></pre></td></tr></table></figure><p>帮助文档的地址：<br>docs.docker.com里有一个Reference</p><p>docs.docker.com&#x2F;engine&#x2F;reference&#x2F;commandline</p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><p><strong>docker images</strong> 查看所有本地主机上的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解释</span><br>REPOSITORY镜像的仓库源<br>TAG镜像的标签<br>IMAGE ID    镜像的ID<br>CREATED镜像的创建时间<br>SIZE镜像的大小<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项，可以docker image -aq</span><br>Options:<br>  -a, --all             Show all images (default hides intermediate images) 列出所有镜像<br>  -q, --quiet           Only show image IDs 只显示镜像的id<br></code></pre></td></tr></table></figure><p><strong>docker search 搜索镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker search mysql<br>NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                             MySQL is a widely used, open-source relation…   11912     [OK]       <br>mariadb                           MariaDB Server is a high performing open sou…   4558      [OK]       <br>mysql/mysql-server                Optimized MySQL Server Docker images. Create…   895                  [OK]<br>phpmyadmin                        phpMyAdmin - A web interface for MySQL and M…   415       [OK]<br>......<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">可选项，通过收藏来过滤</span><br>Options:<br>--filter=STARS=3000  # 搜索出来的镜像就是STARS大于3000的<br><br>[bupt_114@AIServer ~]$ docker search mysql --filter=STARS=3000<br>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   11912     [OK]       <br>mariadb   MariaDB Server is a high performing open sou…   4558      [OK]<br></code></pre></td></tr></table></figure><p><strong>docker pull 下载镜像</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名[:tag]</span><br>[bupt_114@AIServer ~]$ docker pull mysql<br>Using default tag: latest  # 如果不写tag，默认就是latest<br>latest: Pulling from library/mysql          # <br>72a69066d2fe: Pull complete # 分层下载，docker image的核心 联合文件系统<br>93619dbc5b36: Pull complete <br>99da31dd6142: Pull complete <br>626033c43d70: Pull complete <br>37d5d7efb64e: Pull complete <br>ac563158d721: Pull complete <br>d2ba16033dad: Pull complete <br>688ba7d5c01a: Pull complete <br>00e060b6d11d: Pull complete <br>1c04857f594f: Pull complete <br>4d7cfa90e6ea: Pull complete <br>e0431212d27d: Pull complete <br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709# 签名，防伪标志<br>Status: Downloaded newer image for mysql:latest<br>docker.io/library/mysql:latest# 真实地址<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">等价</span><br>docker pull mysql 和 docker pull docker.io/library/mysql:latest是等价的<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定版本下载</span><br>[bupt_114@AIServer ~]$ docker pull mysql:5.7  # 注意版本一定要在官方文档里有<br>【docker笔记3图2】<br><br>[bupt_114@AIServer ~]$ docker pull mysql:5.7<br>5.7: Pulling from library/mysql<br>72a69066d2fe: Already exists <br>93619dbc5b36: Already exists <br>99da31dd6142: Already exists <br>626033c43d70: Already exists <br>37d5d7efb64e: Already exists <br>ac563158d721: Already exists <br>d2ba16033dad: Already exists <br>0ceb82207cd7: Pull complete <br>37f2405cae96: Pull complete <br>e2482e017e53: Pull complete <br>70deed891d42: Pull complete <br>Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Status: Downloaded newer image for mysql:5.7<br>docker.io/library/mysql:5.7<br></code></pre></td></tr></table></figure><p><strong>docker rmi 删除镜像</strong><br>（既可以通过镜像的ID来删除，也可以通过镜像的名称来删除，涉及到删除的指令都非常危险啊）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker rmi -f c20987f18b13<br>Untagged: mysql:5.7<br>Untagged: mysql@sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Deleted: sha256:c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab302a76<br>Deleted: sha256:6567396b065ee734fb2dbb80c8923324a778426dfd01969f091f1ab2d52c7989<br>Deleted: sha256:0910f12649d514b471f1583a16f672ab67e3d29d9833a15dc2df50dd5536e40f<br>Deleted: sha256:6682af2fb40555c448b84711c7302d0f86fc716bbe9c7dc7dbd739ef9d757150<br>Deleted: sha256:5c062c3ac20f576d24454e74781511a5f96739f289edaadf2de934d06e910b92<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">批量删除所有的</span><br>[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq)  # 删除全部的容器<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker rmi -f 容器id     # 删除指定的容器<br>[bupt_114@AIServer ~]$ docker rmi -f 容器id 容器id 容器id   # 删除多个容器<br>[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq)  # 删除全部的容器<br></code></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</strong></p><p>在docker里面再装一个虚拟机！？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull centos<br></code></pre></td></tr></table></figure><p><strong>新建容器并启动</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run [可选参数] image<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">参数说明</span><br>--name=&quot;Name&quot;# 容器名字，跑起来要知道叫什么，tomcat01, tomcat02，用来区分容器<br>-d    # 后台方式运行<br>-it                 # 使用交互方式运行，进入容器查看内容<br>-p   # 指定容器的端口 -p 8080:8080，可以和主机映射起来也<br>-p ip:主机端口:容器端口<br>-p 主机端口:容器端口（常用）<br>-p 容器端口<br>容器端口<br>-P                  # 大P，随机指定端口<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span><br>[bupt_114@AIServer ~]$ docker run -it centos /bin/bash<br>[root@364710ff50c7 /]# <br>[root@364710ff50c7 /]# ls    # 查看容器内部的centos，基础版本，很多命令都是不完善的<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从容器中退回主机</span><br>[root@364710ff50c7 /]# exit<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>列出所有运行中的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">docker ps 命令</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">列出当前正在运行的容器</span><br>-a # 列出当前正在运行的容器 + 带出历史运行过的容器<br>-n=?    # 显示最近创建的容器，即个数<br>-q # 只显示容器的编号<br><br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                          PORTS     NAMES<br>364710ff50c7   centos         &quot;/bin/bash&quot;   5 minutes ago   Exited (0) About a minute ago             elated_lichterman<br>93427549984f   feb5d9fea6a5   &quot;/hello&quot;      29 hours ago    Exited (0) 29 hours ago                   exciting_villani<br>[bupt_114@AIServer ~]$ docker ps -a -n=1<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>364710ff50c7   centos    &quot;/bin/bash&quot;   7 minutes ago   Exited (0) 3 minutes ago             elated_lichterman<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>退出容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit # 直接停止容器并退出<br>ctrl + P + Q   # 容器不停止并退出<br></code></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker rm 容器id# 删除指定的容器，不能删除正在运行的容器，如果要强制删除，rm -f<br>docker rm -f $(docker ps -aq)   # 删除所有的容器<br>docker ps -a -q | xargs docker rm  # 删除所有的容器（docker玩的不错跑路就玩得不错哈哈哈哈）<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行中的不能直接删除，要加-f代表force</span><br>[bupt_114@AIServer ~]$ docker rm f406a8591325<br>Error response from daemon: You cannot remove a running container f406a8591325995950d4defb6d7eefbe45bd5ec11e895f7238ce53de4546c297. Stop the container before attempting removal or force remove<br></code></pre></td></tr></table></figure><p><strong>启动和停止容器的操作</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker start 容器id# 启动容器<br>docker attach 容器id# 进入容器<br>docker restart 容器id# 重启容器<br>docker stop 容器id# 停止当前正在运行的容器<br>docker kill 容器id# 强制定制当前正在运行的容器<br><br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>87ac7567be74   centos    &quot;/bin/bash&quot;   9 seconds ago   Exited (0) 6 seconds ago             determined_cohen<br>[bupt_114@AIServer ~]$ docker start 87ac7567be74<br>87ac7567be74<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS         PORTS     NAMES<br>87ac7567be74   centos    &quot;/bin/bash&quot;   24 seconds ago   Up 4 seconds             determined_cohen<br>[bupt_114@AIServer ~]$ docker stop 87ac7567be74<br>87ac7567be74<br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><h2 id="常用的其他命令"><a href="#常用的其他命令" class="headerlink" title="常用的其他命令"></a>常用的其他命令</h2><p><strong>后台启动容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令，docker run -d 镜像名！</span><br>[bupt_114@AIServer ~]$ docker run -d centos<br>0aab13a3c396931520159092a755ccc7eb1a2fc56895ab2e2cc43267e86be432<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">问题，docker ps，发现centos停止了</span><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES<br>0aab13a3c396   centos    &quot;/bin/bash&quot;   12 seconds ago   Exited (0) 11 seconds ago             exciting_bose<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">nginx，容器启动后，发现自己没有提供服务，就会立刻停止，没有程序了</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这块有点没理解，往后学习再看了</span><br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>查看日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker logs<br><br>[bupt_114@AIServer ~]$ docker ps -a<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES<br>0aab13a3c396   centos    &quot;/bin/bash&quot;   15 minutes ago   Exited (0) 15 minutes ago             exciting_bose<br>[bupt_114@AIServer ~]$ docker logs -tf --tail 10 0aab13a3c396<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示日志</span><br>-tf  # 显示日志，f是实时追踪，滚动查看<br>--tail number# 要显示的日志条数<br></code></pre></td></tr></table></figure><p><strong>查看容器中的进程信息</strong> ps用来查linux的进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">注意，要容器正在运行才能查的出来</span><br><br>docker top [容器id]<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   15 seconds ago   Up 14 seconds             pensive_dirac<br>[bupt_114@AIServer ~]$ docker top 8d05d658639d<br>UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD<br>root                11758               11735               0                   21:37               pts/0               00:00:00            /bin/bash<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>查看镜像的元数据</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><code class="hljs shell">[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   About a minute ago   Up About a minute             pensive_dirac<br>[bupt_114@AIServer ~]$ docker inspect 8d05d658639d<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732&quot;,<br>        &quot;Created&quot;: &quot;2022-01-07T13:37:12.953676774Z&quot;,<br>        &quot;Path&quot;: &quot;/bin/bash&quot;,<br>        &quot;Args&quot;: [],<br>        &quot;State&quot;: &#123;<br>            &quot;Status&quot;: &quot;running&quot;,<br>            &quot;Running&quot;: true,<br>            &quot;Paused&quot;: false,<br>            &quot;Restarting&quot;: false,<br>            &quot;OOMKilled&quot;: false,<br>            &quot;Dead&quot;: false,<br>            &quot;Pid&quot;: 11758,<br>            &quot;ExitCode&quot;: 0,<br>            &quot;Error&quot;: &quot;&quot;,<br>            &quot;StartedAt&quot;: &quot;2022-01-07T13:37:13.28978368Z&quot;,<br>            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;,<br>        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,<br>        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/resolv.conf&quot;,<br>        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hostname&quot;,<br>        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hosts&quot;,<br>        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732-json.log&quot;,<br>        &quot;Name&quot;: &quot;/pensive_dirac&quot;,<br>        &quot;RestartCount&quot;: 0,<br>        &quot;Driver&quot;: &quot;overlay2&quot;,<br>        &quot;Platform&quot;: &quot;linux&quot;,<br>        &quot;MountLabel&quot;: &quot;&quot;,<br>        &quot;ProcessLabel&quot;: &quot;&quot;,<br>        &quot;AppArmorProfile&quot;: &quot;&quot;,<br>        &quot;ExecIDs&quot;: null,<br>        &quot;HostConfig&quot;: &#123;<br>            &quot;Binds&quot;: null,<br>            &quot;ContainerIDFile&quot;: &quot;&quot;,<br>            &quot;LogConfig&quot;: &#123;<br>                &quot;Type&quot;: &quot;json-file&quot;,<br>                &quot;Config&quot;: &#123;&#125;<br>            &#125;,<br>            &quot;NetworkMode&quot;: &quot;default&quot;,<br>            &quot;PortBindings&quot;: &#123;&#125;,<br>            &quot;RestartPolicy&quot;: &#123;<br>                &quot;Name&quot;: &quot;no&quot;,<br>                &quot;MaximumRetryCount&quot;: 0<br>            &#125;,<br>            &quot;AutoRemove&quot;: false,<br>            &quot;VolumeDriver&quot;: &quot;&quot;,<br>            &quot;VolumesFrom&quot;: null,<br>            &quot;CapAdd&quot;: null,<br>            &quot;CapDrop&quot;: null,<br>            &quot;CgroupnsMode&quot;: &quot;host&quot;,<br>            &quot;Dns&quot;: [],<br>            &quot;DnsOptions&quot;: [],<br>            &quot;DnsSearch&quot;: [],<br>            &quot;ExtraHosts&quot;: null,<br>            &quot;GroupAdd&quot;: null,<br>            &quot;IpcMode&quot;: &quot;private&quot;,<br>            &quot;Cgroup&quot;: &quot;&quot;,<br>            &quot;Links&quot;: null,<br>            &quot;OomScoreAdj&quot;: 0,<br>            &quot;PidMode&quot;: &quot;&quot;,<br>            &quot;Privileged&quot;: false,<br>            &quot;PublishAllPorts&quot;: false,<br>            &quot;ReadonlyRootfs&quot;: false,<br>            &quot;SecurityOpt&quot;: null,<br>            &quot;UTSMode&quot;: &quot;&quot;,<br>            &quot;UsernsMode&quot;: &quot;&quot;,<br>            &quot;ShmSize&quot;: 67108864,<br>            &quot;Runtime&quot;: &quot;runc&quot;,<br>            &quot;ConsoleSize&quot;: [<br>                0,<br>                0<br>            ],<br>            &quot;Isolation&quot;: &quot;&quot;,<br>            &quot;CpuShares&quot;: 0,<br>            &quot;Memory&quot;: 0,<br>            &quot;NanoCpus&quot;: 0,<br>            &quot;CgroupParent&quot;: &quot;&quot;,<br>            &quot;BlkioWeight&quot;: 0,<br>            &quot;BlkioWeightDevice&quot;: [],<br>            &quot;BlkioDeviceReadBps&quot;: null,<br>            &quot;BlkioDeviceWriteBps&quot;: null,<br>            &quot;BlkioDeviceReadIOps&quot;: null,<br>            &quot;BlkioDeviceWriteIOps&quot;: null,<br>            &quot;CpuPeriod&quot;: 0,<br>            &quot;CpuQuota&quot;: 0,<br>            &quot;CpuRealtimePeriod&quot;: 0,<br>            &quot;CpuRealtimeRuntime&quot;: 0,<br>            &quot;CpusetCpus&quot;: &quot;&quot;,<br>            &quot;CpusetMems&quot;: &quot;&quot;,<br>            &quot;Devices&quot;: [],<br>            &quot;DeviceCgroupRules&quot;: null,<br>            &quot;DeviceRequests&quot;: null,<br>            &quot;KernelMemory&quot;: 0,<br>            &quot;KernelMemoryTCP&quot;: 0,<br>            &quot;MemoryReservation&quot;: 0,<br>            &quot;MemorySwap&quot;: 0,<br>            &quot;MemorySwappiness&quot;: null,<br>            &quot;OomKillDisable&quot;: false,<br>            &quot;PidsLimit&quot;: null,<br>            &quot;Ulimits&quot;: null,<br>            &quot;CpuCount&quot;: 0,<br>            &quot;CpuPercent&quot;: 0,<br>            &quot;IOMaximumIOps&quot;: 0,<br>            &quot;IOMaximumBandwidth&quot;: 0,<br>            &quot;MaskedPaths&quot;: [<br>                &quot;/proc/asound&quot;,<br>                &quot;/proc/acpi&quot;,<br>                &quot;/proc/kcore&quot;,<br>                &quot;/proc/keys&quot;,<br>                &quot;/proc/latency_stats&quot;,<br>                &quot;/proc/timer_list&quot;,<br>                &quot;/proc/timer_stats&quot;,<br>                &quot;/proc/sched_debug&quot;,<br>                &quot;/proc/scsi&quot;,<br>                &quot;/sys/firmware&quot;<br>            ],<br>            &quot;ReadonlyPaths&quot;: [<br>                &quot;/proc/bus&quot;,<br>                &quot;/proc/fs&quot;,<br>                &quot;/proc/irq&quot;,<br>                &quot;/proc/sys&quot;,<br>                &quot;/proc/sysrq-trigger&quot;<br>            ]<br>        &#125;,<br>        &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74-init/diff:/var/lib/docker/overlay2/70a302960300b9000282549b5adf25e9a4bd66f8e9c50f12844d5d156ea2c712/diff&quot;,<br>                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/merged&quot;,<br>                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/diff&quot;,<br>                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/work&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;overlay2&quot;<br>        &#125;,<br>        &quot;Mounts&quot;: [],<br>        &quot;Config&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;8d05d658639d&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: true,<br>            &quot;AttachStdout&quot;: true,<br>            &quot;AttachStderr&quot;: true,<br>            &quot;Tty&quot;: true,<br>            &quot;OpenStdin&quot;: true,<br>            &quot;StdinOnce&quot;: true,<br>            &quot;Env&quot;: [<br>                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;<br>            ],<br>            &quot;Cmd&quot;: [<br>                &quot;/bin/bash&quot;<br>            ],<br>            &quot;Image&quot;: &quot;centos&quot;,<br>            &quot;Volumes&quot;: null,<br>            &quot;WorkingDir&quot;: &quot;&quot;,<br>            &quot;Entrypoint&quot;: null,<br>            &quot;OnBuild&quot;: null,<br>            &quot;Labels&quot;: &#123;<br>                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,<br>                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,<br>                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,<br>                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,<br>                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;<br>            &#125;<br>        &#125;,<br>        &quot;NetworkSettings&quot;: &#123;<br>            &quot;Bridge&quot;: &quot;&quot;,<br>            &quot;SandboxID&quot;: &quot;e1251439f6970af7a132751b9c2f1bc9bcd997589ed16c1824047626a5c34153&quot;,<br>            &quot;HairpinMode&quot;: false,<br>            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,<br>            &quot;LinkLocalIPv6PrefixLen&quot;: 0,<br>            &quot;Ports&quot;: &#123;&#125;,<br>            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/e1251439f697&quot;,<br>            &quot;SecondaryIPAddresses&quot;: null,<br>            &quot;SecondaryIPv6Addresses&quot;: null,<br>            &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;,<br>            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>            &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>            &quot;GlobalIPv6PrefixLen&quot;: 0,<br>            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>            &quot;IPPrefixLen&quot;: 16,<br>            &quot;IPv6Gateway&quot;: &quot;&quot;,<br>            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>            &quot;Networks&quot;: &#123;<br>                &quot;bridge&quot;: &#123;<br>                    &quot;IPAMConfig&quot;: null,<br>                    &quot;Links&quot;: null,<br>                    &quot;Aliases&quot;: null,<br>                    &quot;NetworkID&quot;: &quot;46238680691e2ebb3e190ccf96fb7814787a55c663b4585dae38cd8e3abc4070&quot;,<br>                    &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;,<br>                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>                    &quot;IPPrefixLen&quot;: 16,<br>                    &quot;IPv6Gateway&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6PrefixLen&quot;: 0,<br>                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>                    &quot;DriverOpts&quot;: null<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br>[bupt_114@AIServer ~]$ <br></code></pre></td></tr></table></figure><p><strong>进入当前正在运行的容器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令1</span><br>docker exec -it 容器id bashShell<br><br>[bupt_114@AIServer ~]$ docker exec -it 8d05d658639d /bin/bash<br>[root@8d05d658639d /]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">命令2，注意进入的是一个正在进行的命令行！！！！而不是开启一个新的窗口</span><br>docker attach 容器id<br><br>[bupt_114@AIServer ~]$ docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES<br>8d05d658639d   centos    &quot;/bin/bash&quot;   8 minutes ago   Up 8 minutes             pensive_dirac<br>[bupt_114@AIServer ~]$ docker attach 8d05d658639d<br>[root@8d05d658639d /]# ps -ef   <br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 13:37 pts/0    00:00:00 /bin/bash<br>root        30     1  0 13:45 pts/0    00:00:00 ps -ef<br>[root@8d05d658639d /]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">docker <span class="hljs-built_in">exec</span> <span class="hljs-comment"># 进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">dockerattach <span class="hljs-comment"># 进入容器正在执行的终端，不会启动新的进程！</span></span><br></code></pre></td></tr></table></figure><p><strong>从容器内拷贝文件到主机</strong> 注：从主机内拷到容器内一般用挂载来做！</p><p>容器内外是隔离的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp 容器id:容器内路径 目的的主机路径<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝使用一个手动过程，未来我们使用 -v 卷的技术，可以实现</span><br></code></pre></td></tr></table></figure><p>学习方式：命令全部跟着敲一遍，自己记录笔记</p><h2 id="docker命令小结"><a href="#docker命令小结" class="headerlink" title="docker命令小结"></a>docker命令小结</h2><p><img src="/images/2022-01-08-00-24-45.png"></p><p>docker的命令是十分多的，上边是常见的容器和镜像命令</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记2-安装环境-狂神视频</title>
    <link href="/2022/01/07/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/07/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>本篇博客记录根据狂神视频学习的Docker安装过程和一些安装后的基本配置</p><p>TODO 未来将在此博客补充Docker的离线部署过程，在真实的使用场景下还是有很多离线部署的场景需求的</p><span id="more"></span><h1 id="Docker安装环境和一些基础配置"><a href="#Docker安装环境和一些基础配置" class="headerlink" title="Docker安装环境和一些基础配置"></a>Docker安装环境和一些基础配置</h1><h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><p><strong>注，下述安装过程是联网配置的过程，如果是离线部署的话还需要未来进一步学习</strong></p><blockquote><p>环境准备</p></blockquote><p>1、需要会一点点Linux的基础；<br>2、CentOS7；<br>3、使用finalshell连接远程服务器进行操作；</p><p>个人在学习过程中在拥有root权限的zfx223服务器上操作，这样比较方便安装各种依赖环境等。环境查看如下所示：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 系统内核是3.10以上的</span><br>[root<span class="hljs-symbol">@AIServer</span> ~]<span class="hljs-meta"># uname -r</span><br><span class="hljs-number">3.10</span><span class="hljs-number">.0</span><span class="hljs-number">-957.</span>el7.x86_64<br>[root<span class="hljs-symbol">@AIServer</span> ~]<span class="hljs-meta"># </span><br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 查看系统版本</span><br><span class="hljs-section">[root@AIServer ~]</span><span class="hljs-comment"># cat /etc/os-release</span><br><span class="hljs-attr">NAME</span>=<span class="hljs-string">&quot;CentOS Linux&quot;</span><br><span class="hljs-attr">VERSION</span>=<span class="hljs-string">&quot;7 (Core)&quot;</span><br><span class="hljs-attr">ID</span>=<span class="hljs-string">&quot;centos&quot;</span><br><span class="hljs-attr">ID_LIKE</span>=<span class="hljs-string">&quot;rhel fedora&quot;</span><br><span class="hljs-attr">VERSION_ID</span>=<span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-attr">PRETTY_NAME</span>=<span class="hljs-string">&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="hljs-attr">ANSI_COLOR</span>=<span class="hljs-string">&quot;0;31&quot;</span><br><span class="hljs-attr">CPE_NAME</span>=<span class="hljs-string">&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="hljs-attr">HOME_URL</span>=<span class="hljs-string">&quot;https://www.centos.org/&quot;</span><br><span class="hljs-attr">BUG_REPORT_URL</span>=<span class="hljs-string">&quot;https://bugs.centos.org/&quot;</span><br><br><span class="hljs-attr">CENTOS_MANTISBT_PROJECT</span>=<span class="hljs-string">&quot;CentOS-7&quot;</span><br><span class="hljs-attr">CENTOS_MANTISBT_PROJECT_VERSION</span>=<span class="hljs-string">&quot;7&quot;</span><br><span class="hljs-attr">REDHAT_SUPPORT_PRODUCT</span>=<span class="hljs-string">&quot;centos&quot;</span><br><span class="hljs-attr">REDHAT_SUPPORT_PRODUCT_VERSION</span>=<span class="hljs-string">&quot;7&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>安装</p></blockquote><p>参考帮助文档，docs.docker.com</p><p><img src="/images/2022-01-08-00-05-32.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1、 卸载旧的版本</span><br>[root@AIServer ~]# yum remove docker \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">                  docker-client \</span><br><span class="language-bash">&gt;                   docker-client-latest \</span><br><span class="language-bash">&gt;                   docker-common \</span><br><span class="language-bash">&gt;                   docker-latest \</span><br><span class="language-bash">&gt;                   docker-latest-logrotate \</span><br><span class="language-bash">&gt;                   docker-logrotate \</span><br><span class="language-bash">&gt;                   docker-engine</span><br>已加载插件：fastestmirror, langpacks<br>参数 docker 没有匹配<br>参数 docker-client 没有匹配<br>参数 docker-client-latest 没有匹配<br>参数 docker-common 没有匹配<br>参数 docker-latest 没有匹配<br>参数 docker-latest-logrotate 没有匹配<br>参数 docker-logrotate 没有匹配<br>参数 docker-engine 没有匹配<br>不删除任何软件包<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">2、 需要的安装包</span><br>[root@AIServer ~]# yum install -y yum-utils<br>已加载插件：fastestmirror, langpacks<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * centos-gluster7: mirrors.aliyun.com<br> * centos-ovirt42: mirrors.aliyun.com<br> * centos-ovirt43: mirrors.aliyun.com<br> * centos-qemu-ev: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.huaweicloud.com<br>base                                                                                                                                                     | 3.6 kB  00:00:00     <br>centos-gluster7                                                                                                                                          | 3.0 kB  00:00:00     <br>centos-ovirt42                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-ovirt43                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-qemu-ev                                                                                                                                           | 3.0 kB  00:00:00     <br>centos-release-opstools                                                                                                                                  | 2.9 kB  00:00:00     <br>extras                                                                                                                                                   | 2.9 kB  00:00:00     <br>updates                                                                                                                                                  | 2.9 kB  00:00:00     <br>正在解决依赖关系<br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">正在检查事务</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">软件包 yum-utils.noarch.0.1.1.31-50.el7 将被 升级</span><br><span class="hljs-meta prompt_">---&gt; </span><span class="language-bash">软件包 yum-utils.noarch.0.1.1.31-54.el7_8 将被 更新</span><br><span class="hljs-meta prompt_">--&gt; </span><span class="language-bash">解决依赖关系完成</span><br><br>依赖关系解决<br><br>================================================================================================================================================================================<br> Package                                   架构                                   版本                                               源                                    大小<br>================================================================================================================================================================================<br>正在更新:<br> yum-utils                                 noarch                                 1.1.31-54.el7_8                                    base                                 122 k<br><br>事务概要<br>================================================================================================================================================================================<br>升级  1 软件包<br><br>总计：122 k<br>Downloading packages:<br>Running transaction check<br>Running transaction test<br>Transaction test succeeded<br>Running transaction<br>  正在更新    : yum-utils-1.1.31-54.el7_8.noarch                                                                                                                            1/2 <br>  清理        : yum-utils-1.1.31-50.el7.noarch                                                                                                                              2/2 <br>  验证中      : yum-utils-1.1.31-54.el7_8.noarch                                                                                                                            1/2 <br>  验证中      : yum-utils-1.1.31-50.el7.noarch                                                                                                                              2/2 <br><br>更新完毕:<br>  yum-utils.noarch 0:1.1.31-54.el7_8                                                                                                                                            <br><br>完毕！<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">3、 设置镜像的仓库（通过仓库的方法进行安装）<br><br>sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo  # 默认是从国外下载的，十分慢<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过如下方式找到国内的</span><br>https://blog.csdn.net/lvdingding/article/details/112862396<br><br>yum-config-manager \<br>--add-repo \<br>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br><br>[root@AIServer ~]# yum-config-manager \<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">--add-repo \</span><br><span class="language-bash">&gt; http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br>已加载插件：fastestmirror, langpacks<br>adding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>grabbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.repo<br>repo saved to /etc/yum.repos.d/docker-ce.repo<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">更新yum软件包索引，下述步骤中的fastestmirror还需要进一步学习</span><br>yum makecache <br><br>[root@AIServer ~]# yum makecache fast<br>已加载插件：fastestmirror, langpacks<br>Loading mirror speeds from cached hostfile<br> * base: mirrors.aliyun.com<br> * centos-gluster7: mirrors.aliyun.com<br> * centos-ovirt42: mirrors.aliyun.com<br> * centos-ovirt43: mirrors.aliyun.com<br> * centos-qemu-ev: mirrors.aliyun.com<br> * extras: mirrors.aliyun.com<br> * updates: mirrors.huaweicloud.com<br>base                                                                                                                                                     | 3.6 kB  00:00:00     <br>centos-gluster7                                                                                                                                          | 3.0 kB  00:00:00     <br>centos-ovirt42                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-ovirt43                                                                                                                                           | 2.9 kB  00:00:00     <br>centos-qemu-ev                                                                                                                                           | 3.0 kB  00:00:00     <br>centos-release-opstools                                                                                                                                  | 2.9 kB  00:00:00     <br>docker-ce-stable                                                                                                                                         | 3.5 kB  00:00:00     <br>extras                                                                                                                                                   | 2.9 kB  00:00:00     <br>updates                                                                                                                                                  | 2.9 kB  00:00:00     <br>元数据缓存已建立<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">4、安装docker相关的 docker-ce社区版， ee企业版  安装的过程一路<span class="hljs-built_in">yes</span>过去~</span><br>yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">5、 启动docker<br>systemctl start docker<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">6、 使用docker version查看是否安装成功<br>[bupt_114@AIServer ~]$ docker version  # 查看是否安装成功<br>Client: Docker Engine - Community<br> Version:           20.10.12<br> API version:       1.41<br> Go version:        go1.16.12<br> Git commit:        e91ed57<br> Built:             Mon Dec 13 11:45:41 2021<br> OS/Arch:           linux/amd64<br> Context:           default<br> Experimental:      true<br><br>......<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">7、 hello-world<br><br>docker run hello-world<br></code></pre></td></tr></table></figure><p><img src="/images/2022-01-08-00-06-12.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">8、 查看一下下载的这个hello-world镜像<br>[root@AIServer ~]# docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   3 months ago   13.3kB<br>[root@AIServer ~]# <br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">了解，卸载docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载依赖</span><br>sudo yum remove docker-ce docker-ce-cli containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除资源</span><br>sudo rm -rf /var/lib/docker<br>sudo rm -rf /var/lib/containerd<br></code></pre></td></tr></table></figure><h2 id="Docker各个用户权限的设置，用户组"><a href="#Docker各个用户权限的设置，用户组" class="headerlink" title="Docker各个用户权限的设置，用户组"></a>Docker各个用户权限的设置，用户组</h2><p>Reference: <a href="https://www.cnblogs.com/franson-2016/p/6412971.html">https://www.cnblogs.com/franson-2016/p/6412971.html</a></p><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><p>这是针对在阿里云上购买而言的，而且好像要收费？</p><p>1、登录阿里云，找到容器服务<br>2、找到镜像加速地址<br>3、配置使用</p><h2 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h2><p><img src="/images/2022-01-08-00-09-18.png"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker是怎么工作的</strong></p><p>Docker是一个Clinet-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问</p><p>DockerServer接收到Docker-Client的指令，就会执行这个命令！</p><p><img src="/images/2022-01-08-00-09-49.png"></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层。<br>2、Docker利用的是宿主机的内核，vm需要是Guest OS。</p><p><img src="/images/2022-01-08-00-10-23.png"></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！</p><p><img src="/images/2022-01-08-00-10-57.png"></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>1614.括号的最大嵌套深度-python</title>
    <link href="/2022/01/07/algorithms/leetcode-python/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-python/"/>
    <url>/2022/01/07/algorithms/leetcode-python/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-python/</url>
    
    <content type="html"><![CDATA[<p>1614.括号的最大嵌套深度（简单）</p><p>题目大意：</p><p>如果字符串满足以下条件之一，则可以称之为<strong>有效括号字符串（valid parentheses string</strong>，可以简写为<strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串<code>&quot;&quot;</code>，或者是一个不为<code>&quot;(&quot;</code>或<code>&quot;)&quot;</code>的单字符。</li><li>字符串可以写为<code>AB</code>（<code>A</code>与<code>B</code>字符串连接），其中<code>A</code>和<code>B</code>都是 有效括号字符串 。</li><li>字符串可以写为<code>(A)</code>，其中<code>A</code>是一个 有效括号字符串 。</li></ul><p>类似地，可以定义任何有效括号字符串<code>S</code>的 嵌套深度<code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中<code>C</code>是单个字符的字符串，且该字符不是<code>&quot;(&quot;</code>或者<code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中<code>A</code>和<code>B</code>都是 有效括号字符串</li><li><code>epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中<code>A</code>是一个 有效括号字符串</li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code>都是 有效括号字符串（嵌套深度分别为 0、1、2），而<code>&quot;)(&quot;</code>、<code>&quot;(()&quot;</code>都不是 有效括号字符串 。</p><p>给你一个<strong>有效括号字符串</strong><code>s</code>，返回该字符串的<code>s</code><strong>嵌套深度</strong>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/">题目链接</a></p><p>题目大意：</p><p>如果字符串满足以下条件之一，则可以称之为<strong>有效括号字符串（valid parentheses string</strong>，可以简写为<strong>VPS</strong>）：</p><ul><li>字符串是一个空字符串<code>&quot;&quot;</code>，或者是一个不为<code>&quot;(&quot;</code>或<code>&quot;)&quot;</code>的单字符。</li><li>字符串可以写为<code>AB</code>（<code>A</code>与<code>B</code>字符串连接），其中<code>A</code>和<code>B</code>都是 有效括号字符串 。</li><li>字符串可以写为<code>(A)</code>，其中<code>A</code>是一个 有效括号字符串 。</li></ul><p>类似地，可以定义任何有效括号字符串<code>S</code>的 嵌套深度<code>depth(S)</code>：</p><ul><li><code>depth(&quot;&quot;) = 0</code></li><li><code>depth(C) = 0</code>，其中<code>C</code>是单个字符的字符串，且该字符不是<code>&quot;(&quot;</code>或者<code>&quot;)&quot;</code></li><li><code>depth(A + B) = max(depth(A), depth(B))</code>，其中<code>A</code>和<code>B</code>都是 有效括号字符串</li><li><code>epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)</code>，其中<code>A</code>是一个 有效括号字符串</li></ul><p>例如：<code>&quot;&quot;</code>、<code>&quot;()()&quot;</code>、<code>&quot;()(()())&quot;</code>都是 有效括号字符串（嵌套深度分别为 0、1、2），而<code>&quot;)(&quot;</code>、<code>&quot;(()&quot;</code>都不是 有效括号字符串 。</p><p>给你一个<strong>有效括号字符串</strong><code>s</code>，返回该字符串的<code>s</code><strong>嵌套深度</strong>。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1+(2*3)+((8)/4))+1&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：数字 <span class="hljs-number">8</span> 在嵌套的 <span class="hljs-number">3</span> 层括号中。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(1)+((2))+(((3)))&quot;</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1+(2*3)/(2-1)&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 由数字 0-9 和字符 ‘+’、’-‘、’*’、’&#x2F;‘、’(‘、’)’ 组成</li><li>题目数据保证括号表达式 s 是 有效的括号表达式</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题如果是python的话只要搞个list模拟栈就可以了，每次操作的时候判断当前list的长度，来更新max_depth还是很简单的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxDepth</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        stack = []<br>        max_depth = -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;(&#x27;</span>:<br>                stack.append(c)<br>            <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;)&#x27;</span>:<br>                stack = stack[:-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 截断到最后一个</span><br>            <br>            max_depth = <span class="hljs-built_in">max</span>(max_depth, <span class="hljs-built_in">len</span>(stack))<br>        <span class="hljs-keyword">return</span> max_depth<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64.最小路径和-python</title>
    <link href="/2022/01/06/algorithms/leetcode-python/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-python/"/>
    <url>/2022/01/06/algorithms/leetcode-python/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>64.最小路径和（中等）</p><p>题目大意：</p><p>给定一个包含非负整数的<code>m x n</code>网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">题目链接</a></p><p>题目大意：</p><p>给定一个包含非负整数的<code>m x n</code>网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p>示例1：<br><img src="/images/2022-01-06-14-30-08.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,3,1],[1,5,1],[4,2,1]]</span><br>输出：<span class="hljs-number">7</span><br>解释：因为路径 <span class="hljs-number">1</span>→<span class="hljs-number">3</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span>→<span class="hljs-number">1</span> 的总和最小。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：grid = <span class="hljs-string">[[1,2,3],[4,5,6]]</span><br>输出：<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; grid.length</li><li>n &#x3D;&#x3D; grid[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 200</li><li>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>也是一眼就能看出来是二维dp的题目，往下走和往右都是只有一种不断累加的走法</p><p>之后的状态转移方程<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minPathSum</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[int]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 一眼dp，然后想想dp的思路应该也挺简单的，做一个min应该就行吧</span><br>        m = <span class="hljs-built_in">len</span>(grid)<br>        n = <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <br>        <span class="hljs-comment"># 初始化dp数组的第一行，第一列</span><br>        <span class="hljs-comment">## 初始化dp数组的第一行</span><br>        now = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            now += grid[<span class="hljs-number">0</span>][i]<br>            dp[<span class="hljs-number">0</span>][i] = now<br>        <span class="hljs-comment">## 初始化dp数组的第一列</span><br>        now = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            now += grid[i][<span class="hljs-number">0</span>]<br>            dp[i][<span class="hljs-number">0</span>] = now<br>        <span class="hljs-comment"># print(dp)</span><br><br>        <span class="hljs-comment">##</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j]<br>        <br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>62.不同路径-python</title>
    <link href="/2022/01/06/algorithms/leetcode-python/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-python/"/>
    <url>/2022/01/06/algorithms/leetcode-python/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-python/</url>
    
    <content type="html"><![CDATA[<p>62.不同路径（中等）</p><p>题目大意：</p><p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/unique-paths/">题目链接</a></p><p>题目大意：</p><p>一个机器人位于一个<code>m x n</code>网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p>示例1：<br><img src="/images/2022-01-06-14-14-44.png"></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">7</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入：m = <span class="hljs-number">3</span>, n = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">3</span><br>解释：<br>从左上角开始，总共有 <span class="hljs-number">3</span> 条路径可以到达右下角。<br><span class="hljs-number">1.</span> 向右 -&gt; 向下 -&gt; 向下<br><span class="hljs-number">2.</span> 向下 -&gt; 向下 -&gt; 向右<br><span class="hljs-number">3.</span> 向下 -&gt; 向右 -&gt; 向下<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">7</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">28</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：m = <span class="hljs-number">3</span>, <span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于<code>2 * 109</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>很明显的二维dp，向下走的所有格子和向右走的所有格子都只有一种走法，所以初始化为1</p><p>之后的状态转移方程很好想<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">uniquePaths</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)]<br>        <span class="hljs-comment"># 把第一行第一列进行初始化，第一行第一列都只有一种走法</span><br>        <span class="hljs-comment">## 第一行 </span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span><br>        <span class="hljs-comment">## 第一列</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>            dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 开启新的dp状态转移</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, m):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>                <span class="hljs-comment"># 新的mn位置处有几种到达走法</span><br>                dp[i][j] = dp[i][j-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">1</span>][j]<br><br>        <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>数学</tag>
      
      <tag>组合数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>141.环形链表-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-python/</url>
    
    <content type="html"><![CDATA[<p>141.环形链表（简单）</p><p>题目大意：</p><p>给你一个链表的头节点<code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪<code>next</code>指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。如果<code>pos</code>是<code>-1</code>，则在该链表中没有环。注意：<code>pos</code>不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">题目链接</a></p><p>题目大意：</p><p>给你一个链表的头节点<code>head</code>，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪<code>next</code>指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从 <code>0</code>开始）。如果<code>pos</code>是<code>-1</code>，则在该链表中没有环。注意：<code>pos</code>不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回<code>true</code>。 否则，返回<code>false</code>。</p><p>示例1：<br><img src="/images/2022-01-05-23-41-23.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-01-05-23-41-35.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p>示例3：<br><img src="/images/2022-01-05-23-41-45.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;&#x3D; Node.val &lt;&#x3D; 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><p>进阶：你能用 O(1)（即，常量）内存解决此问题吗？</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, x</span>):<br>        self.val = x<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h2 id="方法1，普通的字典法"><a href="#方法1，普通的字典法" class="headerlink" title="方法1，普通的字典法"></a>方法1，普通的字典法</h2><p>这个node对象是可哈希化的，可以用来当做键，所以设置一个字典就知道了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        save_dict = &#123;&#125;<br>        <span class="hljs-keyword">while</span> head != <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> save_dict.get(head) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            save_dict[head] = <span class="hljs-number">1</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="方法2，巧妙的修改值法"><a href="#方法2，巧妙的修改值法" class="headerlink" title="方法2，巧妙的修改值法"></a>方法2，巧妙的修改值法</h2><p>妙！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> head != <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">if</span> head.val == <span class="hljs-string">&quot;啊哈哈哈哈&quot;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">else</span>:<br>                head.val = <span class="hljs-string">&quot;啊哈哈哈哈&quot;</span><br>            head = head.<span class="hljs-built_in">next</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h2 id="方法3，快慢指针"><a href="#方法3，快慢指针" class="headerlink" title="方法3，快慢指针"></a>方法3，快慢指针</h2><p>一个慢的乌龟和一个快的兔子，兔子跑得快，如果有环那兔子是总能追上乌龟的</p><p>快慢指针需要注意不能条件的判断，要把例如head和head.next这种的一起来判断！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hasCycle</span>(<span class="hljs-params">self, head</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type head: ListNode</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 先要把异常判断做好了</span><br>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>        slow_turtle = head<br>        fast_rabbit = head.<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">while</span> slow_turtle != fast_rabbit:<br>            <span class="hljs-keyword">if</span> fast_rabbit <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> fast_rabbit.<span class="hljs-built_in">next</span> <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                slow_turtle = slow_turtle.<span class="hljs-built_in">next</span><br>                fast_rabbit = fast_rabbit.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>双指针</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49.字母异位词分组-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-python/</url>
    
    <content type="html"><![CDATA[<p>49.字母异位词分组（中等）</p><p>题目大意：</p><p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong>是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/">题目链接</a></p><p>给你一个字符串数组，请你将<strong>字母异位词</strong>组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong>是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: strs = [<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>]<br>输出: [[<span class="hljs-string">&quot;bat&quot;</span>],[<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],[<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>]]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;&quot;]]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: strs = [<span class="hljs-string">&quot;a&quot;</span>]<br>输出: <span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code>仅包含小写字母</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题想想自己做法也挺奇葩的，只能说Counter永远的神了</p><p>先重整理数组，在原有的字符串基础上变成<code>[字符串, Counter对象, 标记位（标记是否已经加入了）]</code></p><p>一个两重for循环，在外层for循环中，如果没有加入则加入，如果已经加入了则continue。在内层循环中，a-b, b-a判断Counter是否相等（这里比如a是外层的i，b是内层的j），如果相等并且没加入，就加入到外层循环初始化的list中，然后内层循环结束后append</p><p><strong>Counter永远的神！（除了效率hhh）</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">groupAnagrams</span>(<span class="hljs-params">self, strs</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type strs: List[str]</span><br><span class="hljs-string">        :rtype: List[List[str]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br>        <br>        <span class="hljs-comment"># 一旦用上Coutner耗时就会很高？ 不过Counter真的是个好东西</span><br>        temp_list = []<br>        <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(strs):<br>            temp_list.append([item, Counter(item), <span class="hljs-number">0</span>])  <span class="hljs-comment"># 0是一个标记位，标记是否被加进去了</span><br>        <br>        return_list = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(temp_list)):<br>            <span class="hljs-keyword">if</span> temp_list[i][<span class="hljs-number">2</span>] == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">continue</span><br>            add_list = [temp_list[i][<span class="hljs-number">0</span>]]<br>            temp_list[i][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(temp_list)):<br>                <span class="hljs-keyword">if</span> temp_list[j][<span class="hljs-number">1</span>] == temp_list[i][<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> temp_list[j][<span class="hljs-number">2</span>] == <span class="hljs-number">0</span>:<br>                    add_list.append(temp_list[j][<span class="hljs-number">0</span>])<br>                    temp_list[j][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br>            return_list.append(add_list)<br>            add_list = []<br>    <br>        <span class="hljs-keyword">return</span> return_list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48.旋转图像-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-python/</url>
    
    <content type="html"><![CDATA[<p>48.旋转图像（中等）</p><p>题目大意：</p><p>给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/">题目链接</a></p><p>题目大意：</p><p>给定一个<code>n × n</code>的二维矩阵<code>matrix</code>表示一个图像。请你将图像顺时针旋转<code>90</code>度。</p><p>你必须在<strong>原地</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p>示例1：<br><img src="/images/2022-01-05-21-46-28.png"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2,3],[4,5,6],[7,8,9]]</span><br>输出：<span class="hljs-string">[[7,4,1],[8,5,2],[9,6,3]]</span><br></code></pre></td></tr></table></figure><p>示例2：<br><img src="/images/2022-01-05-21-46-42.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：matrix = <span class="hljs-comment">[<span class="hljs-comment">[5,1,9,11]</span>,<span class="hljs-comment">[2,4,8,10]</span>,<span class="hljs-comment">[13,3,6,7]</span>,<span class="hljs-comment">[15,14,12,16]</span>]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[15,13,2,5]</span>,<span class="hljs-comment">[14,3,4,1]</span>,<span class="hljs-comment">[12,6,8,9]</span>,<span class="hljs-comment">[16,7,10,11]</span>]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1]]</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[1,2],[3,4]]</span><br>输出：<span class="hljs-string">[[3,1],[4,2]]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>matrix.length == n</code></li><li><code>matrix[i].length == n</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>直接硬转实在是太考验人了，所以现在是两种方法，这样算起来就变简单非常多了</p><ul><li>先水平翻转，再沿副对角线翻转</li><li>先上下翻转，再沿主对角线翻转</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self, matrix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type matrix: List[List[int]]</span><br><span class="hljs-string">        :rtype: None Do not return anything, modify matrix in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 首先进行左右翻转，然后按照副对角线进行翻转，在torch里是triu相关的操作，哈哈</span><br>        n = <span class="hljs-built_in">len</span>(matrix)  <span class="hljs-comment"># 一个 nxn 的矩阵</span><br>        <span class="hljs-comment">## 执行左右翻转</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n//<span class="hljs-number">2</span>):<br>                <span class="hljs-comment"># 执行翻转</span><br>                temp = matrix[i][j]<br>                matrix[i][j] = matrix[i][n-<span class="hljs-number">1</span>-j]<br>                matrix[i][n-<span class="hljs-number">1</span>-j] = temp<br>        <span class="hljs-comment"># print(matrix)</span><br>        <span class="hljs-comment">## 按照副对角线进行翻转，事后复盘来看的话，按照副对角线翻转有些复杂了</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>-i):<br>                <span class="hljs-comment"># 执行翻转</span><br>                temp = matrix[i][j]<br>                matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-j][n-<span class="hljs-number">1</span>-i]<br>                matrix[n-<span class="hljs-number">1</span>-j][n-<span class="hljs-number">1</span>-i] = temp<br>                <br>                <span class="hljs-comment"># print(i, j)</span><br>        <br>        <span class="hljs-comment"># print(matrix)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1576.替换所有的问号-python</title>
    <link href="/2022/01/05/algorithms/leetcode-python/1576-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7-python/"/>
    <url>/2022/01/05/algorithms/leetcode-python/1576-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7-python/</url>
    
    <content type="html"><![CDATA[<p>1576.替换所有的问号（简单）</p><p>题目大意：</p><p>给你一个仅包含小写英文字母和<code>&#39;?&#39;</code>字符的字符串<code>s</code>，请你将所有的<code>&#39;?&#39;</code>转换为若干小写字母，使最终的字符串不包含任何<strong>连续重复</strong>的字符。</p><p>注意：你<strong>不能</strong>修改非<code>&#39;?&#39;</code>字符。</p><p>题目测试用例保证<strong>除</strong><code>&#39;?&#39;</code>字符<strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/">题目链接</a></p><p>题目大意：</p><p>给你一个仅包含小写英文字母和<code>&#39;?&#39;</code>字符的字符串<code>s</code>，请你将所有的<code>&#39;?&#39;</code>转换为若干小写字母，使最终的字符串不包含任何<strong>连续重复</strong>的字符。</p><p>注意：你<strong>不能</strong>修改非<code>&#39;?&#39;</code>字符。</p><p>题目测试用例保证<strong>除</strong><code>&#39;?&#39;</code>字符<strong>之外</strong>，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;?zs&quot;</span><br>输出：<span class="hljs-string">&quot;azs&quot;</span><br>解释：该示例共有 <span class="hljs-number">25</span> 种解决方案，从 <span class="hljs-string">&quot;azs&quot;</span> 到 <span class="hljs-string">&quot;yzs&quot;</span> 都是符合题目要求的。只有 <span class="hljs-string">&quot;z&quot;</span> 是无效的修改，因为字符串 <span class="hljs-string">&quot;zzs&quot;</span> 中有连续重复的两个 &#x27;z&#x27; 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ubv?w&quot;</span><br>输出：<span class="hljs-string">&quot;ubvaw&quot;</span><br>解释：该示例共有 <span class="hljs-number">24</span> 种解决方案，只有替换成 <span class="hljs-string">&quot;v&quot;</span> 和 <span class="hljs-string">&quot;w&quot;</span> 不符合题目要求。因为 <span class="hljs-string">&quot;ubvvw&quot;</span> 和 <span class="hljs-string">&quot;ubvww&quot;</span> 都包含连续重复的字符。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;j?qg??b&quot;</span><br>输出：<span class="hljs-string">&quot;jaqgacb&quot;</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;??yw?ipkj?&quot;</span><br>输出：<span class="hljs-string">&quot;acywaipkja&quot;</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s 仅包含小写英文字母和 ‘?’ 字符</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>每日一题还是挺简单的，这题主要注意的情况是一个字符最多相邻两个，也就是说只要准备三个需要被换的字符，比如<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>就可以了</p><p>另外是还需要判断问号连续出现的情况就行了</p><p>另：python的字符串处理最好先用列表，然后再join到一起，耗时问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">modifyString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 注意可能连续出现两个问号！！！！</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;?&#x27;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;a&quot;</span><br><br><br>        letters = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]  <span class="hljs-comment"># 必将在三个字母中找到答案！ 这个地方还是挺关键的</span><br>        return_list = []  <span class="hljs-comment"># python字符串，先用list，然后join回去</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] != <span class="hljs-string">&#x27;?&#x27;</span>:<br>                return_list.append(s[i])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != s[i+<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> i == <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != return_list[i-<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> letters:<br>                        <span class="hljs-keyword">if</span> letter != s[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> letter != return_list[i-<span class="hljs-number">1</span>]:<br>                            return_list.append(letter)<br>                            <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(return_list)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记1-背景-狂神视频</title>
    <link href="/2022/01/05/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E8%83%8C%E6%99%AF-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/"/>
    <url>/2022/01/05/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E8%83%8C%E6%99%AF-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/</url>
    
    <content type="html"><![CDATA[<p>在未来的项目部署中一定还会用到Docker，k8s等，该篇博客主要记录学习Docker的过程</p><p>之后还会整理一篇离线普通方式部署的博客，现在离线普通方式部署自己操作过几次弄的比较明白了，但是问题是对接方很难完全弄明白，所以也是学习Docker的原因之一吧</p><span id="more"></span><h1 id="Docker学习"><a href="#Docker学习" class="headerlink" title="Docker学习"></a>Docker学习</h1><ul><li>Docker概述</li><li>Docker安装</li><li>Docker命令<ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li>Docker镜像</li><li>容器数据卷</li><li>DockerFile</li><li>Docker网络原理</li><li>IDEA整合Docker</li><li>Docker Compose（集群编排）</li><li>Docker Swarm（集群管理，简化版k8s）</li><li>CI&#x2F;CD Jenkins</li></ul><h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现"><a href="#Docker为什么出现" class="headerlink" title="Docker为什么出现"></a>Docker为什么出现</h2><p>一款产品：开发-上线，两套环境！环境部署一次是非常麻烦的，应用环境，应用配置等</p><p>开发 —- 运维。问题：我在我的电脑上可以运行！版本更新，导致服务不可用（例如最近的log4j漏洞更新）！对于运维来说比较麻烦</p><p>开发即运维！环境配置是十分的麻烦，每一个机器都要部署环境（集群Redis，ES，Hadoop……）！费时费力。</p><p>发布一个项目，（jar + （Redis，MySQL，ES，jdk））一整套的环境，项目能不能都带上环境安装打包！</p><p>之前在服务器配置一个应用的环境Redis，MySQL，ES，jdk，Hadoop，配置超麻烦了，不能够跨平台。</p><p>Windows，最后发布到Linux，环境上的区别很大</p><p>传统：开发给一个jar包，其他交给运维来做</p><p>现在：开发打包部署上线，一套流程做完</p><p>&amp;nbsp;</p><p>java – apk – 发布（应用商店） – 张三使用apk – 安装即可用！</p><p>java – jar（环境） – 打包项目带上环境（镜像） – （Docker仓库：商店） – 下载我们发布的镜像 – 直接运行即可！</p><p>&amp;nbsp;</p><p>Docker给以上问题提出了解决方案，思想就来自于集装箱！</p><p>JRE – 多个应用（端口冲突） – 原来都是交叉的！</p><p><strong>隔离</strong>：Docker核心思想！打包装箱！每个箱子是互相隔离的</p><p>水果 生化武器</p><p>Docker通过隔离机制，可以将服务器利用到极致！</p><p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！（Error analyze）</p><p>&amp;nbsp;</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>API小子哈哈哈哈，我爬了，还是做API小子吧</p><p>2013年docker开源，2014.4.9 docker1.0开源，相较于虚拟机非常轻量化。docker是一种容器技术。</p><p>虚拟机也是属于虚拟化技术，Docker容器技术也是一种虚拟化技术！</p><p>vm：centos等等，隔离，需要开启多个虚拟机！几G</p><p>docker：隔离，镜像（最核心的环境4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！</p><blockquote><p>聊聊docker</p></blockquote><p>Docker是基于Go语言开发的！是一个开源项目</p><p><a href="http://www.docker.com/">www.docker.com</a></p><p>docs.docker.com，Docker的文档是非常详细的</p><p>仓库地址：hub.docker.com git push, pull等等</p><p>虚拟化，容器沙箱机制</p><h2 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h2><blockquote><p>之前的虚拟机技术</p></blockquote><p>虚拟机技术缺点：</p><p>1、资源占用非常多<br>2、冗余步骤多<br>3、启动很慢</p><blockquote><p>容器化技术 container</p></blockquote><p><strong>容器化技术不是模拟的一个完整的操作系统</strong></p><p><img src="/images/2022-01-05-15-40-13.png"></p><blockquote><p>比较Docker和虚拟机技术的不同</p></blockquote><ul><li>传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件；</li><li>容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li><li>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响</li></ul><blockquote><p>DevOps(开发、运维)</p></blockquote><p><strong>应用更快速的交付和部署</strong></p><p>传统：一堆帮助文档，安装程序</p><p>Docker：打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩缩容</strong></p><p>使用了docker之后，我们部署应用就像搭积木一样</p><p>Redis5，tomcat 分别升级</p><p>(redis, tomcat) 打包升级</p><p>水平扩展负载均衡</p><p><strong>更简单的系统运维</strong></p><p>在容器化之后，我们的开发，测试环境都是一致的，不会出现在我的电脑上能用，在别人的电脑上用不了这种情况</p><p><strong>更高效的计算资源利用</strong></p><p>一个服务器运行几十个redis等等，集群</p><p>Docker是内核级别的虚拟化，一个物理机上运行很多个容器实例</p><h1 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h1><p><img src="/images/2022-01-05-15-55-22.png"></p><p>分成了三个部分，客户端、服务器、仓库</p><p>docker run运行一个哦让你去</p><p>docker pull拉取</p><p>docker build …..</p><p>镜像运行起来就变成容器了！ tomcat镜像，tomcat1容器，tomcat2容器，等等</p><p><strong>镜像（image）：</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 &#x3D;&#x3D;&#x3D;&gt; run &#x3D;&#x3D;&#x3D;&gt; tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</p><p><strong>容器（container）：</strong></p><p>Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的</p><p>启动，停止，删除，基本命令！</p><p>目前就可以把这个容器理解为就是一个简易的linux系统，</p><p><strong>仓库（repository）：</strong></p><p>仓库就是存放镜像的地方！</p><ul><li>公有仓库</li><li>私有仓库</li></ul><p>Docker Hub（默认是国外的）</p><p>阿里云，都有容器服务（配置镜像加速）</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>274场LeetCode周赛</title>
    <link href="/2022/01/02/algorithms/leetcode-weekly-contest/274%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2022/01/02/algorithms/leetcode-weekly-contest/274%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>前三个感觉都是水题，自己做的话感觉难得的10-20分钟就搞定了，因为是后来做的看了眼大佬们最快都做了20多分钟，前三个题这么简单的话第四题估计自己现在的水平很难做出来了；</p><p>第一题：一个由ab组成的字符串，如果b出现过了后边就不能出现a了，用一个flag判断就可以了；</p><p>第二题：用Counter统计每行1的个数，然后把0的行排除掉，<code>result += count[i] * count[i+1]</code>就可以了；</p><p>第三题：还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了；</p><p>第四题：未来有机会再试了</p><span id="more"></span><h1 id="第一题：2124-检查是否所有A都在B之前"><a href="#第一题：2124-检查是否所有A都在B之前" class="headerlink" title="第一题：2124.检查是否所有A都在B之前"></a>第一题：2124.检查是否所有A都在B之前</h1><p><a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个<strong>仅</strong>由字符<code>&#39;a&#39;</code>和<code>&#39;b&#39;</code>组成的字符串<code>s</code>。如果字符串中 每个<code>&#39;a&#39;</code>都出现在 每个<code>&#39;b&#39;</code>之前，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;aaabbb&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br><span class="hljs-string">&#x27;a&#x27;</span> 位于下标 <span class="hljs-number">0</span>、<span class="hljs-number">1</span> 和 <span class="hljs-number">2</span> ；而 <span class="hljs-string">&#x27;b&#x27;</span> 位于下标 <span class="hljs-number">3</span>、<span class="hljs-number">4</span> 和 <span class="hljs-number">5</span> 。<br>因此，每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;abab&quot;</span><br>输出：<span class="hljs-literal">false</span><br>解释：<br>存在一个 <span class="hljs-string">&#x27;a&#x27;</span> 位于下标 <span class="hljs-number">2</span> ，而一个 <span class="hljs-string">&#x27;b&#x27;</span> 位于下标 <span class="hljs-number">1</span> 。<br>因此，不能满足每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">false</span> 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：s = <span class="hljs-string">&quot;bbb&quot;</span><br>输出：<span class="hljs-literal">true</span><br>解释：<br>不存在 <span class="hljs-string">&#x27;a&#x27;</span> ，因此可以视作每个 <span class="hljs-string">&#x27;a&#x27;</span> 都出现在每个 <span class="hljs-string">&#x27;b&#x27;</span> 之前，所以返回 <span class="hljs-literal">true</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 100</li><li>s[i] 为 ‘a’ 或 ‘b’</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>easy题，读懂题意就好</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">checkString</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        flag = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> flag == <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> c == <span class="hljs-string">&#x27;a&#x27;</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;b&#x27;</span>:<br>                flag = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2125-银行中的激光束数量"><a href="#第二题：2125-银行中的激光束数量" class="headerlink" title="第二题：2125.银行中的激光束数量"></a>第二题：2125.银行中的激光束数量</h1><p><a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>银行内部的防盗安全装置已经激活。给你一个下标从<strong>0</strong>开始的二进制字符串数组<code>bank</code>，表示银行的平面图，这是一个大小为<code>m x n</code>的二维矩阵。<code>bank[i]</code>表示第<code>i</code>行的设备分布，由若干<code>&#39;0&#39;</code>和若干<code>&#39;1&#39;</code>组成。<code>&#39;0&#39;</code>表示单元格是空的，而<code>&#39;1&#39;</code>表示单元格有一个安全设备。</p><p>对任意两个安全设备而言，<strong>如果同时</strong>满足下面两个条件，则二者之间存在 一个 激光束：</p><p>两个设备位于两个 不同行 ：<code>r1</code>和<code>r2</code>，其中<code>r1 &lt; r2</code>。<br>满足<code>r1 &lt; i &lt; r2</code>的<strong>所有</strong>行<code>i</code>，都<strong>没有安全设备</strong>。<br>激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。</p><p>返回银行中激光束的总数量。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：bank = [<span class="hljs-string">&quot;011001&quot;</span>,<span class="hljs-string">&quot;000000&quot;</span>,<span class="hljs-string">&quot;010100&quot;</span>,<span class="hljs-string">&quot;001000&quot;</span>]<br>输出：<span class="hljs-number">8</span><br>解释：在下面每组设备对之间，存在一条激光束。总共是 <span class="hljs-number">8</span> 条激光束：<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]<br> * bank[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] -- bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<br> * bank[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] -- bank[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<br> * bank[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] -- bank[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<br>注意，第 <span class="hljs-number">0</span> 行和第 <span class="hljs-number">3</span> 行上的设备之间不存在激光束。<br>这是因为第 <span class="hljs-number">2</span> 行存在安全设备，这不满足第 <span class="hljs-number">2</span> 个条件。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">输入：<span class="hljs-keyword">bank </span>= [<span class="hljs-string">&quot;000&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-string">&quot;000&quot;</span>]<br>输出：<span class="hljs-number">0</span><br>解释：不存在两个位于不同行的设备<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; bank.length</li><li>n &#x3D;&#x3D; bank[i].length</li><li>1 &lt;&#x3D; m, n &lt;&#x3D; 500</li><li>bank[i][j] 为 ‘0’ 或 ‘1’</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解题意就比较好做了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numberOfBeams</span>(<span class="hljs-params">self, bank</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type bank: List[str]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        result = <span class="hljs-number">0</span><br>        num_list = []<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> bank:<br>            count = Counter(<span class="hljs-built_in">list</span>(item))[<span class="hljs-string">&#x27;1&#x27;</span>]<br>            <span class="hljs-keyword">if</span> count != <span class="hljs-number">0</span>:<br>                num_list.append(count)<br><br>        <span class="hljs-comment"># print(num_list)</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(num_list) - <span class="hljs-number">1</span>):<br>            result += num_list[i] * num_list[i+<span class="hljs-number">1</span>]<br><br>        <span class="hljs-keyword">return</span> result<br></code></pre></td></tr></table></figure><h1 id="第三题：2126-摧毁小行星"><a href="#第三题：2126-摧毁小行星" class="headerlink" title="第三题：2126.摧毁小行星"></a>第三题：2126.摧毁小行星</h1><p><a href="https://leetcode-cn.com/problems/destroying-asteroids/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数<code>mass</code>，它表示一颗行星的初始质量。再给你一个整数数组<code>asteroids</code>，其中<code>asteroids[i]</code>是第<code>i</code>颗小行星的质量。</p><p>你可以按<strong>任意顺序</strong>重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量<strong>大于等于</strong>小行星的质量，那么小行星被<strong>摧毁</strong>，并且行星会<strong>获得</strong>这颗小行星的质量。否则，行星将被摧毁。</p><p>如果所有小行星<strong>都</strong>能被摧毁，请返回<code>true</code>，否则返回<code>false</code>。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mass = 10, asteroids = [3,9,19,5,21]<br>输出：true<br>解释：一种安排小行星的方式为 [9,19,5,3,21] ：<br>- 行星与质量为<span class="hljs-number"> 9 </span>的小行星碰撞。新的行星质量为：10 +<span class="hljs-number"> 9 </span>= 19<br>- 行星与质量为<span class="hljs-number"> 19 </span>的小行星碰撞。新的行星质量为：19 +<span class="hljs-number"> 19 </span>= 38<br>- 行星与质量为<span class="hljs-number"> 5 </span>的小行星碰撞。新的行星质量为：38 +<span class="hljs-number"> 5 </span>= 43<br>- 行星与质量为<span class="hljs-number"> 3 </span>的小行星碰撞。新的行星质量为：43 +<span class="hljs-number"> 3 </span>= 46<br>- 行星与质量为<span class="hljs-number"> 21 </span>的小行星碰撞。新的行星质量为：46 +<span class="hljs-number"> 21 </span>= 67<br>所有小行星都被摧毁。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：mass = 5, asteroids = [4,9,23,4]<br>输出：false<br>解释：<br>行星无论如何没法获得足够质量去摧毁质量为<span class="hljs-number"> 23 </span>的小行星。<br>行星把别的小行星摧毁后，质量为<span class="hljs-number"> 5 </span>+<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 22 </span>。<br>它比<span class="hljs-number"> 23 </span>小，所以无法摧毁最后一颗小行星。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; mass &lt;&#x3D; 105</li><li>1 &lt;&#x3D; asteroids.length &lt;&#x3D; 105</li><li>1 &lt;&#x3D; asteroids[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">asteroidsDestroyed</span>(<span class="hljs-params">self, mass, asteroids</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type mass: int</span><br><span class="hljs-string">        :type asteroids: List[int]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        tmp_list = []<br>        <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(asteroids):<br>            <span class="hljs-keyword">if</span> item &lt;= mass:<br>                mass += item<br>            <span class="hljs-keyword">else</span>:<br>                tmp_list.append(item)<br>        <br>        tmp_list = <span class="hljs-built_in">sorted</span>(tmp_list, reverse=<span class="hljs-literal">False</span>)<br>        <br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> tmp_list:<br>            <span class="hljs-keyword">if</span> item &lt;= mass:<br>                mass += item<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>贪心</tag>
      
      <tag>矩阵</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>273场LeetCode周赛</title>
    <link href="/2021/12/26/algorithms/leetcode-weekly-contest/273%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <url>/2021/12/26/algorithms/leetcode-weekly-contest/273%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>第一题：感觉比较水，123400倒过来是004321，再倒回去是1234和原来的数字不一样了，这样其实可以直接判断末尾是不是0，还有是不是单独一个0就可以了；</p><p>第二题：矩阵内简单的模拟，up down left right，经过这四个操作后，不能越过矩阵的边界就行了，后缀在python里<code>[i:]</code>好像比较简单；</p><p>第三题：在当时做的时候何老板就在想是不是和数学有关的，后来听了卿哥的解答后感觉最关键的是abcde这个思路，这样比较容易可能能想到前缀和后缀的问题了，对于一个数字2，比如其角标在<code>[a, b, c, d, e]</code>五个位置，那么根据题意可以模拟下每个位置下的和，这样能看出来之间的关系，详见下文解答；</p><p>第四题：未来有机会再试了；</p><span id="more"></span><h1 id="第一题：2119-反转两次的数字"><a href="#第一题：2119-反转两次的数字" class="headerlink" title="第一题：2119.反转两次的数字"></a>第一题：2119.反转两次的数字</h1><p><a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>反转</strong>一个整数意味着倒置它的所有位。</p><p>例如，反转<code>2021</code>得到<code>1202</code>。反转<code>12300</code>得到<code>321</code>，<strong>不保留前导零</strong>。<br>给你一个整数<code>num</code>，<strong>反转</strong><code>num</code>得到<code>reversed1</code>，<strong>接着反转</strong><code>reversed1</code>得到<code>reversed2</code>。如果<code>reversed2</code>等于<code>num</code>，返回<code>true</code>；否则，返回<code>false</code>。</p><p>示例1：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">526</span><br>输出：<span class="hljs-keyword">true</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">625</span> ，接着反转 <span class="hljs-number">625</span> 得到 <span class="hljs-number">526</span> ，等于 <span class="hljs-built_in">num</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">1800</span><br>输出：<span class="hljs-keyword">false</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">81</span> ，接着反转 <span class="hljs-number">81</span> 得到 <span class="hljs-number">18</span> ，不等于 <span class="hljs-built_in">num</span> 。 <br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">输入：<span class="hljs-built_in">num</span> = <span class="hljs-number">0</span><br>输出：<span class="hljs-keyword">true</span><br>解释：反转 <span class="hljs-built_in">num</span> 得到 <span class="hljs-number">0</span> ，接着反转 <span class="hljs-number">0</span> 得到 <span class="hljs-number">0</span> ，等于 <span class="hljs-built_in">num</span> 。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; num &lt;&#x3D; 106</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉不能被题面唬住了，还是判断后边有没有0就可以了，然后单独0的单独处理下；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isSameAfterReversals</span>(<span class="hljs-params">self, num</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type num: int</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-built_in">str</span>(num)) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(num)[-<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;0&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h1 id="第二题：2120-执行所有后缀指令"><a href="#第二题：2120-执行所有后缀指令" class="headerlink" title="第二题：2120.执行所有后缀指令"></a>第二题：2120.执行所有后缀指令</h1><p><a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有一个<code>n x n</code>大小的网格，左上角单元格坐标<code>(0, 0)</code>，右下角单元格坐标<code>(n - 1, n - 1)</code>。给你整数<code>n</code>和一个整数数组<code>startPos</code>，其中<code>startPos = [startrow, startcol]</code>表示机器人最开始在坐标为<code>(startrow, startcol)</code>的单元格上。</p><p>另给你一个长度为<code>m</code>、下标从<code>0</code>开始的字符串<code>s</code>，其中<code>s[i]</code>是对机器人的第<code>i</code>条指令：<code>&#39;L&#39;</code>（向左移动），<code>&#39;R&#39;</code>（向右移动），<code>&#39;U&#39;</code>（向上移动）和 <code>&#39;D&#39;</code>（向下移动）。</p><p>机器人可以从<code>s</code>中的任一第<code>i</code>条指令开始执行。它将会逐条执行指令直到<code>s</code>的末尾，但在满足下述条件之一时，机器人将会停止：</p><p>下一条指令将会导致机器人移动到网格外。<br>没有指令可以执行。<br>返回一个长度为<code>m</code>的数组<code>answer</code>，其中<code>answer[i]</code>是机器人从第<code>i</code>条指令 开始 ，可以执行的 指令数目 。</p><p>示例1：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：n = <span class="hljs-number">3</span>, startPos = <span class="hljs-selector-attr">[0,1]</span>, s = <span class="hljs-string">&quot;RRDDLU&quot;</span><br>输出：<span class="hljs-selector-attr">[1,5,4,3,1,0]</span><br>解释：机器人从 startPos 出发，并从第 <span class="hljs-selector-tag">i</span> 条指令开始执行：<br>- <span class="hljs-number">0</span>: <span class="hljs-string">&quot;RRDDLU&quot;</span> 在移动到网格外之前，只能执行一条 <span class="hljs-string">&quot;R&quot;</span> 指令。<br>- <span class="hljs-number">1</span>:  <span class="hljs-string">&quot;RDDLU&quot;</span> 可以执行全部五条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;DDLU&quot;</span> 可以执行全部四条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">3</span>:    <span class="hljs-string">&quot;DLU&quot;</span> 可以执行全部三条指令，机器人仍在网格内，最终到达 (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) 。<br>- <span class="hljs-number">4</span>:     <span class="hljs-string">&quot;LU&quot;</span> 在移动到网格外之前，只能执行一条 <span class="hljs-string">&quot;L&quot;</span> 指令。<br>- <span class="hljs-number">5</span>:      <span class="hljs-string">&quot;U&quot;</span> 如果向上移动，将会移动到网格外。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">2</span>, startPos = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], s = <span class="hljs-string">&quot;LURD&quot;</span><br>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：<br>- <span class="hljs-number">0</span>: <span class="hljs-string">&quot;LURD&quot;</span><br>- <span class="hljs-number">1</span>:  <span class="hljs-string">&quot;URD&quot;</span><br>- <span class="hljs-number">2</span>:   <span class="hljs-string">&quot;RD&quot;</span><br>- <span class="hljs-number">3</span>:    <span class="hljs-string">&quot;D&quot;</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：n = <span class="hljs-number">1</span>, startPos = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], s = <span class="hljs-string">&quot;LRUD&quot;</span><br>输出：[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>解释：无论机器人从哪条指令开始执行，都会移动到网格外。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>m &#x3D;&#x3D; s.length</li><li>1 &lt;&#x3D; n, m &lt;&#x3D; 500</li><li>startPos.length &#x3D;&#x3D; 2</li><li>0 &lt;&#x3D; startrow, startcol &lt; n</li><li>s 由 ‘L’、’R’、’U’ 和 ‘D’ 组成</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较水，实际上是简单题，执行就可以了，后缀执行用<code>s[:i]</code>截断就可以了，边界的判断就像dfs couting lakes的判断一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">executeInstructions</span>(<span class="hljs-params">self, n, startPos, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        :type startPos: List[int]</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        matrix = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        cnt = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]<br>        <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            startX = startPos[<span class="hljs-number">0</span>]<br>            startY = startPos[<span class="hljs-number">1</span>]<br>            tmp_seq = s[i:]<br>            <span class="hljs-comment"># print(cnt)</span><br>            <span class="hljs-keyword">for</span> j, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tmp_seq):<br>                <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;L&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startY - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>:<br>                        startY = startY - <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;R&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startY + <span class="hljs-number">1</span> &lt; n:<br>                        startY = startY + <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;U&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startX - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>:<br>                        startX = startX - <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">elif</span> c == <span class="hljs-string">&#x27;D&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> startX + <span class="hljs-number">1</span> &lt; n:<br>                        startX = startX + <span class="hljs-number">1</span><br>                        cnt[i] += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-keyword">break</span><br>            <br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure><h1 id="第三题：2121-相同元素的间隔之和"><a href="#第三题：2121-相同元素的间隔之和" class="headerlink" title="第三题：2121.相同元素的间隔之和"></a>第三题：2121.相同元素的间隔之和</h1><p><a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从<strong>0</strong>开始、由<code>n</code>个整数组成的数组<code>arr</code>。</p><p>arr 中两个元素的 间隔 定义为它们下标之间的<strong>绝对差</strong>。更正式地，<code>arr[i]</code>和<code>arr[j]</code>之间的间隔是<code>|i - j|</code>。</p><p>返回一个长度为<code>n</code>的数组<code>intervals</code>，其中<code>intervals[i]</code>是<code>arr[i]</code>和<code>arr</code>中每个相同元素（与<code>arr[i]</code>的值相同）的<strong>间隔之和</strong>。</p><p>注意：<code>|x|</code>是<code>x</code>的绝对值。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [2,1,3,1,2,3,3]<br>输出：[4,2,7,2,4,4,5]<br>解释：<br>- 下标<span class="hljs-number"> 0 </span>：另一个<span class="hljs-number"> 2 </span>在下标<span class="hljs-number"> 4 </span>，|0 - 4| = 4<br>- 下标<span class="hljs-number"> 1 </span>：另一个<span class="hljs-number"> 1 </span>在下标<span class="hljs-number"> 3 </span>，|1 - 3| = 2<br>- 下标<span class="hljs-number"> 2 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 5 </span>和<span class="hljs-number"> 6 </span>，|2 - 5| + |2 - 6| = 7<br>- 下标<span class="hljs-number"> 3 </span>：另一个<span class="hljs-number"> 1 </span>在下标<span class="hljs-number"> 1 </span>，|3 - 1| = 2<br>- 下标<span class="hljs-number"> 4 </span>：另一个<span class="hljs-number"> 2 </span>在下标<span class="hljs-number"> 0 </span>，|4 - 0| = 4<br>- 下标<span class="hljs-number"> 5 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 6 </span>，|5 - 2| + |5 - 6| = 4<br>- 下标<span class="hljs-number"> 6 </span>：另两个<span class="hljs-number"> 3 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 5 </span>，|6 - 2| + |6 - 5| = 5<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [10,5,10,10]<br>输出：[5,0,3,4]<br>解释：<br>- 下标<span class="hljs-number"> 0 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 2 </span>和<span class="hljs-number"> 3 </span>，|0 - 2| + |0 - 3| = 5<br>- 下标<span class="hljs-number"> 1 </span>：只有这一个<span class="hljs-number"> 5 </span>在数组中，所以到相同元素的间隔之和是 0<br>- 下标<span class="hljs-number"> 2 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 3 </span>，|2 - 0| + |2 - 3| = 3<br>- 下标<span class="hljs-number"> 3 </span>：另两个<span class="hljs-number"> 10 </span>在下标<span class="hljs-number"> 0 </span>和<span class="hljs-number"> 2 </span>，|3 - 0| + |3 - 2| = 4<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; arr.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 105</li><li>1 &lt;&#x3D; arr[i] &lt;&#x3D; 105</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>思路还是很巧妙的，假设一个<code>[a, b, c, d, e]</code>角标数组，现在要统计<code>c</code>这个位置下的角标绝对差，那么这个位置上就是<code>(c-a) + (c-b) + (d-c) + (e-c)</code>，如果要统计</p><figure class="highlight plaintext"><figcaption><span>+ (d-b) + (d-c) + (e-d)```，这样：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs d```这个位置下的角标绝对差，那么这个位置上就是```(d-a)"><br>- 在```c```的位置下看规律，前缀（left_sum）是```a+b```，后缀（right_sum）是```d+e```，求和是：```(c-a) + (c-b) + (d-c) + (e-c)```<br><br>- 在```d```的位置下看规律，前缀（left_sum）是```a+b+c```，后缀（right_sum）是```e```，求和是：```(d-a) + (d-b) + (d-c) + (e-d)```<br><br>这样感觉可以总结出来规律了，在哪个角标x位置，就是：``` ((x * 前缀个数) - 前缀) + (后缀 - (x * 后缀个数))```，这样前缀后缀可以通过一种类似于滑动窗口的方法更新，大大减少了时间复杂度。<br><br><br>```python<br>class Solution(object):<br>    def getDistances(self, arr):<br>        &quot;&quot;&quot;<br>        :type arr: List[int]<br>        :rtype: List[int]<br>        &quot;&quot;&quot;<br>        return_list = [0 for i in range(len(arr))]<br><br>        # 把arr转化为一个map，类似于3: [2, 5, 6]这样的，前边是数值，后边是数值的角标<br>        tmp_dict = &#123;&#125;  # &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;<br>        for i, item in enumerate(arr):<br>            if tmp_dict.get(arr[i]) is None:<br>                tmp_dict[arr[i]] = [i]<br>            else:<br>                tmp_dict[arr[i]].append(i)<br>        <br>        for key, value in tmp_dict.items():<br>            # 在每个value中，使用 a b c d e的思想<br>            left_sum = 0<br>            left_cnt = 0<br>            right_sum = 0<br>            right_cnt = 0<br>            for i in range(0, len(value)):<br>                right_sum += value[i]<br>                right_cnt += 1<br>            <br>            for i in range(len(value)):<br>                # 滑动窗口的感觉<br>                right_sum -= value[i]<br>                right_cnt -= 1<br>                return_list[value[i]] = (right_sum - (right_cnt * value[i])) + (left_cnt * value[i] - left_sum)<br>                left_sum += value[i]<br>                left_cnt += 1<br>                <br>        return return_list<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode周赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>前缀和</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>709.转换成小写字母-python</title>
    <link href="/2021/12/19/algorithms/leetcode-python/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D-python/"/>
    <url>/2021/12/19/algorithms/leetcode-python/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D-python/</url>
    
    <content type="html"><![CDATA[<p>709.转换成小写字母（简单）</p><p>题目大意：</p><p>给你一个字符串<code>s</code>，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/to-lower-case/">题目链接</a></p><p>给你一个字符串<code>s</code>，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span><br>输出：<span class="hljs-string">&quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;here&quot;</span><br>输出：<span class="hljs-string">&quot;here&quot;</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;LOVELY&quot;</span><br>输出：<span class="hljs-string">&quot;lovely&quot;</span><br></code></pre></td></tr></table></figure><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>主要是python语言的转小写，<code>str.lower()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">toLowerCase</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: str</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> s.lower()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>200.岛屿数量-python</title>
    <link href="/2021/12/17/algorithms/leetcode-python/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-python/"/>
    <url>/2021/12/17/algorithms/leetcode-python/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-python/</url>
    
    <content type="html"><![CDATA[<p>200.岛屿数量（中等）</p><p>题目大意：</p><p>给你一个由<code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/number-of-islands/">题目链接</a></p><p>给你一个由<code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>]<br>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：grid = [<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>],<br>  [<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;0&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>]<br>]<br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>poj2386 Couting Lake的模板<a href="http://poj.org/problem?id=2386">题目链接</a></p><p>走到每个位置上dfs，dfs不需要回溯所以很简单，就是把grid的所有状态修改了，这个题做过比较多次了比较熟悉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numIslands</span>(<span class="hljs-params">self, grid</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type grid: List[List[str]]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dfs</span>(<span class="hljs-params">x, y</span>):<br>            grid[x][y] = <span class="hljs-string">&quot;0&quot;</span><br>            dx = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>            dy = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                nx = x + dx[i]<br>                ny = y + dy[i]<br>                <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= nx &lt; <span class="hljs-built_in">len</span>(grid) <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> &lt;= ny &lt; <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>]) <span class="hljs-keyword">and</span> grid[nx][ny] == <span class="hljs-string">&quot;1&quot;</span>:<br>                    dfs(nx, ny)<br>        cnt = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])):<br>                <span class="hljs-keyword">if</span> grid[i][j] == <span class="hljs-string">&quot;1&quot;</span>:<br>                    cnt += <span class="hljs-number">1</span><br>                    dfs(i, j)<br>        <span class="hljs-keyword">return</span> cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>深度优先搜索</tag>
      
      <tag>广度优先搜索</tag>
      
      <tag>并查集</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>312.戳气球-python</title>
    <link href="/2021/12/16/algorithms/leetcode-python/312-%E6%88%B3%E6%B0%94%E7%90%83-python/"/>
    <url>/2021/12/16/algorithms/leetcode-python/312-%E6%88%B3%E6%B0%94%E7%90%83-python/</url>
    
    <content type="html"><![CDATA[<p>312.戳气球（困难）</p><p>题目大意：</p><p>有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。 这里的<code>i - 1</code>和<code>i + 1</code>代表和<code>i</code>相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p><p>求所能获得硬币的最大数量。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">题目链接</a></p><p>有<code>n</code>个气球，编号为<code>0</code>到<code>n - 1</code>，每个气球上都标有一个数字，这些数字存在数组<code>nums</code>中。</p><p>现在要求你戳破所有的气球。戳破第<code>i</code>个气球，你可以获得<code>nums[i - 1] * nums[i] * nums[i + 1]</code>枚硬币。 这里的<code>i - 1</code>和<code>i + 1</code>代表和<code>i</code>相邻的两个气球的序号。如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球。</p><p>求所能获得硬币的最大数量。</p><p>示例1：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">输入：nums = [3,1,5,8]<br>输出：167<br>解释：<br>nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []<br>coins =  3<span class="hljs-number">*1</span><span class="hljs-number">*5</span>    +   3<span class="hljs-number">*5</span><span class="hljs-number">*8</span>   +  1<span class="hljs-number">*3</span><span class="hljs-number">*8</span>  + 1<span class="hljs-number">*8</span><span class="hljs-number">*1</span> = 167<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,5]</span><br><span class="hljs-string">输出：10</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; nums.length</li><li>1 &lt;&#x3D; n &lt;&#x3D; 500</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在没有见过之前几乎很难想到这个dp的思路，二维<code>dp[i][j]</code>数组代表的含义是，在开区间(i, j)之间所能获得的最大金币数。</p><p><strong>注意dp数组的初始化，避免深浅拷贝问题！</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]  <span class="hljs-comment"># 避免深浅拷贝问题</span><br></code></pre></td></tr></table></figure><p>想到状态转移的递推关系，戳爆最后一个气球的时候，最后一个气球必然两边都是空的，也就是题目中说如果「如果<code>i - 1</code>或<code>i + 1</code>超出了数组的边界，那么就当它是一个数字为<code>1</code>的气球」，这个时候的状态，也就是<code>dp[0][len(nums)-1]</code>（注意这里的nums已经经过扩充，<code>nums.insert(0, 1)，nums.insert(len(nums), 1)</code>。</p><p>想在最后一个状态的状态转移方程，<code>dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]</code>，这里想法是要遍历k在整个区间上，找到一个最大的赋值给<code>dp[0][len(nums)-1]</code>。经过这个状态转移方程后，感觉可以慢慢想到是一种自底向上的动态规划策略，由于是开区间(i, j)，所以最小的窗口要从3开始，到len(nums)这个长度为止。然后用每个长度的窗口3、4 … len(nums)在上边滑动。循环整体结构如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间</span><br><span class="hljs-keyword">for</span> window_size <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>    <span class="hljs-comment"># 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-window_size):<br></code></pre></td></tr></table></figure><p>在每次的循环内部，需要计算<code>dp[i][i+window_size]</code>的值，这个就是上文中分析的开区间(i, j)之间能获得的最大金币数，遍历<code>for k in range(i+1, j)</code>，使用状态转移方程<code>dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]</code>，在不断的循环中窗口会扩大，也会自底向上。</p><p>完整解答如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxCoins</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        自底向上动态规划感觉可以算非常经典的题目了？</span><br><span class="hljs-string">        如果能想到dp数组的含义感觉还是可以理解的，但是感觉这个dp数组的含义实在不太好想</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        假设 dp[i][j] 表示【【【开区间】】】 (i,j) 内你能拿到的最多金币</span><br><span class="hljs-string">        想到这个递推的关系，删除【【【最后】】】一个气球k的时候，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j]</span><br><span class="hljs-string">        再加上这个题说如果i-1，i+1超出了数组的时候，就当他是一个数字为1的气球</span><br><span class="hljs-string"></span><br><span class="hljs-string">        所以如果在开始和最后补充上两个1的话，在新的数组上开区间(0, len(nums)-1)所能拿到的最大值，就是最终的状态了</span><br><span class="hljs-string">        这个状态在递推下，就等于最后一个删除的气球k，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j]，有一种分而治之的思想</span><br><span class="hljs-string"></span><br><span class="hljs-string">        由于是开区间，所以最小的长度为3才可以，也或许是先想出上边的递推公式后，再来看dp的思路，dp数组的含义是什么了，感觉还是得想状态转移</span><br><span class="hljs-string"></span><br><span class="hljs-string">        最后来看的话，这个题是一个自底向上的动态规划问题，要首先找到小区间的，例如对于一个长度为3的开区间，永远就是当前窗口中间的那个数字</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        解法的话按照答案的思路写了一遍，答案还是有很多内容需要注意到的</span><br><span class="hljs-string">            - 包括区间不要让角标超出限制</span><br><span class="hljs-string">            - 还有range_best中的ij参数是代表开区间，所以在遍历的时候for k in range(i+1, j)就可以这样的</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_range_best</span>(<span class="hljs-params">i, j</span>):<br>            max_value = <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, j):<br>                tmp_value = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]<br>                max_value = <span class="hljs-built_in">max</span>(max_value, tmp_value)<br>            dp[i][j] = max_value<br><br><br>        nums.insert(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>        nums.insert(<span class="hljs-built_in">len</span>(nums), <span class="hljs-number">1</span>)<br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br><br>        <span class="hljs-comment"># 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间</span><br>        <span class="hljs-keyword">for</span> window_size <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-comment"># 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-window_size):<br>                get_range_best(i, i+window_size)  <span class="hljs-comment"># 这个函数的作用是，找到在i, i+window_size这个开区间中，最大的那一个值，窗口大小是3（window_size=2时，就是那个值）</span><br>            <br>            <span class="hljs-comment"># print(dp)</span><br>            <span class="hljs-comment"># assert False</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>72.编辑距离-python</title>
    <link href="/2021/12/16/algorithms/leetcode-python/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-python/"/>
    <url>/2021/12/16/algorithms/leetcode-python/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-python/</url>
    
    <content type="html"><![CDATA[<p>72.编辑距离（困难）</p><p>题目大意：</p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">题目链接</a></p><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>示例1：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;horse&quot;</span>, word2 = <span class="hljs-string">&quot;ros&quot;</span><br>输出：<span class="hljs-number">3</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">horse</span> -&gt;</span> rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rorse</span> -&gt;</span> rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">rose</span> -&gt;</span> ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xl">输入：word1 = <span class="hljs-string">&quot;intention&quot;</span>, word2 = <span class="hljs-string">&quot;execution&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：<br><span class="hljs-function"><span class="hljs-title">intention</span> -&gt;</span> inention (删除 <span class="hljs-string">&#x27;t&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">inention</span> -&gt;</span> enention (将 <span class="hljs-string">&#x27;i&#x27;</span> 替换为 <span class="hljs-string">&#x27;e&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">enention</span> -&gt;</span> exention (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exention</span> -&gt;</span> exection (将 <span class="hljs-string">&#x27;n&#x27;</span> 替换为 <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-function"><span class="hljs-title">exection</span> -&gt;</span> execution (插入 <span class="hljs-string">&#x27;u&#x27;</span>)<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; word1.length, word2.length &lt;&#x3D; 500</li><li>word1 和 word2 由小写英文字母组成</li></ul><h1 id="题目分析和解答"><a href="#题目分析和解答" class="headerlink" title="题目分析和解答"></a>题目分析和解答</h1><p>二维dp的题目，想象两个单词word1和word2，二维dp的每个位置上，代表word1的i位置处，和word2的j位置处情况下，多少次变换能达到是一样的情况；</p><p>个人习惯上把word1作为行来放置，把word2作为列来放置；</p><p>由于word1和word2都可能为空，所以在初始化二维dp数组的时候，行和列要分别是<code>len(word1)+1</code>和<code>len(word2)+1</code>，初始化dp数组的第一行第一列，想象i到j的这个顺序，第一列<code>dp[i][0]</code>代表word1在当前的情况下经过多少次操作能变成空，所以这个数值就等于i；第一行<code>dp[0][i]</code>就是代表空字符串经过多少次能变到word2的当前这个位置上。</p><p>现在初始化好了dp数组的第一行第一列，<strong>下边就来想状态转移这个方程</strong>，也是这个题目每次复习的时候需要想到的部分，<code>dp[i][j]</code>可以由<code>dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1]</code>得到：</p><ul><li><code>dp[i-1][j-1]</code>到<code>dp[i][j]</code>的操作是修改，注意修改这个操作需要判断word1 i位置处的值和word2 j位置处的值是不是相等的，如果相等的话则不需要修改，如果是不相等的话则需要修改，也就是<code>dp[i-1][j-1]+1</code>；</li><li><code>dp[i][j-1]</code>到<code>dp[i][j]</code>的操作是删除，想象最左上角的三个块，ij代表word1变到word2的这一种感觉。执行删除的情况下，状态转移后必然是<code>dp[i][j]=dp[i][j-1]+1</code>；</li><li><code>dp[i-1][j]</code>到<code>dp[i][j]</code>的操作是新增，同样是想象最左上角的三个块。执行新增的情况下，状态转移后必然是<code>dp[i][j]=dp[i-1][j]+1</code></li></ul><p>经过如上分析后，在每次判断时先判断是不是相等，如果相等的话，可以走<code>dp[i][j]=dp[i-1][j-1]</code>，代表不需要修改。如果是不相等的话就需要对三种情况进行min判断，<code>dp[i][j]=min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1</code></p><p>经过上述循环后，因为在最开始前边补充的字符串为空的长度情况，所以<code>dp[len(word1)][len(word2)]</code>就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">minDistance</span>(<span class="hljs-params">self, word1, word2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word1: str</span><br><span class="hljs-string">        :type word2: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        二维dp的题目，dp数组代表，word1的前i个字符，和word2的前j个字符，需要几次修改可以变成一样的</span><br><span class="hljs-string">        回想题解里给出的那张图，要分别想到word1，word2为空字符串的情况</span><br><span class="hljs-string">        空串情况下的初始化状态比较容易想，一个字符串变成空串，就是这个字符串的长度的次数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 初始化dp数组状态，word1在行维度上，word2在列维度上</span><br>        dp = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>)]  <span class="hljs-comment"># 注意深浅拷贝的问题，这个还挺坑的，只能这么初始化数组</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            dp[i][<span class="hljs-number">0</span>] = i<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>):<br>            dp[<span class="hljs-number">0</span>][i] = i<br>        <br><br>        <span class="hljs-comment"># 假设每个地方想象的是从竖着的word1变到横着的word2的状态，那么[i-1][j-1]代表替换，[i-1][j]代表插入，[i][j-1]代表删除（想初始状态即可）</span><br>        <span class="hljs-comment"># 如果当前两个字符相等的情况下，保持不变（即不做修改[i-1][j-1]的状态）一定是最优的，因为无论增加或减少，则一定还需要1次操作</span><br>        <span class="hljs-comment"># 而如果当前两个字符不等的情况，则由删除，增加，修改三种之最小的+1次操作得到</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word1)+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(word2)+<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> word1[i-<span class="hljs-number">1</span>] == word2[j-<span class="hljs-number">1</span>]:<br>                    dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>]<br>                <span class="hljs-keyword">else</span>:<br>                    dp[i][j] = <span class="hljs-built_in">min</span>(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>], dp[i][j-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">1</span>][j]) +<span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(word1)][<span class="hljs-built_in">len</span>(word2)]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
      <tag>HARD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.盛最多水的容器-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-python/</url>
    
    <content type="html"><![CDATA[<p>11.盛最多水的容器（中等）</p><p>题目大意：</p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">题目链接</a></p><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><p>示例1：<br><img src="/images/2021-12-15-18-56-13.png"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,3,2,1,4]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>n &#x3D;&#x3D; height.length</li><li>2 &lt;&#x3D; n &lt;&#x3D; 105</li><li>0 &lt;&#x3D; height[i] &lt;&#x3D; 104</li></ul><h1 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h1><p>O(n^2)的方法很会超时</p><p>对上述方法采用双指针进行优化，整体性的思路如下：</p><p>在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i) <code>min(a[i], a[j]) * (j-i)</code></p><p>由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小</p><p>所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板（贪心的思想应该隐含在这里了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxArea</span>(<span class="hljs-params">self, height</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type height: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># O(n^2) time limit了</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        max_water = 0</span><br><span class="hljs-string">        for i in range(len(height)):</span><br><span class="hljs-string">            for j in range(i, len(height)):</span><br><span class="hljs-string">                max_water = max(max_water, (j-i)*min(height[i], height[j]))</span><br><span class="hljs-string">        return max_water</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        对上述方法采用双指针进行优化，整体性的思路如下：</span><br><span class="hljs-string">            在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i)</span><br><span class="hljs-string">            由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小</span><br><span class="hljs-string">            所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(height) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        i = <span class="hljs-number">0</span><br>        j = <span class="hljs-built_in">len</span>(height) - <span class="hljs-number">1</span><br>        max_water = (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j])<br>        <br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            <span class="hljs-keyword">if</span> height[i] &lt;= height[j]:  <span class="hljs-comment"># 等号随便给一边就可以了</span><br>                <span class="hljs-keyword">while</span> i &lt; j <span class="hljs-keyword">and</span> height[i] &lt;= height[j]:<br>                    max_water = <span class="hljs-built_in">max</span>(max_water, (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j]))<br>                    i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">while</span> j &gt; i <span class="hljs-keyword">and</span> height[j] &lt;= height[i]:<br>                    max_water = <span class="hljs-built_in">max</span>(max_water, (j-i) * <span class="hljs-built_in">min</span>(height[i], height[j]))<br>                    j -= <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">return</span> max_water<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>贪心</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15.三数之和-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-python/</url>
    
    <content type="html"><![CDATA[<p>15.三数之和（中等）</p><p>题目大意：</p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/3sum/">题目链接</a></p><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; nums.length &lt;&#x3D; 3000</li><li>-105 &lt;&#x3D; nums[i] &lt;&#x3D; 105</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>O(n^3)是一种最容易想到的解法，但是会超时。</p><p>外层i，内层双指针+移动位置，移动位置主要是为去重的，每次ijk都要移动到下一个不一样的，指针的移动这里要模拟do-while循环，这个非常关键</p><p>既然是要求和为0，可以想到进行排序O(nlogn)，从小到大。之后的思路感觉是一种O(n^2)的思路，设立ijk</p><ul><li>i代表：一个基准的数字，可以看做jk位置处的数字加起来要等于-i位置处的数字</li><li>j，k代表：在i后边的数字序列中，j从头开始，k从尾开始，这样根据加了后的关系可以判断是j该往后移动还是k该往前移动</li></ul><p>由于题目中要求答案中不可以包含重复的三元组，这里就是题目里代码实现起来很容易出错的部分了，i，j，k在每次遍历的时候都要走到下一个不一样的地方去，这里感觉有一种do-while循环的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在如下的操作下，j最终会停在不相等的位置上</span><br>j += <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>    j += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>要分加起来等于0，小于0，大于0三个讨论，其中等于0的情况jk一起移动</p><p>有剪枝操作，在排序了后如果i位置处都大于0了，那么就可以结束了</p><p>解答如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">threeSum</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: List[List[int]]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        # O(n^3)，其中tuple这个操作用来去重用，tuple是可哈希化的，这种方法超时了</span><br><span class="hljs-string">        rlist = []</span><br><span class="hljs-string">        for i in range(len(nums)):</span><br><span class="hljs-string">            for j in range(i+1, len(nums)):</span><br><span class="hljs-string">                for k in range(j+1, len(nums)):</span><br><span class="hljs-string">                    if nums[i] + nums[j] + nums[k] == 0:</span><br><span class="hljs-string">                        tmplist = sorted([nums[i], nums[j], nums[k]])</span><br><span class="hljs-string">                        rlist.append(tuple(tmplist))</span><br><span class="hljs-string">        temp = list(set(rlist))</span><br><span class="hljs-string">        return [[x[0], x[1], x[2]] for x in temp]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-comment"># 优化方法</span><br>        <span class="hljs-comment"># O(nlogn)排序+ O(n^2)双指针，一前一后，跳过后</span><br>        rlist = []<br>        nums = <span class="hljs-built_in">sorted</span>(nums)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">2</span>):<br>            <span class="hljs-comment"># 学习题解中的剪枝操作</span><br>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>: <br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i-<span class="hljs-number">1</span>]: <span class="hljs-comment"># 三元组不能重复，注意python的-1问题</span><br>                <span class="hljs-keyword">continue</span><br><br>            j = i + <span class="hljs-number">1</span><br>            k = <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">while</span> j &lt; k:<br>                <span class="hljs-keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="hljs-number">0</span>:<br>                    rlist.append([nums[i], nums[j], nums[k]])<br>                    <span class="hljs-comment"># print(rlist)</span><br>                    <span class="hljs-comment"># j移动到下一个不一样的</span><br>                    j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br><br>                    k -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> k &gt; j <span class="hljs-keyword">and</span> nums[k] == nums[k+<span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                    <br>                <span class="hljs-keyword">elif</span> nums[i] + nums[j] + nums[k] &gt; <span class="hljs-number">0</span>: <span class="hljs-comment"># 太大了，k往左移动到一个不一样的</span><br>                    k -= <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> k &gt; j <span class="hljs-keyword">and</span> nums[k] == nums[k+<span class="hljs-number">1</span>]:<br>                        k -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># 模拟do-while循环</span><br>                    j += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">while</span> j &lt; k <span class="hljs-keyword">and</span> nums[j] == nums[j-<span class="hljs-number">1</span>]:<br>                        j += <span class="hljs-number">1</span><br>    <br>        <span class="hljs-keyword">return</span> rlist<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>146.LRU缓存机制-python</title>
    <link href="/2021/12/15/algorithms/leetcode-python/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-python/"/>
    <url>/2021/12/15/algorithms/leetcode-python/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-python/</url>
    
    <content type="html"><![CDATA[<p>146.LRU缓存机制（中等）</p><p>题目大意：</p><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">题目链接</a></p><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p>进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><p>示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs haxe">输入<br>[<span class="hljs-string">&quot;LRUCache&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;put&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>]<br>[[<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>]]<br>输出<br>[<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><br>解释<br>LRUCache lRUCache = <span class="hljs-keyword">new</span> <span class="hljs-type">LRUCache</span>(<span class="hljs-number">2</span>);<br>lRUCache.put(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 缓存是 &#123;1=1&#125;</span><br>lRUCache.put(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 缓存是 &#123;1=1, 2=2&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 1</span><br>lRUCache.put(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">2</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.put(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// 返回 -1 (未找到)</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">3</span>);    <span class="hljs-comment">// 返回 3</span><br>lRUCache.<span class="hljs-keyword">get</span>(<span class="hljs-number">4</span>);    <span class="hljs-comment">// 返回 4</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; capacity &lt;&#x3D; 3000</li><li>0 &lt;&#x3D; key &lt;&#x3D; 10000</li><li>0 &lt;&#x3D; value &lt;&#x3D; 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h1 id="解答与分析"><a href="#解答与分析" class="headerlink" title="解答与分析"></a>解答与分析</h1><p>这个题实在是太经典了，而且是自己面试过程中真正被问到而没有做出来的题目，首先第一步要根据题目所给出的内容自定义LRUCache类，也借此进一步熟悉语法。</p><h2 id="自定义LRUCache类"><a href="#自定义LRUCache类" class="headerlink" title="自定义LRUCache类"></a>自定义LRUCache类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        self.capacity = capacity<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="使用双向链表来完成题目要求的操作时间复杂度要求"><a href="#使用双向链表来完成题目要求的操作时间复杂度要求" class="headerlink" title="使用双向链表来完成题目要求的操作时间复杂度要求"></a>使用双向链表来完成题目要求的操作时间复杂度要求</h2><p>题目中要求的O(1)时间复杂度下完成各个操作，主要靠的是cache词典和双向链表中的一些操作，缓存（cache）在这个题中十分关键</p><p>首先搞起来双向链表的基本模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiLinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=-<span class="hljs-number">1</span>, val=-<span class="hljs-number">1</span>, prev=<span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.key = key<br>        self.val = val<br>        self.prev = prev<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><h2 id="LRUCache-init-中需要初始化的内容"><a href="#LRUCache-init-中需要初始化的内容" class="headerlink" title="LRUCache __init__中需要初始化的内容"></a>LRUCache __init__中需要初始化的内容</h2><p>按照题目一步步的来分析，首先分析需要哪些内容放在LRUcatch的init中，首先是题目中给了的capacity代表这个LRU cache的最大容量，之后是一个为0的current_size代表当前LRU cache的容量，之后可以根据做一些特殊的判断。还有就是一个词典的cache，代表有哪些已经在LRUcache中了，这里最关键的是记住这个cache中存储的是key-node的mapping。还有就是初始化一个双向链表，注意这个双向链表的头和尾虽然直接初始化了，但是这两个节点并没有什么含义，所以head.next和tail.prev中间这些的才感觉是有用的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        self.capacity = capacity<br>        self.current_size = <span class="hljs-number">0</span><br>        self.cache = &#123;&#125;<br><br>        self.head = BiLinkedList()<br>        self.tail = BiLinkedList()<br>        self.head.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = self.head<br></code></pre></td></tr></table></figure><h2 id="分析LRUCache中的插入（put）操作和查找（get）操作"><a href="#分析LRUCache中的插入（put）操作和查找（get）操作" class="headerlink" title="分析LRUCache中的插入（put）操作和查找（get）操作"></a>分析LRUCache中的插入（put）操作和查找（get）操作</h2><h3 id="插入（put）"><a href="#插入（put）" class="headerlink" title="插入（put）"></a>插入（put）</h3><p>插入给了一个key和一个value。</p><p>首先判断key是不是已经在cache中了</p><ul><li><p>如果已经在cache中了</p><ul><li>在cache中删除这个key对应的node，然后把这个节点的更新值头插法搞到链表的最前边去。<strong>这里体现了双向链表的作用还有cache中key-node mapping的作用，，mapping找到一个node后，基于双向链表可完成O(1)的删除</strong></li></ul></li><li><p>如果不在的话</p><ul><li>首先判断目前的self.current_size和self.capacity的关系，<ul><li>如果相等了，则删除目前双向链表尾部的，之后用头插法在前边插入上。</li><li>如果self.current_size小于self.capacity，直接在头部插入后，self.capacity++就可以了</li></ul></li></ul></li></ul><h3 id="查找（get）"><a href="#查找（get）" class="headerlink" title="查找（get）"></a>查找（get）</h3><p>查找只给了一个key，返回这个key对应的value，如果找不到就返回-1</p><p>这个直接从cache中找就可以了，但是注意查找到的同样要删除，并且头插法到最前边来</p><h2 id="双向链表操作函数的编写"><a href="#双向链表操作函数的编写" class="headerlink" title="双向链表操作函数的编写"></a>双向链表操作函数的编写</h2><p>综上所述，在该题中需要双向链表的三种操作：（注意这里只管链表的操作，是否能执行这些操作的判断在其他地方试）</p><p>①头插法</p><p>②尾部删除：特别注意这里的尾部删除，在超出capacity的时候会执行尾部删除，<strong>这个时候要拿到尾部删除后的node</strong>，以便从cache中将其移除！！！！！！！！</p><p>③中间删除</p><p>下边这些实现还要经常复习，主要是涉及顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_head</span>(<span class="hljs-params">self, node</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入</span><br><span class="hljs-string">    注意这里，是插入到虚拟head之后的一个</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    node.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>    node.prev = self.head<br>    self.head.<span class="hljs-built_in">next</span>.prev = node<br>    self.head.<span class="hljs-built_in">next</span> = node<br>    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_tail</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除</span><br><span class="hljs-string">    注意这里，是删除虚拟尾结点前边的一个！</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    temp = self.tail.prev<br>    self.tail.prev = self.tail.prev.prev<br>    self.tail.prev.<span class="hljs-built_in">next</span> = self.tail<br>    temp.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>    temp.prev = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">return</span> temp<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_inter</span>(<span class="hljs-params">self, node</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    双向链表的中间节点删除</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>    node.<span class="hljs-built_in">next</span>.prev = node.prev<br></code></pre></td></tr></table></figure><h2 id="工具都造好了，最终整体上的代码实现如下，还要经常复习啊"><a href="#工具都造好了，最终整体上的代码实现如下，还要经常复习啊" class="headerlink" title="工具都造好了，最终整体上的代码实现如下，还要经常复习啊"></a>工具都造好了，最终整体上的代码实现如下，还要经常复习啊</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">使用双向链表的原因是因为双向链表的删除可以做到O(1)？也或许还有其他特性</span><br><span class="hljs-string">！注意题目中的关键字key存在于缓存中，要拿到关键字的值，也就是一个key-value的关系，一定要注意这个</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiLinkedList</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, key=-<span class="hljs-number">1</span>, value=-<span class="hljs-number">1</span>, prev=<span class="hljs-literal">None</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.key = key<br>        self.value = value<br>        self.prev = prev<br>        self.prev = <span class="hljs-built_in">next</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type capacity: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.capacity = capacity<br>        self.current_size = <span class="hljs-number">0</span><br>        self.cache = &#123;&#125; <span class="hljs-comment"># 这个mapping是key -&gt; node！！</span><br>        <span class="hljs-comment"># 创建一个初始的头和一个初始的尾</span><br>        self.head = BiLinkedList()<br>        self.tail = BiLinkedList()<br>        self.head.<span class="hljs-built_in">next</span> = self.tail<br>        self.tail.prev = self.head<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_to_head</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入</span><br><span class="hljs-string">        注意这里，是插入到虚拟head之后的一个</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node.<span class="hljs-built_in">next</span> = self.head.<span class="hljs-built_in">next</span><br>        node.prev = self.head<br>        self.head.<span class="hljs-built_in">next</span>.prev = node<br>        self.head.<span class="hljs-built_in">next</span> = node<br>        <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_tail</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除</span><br><span class="hljs-string">        注意这里，是删除虚拟尾结点前边的一个！</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        temp = self.tail.prev<br>        self.tail.prev = self.tail.prev.prev<br>        self.tail.prev.<span class="hljs-built_in">next</span> = self.tail<br>        temp.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        temp.prev = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">return</span> temp<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_inter</span>(<span class="hljs-params">self, node</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        双向链表的中间节点删除</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node.prev.<span class="hljs-built_in">next</span> = node.<span class="hljs-built_in">next</span><br>        node.<span class="hljs-built_in">next</span>.prev = node.prev<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        # 注意get的时候，要把这个地方挪到最前边，因为LRU访问的时候要挪到前边来</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cache.get(key) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            node = self.cache.get(key)<br>            self.remove_inter(node)<br>            self.add_to_head(node)<br>            <span class="hljs-keyword">return</span> node.value<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type key: int</span><br><span class="hljs-string">        :type value: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> self.cache.get(key) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            需要头插入，如果插入后长度超过了capacity，就要进行尾部删除</span><br><span class="hljs-string">            cache需要变动</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            node = BiLinkedList(key=key, value=value)<br>            self.add_to_head(node)<br>            self.current_size += <span class="hljs-number">1</span><br>            self.cache[key] = node<br>            <span class="hljs-keyword">if</span> self.current_size &gt; self.capacity:  <span class="hljs-comment"># 超出容量了，要删除，同时cache也要删除</span><br>                temp = self.remove_tail()<br>                <span class="hljs-keyword">del</span> self.cache[temp.key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            已经有了，拿到一个node，需要先删除，然后挪到最前边</span><br><span class="hljs-string">            cache不需要变动</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            node = self.cache.get(key)<br>            self.remove_inter(node)<br>            node = BiLinkedList(key=key, value=value)  <span class="hljs-comment"># 更新val值</span><br>            self.cache[key] = node<br>            self.add_to_head(node)<br><br><br><br><span class="hljs-comment"># Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = LRUCache(capacity)</span><br><span class="hljs-comment"># param_1 = obj.get(key)</span><br><span class="hljs-comment"># obj.put(key,value)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>设计</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>383.赎金信-python</title>
    <link href="/2021/12/14/algorithms/leetcode-python/383-%E8%B5%8E%E9%87%91%E4%BF%A1-python/"/>
    <url>/2021/12/14/algorithms/leetcode-python/383-%E8%B5%8E%E9%87%91%E4%BF%A1-python/</url>
    
    <content type="html"><![CDATA[<p>383.赎金信（简单）</p><p>题目大意：</p><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/ransom-note/">题目链接</a></p><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;b&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">ransomNote</span> = <span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-attr">magazine</span> = <span class="hljs-string">&quot;aab&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; ransomNote.length, magazine.length &lt;&#x3D; 105</li><li>ransomNote 和 magazine 由小写英文字母组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>python中Counter的妙用，Counter是可以相减的！</p><p>所以说如果在ransomNote中，减掉magazine后是空的，就代表可以组成的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">canConstruct</span>(<span class="hljs-params">self, ransomNote, magazine</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type ransomNote: str</span><br><span class="hljs-string">        :type magazine: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        c1 = Counter(ransomNote)<br>        c2 = Counter(magazine)<br>        <span class="hljs-keyword">return</span> c1 - c2 == Counter(<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>计数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>139.单词拆分-python</title>
    <link href="/2021/12/14/algorithms/leetcode-python/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-python/"/>
    <url>/2021/12/14/algorithms/leetcode-python/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-python/</url>
    
    <content type="html"><![CDATA[<p>139.单词拆分（中等）</p><p>题目大意：给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/word-break/">题目链接</a></p><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;leetcode&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;leet&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;leetcode&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;leet code&quot;</span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;applepenapple&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;pen&quot;</span>]<br>输出: <span class="hljs-literal">true</span><br>解释: 返回 <span class="hljs-literal">true</span> 因为 <span class="hljs-string">&quot;applepenapple&quot;</span> 可以被拆分成 <span class="hljs-string">&quot;apple pen apple&quot;</span>。<br>     注意你可以重复使用字典中的单词。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;catsandog&quot;</span>, <span class="hljs-attr">wordDict</span> = [<span class="hljs-string">&quot;cats&quot;</span>, <span class="hljs-string">&quot;dog&quot;</span>, <span class="hljs-string">&quot;sand&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>]<br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 300</li><li>1 &lt;&#x3D; wordDict.length &lt;&#x3D; 1000</li><li>1 &lt;&#x3D; wordDict[i].length &lt;&#x3D; 20</li><li>s 和 wordDict[i] 仅有小写英文字母组成</li><li>wordDict 中的所有字符串 互不相同</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题在没见过之前想到dp还是挺难的，这里使用的是一维dp数组，其数组的含义是，当前这个位置下，能否被拆分成多个字典中的词</p><p>dp的状态转移方程想法是，从这个位置之前逐个遍历</p><ul><li>要么是0到这个位置能构成一个单词</li><li>要么是之前一个能构成字典中单词的位置，到现在这个位置之间的词也在字典中</li></ul><p>重点也是要特殊处理如下j&#x3D;&#x3D;0的情况，另外列表截取的左闭右开</p><p>这个题要用dp的思路，这个感觉是最难想的，dp的每个位置代表当前位置，是否所有单词都能包含在词典中；；；对于一个位置，如果之前出现过能包含在词典中的（dp[j]&#x3D;&#x3D;True），并且j到i（[j+1: i+1]）也在词典里，那么这个位置就是在的；；；注意按照这种思路，可能需要处理一些0的特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wordBreak</span>(<span class="hljs-params">self, s, wordDict</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :type wordDict: List[str]</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <br>        <span class="hljs-comment"># 这个题很难看出是dp的思路了，一眼看过去还以为是Trie树，KMP这样的</span><br>        <span class="hljs-comment"># dp数组代表的含义是，当前这个位置下，[能否](bool)被拆分成多个字典词</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br><br><br>        dp = [<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s))]  <span class="hljs-comment"># 当前这个位置下，能否全部在词典中出现</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):    <br>            <span class="hljs-comment"># 如果i为0的情况</span><br>            <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> s[i] <span class="hljs-keyword">in</span> wordDict:<br>                    dp[i] = <span class="hljs-literal">True</span>            <br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 对于一个位置判断是否能全部在词典中出现，等于前一个能出现的位置 and 那个位置到这个位置之间能不能出现</span><br>                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[: i+<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> wordDict:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">break</span><br>                    <span class="hljs-comment"># j == 0没法走到这个情况</span><br>                    <span class="hljs-keyword">if</span> dp[j] <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> s[j+<span class="hljs-number">1</span>: i+<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> wordDict:<br>                        dp[i] = <span class="hljs-literal">True</span><br>                        <span class="hljs-keyword">break</span><br>        <span class="hljs-comment"># print(dp)</span><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>动态规划</tag>
      
      <tag>哈希表</tag>
      
      <tag>字典树</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>198.打家劫舍-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-python/</url>
    
    <content type="html"><![CDATA[<p>198.打家劫舍（中等）</p><p>题目大意：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/house-robber/">题目链接</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>不触动警报装置的情况下</strong>，一夜之内能够偷窃到的最高金额。</p><p>示例1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[1,2,3,1]<br>输出：4<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 1) ，然后偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 3)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃<span class="hljs-number"> 1 </span>号房屋 (金额 = 2), 偷窃<span class="hljs-number"> 3 </span>号房屋 (金额 = 9)，接着偷窃<span class="hljs-number"> 5 </span>号房屋 (金额 = 1)。<br>     偷窃到的最高金额 =<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 9 </span>+<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 12 </span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 100</li><li>0 &lt;&#x3D; nums[i] &lt;&#x3D; 400</li></ul><h1 id="解答与分析"><a href="#解答与分析" class="headerlink" title="解答与分析"></a>解答与分析</h1><p>这个题dp的还是比较明显的，感觉可以算简单题了<code>dp[i] = max(dp[i-1], s[i] + dp[i-2])</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rob</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]<br>        dp = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>], nums[<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">len</span>(nums)):<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i-<span class="hljs-number">1</span>], dp[i-<span class="hljs-number">2</span>] + nums[i])<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1446.连续字符-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6-python/</url>
    
    <content type="html"><![CDATA[<p>1446.连续字符（简单）</p><p>题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/consecutive-characters/">题目链接</a></p><p>题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。</p><p>示例1：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：子字符串 <span class="hljs-string">&quot;ee&quot;</span> 长度为 <span class="hljs-number">2</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c">输入：s = <span class="hljs-string">&quot;abbcccddddeeeeedcba&quot;</span><br>输出：<span class="hljs-number">5</span><br>解释：子字符串 <span class="hljs-string">&quot;eeeee&quot;</span> 长度为 <span class="hljs-number">5</span> ，只包含字符 &#x27;e&#x27; 。<br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;triplepillooooow&quot;</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hooraaaaaaaaaaay&quot;</span><br>输出：<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>示例5：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tourist&quot;</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 500</li><li>s 只包含小写英文字母。</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>比较简单，O(n)遍历一次，如果不等清空重新计数就可以了，另外感觉有很多种实现方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxPower</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><br>        max_cnt = <span class="hljs-number">1</span><br>        cnt = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">if</span> s[i] == s[i-<span class="hljs-number">1</span>]:<br>                cnt += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt = <span class="hljs-number">1</span><br>            max_cnt = <span class="hljs-built_in">max</span>(max_cnt, cnt)<br><br>        <span class="hljs-keyword">return</span> max_cnt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>208.实现Trie前缀树-python</title>
    <link href="/2021/12/13/algorithms/leetcode-python/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91-python/"/>
    <url>/2021/12/13/algorithms/leetcode-python/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91-python/</url>
    
    <content type="html"><![CDATA[<p>208.最长递增子序列（中等）</p><p>题目大意：Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。</p><ul><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">题目链接</a></p><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><p>Trie() 初始化前缀树对象。</p><ul><li>void insert(String word) 向前缀树中插入字符串 word 。</li><li>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。</li><li>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false</li></ul><p>示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">输入<br>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]<br>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]<br>输出<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">true</span>]<br><br>解释<br>Trie trie = <span class="hljs-built_in">new</span> Trie();<br>trie.<span class="hljs-keyword">insert</span>(&quot;apple&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;apple&quot;);   // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">False</span><br>trie.startsWith(&quot;app&quot;); // 返回 <span class="hljs-keyword">True</span><br>trie.<span class="hljs-keyword">insert</span>(&quot;app&quot;);<br>trie.<span class="hljs-keyword">search</span>(&quot;app&quot;);     // 返回 <span class="hljs-keyword">True</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; word.length, prefix.length &lt;&#x3D; 2000</li><li>word 和 prefix 仅由小写英文字母组成</li><li>insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>Trie树还是很经典的，同样是一个妙脆妙妙角一样妙的结构。这个题主要需要记住的是首先构建一个TrieNode，代表Trie树中的每个节点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mapping = &#123;&#125;<br>        self.is_end = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>在之后想想每次插入过程，<strong>每次都从root开始进行插入</strong>，第一次插入一个单词如“apple”的时候，首先是“a“，令<code>node=root</code>，因为现在node肯定是空的，所以使得<code>node.mapping[&#39;a&#39;]</code>为一个新的TrieNode，之后走到这个TrieNode上，<code>node=node.mapping.get(c)</code>。<strong>特别注意，这里的mapping key是每个char，value是TrieNode类型的</strong>，在插入的最后，要使得node.is_end&#x3D;True，标志出这个单词的结尾</p><p>在这样的插入条件下，第一次插入就是构建了一个超长的串。第二次插入的时候由于第一次插入过程中，有些节点已经可以共用了，所以就有“前缀”的感觉了，这样的感觉就是顺着串走，直到遇到新的后，就建立走到新的分支上，要想到Trie树并不是只插入一个字符串就结束了</p><p>找prefix和word都很简单，找word要多加一个判断is_end</p><p>题目解答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TrieNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    实现一个TrieNode进行封装</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mapping = &#123;&#125;<br>        self.is_end = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.root = TrieNode()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">insert</span>(<span class="hljs-params">self, word</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        注意这个insert函数会多次执行，</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                node.mapping[c] = TrieNode()  <span class="hljs-comment"># 这里每次放入的是TreeNode</span><br>            node = node.mapping[c]<br>        node.is_end = <span class="hljs-literal">True</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">self, word</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type word: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            node = node.mapping[c]<br>        <span class="hljs-keyword">if</span> node.is_end == <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>·<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">startsWith</span>(<span class="hljs-params">self, prefix</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type prefix: str</span><br><span class="hljs-string">        :rtype: bool</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        node = self.root<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(prefix):<br>            <span class="hljs-keyword">if</span> node.mapping.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            node = node.mapping[c]<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Trie()</span><br><span class="hljs-comment"># obj.insert(word)</span><br><span class="hljs-comment"># param_2 = obj.search(word)</span><br><span class="hljs-comment"># param_3 = obj.startsWith(prefix)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>字典树</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>438.找到字符串中所有字母异位词-python</title>
    <link href="/2021/12/12/algorithms/leetcode-python/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-python/"/>
    <url>/2021/12/12/algorithms/leetcode-python/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-python/</url>
    
    <content type="html"><![CDATA[<p>438.找到字符串中所有字母异位词（中等）</p><p>题目大意：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">题目链接</a></p><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p><p>示例一：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;cbaebabacd&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;abc&quot;</span><br>输出: <span class="hljs-selector-attr">[0,6]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;cba&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">6</span> 的子串是 <span class="hljs-string">&quot;bac&quot;</span>, 它是 <span class="hljs-string">&quot;abc&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p>示例二：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入: s = <span class="hljs-string">&quot;abab&quot;</span>, <span class="hljs-selector-tag">p</span> = <span class="hljs-string">&quot;ab&quot;</span><br>输出: <span class="hljs-selector-attr">[0,1,2]</span><br>解释:<br>起始索引等于 <span class="hljs-number">0</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">1</span> 的子串是 <span class="hljs-string">&quot;ba&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br>起始索引等于 <span class="hljs-number">2</span> 的子串是 <span class="hljs-string">&quot;ab&quot;</span>, 它是 <span class="hljs-string">&quot;ab&quot;</span> 的异位词。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 104</li><li>s 和 p 仅包含小写字母</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题要构建一个“滑动窗口”来减少操作次数的感觉，就是说如果每i+&#x3D;1向后移动一位的时候，如果都重新计数，那么将会时间复杂度非常高。所以在每次移动的时候，只需要把i-1位置的删除，再加入i+window_size-1位置处最新的字符即可，这样的话每次移动只用操作两下；</p><p>一开始设置一个和p长度相等的s之后开始滑动窗口，删除头并新增尾只需要操作两次了（注意做字典判断相等时候，要把字典值为0的删除掉），另外注意print语句也会占用时间；</p><p>另外这个题也可以使用colletions.Counter，Counter可以进行一个计数操作，而且最关键的是<strong>Counter居然可以执行加减操作</strong>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1 = <span class="hljs-string">&quot;aaabbbccc&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count = Counter(text1)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text1_count.get(<span class="hljs-string">&#x27;b&#x27;</span>)<br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(text1_count)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;collections.Counter&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>text2 = <span class="hljs-string">&quot;abcd&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>text2_count = Counter(text2)<br><span class="hljs-meta">&gt;&gt;&gt; </span>text2_count<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tmp = text1_count - text2_count<br><span class="hljs-meta">&gt;&gt;&gt; </span>tmp<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br></code></pre></td></tr></table></figure><p>在上述思路分析后，主要记住新加入的位置是i+window_size-1就好了，代码编写思路还是比较简单，这里使用了Counter的方法，实际上用字典的方法也可以，而且说不定可以增加效率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">findAnagrams</span>(<span class="hljs-params">self, s, p</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    :type s: str</span><br><span class="hljs-string">    :type p: str</span><br><span class="hljs-string">    :rtype: List[int]</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    rList = []<br>    window_size = <span class="hljs-built_in">len</span>(p)<br>    compare_dict = collections.Counter(p)<br>    record_s_dict = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)-window_size+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> record_s_dict <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            record_s_dict = collections.Counter(s[i: window_size])<br>        <span class="hljs-keyword">else</span>:<br>            remove_head = collections.Counter(s[i-<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># print(&quot;remove_head: &quot;, i, remove_head)</span><br>            add_tail = collections.Counter(s[i+window_size-<span class="hljs-number">1</span>]) <span class="hljs-comment"># 调试还是比较容易看出来这个错误的</span><br>            <span class="hljs-comment"># print(&quot;add tail: &quot;, i, add_tail)</span><br>            record_s_dict -= remove_head<br>            record_s_dict += add_tail<br>            <span class="hljs-comment"># print(&quot;record_s_dict: &quot;, i, record_s_dict)</span><br>        <span class="hljs-keyword">if</span> record_s_dict == compare_dict:<br>            rList.append(i)<br>    <br>    <span class="hljs-keyword">return</span> rList<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-screen命令整理</title>
    <link href="/2021/12/08/macOS%E5%8F%8ALinux-screen%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2021/12/08/macOS%E5%8F%8ALinux-screen%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>需求：例如在跑深度学习等程序的时候，需要让程序挂载在后台执行，这时候就可以使用screen命令进行后台的挂载</p><span id="more"></span><h1 id="screen-ls"><a href="#screen-ls" class="headerlink" title="screen -ls"></a>screen -ls</h1><p>查看：<code>screen -ls</code>可以查看当前有哪些Attached&#x2F;Detached的screen界面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">(base) lyx@h5:~$ screen -ls<br>There is a screen on:<br>        12442.xxxxxxx       (12/08/2021 02:12:53 PM)        (Detached)<br>1 Socket in /var/run/screen/S-lyx.=<br></code></pre></td></tr></table></figure><h1 id="screen-S-name"><a href="#screen-S-name" class="headerlink" title="screen -S [name]"></a>screen -S [name]</h1><p>新建：<code>screen -S [name]</code>可以打开一个新的名称为[name]的screen界面</p><h1 id="screen-r-name"><a href="#screen-r-name" class="headerlink" title="screen -r [name]"></a>screen -r [name]</h1><p>返回：<code>screen -r [name]</code>可以返回名称为[name]的screen界面（例如之前暂时退出了，可通过此命令返回），名称可通过<code>screen -ls</code>查看</p><h1 id="screen-X-S-id-quit"><a href="#screen-X-S-id-quit" class="headerlink" title="screen -X -S [id] quit"></a>screen -X -S [id] quit</h1><p>删除：<code>screen -X -S [id] quit</code>可以关闭挂载的一些screen，这里只用输入id号即可</p><h1 id="screen-D-name"><a href="#screen-D-name" class="headerlink" title="screen -D [name]"></a>screen -D [name]</h1><p>有些情况下，如果finalshell等ssh窗口已经关闭，但是还显示在Attached的状态，就需要先D掉再进去</p><p>&#96;&#96;&#96;screen -D [name]&#96;&#96;</p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2+ohmyzsh安装及插件配置</title>
    <link href="/2021/12/06/iterm2+ohmyzsh%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/12/06/iterm2+ohmyzsh%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>背景：iterm2可以替代macOS自带的terminal，而ohmyzsh是基于zsh命令行的一个扩展工具集，在其上可以安装插件来丰富命令行的功能（何老板推荐的syntax highlighting和auto suggestion）</p><span id="more"></span><h1 id="安装item2"><a href="#安装item2" class="headerlink" title="安装item2"></a>安装item2</h1><p>直接官网安装即可，安装后把其保留在程序坞中，手工替代terminal</p><blockquote><p><a href="https://iterm2.com/">https://iterm2.com/</a></p></blockquote><h1 id="安装ohmyzsh"><a href="#安装ohmyzsh" class="headerlink" title="安装ohmyzsh"></a>安装ohmyzsh</h1><p>直接执行官网的一句话命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://ohmyz.sh/#install">https://ohmyz.sh/#install</a></p></blockquote><h1 id="安装ohmyzsh的插件syntax-highlighting和auto-suggestion"><a href="#安装ohmyzsh的插件syntax-highlighting和auto-suggestion" class="headerlink" title="安装ohmyzsh的插件syntax highlighting和auto suggestion"></a>安装ohmyzsh的插件syntax highlighting和auto suggestion</h1><p>Reference:</p><blockquote><p><a href="https://www.jianshu.com/p/2f2c09ebfb7f">https://www.jianshu.com/p/2f2c09ebfb7f</a><br><a href="https://blog.csdn.net/qq_38839744/article/details/90247628">https://blog.csdn.net/qq_38839744/article/details/90247628</a></p></blockquote><h2 id="zsh-syntax-highlighting安装"><a href="#zsh-syntax-highlighting安装" class="headerlink" title="zsh-syntax-highlighting安装"></a>zsh-syntax-highlighting安装</h2><p>官网：</p><blockquote><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting">https://github.com/zsh-users/zsh-syntax-highlighting</a></p></blockquote><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git <br>echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc<br></code></pre></td></tr></table></figure><p>生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source ~/.zshrc<br></code></pre></td></tr></table></figure><h2 id="Auto-suggestion的安装"><a href="#Auto-suggestion的安装" class="headerlink" title="Auto suggestion的安装"></a>Auto suggestion的安装</h2><p>auto suggestion是ohmyzsh的一个插件，作用基本上是根据历史输入指令记录即使的提示，能够提高效率</p><ol><li>git clone项目，并与ZSH建立关联</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone git:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/zsh-users/</span>zsh-autosuggestions <span class="hljs-variable">$ZSH_CUSTOM</span><span class="hljs-regexp">/plugins/</span>zsh-autosuggestions<br></code></pre></td></tr></table></figure><p>其中通过echo查看$ZSH_CUSTOM</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  ~ echo $ZSH_CUSTOM<br>/Users/curious/.oh-my-zsh/custom<br></code></pre></td></tr></table></figure><ol start="2"><li>编辑~&#x2F;.zshrc文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.zshrc<br></code></pre></td></tr></table></figure><p>按i 进入–INSERT–编辑模式，使用上下左右键找找到plugins&#x3D;(git)这一行添加</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">plugins=(git zsh-autosuggestions)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker-Learning</title>
    <link href="/2021/12/06/develop/docker/docker-Learning/"/>
    <url>/2021/12/06/develop/docker/docker-Learning/</url>
    
    <content type="html"><![CDATA[<p>背景：docker有一种更加轻量级虚拟机的感觉，正好在一个课程中需要使用HBase、Hadoop等，又不方便在本地安装，所以可以使用docker的方式，也借此机会学习docker</p><span id="more"></span><h1 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h1><p>macOS上可以安装docker destop，是个可视化的工具</p><blockquote><p><a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></p></blockquote><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><ol><li>第一步，clone a repository</li></ol><p>Getting Started项目是一个简单的Github repository，包含了一切建立镜像（image）和运行为容器（container）的过程</p><p>通过在容器中运行git克隆存储库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:~ curious$ docker run --name repo alpine git clone https://github.com/docker/getting-started.git<br></code></pre></td></tr></table></figure><ol start="2"><li>之后，构建image</li></ol><p>Docker映像是仅用于容器的私有文件系统。它提供容器所需的所有文件和代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:~ curious$ cd getting-started <br>CuriousdeMacBook-Pro:getting-started curious$  docker build -t docker101tutorial .<br></code></pre></td></tr></table></figure><ol start="3"><li>运行第一个container</li></ol><p>基于上一步中生成的映像启动容器。运行容器会启动具有私有资源的应用程序，这些资源与计算机的其余部分安全隔离。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CuriousdeMacBook-Pro:getting-started curious$ docker run -d - p 80:80 --name docker-tutorial docker101tutorial cfd8702ce730feb351565711d7a44d147476d8faa18b03ae2d4815cc137d121b<br></code></pre></td></tr></table></figure><ol start="4"><li>保存并分享镜像</li></ol><p>在Docker Hub上保存和共享您的映像，以便其他用户可以轻松地在任何目标计算机上下载和运行映像。</p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github443问题的解决办法</title>
    <link href="/2021/12/06/mixed/git/github443%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2021/12/06/mixed/git/github443%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>背景：github经常遇到443问题，例如Failed to connect to github.com port 443: Operation timed out，这种情况下需要一些解决办法；</p><p>Reference：</p><blockquote><p><a href="https://www.jianshu.com/p/471aeba64724">https://www.jianshu.com/p/471aeba64724</a></p></blockquote><span id="more"></span><h1 id="解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）"><a href="#解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）" class="headerlink" title="解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）"></a>解决方法一（暂未尝试，但是从原理上来说应该是可以解决的）</h1><ol><li>查询可以用的IP，在</li></ol><blockquote><p><a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a></p></blockquote><p>上分别搜索<code>github.com、github.global-ssl.fastly.net</code></p><ol start="2"><li>修改host文件</li></ol><p>操作：<code>sudo vi /etc/hosts</code> 替换成以下ip即可</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">151.101.185.194</span> github.global-ssl.fastly.net<br><span class="hljs-number">192.30.253.112</span>  github.com<br></code></pre></td></tr></table></figure><p>之后就可以进行一些尝试了</p><h1 id="解决方法二（尝试了可以，需要梯子资源）"><a href="#解决方法二（尝试了可以，需要梯子资源）" class="headerlink" title="解决方法二（尝试了可以，需要梯子资源）"></a>解决方法二（尝试了可以，需要梯子资源）</h1><ol><li>设置代理的方法，首先查找梯子代理的端口：</li></ol><p><img src="/images/2021-12-06-11-45-05.png"></p><p>通过git config命令来设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global http.proxy &quot;localhost:port&quot;<br></code></pre></td></tr></table></figure><ol start="2"><li>在使用完毕后可以改回来</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --unset http.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次hexo博客迁移过程</title>
    <link href="/2021/12/05/mixed/hexo/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/12/05/mixed/hexo/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>背景：换了一个新电脑，需要把原来在github上配置的yixuan004.github.io博客环境重新在本地部署，中间涉及到一些软件的安装等</p><span id="more"></span><h1 id="记录一次hexo博客迁移过程"><a href="#记录一次hexo博客迁移过程" class="headerlink" title="记录一次hexo博客迁移过程"></a>记录一次hexo博客迁移过程</h1><p>换了一个电脑后要重新部署自己的yixuan004.github.io博客，因为之前设置的已经比较完备了，把master分支和coding-pages分支（实际上的主分支）在github上分隔开了，所以首先拉取远程的coding-pages（实际上的主分支）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/yixuan004/yixuan004.github.io.git<br></code></pre></td></tr></table></figure><p>在之后需要在本地补充npm安装hexo环境，<strong>注意hexo环境必须安装在文件夹下</strong></p><p>如果本地没node&#x2F;npm环境的话，可到官网下载</p><blockquote><p><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo npm install hexo<br>sudo npm install npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>在这之后理论上就可以进行操作和push了，和之前的博客一样即可：</p><blockquote><p><a href="https://yixuan004.github.io/2021/09/13/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/">https://yixuan004.github.io/2021/09/13/我的首篇github博客/</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28.实现strStr-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/28-%E5%AE%9E%E7%8E%B0strStr-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/28-%E5%AE%9E%E7%8E%B0strStr-python/</url>
    
    <content type="html"><![CDATA[<p>28.实现strStr()（中等）</p><p>题目大意：实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">题目链接</a></p><p>实现 strStr() 函数。</p><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。</p><p>说明：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。<br>对于本题而言，当 needle 是空字符串时我们应当返回 <span class="hljs-number">0</span> 。这与 C 语言的 <span class="hljs-built_in">strstr</span>() 以及 Java 的 <span class="hljs-built_in">indexOf</span>() 定义相符。<br></code></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;ll&quot;</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;aaaaa&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;bba&quot;</span><br>输出：-<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">haystack</span> = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">needle</span> = <span class="hljs-string">&quot;&quot;</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 5 * 104</li><li>haystack 和 needle 仅由小写英文字符组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题就是KMP算法的完全模板，虽然题目标注的难度是简单但感觉那是调用函数直接的做法。。。例如在python中可以直接用str1.find(str2)来解决，而题目要考察的就是这个函数的实现</p><p>KMP算法非常巧妙，这里学习的是Youtube+b站转载翻译的一个思路：</p><blockquote><p><a href="https://www.bilibili.com/video/BV18k4y1m7Ar?p=1">https://www.bilibili.com/video/BV18k4y1m7Ar?p=1</a></p></blockquote><p>思路是首先在needle（又称pattern）上构建pre数组，或者有人称为next数组。next数组的含义很有可能在面试中被问到，自己写几个的话，感觉强行理解这个next数组就是当前这个位置下，pattern的首尾最长公共子串的数目，例如<code>abc ... abc</code>是一个首尾重复的，这样的话，j在回退的时候，不必每次都回退到头部，而是回退到next[j]的位置，复习一下这个构建next数组的操作，这个kmp算法感觉还是要做到经常操作的（暂时不太考虑很特殊的情况）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">construct_pre_arr</span>(<span class="hljs-params">pattern</span>):<br>    j = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">1</span><br>    pre = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(pattern):<br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[j]:<br>            pre[i] = j + <span class="hljs-number">1</span><br>            j += <span class="hljs-number">1</span><br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> pattern[i] != pattern[j]:<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                pre[i] = <span class="hljs-number">0</span><br>                i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                j = <span class="hljs-built_in">next</span>[j]    <br>    <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure><p>在构建好pre数组后，之后就是两个串来操作了，使用pre数组，让在串str1中寻找pattern的时候，不用每次都回退到pattern的头部，自己手工复习一下这个写法，整个写法上来看是先判断有没有（j是否遍历到了最后一位），再找是哪一段。这里基本只是运用pre数组了，比之前修改还简单些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">i = <span class="hljs-number">0</span>  <span class="hljs-comment"># str1的index</span><br>j = <span class="hljs-number">0</span>  <span class="hljs-comment"># pattern的index</span><br><br><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(str1) <span class="hljs-keyword">and</span> j &lt; <span class="hljs-built_in">len</span>(pattern):<br>    <span class="hljs-keyword">if</span> str1[i] == pattern[j]:<br>        i += <span class="hljs-number">1</span><br>        j += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            j = pre[j]<br><br><span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(pattern):<br>    <span class="hljs-keyword">return</span> i - j<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>整体题目的解答：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type haystack: str</span><br><span class="hljs-string">        :type needle: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        m, n = <span class="hljs-built_in">len</span>(haystack), <span class="hljs-built_in">len</span>(needle)<br>       <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_pre_array</span>(<span class="hljs-params">needle</span>):  <span class="hljs-comment"># 这个是计算pattern串的pre数组</span><br>            pre = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(needle))]<br>            j = <span class="hljs-number">0</span><br>            i = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(needle):<br>                <span class="hljs-keyword">if</span> needle[i] == needle[j]:<br>                    pre[i] = j + <span class="hljs-number">1</span>  <span class="hljs-comment"># 注意这里的等于j + 1，实际上就是一个长度的感觉</span><br>                    j += <span class="hljs-number">1</span><br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                        pre[i] = <span class="hljs-number">0</span><br>                        i += <span class="hljs-number">1</span><br>                    <span class="hljs-keyword">elif</span> j != <span class="hljs-number">0</span>:<br>                        j = pre[j-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 精髓</span><br>            <span class="hljs-keyword">return</span> pre  <span class="hljs-comment"># pre数组的含义是，单个串在这个位置上，前缀长度等于后缀长度的个数，但是为什么要这么做还不是很理解</span><br>        pre = compute_pre_array(needle)<br>       <br>        <span class="hljs-comment"># step2 使用pre数组</span><br>        i = <span class="hljs-number">0</span>  <span class="hljs-comment"># 串1的index</span><br>        j = <span class="hljs-number">0</span>  <span class="hljs-comment"># 串2的index</span><br>        <span class="hljs-keyword">while</span> i &lt; m <span class="hljs-keyword">and</span> j &lt; n:<br>            <span class="hljs-keyword">if</span> haystack[i] == needle[j]:<br>                i += <span class="hljs-number">1</span><br>                j += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> j != <span class="hljs-number">0</span>:<br>                    j = pre[j-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(needle):<br>            <span class="hljs-keyword">return</span> i - j <span class="hljs-comment"># i停下的位置找回去</span><br>        <span class="hljs-keyword">else</span>: <br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>519.随机翻转矩阵-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-python/</url>
    
    <content type="html"><![CDATA[<p>519.随机翻转矩阵（中等）</p><p>题目大意：给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) 被选取的概率应当均等。</p><p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p><p>实现 Solution 类：</p><ul><li>Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象</li><li>int[] flip() 返回一个满足 matrix[i][j] &#x3D;&#x3D; 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1</li><li>void reset() 将矩阵中所有的值重置为 0</li></ul><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/random-flip-matrix/">题目链接</a></p><p>给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] &#x3D;&#x3D; 0 的下标 (i, j) 被选取的概率应当均等。</p><p>尽量最少调用内置的随机函数，并且优化时间和空间复杂度。</p><p>实现 Solution 类：</p><ul><li>Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象</li><li>int[] flip() 返回一个满足 matrix[i][j] &#x3D;&#x3D; 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1</li><li>void reset() 将矩阵中所有的值重置为 0</li></ul><p>示例：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入<br>[<span class="hljs-string">&quot;Solution&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>, <span class="hljs-string">&quot;reset&quot;</span>, <span class="hljs-string">&quot;flip&quot;</span>]<br>[[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [], [], [], [], []]<br>输出<br>[null, [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], null, [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]<br><br>解释<br><span class="hljs-symbol">Solution</span> solution = new <span class="hljs-symbol">Solution</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>solution.flip();  // 返回 [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]，此时返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]、[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 的概率应当相同<br>solution.flip();  // 返回 [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]，因为 [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 已经返回过了，此时返回 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>] 的概率应当相同<br>solution.flip();  // 返回 [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]，根据前面已经返回过的下标，此时只能返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>solution.reset(); // 所有值都重置为 <span class="hljs-number">0</span> ，并可以再次选择下标返回<br>solution.flip();  // 返回 [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]，此时返回 [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]、[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>] 和 [<span class="hljs-number">2</span>,<span class="hljs-number">0</span>] 的概率应当相同<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; m, n &lt;&#x3D; 104</li><li>每次调用flip 时，矩阵中至少存在一个值为 0 的格子。</li><li>最多调用 1000 次 flip 和 reset 方法。</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题如果未来会被问到的话，首先需要自己熟悉一下手写基础框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, m, n</span>):<br>        self.m = m<br>        self.n = n<br>        <span class="hljs-comment"># do something</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># do something</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># do something</span><br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>目前使用一种非常简单的方法就解决了，每次随机一个[0, m-1]，随机一个[0, n-1]（使用random.randint(a, b)，注意这里a，b都是闭区间的），用一个dict判断d[(rand_m, rand_n)]是否有，如果有就一直重新随机，直到不存在，不存在的情况下加入dict。清空则就是清空词典。但这个运气最差得情况下会调用很多次随机函数，所以实际上不符合题意的，只是比较简单实现，暂时不属于hot100题就未来补充了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, m, n</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type m: int</span><br><span class="hljs-string">        :type n: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.m = m<br>        self.n = n<br>        self.temp_dict = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">flip</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: List[int]</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 把self的值取过来</span><br>        m = self.m<br>        n = self.n<br>        <br>        m_temp = random.randint(<span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>)<br>        n_temp = random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-keyword">while</span> self.temp_dict.get((m_temp, n_temp)) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            m_temp = random.randint(<span class="hljs-number">0</span>, m-<span class="hljs-number">1</span>)<br>            n_temp = random.randint(<span class="hljs-number">0</span>, n-<span class="hljs-number">1</span>)<br>        self.temp_dict[(m_temp, n_temp)] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> [m_temp, n_temp]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.temp_dict = &#123;&#125;<br><br><span class="hljs-comment"># Your Solution object will be instantiated and called as such:</span><br><span class="hljs-comment"># obj = Solution(m, n)</span><br><span class="hljs-comment"># param_1 = obj.flip()</span><br><span class="hljs-comment"># obj.reset()</span><br></code></pre></td></tr></table></figure><h1 id="优化解法（减少随机函数的调用次数）待补充"><a href="#优化解法（减少随机函数的调用次数）待补充" class="headerlink" title="优化解法（减少随机函数的调用次数）待补充"></a>优化解法（减少随机函数的调用次数）待补充</h1>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>哈希表</tag>
      
      <tag>TODO优化</tag>
      
      <tag>数学</tag>
      
      <tag>水塘抽样</tag>
      
      <tag>随机化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>121.买卖股票的最佳时机-python</title>
    <link href="/2021/12/03/algorithms/leetcode-python/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-python/"/>
    <url>/2021/12/03/algorithms/leetcode-python/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-python/</url>
    
    <content type="html"><![CDATA[<p>121.买卖股票的最佳时机（简单）</p><p>题目大意：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">题目链接</a></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。</p><p>设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p>示例 1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[7,1,5,3,6,4]<br>输出：5<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出，最大利润 = 6-1 =<span class="hljs-number"> 5 </span>。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 没有交易完成, 所以最大利润为 <span class="hljs-number">0</span>。<br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; prices.length &lt;&#x3D; 105</li><li>0 &lt;&#x3D; prices[i] &lt;&#x3D; 104</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题感觉比较简单，先设置now_min为arr[0]，然后从角标1开始遍历，每次判断现在的arr[i]-now_min是否最大值，如果是则更新最大值。之后更新now_min，如果当前位置小于now_min就更新；</p><p>之前在一本算法书上应该看过这个题，想象一根从最低点到最高点的连线。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">maxProfit</span>(<span class="hljs-params">self, prices</span>):<br>        <span class="hljs-comment"># 异常处理</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prices) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <br>        <span class="hljs-comment"># 逻辑处理</span><br>        max_p = <span class="hljs-number">0</span><br>        now_min = prices[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(prices)):<br>            max_p = <span class="hljs-built_in">max</span>(max_p, prices[i] - now_min)<br><br>            <span class="hljs-keyword">if</span> prices[i] &lt; now_min:<br>                now_min = prices[i]<br>        <br>        <span class="hljs-keyword">return</span> max_p<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>EASY</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>300.最长递增子序列-python</title>
    <link href="/2021/12/01/algorithms/leetcode-python/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-python/"/>
    <url>/2021/12/01/algorithms/leetcode-python/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-python/</url>
    
    <content type="html"><![CDATA[<p>300.最长递增子序列（中等）</p><p>题目大意：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">题目链接</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。</p><p>示例1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; nums.length &lt;&#x3D; 2500</li><li>104 &lt;&#x3D; nums[i] &lt;&#x3D; 104</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><h2 id="解法一：O-n-2-向前查找法"><a href="#解法一：O-n-2-向前查找法" class="headerlink" title="解法一：O(n^2)向前查找法"></a>解法一：O(n^2)向前查找法</h2><p>O(n^2)的解法还是比较好想的（简单题），先创建一个一维dp数组，然后走到每个位置的时候要往前看，看看前边比当前数字小的那些数组位置处，选择一个这些位置里dp值最大的，+1得到现在这个位置的dp值。最后返回max(dp)就可以</p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLIS</span>(<span class="hljs-params">self, nums</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 思路还是很简单的，设置dp数组，走到每个位置后，【往前找】比这个位置小的元素，然后选一个最大的dp[i] + 1当做当前位置的dp</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        dp = [<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums))]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(nums)):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                <span class="hljs-keyword">if</span> nums[i] &gt; nums[j]:<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(dp)<br></code></pre></td></tr></table></figure><h2 id="解法二：优化解法（二分查找）待补充"><a href="#解法二：优化解法（二分查找）待补充" class="headerlink" title="解法二：优化解法（二分查找）待补充"></a>解法二：优化解法（二分查找）待补充</h2>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>MEDIUM</tag>
      
      <tag>动态规划</tag>
      
      <tag>二分查找</tag>
      
      <tag>TODO优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.无重复字符的最长子串-python</title>
    <link href="/2021/11/30/algorithms/leetcode-python/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-python/"/>
    <url>/2021/11/30/algorithms/leetcode-python/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-python/</url>
    
    <content type="html"><![CDATA[<p>3.无重复字符的最长子串（中等）</p><p>题目大意：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">题目链接</a></p><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例1：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;abcabcbb&quot;</span><br><span class="hljs-section">输出: 3 </span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;bbbbb&quot;</span><br><span class="hljs-section">输出: 1</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></code></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;pwwkew&quot;</span><br><span class="hljs-section">输出: 3</span><br><span class="hljs-section">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br>     请注意，你的答案必须是 子串 的长度，<span class="hljs-string">&quot;pwke&quot;</span> 是一个子序列，不是子串。<br></code></pre></td></tr></table></figure><p>示例4：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: s = &quot;&quot;</span><br><span class="hljs-section">输出: 0</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 104</li><li>s 由英文字母、数字、符号和空格组成</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题要及时get到使用滑动窗口来解决这个问题，因为题目要求的是”子串“，这是一个连续的</p><p>在get到是用滑动窗口解决问题后，滑动窗口本身来讲感觉就是一个队列，这个题是变长的</p><p><strong>整体上的思路是：</strong></p><p>遍历字符串，如果遇到不在滑动窗口（队列）中的字符，就加入队列的右边。如果遇到出现在队列中的字符，则队列的左边要缩到这个字符出现的下一位（感觉也可以用<code>find(xxx) + 1</code>来优化），然后再把这个字符加入进去；</p><p>在每次遍历i的时候，判断当前变长滑动窗口的大小和当前的最大值，来更新最大值，用来最终返回</p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot; 滑动窗口对应的数据结构是queue &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        que = []<br>        max_len = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-keyword">while</span> s[i] <span class="hljs-keyword">in</span> que:<br>                que = que[<span class="hljs-number">1</span>:] <span class="hljs-comment"># </span><br>            que.append(s[i])<br>            max_len = <span class="hljs-built_in">max</span>(max_len, <span class="hljs-built_in">len</span>(que))<br>        <br>        <span class="hljs-keyword">return</span> max_len<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
      <category>LeetCode-热题 HOT 100</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>423.从英文中重建数字-python</title>
    <link href="/2021/11/29/algorithms/leetcode-python/423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97-python/"/>
    <url>/2021/11/29/algorithms/leetcode-python/423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97-python/</url>
    
    <content type="html"><![CDATA[<p>423.从英文中重建数字（中等）</p><p>题目大意：给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/">题目链接</a></p><p>给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：s = <span class="hljs-string">&quot;owoztneoer&quot;</span><br>输出：<span class="hljs-string">&quot;012&quot;</span><br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">输入：s = <span class="hljs-string">&quot;fviefuro&quot;</span><br>输出：<span class="hljs-string">&quot;45&quot;</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; s.length &lt;&#x3D; 105</li><li>s[i] 为 [“e”,”g”,”f”,”i”,”h”,”o”,”n”,”s”,”r”,”u”,”t”,”w”,”v”,”x”,”z”] 这些字符之一</li><li>s 保证是一个符合题目要求的字符串</li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这种题有一种脑筋急转弯的感觉，每个数字的英文中会有一些特点，这样可以统计出来每个英文字母在哪些数字中出现了，如下图所示。这样可以通过计数的方式来从“出现一次”的分析，例如“x”只在six中出现，之后可以像数独一样链着分析。</p><p>统计分析规律，列出每个字母在哪些数字的英文中出现了，然后有些字母实际上只在一个数字中出现了，统计这些字母的个数就是这个数字的个数。然后来有些字母在两个数字中出现的，贪心下</p><p><strong>需要注意，尽量避免使用一个字母在一个单词中出现两次的，例如nine中的n</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-literal">zero</span><br><span class="hljs-literal">one</span><br><span class="hljs-literal">two</span><br><span class="hljs-literal">three</span> <br><span class="hljs-literal">four</span><br><span class="hljs-literal">five</span><br><span class="hljs-literal">six</span><br><span class="hljs-literal">seven</span><br><span class="hljs-literal">eight</span><br><span class="hljs-literal">nine</span><br></code></pre></td></tr></table></figure><p><img src="/images/2021-11-30-00-12-10.png"></p><p>解题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">originalDigits</span>(<span class="hljs-params">self, s</span>):<br>        cnt_dict = &#123;&#125;<br>        m = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br>        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(s):<br>            <span class="hljs-keyword">if</span> cnt_dict.get(c) <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                cnt_dict[c] = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                cnt_dict[c] += <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 单位的</span><br>        m[<span class="hljs-number">8</span>] = cnt_dict.get(<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">4</span>] = cnt_dict.get(<span class="hljs-string">&#x27;u&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">2</span>] = cnt_dict.get(<span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">6</span>] = cnt_dict.get(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-number">0</span>)<br>        m[<span class="hljs-number">0</span>] = cnt_dict.get(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 两位的</span><br>        m[<span class="hljs-number">5</span>] = cnt_dict.get(<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">4</span>]<br>        m[<span class="hljs-number">3</span>] = cnt_dict.get(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">8</span>]<br>        m[<span class="hljs-number">7</span>] = cnt_dict.get(<span class="hljs-string">&#x27;v&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">5</span>]<br><br>        <span class="hljs-comment"># 差0 1 和 9</span><br>        m[<span class="hljs-number">0</span>] = cnt_dict.get(<span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">3</span>] - m[<span class="hljs-number">4</span>]<br>        m[<span class="hljs-number">1</span>] = cnt_dict.get(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">0</span>] - m[<span class="hljs-number">2</span>] - m[<span class="hljs-number">4</span>]<br>        <span class="hljs-comment"># m[9] = cnt_dict.get(&#x27;n&#x27;, 0) - m[1] - m[7] # 字母尽量选择出现1次的，所以n不行</span><br>        m[<span class="hljs-number">9</span>] = cnt_dict.get(<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>) - m[<span class="hljs-number">5</span>] - m[<span class="hljs-number">6</span>] - m[<span class="hljs-number">8</span>]<br><br>        <span class="hljs-comment"># 可否优化</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>.join(<span class="hljs-built_in">str</span>(i) * m[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MEDIUM</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>700.二叉搜索树中的搜索-python</title>
    <link href="/2021/11/29/algorithms/leetcode-python/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-python/"/>
    <url>/2021/11/29/algorithms/leetcode-python/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-python/</url>
    
    <content type="html"><![CDATA[<p>700.二叉树中的搜索（简单）</p><p>题目大意：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">题目链接</a></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">给定二叉搜索树:<br><br>        <span class="hljs-number">4</span><br>       / <span class="hljs-string">\</span><br>      <span class="hljs-number">2</span>   <span class="hljs-number">7</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br><br>和值: <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>应该返回如下子树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">2</span>     <br> / <span class="hljs-string">\</span>   <br><span class="hljs-number">1</span>   <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>这个题需要明白，return type如果是有类型的，例如这里是TreeNode类型，在此函数内部的递归循环中，每个返回值也要是TreeNode类型的，类似于这题里边的<code>return self.searchBST(root.left, val)</code>，调用的时候是return funct()</p><p>TreeNode类，每次手写一下保持手感</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, left=<span class="hljs-literal">None</span>, right=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.left = left<br>        self.right = right<br></code></pre></td></tr></table></figure><p>求解</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">searchBST</span>(<span class="hljs-params">self, root, val</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type root: TreeNode</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: TreeNode</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>: <span class="hljs-comment"># None要放到前边</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">if</span> val == root.val:<br>            <span class="hljs-keyword">return</span> root<br>        <span class="hljs-keyword">if</span> val &lt; root.val:<br>            <span class="hljs-keyword">return</span> self.searchBST(root.left, val)<br>        <span class="hljs-keyword">elif</span> val &gt; root.val:<br>            <span class="hljs-keyword">return</span> self.searchBST(root.right, val)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode-python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EASY</tag>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
      <tag>二叉搜索树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次pycharm的配置过程</title>
    <link href="/2021/11/24/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1pycharm%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/11/24/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1pycharm%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>在之前会用vscode远程连接服务器写代码，pycharm是另外一种的操作，用了pycharm后感觉可以在本地也备份一份的感觉</p><p>在同步的时候，可以本地不存储那些数据文件，只存储核心的代码文件，这样如果远程服务器和github无法连接的时候，就可以将本地的那些代码文件向github同步（正好在向github同步的时候要避免对于数据的同步，而只同步代码）</p><span id="more"></span><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><ol><li>新建project</li></ol><p><img src="/images/2021-11-24-22-57-01.png"></p><ol start="2"><li>选择路径这里，这里venv可以随意选择（个人感觉最好不选择，但是不一定能跳过这一步）</li></ol><p><img src="/images/2021-11-24-22-58-37.png"></p><ol start="3"><li>打开File -&gt; Preference，选择Interpreter</li></ol><p><img src="/images/2021-11-24-23-00-48.png"></p><p>这里的Interpreter需要选择远程的ssh Interpreter<br><img src="/images/2021-11-24-23-01-51.png"></p><p><img src="/images/2021-11-24-23-05-04.png"></p><p><img src="/images/2021-11-24-23-05-14.png"></p><p><img src="/images/2021-11-24-23-05-57.png"></p><ol start="4"><li>设置deployment，设置有远程文件夹和本地文件夹的同步</li></ol><p><img src="/images/2021-11-24-23-09-45.png"></p><ol start="5"><li>测试torch.cuda.is_available()</li></ol><p><img src="/images/2021-11-24-23-10-41.png"></p><ol start="6"><li>设置本地删除文件后，远程也会随之删除</li></ol><p><img src="/images/2021-11-24-23-12-10.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/149040742">https://zhuanlan.zhihu.com/p/149040742</a><br><a href="https://blog.csdn.net/renhanchi/article/details/93769003">https://blog.csdn.net/renhanchi/article/details/93769003</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录服务器miniconda配置虚拟环境</title>
    <link href="/2021/11/10/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8miniconda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/11/10/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8miniconda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>在服务器上之前自己一直用的是virtualenv的环境建立虚拟环境，有一种比较依赖本机已经安装了相关python的感觉。另外昨天在使用virtualenv的时候发现pip的版本对应有些问题，会报sys.stderr.write(f”ERROR: {exc}”)这个错</p><p>大佬同学推荐了一个miniconda的方法，感觉安装起来很方便，虚拟环境感觉都可以使用类似的方法了</p><span id="more"></span><p>Reference：<br><code>https://conda.io/en/latest/miniconda.html</code></p><h1 id="安装Linux-Installers"><a href="#安装Linux-Installers" class="headerlink" title="安装Linux Installers"></a>安装Linux Installers</h1><p><img src="/images/2021-11-10-09-43-27.png"></p><p>下载后会得到一个<code>Miniconda3-latest-Linux-x86_64.sh</code>，上传到服务器上后可通过bash直接安装</p><h1 id="建立、启动虚拟环境"><a href="#建立、启动虚拟环境" class="headerlink" title="建立、启动虚拟环境"></a>建立、启动虚拟环境</h1><p>可通过如下命令建立启动虚拟环境，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">conda create -n myenv python=3.8 // 安装python</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">conda activate myenv</span><br><span class="hljs-meta prompt_">(myenv)$ </span><span class="language-bash">pip install ...</span> <br></code></pre></td></tr></table></figure><h1 id="安装torch，torchvision，cudatoolkit"><a href="#安装torch，torchvision，cudatoolkit" class="headerlink" title="安装torch，torchvision，cudatoolkit"></a>安装torch，torchvision，cudatoolkit</h1><p>使用conda可以不依赖pip进行安装，conda安装一些内容好像可以非常方便。自己在尝试pip install pytorch的时候经常出现和cuda版本对应不上的问题，还有就是pytorch0.4.1的版本中没有boolTensor，所以需要把pytorch搞成1.x版本并且和cuda版本对应的上</p><p>首先使用nvidia-smi查看当前cuda</p><p><img src="/images/2021-11-13-16-20-10.png"></p><p>在pytorch官网<a href="https://pytorch.org/get-started/previous-versions/%E4%B8%8A%E6%9F%A5%E7%9C%8Bprevious">https://pytorch.org/get-started/previous-versions/上查看previous</a> version，一般来说1.4.0，1.6.0比较稳定？</p><p><img src="/images/2021-11-13-16-21-01.png"></p><p>输入命令进行安装：</p><p><img src="/images/2021-11-13-16-21-42.png"></p><p>测试如下：</p><p><img src="/images/2021-11-13-16-35-55.png"></p><h1 id="另外一种直接pip-install的方式（from-zkh）"><a href="#另外一种直接pip-install的方式（from-zkh）" class="headerlink" title="另外一种直接pip install的方式（from zkh）"></a>另外一种直接pip install的方式（from zkh）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu113<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP代码学习笔记</title>
    <link href="/2021/10/30/research/code/NLP%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/10/30/research/code/NLP%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>记录一些代码中常用的操作说明及bug解决记录</p><span id="more"></span><h1 id="nn-Embedding-from-pretrained"><a href="#nn-Embedding-from-pretrained" class="headerlink" title="nn.Embedding.from_pretrained"></a>nn.Embedding.from_pretrained</h1><p>整个代码的上下文是在做label_ids和slot_ids的embedding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_slot_value_lookup</span>(<span class="hljs-params">self, label_ids, slot_ids</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    self.sv_encoder = BertForUtteranceEncoding.from_pretrained(</span><br><span class="hljs-string">            os.path.join(args.bert_dir, &#x27;bert-base-uncased&#x27;)</span><br><span class="hljs-string">        )</span><br><span class="hljs-string">    # 作者把调用sv_encoder的部分fix住</span><br><span class="hljs-string">    for p in self.sv_encoder.bert.parameters():</span><br><span class="hljs-string">        p.requires_grad = False</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    self.sv_encoder.<span class="hljs-built_in">eval</span>() <span class="hljs-comment"># 切换到evaluate模式</span><br><br>    <span class="hljs-comment"># Slot encoding，这个是fix住的部分</span><br>    slot_type_ids = torch.zeros(slot_ids.size(), dtype=torch.long).to(self.device) <span class="hljs-comment"># 初始化一个空的slot_type_ids</span><br>    slot_mask = slot_ids &gt; <span class="hljs-number">0</span><br>    hid_slot, _ = self.sv_encoder(slot_ids.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    slot_type_ids.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    slot_mask.view(-<span class="hljs-number">1</span>, self.max_label_length),<br>                                    output_all_encoded_layers=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 获取CLS的token，hidden的</span><br>    hid_slot = hid_slot[:, <span class="hljs-number">0</span>, :] <span class="hljs-comment"># 博客中指出，这样的操作是在获取CLStoken，而CLStoken是用来进行分类的，也一般被认为是整句话的embedding</span><br>    hid_slot = hid_slot.detach()<br>    self.slot_lookup = nn.Embedding.from_pretrained(hid_slot, freeze=<span class="hljs-literal">True</span>) <span class="hljs-comment"># slot的embedding结果，是不可以训练的</span><br></code></pre></td></tr></table></figure><h1 id="报在同时使用cpu和gpu的错误"><a href="#报在同时使用cpu和gpu的错误" class="headerlink" title="报在同时使用cpu和gpu的错误"></a>报在同时使用cpu和gpu的错误</h1><p>报在同时使用cpu和gpu的错误除了tensor要tensor.to(device)以外，model也要.to(device)，否则可能会报在同时使用cpu和gpu的错误</p><h1 id="pytorch中判断两个tensor是否相等"><a href="#pytorch中判断两个tensor是否相等" class="headerlink" title="pytorch中判断两个tensor是否相等"></a>pytorch中判断两个tensor是否相等</h1><ol><li><p>tensor.equal()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 该方法用于比较两个tensor是否一样，一样则返回True否则为False</span><br>a = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>b = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br><span class="hljs-built_in">print</span>(a.equal(b))    <span class="hljs-comment"># 返回True</span><br></code></pre></td></tr></table></figure></li><li><p>tensor.eq()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 该方法用于主元素比较是否相等，相等则在对应位置返回True，否则为False</span><br>a = torch.tensor([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br>b = torch.tensor([<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>])<br><span class="hljs-built_in">print</span>(a.eq(b))  <span class="hljs-comment"># 返回tensor([False,True,False,True]),与a==b返回的结果一样</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="pytorch输出整个tensor的方法"><a href="#pytorch输出整个tensor的方法" class="headerlink" title="pytorch输出整个tensor的方法"></a>pytorch输出整个tensor的方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.set_printoptions(profile=<span class="hljs-string">&quot;full&quot;</span>)<br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># prints the whole tensor</span><br>torch.set_printoptions(profile=<span class="hljs-string">&quot;default&quot;</span>) <span class="hljs-comment"># reset</span><br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># prints the truncated tensor</span><br></code></pre></td></tr></table></figure><p>在这样的输出下，之后就可以写到文件里了</p><h1 id="tensor-x3D-tensor-0-0"><a href="#tensor-x3D-tensor-0-0" class="headerlink" title="tensor &#x3D; tensor[0, :, 0]"></a>tensor &#x3D; tensor[0, :, 0]</h1><p>这种操作可能代表着仅需要获取bert的cls token的embedding结果，也被认为是整句话的embedding</p><h1 id="contigous-view"><a href="#contigous-view" class="headerlink" title=".contigous().view()"></a>.contigous().view()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">.contigous().view()<br></code></pre></td></tr></table></figure><p>有些tensor并不是占用一整块内存，而是由不同的数据块组成，而tensor的view()操作依赖于内存是整块的，这时只需要执行contigous()这个函数，把tensor变成在内存中连续分布的形式，再使用view。</p><p>Pytorch0.4中，增加了一个reshape函数，就相当于contigous().view()的功能了！</p><h1 id="pytorch常用的张量操作及归一化算法实现"><a href="#pytorch常用的张量操作及归一化算法实现" class="headerlink" title="pytorch常用的张量操作及归一化算法实现"></a>pytorch常用的张量操作及归一化算法实现</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/76255917">https://zhuanlan.zhihu.com/p/76255917</a></p></blockquote><h1 id="squeeze-和-unsqueeze"><a href="#squeeze-和-unsqueeze" class="headerlink" title=".squeeze() 和 .unsqueeze()"></a>.squeeze() 和 .unsqueeze()</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">.squeeze()<br>.unsqueeze()<br></code></pre></td></tr></table></figure><p>squeeze()为压缩的意思，即去掉维度数为1的dim，默认是去掉所有为1的，但是也可以自己指定，但如果指定的维度不为1则不会发生任何改变。</p><p>unsqueeze(dim)则与squeeze(dim)正好相反，为添加一个维度的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># print(&quot;hidden.shape: &quot;, hidden.shape) # torch.Size([96, 1, 768]</span><br>hidden = hidden.squeeze() <span class="hljs-comment"># .squeeze()舍弃维度</span><br><span class="hljs-comment"># print(&quot;after .squeeze(), hidden.shape: &quot;, hidden.shape) # torch.Size([96, 768])</span><br></code></pre></td></tr></table></figure><h1 id="nn-GRU-与-nn-LSTM"><a href="#nn-GRU-与-nn-LSTM" class="headerlink" title="nn.GRU 与 nn.LSTM"></a>nn.GRU 与 nn.LSTM</h1><p>循环神经网络是一种能够自适应的变长网络，能够对带有上下文的连续序列很好地进行编码</p><blockquote><p><a href="https://pytorch.org/docs/stable/torch.html">https://pytorch.org/docs/stable/torch.html</a></p></blockquote><h2 id="基本文档说明"><a href="#基本文档说明" class="headerlink" title="基本文档说明"></a>基本文档说明</h2><p><strong>参数设置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">input_size: 单个LSTM神经元的输入维度<br>hidden_size: 单个LSTM神经元的隐含层输出维度<br>num_layers: LSTM的层数，这里指的是叠起来的层数，而不是展开的层数，展开是自适应的。<br>bias: 计算过程中是否需要偏置<br>batch_first: batch是否位于第一个维度，很多时候容易混淆，将在之后进一步解释<br>dropout: 其中每一层输出的dropout概率，默认为<span class="hljs-number">0</span>即不进行dropout，需要注意的一点是最后一层的输出是不会加上dropout概率的。也就是说，当只用到一层LSTM的时候，这个参数是不起作用的。<br>bidirectional: 是否双向，当设置为<span class="hljs-literal">True</span>的时候，输出会为将双向LSTM的输出进行拼接，输出的feature size会增加一倍<br>proj_size: 很多博客中都没有解释，用到的时候可能需要参考 <span class="hljs-comment"># https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html#torch.nn.LSTM</span><br><br>self.nbt = nn.LSTM(input_size=self.bert_output_dim,<br>                              hidden_size=self.hidden_dim,<br>                              num_layers=self.rnn_num_layers,<br>                              dropout=self.hidden_dropout_prob,<br>                              batch_first=<span class="hljs-literal">True</span>)<br><br>self.nbt = nn.GRU(input_size=self.bert_output_dim,<br>                              hidden_size=self.hidden_dim, <span class="hljs-comment"># args.hidden_dim</span><br>                              num_layers=self.rnn_num_layers,<br>                              dropout=self.hidden_dropout_prob,<br>                              batch_first=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p><strong>Inputs</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">input</span>: <span class="hljs-built_in">input</span>, (h_0, c_0)<br><br><span class="hljs-built_in">input</span>: 当batch_first = <span class="hljs-literal">False</span>的时候(L, N, H_in)，当batch_first=<span class="hljs-literal">True</span>的时候(N, L, H_in)<br>h_0: (D*num_layers, N, H_out)，containing the initial hidden state <span class="hljs-keyword">for</span> each element <span class="hljs-keyword">in</span> the batch. Defaults to zeros <span class="hljs-keyword">if</span> (h_0, c_0) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> provided.<br>c_0: (D*num_layers, N, H_cell)，containing the initial cell state <span class="hljs-keyword">for</span> each element <span class="hljs-keyword">in</span> the batch. Defaults to zeros <span class="hljs-keyword">if</span> (h_0, c_0) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> provided.<br><br>其中：<br>    N是batch_size<br>    L是每句话的长度<br>    如果使用双向LSTM则D是<span class="hljs-number">2</span>，否则是<span class="hljs-number">1</span><br>    H_in是输入的hiddendim（例如是bert的输出<span class="hljs-number">768</span>）<br>    H_cell是LSTM内部的hidden_size<br>    H_out和输入参数中的proj_size相关，但基本可以理解为就是hidden_size，<br></code></pre></td></tr></table></figure><p><strong>Outputs</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">Outputs: output, (h_n, c_n)<br><br>output: 当batch_first=<span class="hljs-literal">False</span>的时候是(L, N, D*H_out)，当batch_first=<span class="hljs-literal">True</span>的时候是(N, L, D*H_out)，其中包括了LSTM最后一层的输出h_t，对于每个t时刻。在PackedSequence相关上还有其他的操作，不过暂时就先不管了<br>h_n: (D*num_layers, N, H_out)包含了每个batch中最后的一个hidden state的element<br>c_n: (D*num_layersm N, H_cell)包含了最后一个cell的state，对于每个batch的最后一个element？<br></code></pre></td></tr></table></figure><h2 id="关于循环神经网络"><a href="#关于循环神经网络" class="headerlink" title="关于循环神经网络"></a>关于循环神经网络</h2><h3 id="关于输入输出的三个维度"><a href="#关于输入输出的三个维度" class="headerlink" title="关于输入输出的三个维度"></a>关于输入输出的三个维度</h3><p>自：维度在tensor的变化中始终是最关键的部分，怎么理解维度背后的含义？</p><p>对于输入输出，我们首先需要注意是传给的网络输出必须是三维的<br>其中每个维度代表的意思，我们习惯的方式是[batch_size, sequence_length, feature_size]<br>具体来说，假如输入的是句子的话，每个维度的含义就是：</p><p>[一次投入到网络中的句子的条数，句子的长度，句子中每个单词对应的向量维度]</p><p>自：在SUMBT代码中，这里的输入该怎么一步步的理解</p><h3 id="关于batch-first"><a href="#关于batch-first" class="headerlink" title="关于batch first"></a>关于batch first</h3><p>这个是一个非常有趣的参数，他能够将输入的形式变为我们习惯的[batch_size, seq_len, feature_size]</p><p>也就是说原本输入参数的形式是[seq_len, batch_size, feature_size]可以视作原本为一列一句话，现在给我们改成了更习惯的一行一句话</p><p>更通俗的来说，就是原本一行为一个句子，变成每一列为一个句子，其实设置了batch_first，也不过是在内部也是使用了第1维度和第2维度的转置操作来变成初始形式</p><p>在SUMBT中怎么理解这个事情？……</p><h1 id="DST任务中的slot-accuracy和joint-accuracy"><a href="#DST任务中的slot-accuracy和joint-accuracy" class="headerlink" title="DST任务中的slot_accuracy和joint_accuracy"></a>DST任务中的slot_accuracy和joint_accuracy</h1><p>slot_accuracy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">acc_slot = torch.<span class="hljs-built_in">sum</span>(accuracy, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>() / torch.<span class="hljs-built_in">sum</span>(labels.view(-<span class="hljs-number">1</span>, slot_dim) &gt; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>()<br></code></pre></td></tr></table></figure><p>个人总结：按照三个槽分别算，对的除以总的（需要去除padding）就是slot_accuracy</p><p>joint_accuracy:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">acc = <span class="hljs-built_in">sum</span>(torch.<span class="hljs-built_in">sum</span>(accuracy, <span class="hljs-number">1</span>) / slot_dim).<span class="hljs-built_in">float</span>() / torch.<span class="hljs-built_in">sum</span>(labels[:, :, <span class="hljs-number">0</span>].view(-<span class="hljs-number">1</span>) &gt; -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).<span class="hljs-built_in">float</span>() <span class="hljs-comment"># joint accuracy</span><br></code></pre></td></tr></table></figure><p>个人总结：每轮对话的算成一个，例如在每轮对话中有3个槽，对了2个，该轮对话就是0.66，之后把所有轮对话的加在一起，除以对话的有效轮数就是joint_accuracy</p><h1 id="tqdm中的desc参数"><a href="#tqdm中的desc参数" class="headerlink" title="tqdm中的desc参数"></a>tqdm中的desc参数</h1><p>这里desc参数是进度条的前缀名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tqdm(dev_dataloader, desc=<span class="hljs-string">&quot;Validation&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="tensorboard的使用"><a href="#tensorboard的使用" class="headerlink" title="tensorboard的使用"></a>tensorboard的使用</h1><p>看起来tensorboard和tensorboardX不是一个东西？ 所以需要使用pip install进行安装(venv环境下)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install tensorboard</span><br>...<br>(venvsumbt) lyx@h1:/hdd1/lyx$ tensorboard<br>TensorFlow installation not found - running with reduced feature set.<br>Error: A logdir or db must be specified. For example `tensorboard --logdir mylogdir` or `tensorboard --db sqlite:~/.tensorboard.db`. Run `tensorboard --helpfull` for details and examples.<br></code></pre></td></tr></table></figure><p>使用方法如下（SUMBT-lyx为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">(venvsumbt) lyx@h1:/hdd1/lyx/SUMBT-lyx$ tensorboard --logdir=&#x27;SUMBT-lyx/tensorboard/output&#x27;<br>TensorFlow installation not found - running with reduced feature set.<br><br>NOTE: Using experimental fast data loading logic. To disable, pass<br>    &quot;--load_fast=false&quot; and report issues on GitHub. More details:<br>    https://github.com/tensorflow/tensorboard/issues/4784<br><br>Serving TensorBoard on localhost; to expose to the network, use a proxy or pass --bind_all<br>TensorBoard 2.7.0 at http://localhost:6007/ (Press CTRL+C to quit)<br></code></pre></td></tr></table></figure><p>此时还需要配合一条端口转发命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh lyx@xxx.xxx.xxx.xxx -L 6007:localhost:6007<br></code></pre></td></tr></table></figure><p>注意要在训练前另开一个bash执行如下，然后再开启训练，否则可能会出现tensorboard没有显示的情况<br>使用绝对路径！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/ckpt-output<br><br>tensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/20211020-1152-lyx测试<br></code></pre></td></tr></table></figure><h1 id="TensorDataset，SequentialSampler，Dataloader相关"><a href="#TensorDataset，SequentialSampler，Dataloader相关" class="headerlink" title="TensorDataset，SequentialSampler，Dataloader相关"></a>TensorDataset，SequentialSampler，Dataloader相关</h1><p>Reference:</p><blockquote><p><a href="https://pytorch.org/docs/stable/data.html?highlight=sequentialsampler#torch.utils.data.SequentialSampler">https://pytorch.org/docs/stable/data.html?highlight=sequentialsampler#torch.utils.data.SequentialSampler</a></p></blockquote><p>在代码中看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">xxx_sampler = SequentialSampler(xxx_data)  <span class="hljs-keyword">or</span> RandomSampler(xxx_data)<br>xxx_dataloader = DataLoader(xxx_data, sampler=xxx_sampler, batch_size=...)<br></code></pre></td></tr></table></figure><p>自：一般来说在训练过程中使用RandomSampler，dev和test过程中使用SequentialSampler，</p><p>在DST任务中因为和上下文一些状态有关，所以是不是只能顺序采样</p><h2 id="CLASS-torch-utils-data-SequentialSampler-data-source"><a href="#CLASS-torch-utils-data-SequentialSampler-data-source" class="headerlink" title="CLASS torch.utils.data.SequentialSampler(data_source)"></a>CLASS torch.utils.data.SequentialSampler(data_source)</h2><p>按顺序采样元素，始终按相同顺序采样（构建一个迭代器）</p><p>源代码是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SequentialSampler</span>(Sampler[<span class="hljs-built_in">int</span>]):<br>    <span class="hljs-string">r&quot;&quot;&quot;Samples elements sequentially, always in the same order.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        data_source (Dataset): dataset to sample from</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    data_source: Sized<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, data_source: Sized</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.data_source = data_source<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>) -&gt; Iterator[<span class="hljs-built_in">int</span>]:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.data_source)))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.data_source)<br></code></pre></td></tr></table></figure><h2 id="CLASS-torch-utils-data-RandomSampler-data-source-replacement-x3D-False-num-samples-x3D-None-generator-x3D-None"><a href="#CLASS-torch-utils-data-RandomSampler-data-source-replacement-x3D-False-num-samples-x3D-None-generator-x3D-None" class="headerlink" title="CLASS torch.utils.data.RandomSampler(data_source, replacement&#x3D;False, num_samples&#x3D;None, generator&#x3D;None)"></a>CLASS torch.utils.data.RandomSampler(data_source, replacement&#x3D;False, num_samples&#x3D;None, generator&#x3D;None)</h2><p>随机抽取元素样本。如果没有替换，则从无序数据集中采样。如果使用替换，则用户可以指定要绘制的样本数</p><p>源代码见：</p><blockquote><p><a href="https://pytorch.org/docs/stable/_modules/torch/utils/data/sampler.html#RandomSampler">https://pytorch.org/docs/stable/_modules/torch/utils/data/sampler.html#RandomSampler</a></p></blockquote><h1 id="np-prod"><a href="#np-prod" class="headerlink" title="np.prod()"></a>np.prod()</h1><p>Reference: </p><blockquote><p><a href="https://blog.csdn.net/weixin_40522801/article/details/106578775">https://blog.csdn.net/weixin_40522801/article/details/106578775</a></p></blockquote><p>np.prod()用来计算所有元素的乘积，pro应该是product的简写，开始的时候不是很明白为什么在计算acc的时候会使用np.prod这个函数，后来发现这个是在计算jointacc上的很好用的函数，因为对于jointacc来说一轮中只要有一个错就算错了</p><p>下边这个代码展示了一个JointGA的计算方式，注意在fuzz模式下，可能出现不是1的单轮jointacc值，但是还会有一种越乘越小的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Joint goal accuracy.</span><br>goal_acc[JOINT_GOAL_ACCURACY] = np.prod(list_acc) <span class="hljs-keyword">if</span> list_acc <span class="hljs-keyword">else</span> NAN_VAL<br></code></pre></td></tr></table></figure><h1 id="fuzz-token-sort-ratio"><a href="#fuzz-token-sort-ratio" class="headerlink" title="fuzz.token_sort_ratio()"></a>fuzz.token_sort_ratio()</h1><p>在对于DST任务non-categorical槽进行评价的时候，很多方法中会使用fuzz这个模式匹配，代码如下，其中str_ref（erence）是真值字符串，str_hyp（othesis）是预测的那个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">match_score = fuzz.token_sort_ratio(str_ref, str_hyp) / <span class="hljs-number">100.0</span><br></code></pre></td></tr></table></figure><p>解读下fuzz.token_sort_ratio这个函数，在源代码中调用顺序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">token_sort_ratio</span>(<span class="hljs-params">s1, s2, force_ascii=<span class="hljs-literal">True</span>, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return a measure of the sequences&#x27; similarity between 0 and 100</span><br><span class="hljs-string">    but sorting the token before comparing.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> _token_sort(s1, s2, partial=<span class="hljs-literal">False</span>, force_ascii=force_ascii, full_process=full_process)<br><br><span class="hljs-meta">@utils.check_for_none</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_token_sort</span>(<span class="hljs-params">s1, s2, partial=<span class="hljs-literal">True</span>, force_ascii=<span class="hljs-literal">True</span>, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    自己注释：按照token进行排序</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    sorted1 = _process_and_sort(s1, force_ascii, full_process=full_process)<br>    sorted2 = _process_and_sort(s2, force_ascii, full_process=full_process)<br><br>    <span class="hljs-keyword">if</span> partial:<br>        <span class="hljs-keyword">return</span> partial_ratio(sorted1, sorted2)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> ratio(sorted1, sorted2)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_process_and_sort</span>(<span class="hljs-params">s, force_ascii, full_process=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Return a cleaned string with token sorted</span><br><span class="hljs-string">    返回一个按照token排序的干净的string，这里这个干净就是调用full_process</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># pull tokens</span><br>    ts = utils.full_process(s, force_ascii=force_ascii) <span class="hljs-keyword">if</span> full_process <span class="hljs-keyword">else</span> s<br>    tokens = ts.split()<br><br>    <span class="hljs-comment"># sort tokens and join</span><br>    sorted_string = <span class="hljs-string">u&quot; &quot;</span>.join(<span class="hljs-built_in">sorted</span>(tokens))<br>    <span class="hljs-keyword">return</span> sorted_string.strip()<br><br><span class="hljs-comment"># utils.full_process</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">full_process</span>(<span class="hljs-params">s, force_ascii=<span class="hljs-literal">False</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Process string by</span><br><span class="hljs-string">        -- removing all but letters and numbers</span><br><span class="hljs-string">        -- trim whitespace</span><br><span class="hljs-string">        -- force to lower case</span><br><span class="hljs-string">        if force_ascii == True, force convert to ascii</span><br><span class="hljs-string">    这里是几种字符过滤方式，    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> force_ascii:<br>        s = asciidammit(s)<br>    <span class="hljs-comment"># Keep only Letters and Numbers (see Unicode docs).</span><br>    string_out = StringProcessor.replace_non_letters_non_numbers_with_whitespace(s) <span class="hljs-comment"># 用空格替代所有不是字母和数字的</span><br>    <span class="hljs-comment"># Force into lowercase.</span><br>    string_out = StringProcessor.to_lower_case(string_out)<br>    <span class="hljs-comment"># Remove leading and trailing whitespaces.</span><br>    string_out = StringProcessor.strip(string_out)<br>    <span class="hljs-keyword">return</span> string_out<br></code></pre></td></tr></table></figure><p>首先把一个字符串不是字母、数字的字符都用空格替换并转化成小写，然后按照空格切分后进行排序，排序后按照字符级别计算编辑距离比。</p><p>编辑距离比的计算方式是：(len(str1)+len(str2)-编辑距离) &#x2F; (len(str1)+len(str2))</p><p>例如：<br>“Curious San Francisco”（字符含空格长度为21） 和 “San Francisco”（字符不含空格长度为13），编辑距离为8<br>(21 + 13 - 8) &#x2F; (21 + 13) &#x3D; 0.7647</p><p>“CuriousAAA San Francisco”（字符含空格长度为24） 和 “San Francisco”（字符不含空格长度为13），编辑距离为11<br>(24 + 13 - 11) &#x2F; (24 + 13) &#x3D; 0.7027</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-统计文件夹下的文件目录个数</title>
    <link href="/2021/10/28/macOS%E5%8F%8ALinux-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AA%E6%95%B0/"/>
    <url>/2021/10/28/macOS%E5%8F%8ALinux-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>需求：希望直接在命令行中统计文件夹下的文件、目录个数</p><span id="more"></span><ol><li><p>统计文件夹下文件个数，包括子文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR | grep <span class="hljs-string">&quot;^-&quot;</span>| <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li><li><p>统计文件夹下目录个数，包括子目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -lR | grep <span class="hljs-string">&quot;^d&quot;</span>| <span class="hljs-built_in">wc</span> -l<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS删除一个文件夹下的.DS_Store</title>
    <link href="/2021/10/11/macOS%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84-DS-Store/"/>
    <url>/2021/10/11/macOS%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84-DS-Store/</url>
    
    <content type="html"><![CDATA[<p>进入目标目录，输入以下代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./ -name &quot;.DS_Store&quot; -depth -exec rm &#123;&#125; \;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer积累阅读</title>
    <link href="/2021/10/07/research/others/Transformer%E7%A7%AF%E7%B4%AF%E9%98%85%E8%AF%BB/"/>
    <url>/2021/10/07/research/others/Transformer%E7%A7%AF%E7%B4%AF%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<p>Transformer是Google的研究者在2017年《Attention Is All You Need》论文中提出的用于seq2seq任务的模型，它没有RNN的循环结构或CNN的卷积结构，在机器翻译等任务中取得了一定的提升。</p><p>主要的motivation在于RNN、LSTM、GRU类的序列结构中的固有顺序属性阻碍了训练样本之间的并行化，对于长序列，内存限制将阻碍对训练样本的批量处理。</p><p>Transformer中完全依赖于注意力机制对输入输出的全局依赖关系进行建模。因为对依赖的建模完全依赖于注意力机制，Transformer使用的注意力机制被称为自注意力（self-attention）</p><span id="more"></span><p>References:</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/85864250">https://zhuanlan.zhihu.com/p/85864250</a><br><a href="http://jalammar.github.io/illustrated-transformer/">http://jalammar.github.io/illustrated-transformer/</a></p></blockquote><h1 id="A-High-Level-Look"><a href="#A-High-Level-Look" class="headerlink" title="A High-Level Look"></a>A High-Level Look</h1><p>把整个Transformer当做一个黑盒，在机器翻译任务中，一种语言作为Transformer的输入，另外一种经过翻译后的语言作为Transformer的输出。<br><img src="/images/2021-10-08-00-23-19.png"></p><p>略微细化下，我们看到Transformer架构由Encoding组件，Decoding组件，还有Encoding Decoding两个组件之间的连接组成。<br><img src="/images/2021-10-08-00-25-51.png"></p><p>其中的Encoding组件是一个由encoders组成的栈。Decoding组件是一个由和encoders相同数目的decoders组成的栈。<br><img src="/images/2021-10-08-01-21-44.png"></p><p>编码器在结构上都是相同的（但是互相之间不共享权重）。每一层分为两个子层，分别是Self-Attention机制和Feed Forward Neural Network</p><p>编码器的输入首先要通过一个self-attention层，一个帮助编码器在编码特定单词时查看输入句子中其他单词的层。将在之后进一步分析。</p><p>self-attention层的输出反馈给前馈神经网络（feed forward neural network），完全相同的前馈网络独立应用于每个位置。<br><img src="/images/2021-10-08-14-45-35.png"></p><p>解码器具有这两个层，但在这两个层之间有一个Encoder-Decoder注意力层，帮助解码器关注输入句子的相关部分（类似于seq2seq模型中注意力的作用）。<br><img src="/images/2021-10-08-14-57-11.png"></p><h1 id="Bringing-The-Tensors-Into-The-Picture"><a href="#Bringing-The-Tensors-Into-The-Picture" class="headerlink" title="Bringing The Tensors Into The Picture"></a>Bringing The Tensors Into The Picture</h1><p>首先使用embedding算法将每个输入字词转化为向量。使用这种小型的vectors来进行表示。（在SUMBT中，这一步对应了哪一步？为什么这里每个输入字词会变为vectors?）<br><img src="/images/2021-10-08-15-01-00.png"></p><p>embedding只发生在最底层的编码器中。所有编码器都有一个共同的抽象概念，即它们接收一个大小为512的向量列表——在底部编码器中是word embedding，在其他编码器中则是直接位于下方的编码器的输出。这个列表的大小是我们可以设置的超参数，基本上是训练数据集中最长句子的长度。</p><p>在输入序列中word embedding后，每个单词都会流经编码器的两层。<br><img src="/images/2021-10-11-15-30-06.png"></p><p>在这里，我们看到Transformer的一个关键属性，<strong>即每个位置的字在编码器中通过自己的路径流动。在self-attention层中，这些路径之间存在依赖关系。</strong>然而前馈层（feed forward layer）没有这些依赖关系，因此在流经前馈层时，可以并行执行各种路径。</p><p>接下来，把示例切换到一个较短的句子，并查看编码器的每个子层中放生了什么。</p><h1 id="Now-We’re-Encoding"><a href="#Now-We’re-Encoding" class="headerlink" title="Now We’re Encoding!"></a>Now We’re Encoding!</h1><p>正如我们已经提到的，编码器接收向量列表作为输入（在SUMBT中就是bert embedding后的那些内容）。它通过将这些向量传递到self-attention层，然后传入前馈神经网络，然后将输出向上发送到下一个编码器来处理该列表。<br><img src="/images/2021-10-11-15-39-22.png"><br>每个位置的单词都经过一个自我注意过程。然后，它们各自通过一个前馈神经网络——一个完全相同的网络，每个向量分别通过它。</p><h1 id="Self-Attention-at-a-High-Level"><a href="#Self-Attention-at-a-High-Level" class="headerlink" title="Self Attention at a High Level"></a>Self Attention at a High Level</h1><p>不要被我胡说“self-attention”这个词所愚弄，因为这是每个人都应该熟悉的概念。在阅读《Attention Is All You Need》这篇论文之前，博客作者从未想到过这个概念。让我们总结一下它的工作原理。</p><p>假设以下句子是我们要翻译的输入句子：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The animal didn<span class="hljs-comment">&#x27;t cross the street because it was too tired</span><br></code></pre></td></tr></table></figure><p>在这一句子中，“it”指代的是什么？是指代的street还是animal？对于人类这是简单的，但是对于算法这是复杂的</p><p>当我们的模型在处理“it”这个单词的时候，self-attention允许把“it”和“animal”联系起来</p><p>当模型在处理每个单词的时候（输入语句的每个位置处），self-attention允许其关注输入语句的其他位置来寻求线索，并得出一种对于这个word更好的encoding</p><p>如果对RNN足够熟悉，请考虑如何维护hidden state，使得RNN能够将其已处理的先前单词&#x2F;向量的表示形式与其正在处理的当前单词&#x2F;向量结合起来。self-attention是Transformer用来将其他相关单词的“理解”bake到我们当前正在处理的单词中的方法。<br><img src="/images/2021-10-11-15-48-30.png"></p><p>当我们在编码器#5（堆栈中的顶部编码器）中对单词“it”进行编码时，部分注意力机制将注意力集中在“动物”上，并将其表示的一部分烘焙到“it”的编码中。</p><font color="red">这里需要更加明确self-attention机制的输入输出分别是什么，从个人理解来说是3个输入，1个输出？</font><h1 id="Self-Attention-in-Detail"><a href="#Self-Attention-in-Detail" class="headerlink" title="Self-Attention in Detail"></a>Self-Attention in Detail</h1><p>让我们先看看如何使用向量计算自我注意，然后继续看看它是如何实际实现的——使用矩阵</p><p>计算self-attention的第一步是从编码器的每个输入向量中创建三个向量（在本例中，是每个单词的embedding），所以对于每个单词，我们创建Query vector，一个Key vector， 和一个Value vector。<strong>这些向量是通过将embedding乘以我们在训练过程中训练的三个矩阵来创建的</strong></p><font color="red">突然注意到768 / 64 = 12</font><p>请注意，这些新向量的维数小于嵌入向量，它们的维数为64，而且如和编码器输入&#x2F;输出向量的维数为512。它们不必更小，这是一种架构选择，可以使用MultiHeadAttention（多头注意力机制）来使得计算保持不变（这里是指维度？）</p><p>将x1乘以WQ权重矩阵生成q1，即与该单词相关联的“查询”向量。我们最终创建了输入句子中每个单词的“查询”、“键”和“值”投影。</p><p>（差一张手画的图插进来）</p><p>什么是query key value向量？</p><font color="red">根据师兄的解释，query感觉可以理解成一个自己的内容信息，而key理解成一个别人的信息，这样在和别人进行比较的时候就是上是用自己的q和别人所有的k进行比较</font><p>它们是用于计算和思考注意力机制的抽象概念，继续阅读下面的注意力是如何计算的，就会知道关于每个向量所扮演角色的几乎所有内容。</p><p>计算self-attention的<strong>第二步</strong>是计算分数，假设我们正在计算本例中第一个单词“Thinking”的自我关注度。我们需要给输入句子中的每个单词打分。分数决定了当我们在某个位置对一个单词进行编码时，要把多少注意力放在输入句子的其他部分上。</p><p>分数是通过将query向量的点积与我们正在评分的各个单词的key向量相结合来计算的。因此，如果我们处理位置#1的单词的自我注意，第一个分数将是q1和k1的点积。第二个分数是q1和k2的点积。<strong>（点积将会得到一个分数）</strong></p><p><img src="/images/2021-10-12-12-12-03.png"></p><p><strong>第三步和第四步</strong>是将分数除以8（论文中使用的关键向量维数的平方根–64。这会导致更稳定的梯度。这里可能有其他可能的值，但这是默认值），然后通过softmax操作传递结果。Softmax将分数标准化，使其全部为正值，加起来等于1。</p><p>此softmax分数确定每个单词在此位置的表达量。很明显，这个位置上的单词将具有最高的softmax分数，但有时关注与当前单词相关的另一个单词会很有用。</p><p><strong>第五步</strong>是将每个值向量乘以softmax分数（准备将他们相加）。这里的直觉是保持我们想要关注的单词的完整值，并忽略不相关的单词（例如，将它们乘以0.001这样的小数字）</p><p><strong>第六步</strong>是对加权值向量求和。这将在该位置（对于第一个单词）生成自我注意层的输出。</p><p><img src="/images/2021-10-12-13-22-21.png"></p><p>自我注意力计算到此结束。结果向量是我们可以发送到前馈神经网络的向量。然而，在实际实现中，这种计算是以矩阵形式进行的，以加快处理速度。现在我们来看一下，我们已经看到了单词级计算的直觉。</p><h1 id="Matrix-Calculation-of-Self-Attention"><a href="#Matrix-Calculation-of-Self-Attention" class="headerlink" title="Matrix Calculation of Self-Attention"></a>Matrix Calculation of Self-Attention</h1><p>第一步是计算查询、键和值矩阵。我们通过将嵌入项打包到矩阵X中，并将其乘以我们训练的权重矩阵（WQ，WK，WV）来实现这一点。</p><p><img src="/images/2021-10-12-14-07-46.png"></p><p>X矩阵中的每一行对应于输入句子中的一个单词。我们再次看到嵌入向量（512，或图中的4个框）和q&#x2F;k&#x2F;v向量（64，或图中的3个框）的大小差异</p><p>最后，由于我们处理的是矩阵，我们可以将第二步到第六步浓缩成一个公式来计算自我注意层的输出。</p><p><img src="/images/2021-10-12-14-13-01.png"></p><h1 id="The-Beast-With-Many-Heads"><a href="#The-Beast-With-Many-Heads" class="headerlink" title="The Beast With Many Heads"></a>The Beast With Many Heads</h1><p>本文通过添加了一种称为“Multi-Head”注意力的机制，进一步细化了self-attention层。从这两个方面提高了注意层的性能：</p><ol><li><p>它扩展了模型关注不同位置的能力。是的，在上面的例子中，z1包含了一些其他单词所产生的编码，但是它可能被更加实际的单词本身所支配（这里是指权重比较高？）。如果我们翻译一句话，比如“动物没有过马路是因为它太累了”，我们会想知道“它”指的是哪个词。</p></li><li><p>它为注意力层提供了多个“表示子空间”（有一种增大参数量的感觉？）。正如我们接下来将要看到的，对于multihead-attention，我们不仅有一组，而且有多组query&#x2F;key&#x2F;value权重矩阵（Transformer使用8个attentionhead，因此每个编码器&#x2F;解码器有8组）。这些集合中的每一个都是随机初始化的。然后，在训练之后，使用每个集合将输入embedding（或来自较低编码器&#x2F;解码器的向量）投影到不同的表示子空间。</p></li></ol><p><img src="/images/2021-10-13-09-54-56.png"></p><p>通过multihead-attention，我们为每个head维护单独的Q&#x2F;K&#x2F;V权重矩阵，从而产生不同的Q&#x2F;K&#x2F;V矩阵。和前面一样，我们用X乘以W^Q&#x2F;W^K&#x2F;W^V矩阵，得到Q&#x2F;K&#x2F;V矩阵。</p><p>如果我们做上边所述的同样的self-attention计算，只需使用不同的权重矩阵进行八次不同的计算，我们最终得到八个不同的Z矩阵。</p><p><img src="/images/2021-10-13-10-01-25.png"></p><p>这给我们留下了一点挑战，前馈层不需要八个矩阵，它需要一个矩阵（每个单词对应一个向量（自：这里说的是z？））。所以我们需要一种方法把这八个元素压缩成一个矩阵。</p><p>我们怎么做？我们将矩阵合并（concatenate），然后将它们乘以一个额外的权重矩阵W^O。</p><font color="red">这里感觉是concate表示了的不行，还要把这些融合到一起才行？或者说要保证输入的X和输出的Z是shape相同的？multi-head如果是这样的操作的话就是一种增加参数量的作用？ 其亮点还主要在于“平权”的对待各个位置处，起到一种self-attention的作用。</font><p><img src="/images/2021-10-13-10-10-57.png"></p><p>这几乎就是multi-head attention的全部内容。这是相当多的矩阵，如果把他们放在一个图表示就可以更直观的看到这个过程。</p><p><img src="/images/2021-10-13-10-15-18.png"></p><p>既然我们已经谈到了multihead attention，那么让我们回顾一下之前示例，看看在我们的示例语句中对单词“it”进行编码时，不同的注意力头集中在哪里。</p><p><img src="/images/2021-10-13-10-21-43.png"></p><p>当我们对“它”这个词进行编码时，一个注意力集中在“动物”身上，而另一个注意力集中在“疲劳”身上——从某种意义上说，模型对“它”这个词的表达同时包含了一些“动物”和“疲劳”的表达。</p><p>然而，如果我们把所有的注意力都放在画面上，事情就更难解释了：</p><p><img src="/images/2021-10-13-10-24-34.png"></p><h1 id="其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了"><a href="#其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了" class="headerlink" title="其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了"></a>其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了</h1>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DST论文阅读-SUMBT</title>
    <link href="/2021/09/27/research/papers/DST%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-SUMBT/"/>
    <url>/2021/09/27/research/papers/DST%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-SUMBT/</url>
    
    <content type="html"><![CDATA[<p>SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking论文阅读笔记<br>SUMBT: 槽-话语匹配的对话状态跟踪器，用来进行通用和可扩展的信念跟踪</p><span id="more"></span><p>References:</p><blockquote><p>Lee H, Lee J, Kim T Y. SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking[C]&#x2F;&#x2F;Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics. 2019: 5478-5483.<br>对话状态跟踪学习笔记：<a href="https://blog.csdn.net/zerozzl01/article/details/112215175">https://blog.csdn.net/zerozzl01/article/details/112215175</a></p></blockquote><p>注：分段和作者的文章不一定相同</p><h1 id="一些基础概念的个人笔记补充"><a href="#一些基础概念的个人笔记补充" class="headerlink" title="一些基础概念的个人笔记补充"></a>一些基础概念的个人笔记补充</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对话状态跟踪（dialogue state tracking）是任务型（task-oriented）对话系统中的一部分。更具体的来说，是对话管理中的一部分。对话状态是从对话开始到当前对话的用户目标的总结，通常表现为多组槽-值（slot-value）的组合的形式，有时也会包括对话所属的领域、用户意图等信息。对话状态跟踪是指结合对话历史、当前对话、前一轮对话状态等信息，推断并更新当前对话状态的过程</p><h2 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h2><p>1）领域（domain）：可以理解为业务场景，如hotel、train、restaurant等。<br>2）意图（intention）：用户话语的目的，如请求信息、提供信息、确认信息等。<br>3）槽（slot）：槽指某种信息，与完成任务所需要获得的某种信息相对应。比如在预定酒店这个任务中，相关的槽有name、area、price range等。餐馆示例：[area, food, price range]<br>4）本体（ontology）：数据集中，涉及到的所有领域、意图、槽以及相关的所有值构成的数据字典，称为该数据集的本体。</p><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><p>1）联合目标准确率（joint goal accuracy）&#x2F; 联合状态准确率（joint state accuracy）：一般也简称joint accuracy。对于每轮对话，将预测的对话状态和真实的对话状态进行比较，当且仅当对话状态中所有的（domain，slot，value）预测正确时，才认为对话状态预测正确。<br><font color="red"><br>问题记录：<br>这里需要结合论文所给出的代码查看下联合目标准确率的具体含义，到底是不是一次对话过程中，全部状态正确才算正确？<br></font></p><p>2）槽位准确率（slot accuracy）：单独比较每个（domain，slot，value），当预测值与真实值匹配时，认为预测正确。</p><p>3）推断时间复杂度（inference time complexity, ITC）：ITC的计算方式是完成一次对话状态预测，需要inference多少次。ITC越小越好。</p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>在面向目标（goal-oriented）的对话系统中，信念跟踪器（belief trackers）预测每个对话回合时的槽值对概率分布。以前的神经网络方法已经为领域（ontology）和槽依赖的belief trackers进行了建模，导致领域本体配置缺乏灵活性。</p><font color="red">问题记录：以往的方法，建模的跟踪器都是领域/槽位依赖的，所以欠缺领域本体设置的灵活性。作者把这些以往的方法统称为slot-dependent methods。这个地方怎么理解，欠缺设置的灵活性？</font><p>在本文中，作者提出了一种新的通用（universal）并可扩展（scalable）的信念跟踪器方法，被称作slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器，SUMBT）。模型通过基于上下文语义的注意力机制来学习领域槽类别（domain-slot-types）与对话中出现的槽-值对之间的关系。更进一步的，模型通过一种非参数的方法预测槽-值对的值。</p><font color="red">这里所说的“基于上下文语义的注意力机制”类似就是用BERT作为tokenizer的这个感觉？</font><p>根据作者在两个对话语料库WOZ2.0和MultiWOZ上的实验结果，与槽依赖的方法相比，该模型的性能有所提高，并达到了最先进的joint accuracy。</p><font color="red">还要通过后文的阅读，理解这里作者所说的槽依赖（slot-dependent）的方法到底和作者所提的方法有什么不同。</font><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>随着会话代理的广泛使用，面向目标的系统越来越受到学术界和工业界的关注。面向目标的对话系统帮助用户实现目标，如在对话结束时预定餐厅或预定航班。随着对话的进行，系统需要更新对话状态的分布，对话状态包括用户的意图、可信息的槽位、和可请求的槽位。这被称作belief tracking（信念跟踪）或者被称作dialogue state tracking（对话状态跟踪, DST）。</p><font color="red">问题记录：这里对应到数据集上到底在预测什么，除了槽值对外，看起来还有很多需要记录的地方？</font><p>例如，对于给定的域（domain）和槽类型（slot-types），（例：‘restaurant’ domain 和 ‘food’ 槽类型），这个任务估计了在领域本体中<strong>预定义</strong>的，相对应的候选槽值对（slot-value）概率（例：‘Korean’和‘Modern European’）</p><p>由于系统使用DST的预测输出，根据对话策略（Policy Learning环节？）选择下一个操作，因此DST的准确性对于提高系统整体性能至关重要。<strong>此外，对话系统应该能够以灵活的方式处理新添加的域和槽，因此开发可伸缩的对话状态跟踪器是不可避免的。</strong> 关于这一点，Chen等人提出一种从意图-话语对中捕捉关系的模型，用于意图扩展。</p><font color="red">问题记录：这里说以灵活的方式处理新添加的域和槽，这个不应该都是已定义好的，为什么会能增加，作者一直在围绕着可扩展性讲故事。（相对于去雾类的论文中的一些idea，这些想法是否属于在NLP领域中直观的想法）</font><p>传统基于统计方法的belief trackers容易受到词汇和形态变化的影响，因为他们依赖于手动构建的语义词典。随着深度学习方法的兴起，一些neural belief trackers（NBT）被提出，并通过学习单词的语义神经表征来提高性能。然而，可扩展性仍然是一个挑战，先前提出的方法要么对每个域、槽单独建模，要么难以添加本体中未定义的新槽值。</p><p>在本文中，我们致力于开发一个“可伸缩”和“通用”的belief tracker，其中只有一个信念跟踪器用于处理任何域和槽类型。为了解决这个问题，我们提出了一种新的方法，称为slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器），他是一种与域和槽独立的对话状态跟踪器，其结构如figure 1所示。</p><p><img src="/images/2021-09-27-12-06-39.png"></p><p>灵感来自机器阅读理解技术，SUMBT考虑domain-slot type这个组合（例如 ‘restaurant-food’）将其视为一个问题，并在一对用户和系统话语中找到相应的槽值对，假设话语中存在期望的答案。</p><p>SUMBT使用最近提出的BERT对系统和用户的话语（utterance）进行编码，BERT提供句子的语境化语义表示。此外，domain-slot-types 和 slot-values也使用BERT进行字面编码</p><font color="red">上边的意思是，这几个地方都会被BERT编码：[CLS] what type of food would you like? [SEP] a moderately priced modern European food.[SEP]<p>[CLS] restaurant - food [SEP]</p><p>[CLS] modern European [SEP]<br></p></font><p></p><p>然后SUMBT根据上下文语义向量，学习与话语词中domain-slot-type相关的“参加方式（the way where to attend）”。该模型基于某些度量以非参数方式预测slot-value的标签，从而使模型体系结构在结构上不依赖于域和slot-types。因此，单个SUMBT可以处理一对domain-slot-type和slot-value，还可以利用多个域和槽之间的共享知识</p><font color="red">或许这篇文章是比较早把BERT结合进来的操作？</font><p>作者在两个目标面向的对话语料库：WOZ2.0 和 MultiWOZ 上通过实验证明该提议模型的有效性。还将定性分析该模型的工作原理。并将其实现公开发布。</p><h1 id="SUMBT"><a href="#SUMBT" class="headerlink" title="SUMBT"></a>SUMBT</h1><p>所提出的模型由4部分组成，就像图1中所示的。<br>① BERT encoders，用来对【槽】，【值】，【话语】进行encoding（图中的灰色和蓝色部分）<br>② 一个 slot-用户话语匹配的network（图中的红色部分）<br>③ 一个对话状态跟踪器（图中的橙色部分）<br>④ 一个无参数的鉴别器（discriminator，图中的最上端虚线连接）</p><h2 id="Contextual-Semantic-Encoders"><a href="#Contextual-Semantic-Encoders" class="headerlink" title="Contextual Semantic Encoders"></a>Contextual Semantic Encoders</h2><p>对于句子编码器，我们采用了预训练的BERT模型，这是一个双向Transformer编码器的深层堆栈。与普通的词向量相比，这种方式提供了上下文带有语义化的词向量。更进一步的，它提供了词句和句子等词序列的聚合表示，因此我们可以获得由多个词组合的slot-types或slot-values。</p><p>这里主要记录下：</p><p>slot-values: [[area_slot1, area_slot2, area_slot3…], [food_slot1, …], [price_range_1, …]]</p><p>slot-types: [area, food, price range]</p><p>经过一系列操作处理后：</p><p>y_vt label_token_ids根据v_t slot-values得到: [torch.Size([7, 32]), torch.Size([xx1, 32]), torch.Size([xx2, 32])]，这里xx1，xx2分别代表food和price range的标签数目</p><p>q_s slot_token_ids根据s domain-slot-types得到: torch.Size([3, 32])，因为在WOZ这个数据集中只有3个label</p><h2 id="Slot-Utterance-Matching"><a href="#Slot-Utterance-Matching" class="headerlink" title="Slot-Utterance Matching"></a>Slot-Utterance Matching</h2><p>为了从话语中检索与domain-slot-type（area，food，price range）对应的相关信息，该模型使用注意力机制。把domain-slot-type经过encoder的encoded vector q^s作为一个query，将其与【每个each】单词位置的上下文语义向量u相匹配，然后计算注意力分数。</p><p>这里，作者采用了multi-head attention的注意力机制。多头注意力机制将查询矩阵Q、key矩阵K和value矩阵V映射为不同的线性h投影，然后在这些矩阵上执行缩放点积注意力机制。slot s 和 t处的话语之间的有注意上下文向量hst是：</p><p><img src="/images/2021-09-28-17-32-41.png"></p><font color="red">这里的注意力机制可能需要结合代码和原理详细的学习一下，感觉主要是计算用户每一个词是在哪个domain-slot-type做一个分类的感觉？</font><h2 id="Belief-Tracker-对话状态跟踪器"><a href="#Belief-Tracker-对话状态跟踪器" class="headerlink" title="Belief Tracker 对话状态跟踪器"></a>Belief Tracker 对话状态跟踪器</h2><p>随着对话的进行，每个回合的belief state由之前的对话历史和当前的对话回合决定。这个对话流可以被RNN类的LSTM和GRU，或者Transformer decoders建模（例如：left-to-right uni-directional Transformers）</p><p>在本项工作中，上下文向量h_t，还有RNN的上一个state被送入到RNN中，这是用来学习与目标的slot-values相接近的语义向量</p><p><img src="/images/2021-09-28-19-27-17.png"></p><font color="red">等于说每次训练的时候，送入的是当前domain-slot-type和用户utterance的结合，在WOZ数据集上的反应就是，每次训练使用[area, food, price range]这个domain-slot-type结合用户的话术，通过注意力机制实现了用户话语更加关注哪个，然后将这个注意力机制结合之前状态等得到的hidden计算结果与slot-values匹配得到最小的</font><p>作者考虑到BERT是使用layer normalization进行nomal化的，RNN输出的d_t也被送入到一个layer normalizaiton层，来帮助训练训练收敛。</p><p><img src="/images/2021-09-28-19-46-31.png"></p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS及Linux-命令行工具diff</title>
    <link href="/2021/09/16/macOS%E5%8F%8ALinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7diff/"/>
    <url>/2021/09/16/macOS%E5%8F%8ALinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7diff/</url>
    
    <content type="html"><![CDATA[<p>需求：如果使用beyond compare等工具做diff还是有时候有些不方便的，或者说不够灵活。可以在macOS或者Linux系统中直接使用语句进行diff操作，并且在这里补充了一些关于zsh配置和colordiff的说明。</p><span id="more"></span><h1 id="1-流程和操作说明"><a href="#1-流程和操作说明" class="headerlink" title="1. 流程和操作说明"></a>1. 流程和操作说明</h1><p>在目录下执行如下语句即可进行简单的diff操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">diff -u [file A] [file B]</span><br></code></pre></td></tr></table></figure><h1 id="2-colordiff及zsh相关配置"><a href="#2-colordiff及zsh相关配置" class="headerlink" title="2. colordiff及zsh相关配置"></a>2. colordiff及zsh相关配置</h1><p>在目前使用的苹果电脑环境下，通过如上语句显示diff没有高亮不方便阅读，故通过如下命令安装colordiff</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">brew install colordiff</span><br></code></pre></td></tr></table></figure><p>安装完成后，可以在任意一个zsh窗口下执行命令进行带颜色的diff操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">colordiff -u [file A] [file B]</span><br></code></pre></td></tr></table></figure><p>原来的diff已经不用了，可以指定diff直接到colordiff，在当前zsh窗口下执行如下命令，即可在当前窗口完成diff代替colordiff的操作（注：可以使用文件查看）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">alias</span> diff=colordiff</span><br></code></pre></td></tr></table></figure><p>如果要每次都生效，需要执行如下操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim ~/.zshrc</span><br><br>在最后一行加入<br>alias diff=colordiff<br></code></pre></td></tr></table></figure><p><img src="/images/2021-09-16-23-42-12.png"></p><h1 id="3-效果展示"><a href="#3-效果展示" class="headerlink" title="3. 效果展示"></a>3. 效果展示</h1><p><img src="/images/2021-09-16-23-49-33.png"></p>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS基础操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dialogue-State-Tracking简述</title>
    <link href="/2021/09/14/research/papers/Dialogue-State-Tracking%E7%AE%80%E8%BF%B0/"/>
    <url>/2021/09/14/research/papers/Dialogue-State-Tracking%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>学习一些中文论文来大概理解下DST这个任务：</p><p>Reference:</p><blockquote><p>郑正凯. 基于深度学习端到端的对话状态跟踪研究[D].山东大学,2021.</p></blockquote><span id="more"></span><h1 id="1-Dialogue-State-Tracking简述"><a href="#1-Dialogue-State-Tracking简述" class="headerlink" title="1. Dialogue State Tracking简述"></a>1. Dialogue State Tracking简述</h1><p>dst任务一般用在任务型对话中，是pipeline中的一个部分。组成对话系统的各模块按照①自然语言理解（NLU）、②对话状态跟踪（DST）、③策略学习（Policy Learning）、④自然语言生成（NLG）四部分组成。</p><p>其中NLU模块将输入文本转化为结构化的语义表示，提取出对用户当前话语中与任务相关的信息，主要使用意图识别和槽值填充的方法；</p><p>DST模块负责维护系统状态，即获取用户目标，对用户目标进行实时更新；</p><p>PL模块负责根据系统状态选择合适的信息对用户进行反馈；</p><p>NLG模块负责把系统反馈的信息转化为自然语言输出给用户。</p><h1 id="2-对话状态跟踪相关理论"><a href="#2-对话状态跟踪相关理论" class="headerlink" title="2. 对话状态跟踪相关理论"></a>2. 对话状态跟踪相关理论</h1><p>英文数据集MultiWOZ 2.0 2.1 2.2 2.3，其中2.3应该是非常新的版本</p><p>中文数据集CrossWOZ</p><h2 id="2-1-数据组成结构"><a href="#2-1-数据组成结构" class="headerlink" title="2.1 数据组成结构"></a>2.1 数据组成结构</h2><p>在对话状态跟踪任务中，数据由以下几方面组成：基于特定任务的槽值对、用户当前轮输入、上轮次的系统反馈（以前所有轮？）、上轮次的系统状态（以前所有轮？）</p><p>（1）槽值对（Slot-Value）<br>“槽”指系统向用户提供服务之前需要事先确定的信息，而“槽值”是指用户需要提供给系统的具体信息。槽值是具体信息，槽是槽值的统称，一个槽可以对应多个槽值，同一领域内一个槽值只能对应一个槽。</p><p>在跨领域对话系统中，槽的上类称为领域，比如餐馆、酒店、景点等；一个领域可以对应很多槽（酒店有价格、酒店有地理位置……），一个槽也可以对应很多领域（酒店有价格、餐厅有价格……）。<strong>所以我们将领域与槽拼接起来作为槽，这样使得槽变成了唯一</strong>，例如“酒店-名称”，“景点-价格”</p><p>在任务型系统中，一般都会有多个槽，每个槽有多个值，用户的意图是多样且不确定的，系统需要与用户通过多轮互动获取用户的真实意图，如在旅游咨询系统中，将“景点-名称”、“酒店-价格”，“餐馆-推荐菜”等用户需要提供信息的类定义为槽，而“餐馆-推荐菜”对应的“北京烤鸭”，“小笼包”等均为槽值。<strong>对话状态追踪的目的是在每一轮对话中能够准确识别出用户是否表达出某个槽</strong>通过对数据集中槽值对进行统计分析可以获得槽值对形式的知识库，这个知识库能够作为主体文件参与模型的训练与预测。</p><p>（2）用户当前轮输入<br>在多轮对话中，用户当前输入作为对话状态追踪的重要信息，当前轮输入可以是陈述需求或者有疑问推荐，也可以是对上一轮系统反馈的回答及提出新的要求。通过与系统的交互过程中，用户可以随时更新自己的需求，系统会根据用户输入的信息及时更新对话状态。</p><p>（3）上轮次的系统状态与系统反馈（<strong>系统角度</strong>）<br>在DST任务中，一般都会初始化系统状态为{Slot: None}，通过不断地更新状态使得系统获取相关信息。在DST过程中，上下文信息在一定程度上影响了后续的动作，由于上一轮系统反馈与当前轮用户输入有着密切联系，所以一般对话状态跟踪模型均会将上一轮系统状态及反馈作为输入。</p><p>而上一轮的系统反馈无外乎两种信息，一种是针对上一轮用户输入给出的问答式回复或推荐，另一种是由于用户给与的信息量不足或者意图不明确，需要用户增加信息，所以系统会主动向用户发送确认或者请求。</p><p>系统确认是对用户进行槽值确认，如“你喜欢面条吗？”，此时系统的状态为{food: noodle，request: None …}【需要用户增加信息】</p><p>系统请求是询问用户特定槽对应的值，如“不幸的是，价格便宜的已售罄，请选择其他价格范围的菜品”，此时系统状态变为{food: noodle, request: price range}【需要用户增加信息】</p><h2 id="2-2-对话状态追踪过程（DST）"><a href="#2-2-对话状态追踪过程（DST）" class="headerlink" title="2.2 对话状态追踪过程（DST）"></a>2.2 对话状态追踪过程（DST）</h2>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConvLab-2 Getting Started</title>
    <link href="/2021/09/14/ConvLab-2%20Getting%20Started/"/>
    <url>/2021/09/14/ConvLab-2%20Getting%20Started/</url>
    
    <content type="html"><![CDATA[<p>ConvLab-2.ipynb</p><p>ConvLab-2是一个开源工具包，使研究人员能够使用最先进的模型构建面向任务的对话系统，执行端到端评估，并诊断系统的弱点。作为ConvLab的继承者，ConvLab-2继承了ConvLab的框架，但集成了更强大的对话模型并支持更多的数据集。此外，作者还开发了一个分析工具和一个交互式工具，以帮助研究人员诊断（diagnosing）对话系统。</p><p>从这里学习一些对话系列的模型，服务器上操作遇到一些问题，目前还是用google colab操作的</p><p>Reference：</p><blockquote><p><a href="https://github.com/thu-coai/ConvLab-2">https://github.com/thu-coai/ConvLab-2</a></p></blockquote><span id="more"></span><h2 id="1-初始化准备，installation"><a href="#1-初始化准备，installation" class="headerlink" title="1. 初始化准备，installation"></a>1. 初始化准备，installation</h2><p>git clone 自己fork git的内容（<strong>注意在colab环境下的修改一定要同步到本地中，或者说每次都是本地改完想办法传到colab&#x2F;github上</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!git clone https://github.com/yixuan004/ConvLab-2.git &amp;&amp; cd ConvLab-2 &amp;&amp; pip install -e .<br></code></pre></td></tr></table></figure><p>安装spacy使用的en_core_web_sm，来解决BERTNLU中的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">!python -m spacy download en_core_web_sm<br></code></pre></td></tr></table></figure><h2 id="2-build-an-agent"><a href="#2-build-an-agent" class="headerlink" title="2. build an agent"></a>2. build an agent</h2><p>这里感觉是构建一个机器自动应答的pipeline，包括NLU，DST，Policy和NLG这些模块，组合在一起可以作为机器端的对话机器的感觉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> convlab2.nlu.jointBERT.multiwoz <span class="hljs-keyword">import</span> BERTNLU<br><span class="hljs-keyword">from</span> convlab2.nlu.milu.multiwoz <span class="hljs-keyword">import</span> MILU<br><span class="hljs-keyword">from</span> convlab2.dst.rule.multiwoz <span class="hljs-keyword">import</span> RuleDST<br><span class="hljs-keyword">from</span> convlab2.policy.rule.multiwoz <span class="hljs-keyword">import</span> RulePolicy<br><span class="hljs-keyword">from</span> convlab2.nlg.template.multiwoz <span class="hljs-keyword">import</span> TemplateNLG<br><span class="hljs-keyword">from</span> convlab2.dialog_agent <span class="hljs-keyword">import</span> PipelineAgent, BiSession<br><span class="hljs-keyword">from</span> convlab2.evaluator.multiwoz_eval <span class="hljs-keyword">import</span> MultiWozEvaluator<br><span class="hljs-keyword">from</span> pprint <span class="hljs-keyword">import</span> pprint<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;import done!&quot;</span>)<br></code></pre></td></tr></table></figure><p>建立模型并建造一个agent</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># go to README.md of each model for more information</span><br><span class="hljs-comment"># BERT nlu，understanding</span><br>sys_nlu = BERTNLU()<br><span class="hljs-comment"># simple rule DST，tracking</span><br>sys_dst = RuleDST()<br><span class="hljs-comment"># rule policy，rule</span><br>sys_policy = RulePolicy()<br><span class="hljs-comment"># template NLG，生成</span><br>sys_nlg = TemplateNLG(is_user=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># assemble，集成到一个pipeline里</span><br>sys_agent = PipelineAgent(sys_nlu, sys_dst, sys_policy, sys_nlg, name=<span class="hljs-string">&#x27;sys&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;build agent done!&quot;</span>)<br></code></pre></td></tr></table></figure><p>和agent进行手动输入对话测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对话1</span><br>sys_agent.response(<span class="hljs-string">&quot;I want to find a moderate hotel&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>We have <span class="hljs-number">18</span> such places . How about bridge guest house ? Fits your request perfectly .<br><br>sys_agent.response(<span class="hljs-string">&quot;Which type of hotel is it ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>It <span class="hljs-keyword">is</span> a guesthouse .<br><br>sys_agent.response(<span class="hljs-string">&quot;OK , where is its address ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>It <span class="hljs-keyword">is</span> located at <span class="hljs-number">124</span> tenison road.<br><br>sys_agent.response(<span class="hljs-string">&quot;Thank you !&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Thank you <span class="hljs-keyword">for</span> contacting the <span class="hljs-built_in">help</span> desk . Have a great day .<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对话2</span><br>sys_agent.response(<span class="hljs-string">&quot;Try to find me a Chinese restaurant in south area .&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>There are <span class="hljs-number">3</span> different places that <span class="hljs-keyword">match</span> your description . The lucky star has some great reviews . How about chinese ?<br><br>sys_agent.response(<span class="hljs-string">&quot;Which kind of food it provides ?&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>They serve chinese .<br><br>sys_agent.response(<span class="hljs-string">&quot;Book a table for 5 , this Sunday .&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>Your reference number <span class="hljs-keyword">is</span> 00000003 .<br></code></pre></td></tr></table></figure><h2 id="3-Build-a-simulator-to-chat-with-the-agent-and-evaluate"><a href="#3-Build-a-simulator-to-chat-with-the-agent-and-evaluate" class="headerlink" title="3. Build a simulator to chat with the agent and evaluate"></a>3. Build a simulator to chat with the agent and evaluate</h2><p>构建一个模拟器与代理聊天并评估</p><ul><li><p>在许多一对一面向任务的对话系统中，模拟器对于训练RL代理是必不可少的。在我们的框架中，我们不区分用户和系统。所有发言者都是代理人。模拟器也是一个代理，内部有特定的策略以实现用户目标。</p></li><li><p>我们对模拟器使用Agenda策略，该策略需要对话行为输入，这意味着我们应该将PipelineAgent的DST参数设置为None。然后PipelineAgent将直接将对话act传递给策略。有关更多详细信息，请参阅PipelineAgent文档。（这里不是很明白为什么要把user_policy设置为None）</p></li></ul><p>这里是模拟器，因为是模拟器所以代表了用户，这样在交互的过程中并不需要跟踪对话状态，所以不需要DST？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># MILU</span><br>user_nlu = MILU()<br><span class="hljs-comment"># not use dst</span><br>user_dst = <span class="hljs-literal">None</span><br><span class="hljs-comment"># rule policy</span><br>user_policy = RulePolicy(character=<span class="hljs-string">&#x27;usr&#x27;</span>)<br><span class="hljs-comment"># template NLG</span><br>user_nlg = TemplateNLG(is_user=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># assemble</span><br>user_agent = PipelineAgent(user_nlu, user_dst, user_policy, user_nlg, name=<span class="hljs-string">&#x27;user&#x27;</span>) <span class="hljs-comment"># user的agent！</span><br></code></pre></td></tr></table></figure><p>现在我们有了一个simulator和一个agent。我们将使用现有的简单的一对一会话控制器BiSession，还可以定义自己的Session class来应对自己的特殊需求</p><p>我们添加了MultiWozEvaluator来评估性能。它使用的解析的对话框act input 和策略输出对话框act来计算inform f1、book rate以及任务是否成功</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">evaluator = MultiWozEvaluator()<br>sess = BiSession(sys_agent=sys_agent, user_agent=user_agent, kb_query=<span class="hljs-literal">None</span>, evaluator=evaluator)<br></code></pre></td></tr></table></figure><p>让这两个代理进行会话！key是BiSession类的next_turn这个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_seed</span>(<span class="hljs-params">r_seed</span>):<br>    random.seed(r_seed)<br>    np.random.seed(r_seed)<br>    torch.manual_seed(r_seed)<br><br>set_seed(<span class="hljs-number">20210914</span>)<br><br>sys_response = <span class="hljs-string">&#x27;&#x27;</span><br>sess.init_session()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;init goal:&#x27;</span>)<br>pprint(sess.evaluator.goal)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">50</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    sys_response, user_response, session_over, reward = sess.next_turn(sys_response)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;user:&#x27;</span>, user_response)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sys:&#x27;</span>, sys_response)<br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-keyword">if</span> session_over <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;task success:&#x27;</span>, sess.evaluator.task_success())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;book rate:&#x27;</span>, sess.evaluator.book_rate())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;inform precision/recall/f1:&#x27;</span>, sess.evaluator.inform_F1())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span>*<span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;final goal:&#x27;</span>)<br>pprint(sess.evaluator.goal)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;=&#x27;</span>*<span class="hljs-number">100</span>)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>init goal:<br>&#123;<span class="hljs-string">&#x27;attraction&#x27;</span>: &#123;<span class="hljs-string">&#x27;info&#x27;</span>: &#123;<span class="hljs-string">&#x27;area&#x27;</span>: <span class="hljs-string">&#x27;east&#x27;</span>&#125;,<br>                <span class="hljs-string">&#x27;reqt&#x27;</span>: &#123;<span class="hljs-string">&#x27;address&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;entrance fee&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;phone&#x27;</span>: <span class="hljs-string">&#x27;?&#x27;</span>&#125;&#125;&#125;<br>--------------------------------------------------<br>user: I am planning a trip to town <span class="hljs-keyword">and</span> want to sight see a bit . Can you let me know some attractions I may be interested <span class="hljs-keyword">in</span> ? Can you recommend some attractions <span class="hljs-keyword">in</span> the east ?<br>sys: There are <span class="hljs-number">10</span> , anything <span class="hljs-keyword">in</span> particular you are looking <span class="hljs-keyword">for</span> ? I recommend saint barnabas press gallery. They are located at the belfast yard, coldham<span class="hljs-string">&#x27;s road .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Sounds good . Could I get the phone number of the attraction ? Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The attraction phone number is 01223902088 . Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I will need the entrance fee please .</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I would like to know the entrance fee .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: What are the entrance fees ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you tell me the entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Is there an entrance fee ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you tell me the entrance fee ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I will need the entrance fee please .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I would like to know the entrance fee .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: I just need to know how much the entrance fee is .</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you give me the entrance fee ?</span><br><span class="hljs-string">sys: Their entrance fee is ? by our system currently .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Can you let me know what the entrance fee is too ?</span><br><span class="hljs-string">sys: The entry fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">user: Does it have an entrance fee ?</span><br><span class="hljs-string">sys: Its entrance fee is ? .</span><br><span class="hljs-string"></span><br><span class="hljs-string">task success: 0</span><br><span class="hljs-string">book rate: None</span><br><span class="hljs-string">inform precision/recall/f1: (1.0, 0.6666666666666666, 0.8)</span><br><span class="hljs-string">--------------------------------------------------</span><br><span class="hljs-string">final goal:</span><br><span class="hljs-string">&#123;&#x27;</span>attraction<span class="hljs-string">&#x27;: &#123;&#x27;</span>info<span class="hljs-string">&#x27;: &#123;&#x27;</span>area<span class="hljs-string">&#x27;: &#x27;</span>east<span class="hljs-string">&#x27;&#125;,</span><br><span class="hljs-string">                &#x27;</span>reqt<span class="hljs-string">&#x27;: &#123;&#x27;</span>address<span class="hljs-string">&#x27;: &quot;the belfast yard, coldham&#x27;</span>s road<span class="hljs-string">&quot;,</span><br><span class="hljs-string">                         &#x27;entrance fee&#x27;: &#x27;?&#x27;,</span><br><span class="hljs-string">                         &#x27;phone&#x27;: &#x27;01223902088&#x27;&#125;&#125;&#125;</span><br><span class="hljs-string">====================================================================================================</span><br></code></pre></td></tr></table></figure><h2 id="还有一些其他简易操作，例如Try-different-module-combinations，Use-analysis-tool-to-diagnose-the-system，见-ipynb中的整理了"><a href="#还有一些其他简易操作，例如Try-different-module-combinations，Use-analysis-tool-to-diagnose-the-system，见-ipynb中的整理了" class="headerlink" title="还有一些其他简易操作，例如Try different module combinations，Use analysis tool to diagnose the system，见.ipynb中的整理了"></a>还有一些其他简易操作，例如Try different module combinations，Use analysis tool to diagnose the system，见.ipynb中的整理了</h2>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiWOZ数据集学习</title>
    <link href="/2021/09/13/MultiWOZ%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/09/13/MultiWOZ%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>主要记录了通过了解数据集作为对DST任务的入门，MultiWOZ数据集是适用于<strong>任务型对话</strong>系统的数据集，目前看了一遍这个简介后还是不太明白，感觉还需要各种渠道多了解下</p><p>Reference：</p><blockquote><p>任务型对话系统数据集详解大全（MultiWOZ &#x2F;DSTC） <a href="https://zhuanlan.zhihu.com/p/200747822">https://zhuanlan.zhihu.com/p/200747822</a> </p></blockquote><span id="more"></span><h1 id="2021-9-13-首次学习"><a href="#2021-9-13-首次学习" class="headerlink" title="2021.9.13 首次学习"></a>2021.9.13 首次学习</h1><h2 id="1-MultioWOZ的前世今生"><a href="#1-MultioWOZ的前世今生" class="headerlink" title="1. MultioWOZ的前世今生"></a>1. MultioWOZ的前世今生</h2><p>·New WOZ：2018年剑桥大学研究人员在提出一个新的multi-domain DST模型的同时，顺带提出了New WOZ数据集，被看作是1.0的最初版本，发表在ACL；</p><p>·MultiWOZ 2.0：在1.0版本不错后，这些研究人员首次提出了MultiWOZ这个数据集，也就是一般所说的MultiWOZ 2.0，是当年EMNLP的Best Paper；</p><p>·MultiWOZ 2.1：2019年亚马逊的研究人员对MultiWOZ 2.0数据集中的一些错误进行修正，添加了对槽位的解释和对话行为的标注，代表MultiWOZ 2.1版本</p><p>·MultiWOZ 2.2：2020年google的研究人员在2.1的基础上提出升级版2.2；</p><h2 id="2-MultiWOZ这个名字的由来"><a href="#2-MultiWOZ这个名字的由来" class="headerlink" title="2. MultiWOZ这个名字的由来"></a>2. MultiWOZ这个名字的由来</h2><p>MultiWOZ的全称是Multi Domain Wizard-of-Oz，其中Wizard-of-Oz是Wizard-of-Oz Experiment或者Wizard-of-Oz Testing或者Wizard-of-Oz Method，是一种方法、技术。简单来说，你以为你在跟机器对话，实际上这个机器的背后是另一个人，是一种使还没有实现的技术先通过人工模拟系统的相应的技术手段。</p><p>因为用到了Wizard-of-Oz方法进行数据的制作和收集，所以采用这个名字。也提到了crowd-sourcing众包的方法，比较通俗的解释是“众包找人来干活，但不花钱，找社会上的志愿者，你一点我一点大家一起把这个事情完成”。关于这个方法作者还展示了他们做的GUI，专门用来让大众制作收集数据集。</p><h2 id="3-MultiWOZ-2-0数据集细节："><a href="#3-MultiWOZ-2-0数据集细节：" class="headerlink" title="3. MultiWOZ 2.0数据集细节："></a>3. MultiWOZ 2.0数据集细节：</h2><p>·主要目标：在旅游城市的信息中心获取旅游者查询的高度自然对话</p><p>·Domain（域）：Attraction，Hospital，Police，Hotel，Restaurant，Taxi，Train，其中后四个域属于扩展域，包括子任务Booking。每段对话涉及1-5个领域，因此长度和复杂性差别很大。全部的act和slot如下：</p><p><img src="/images/2021-09-13-20-49-44.png"></p><p>·数量及分布：10438个对话，其中3406个单领域对话，7032个多领域对话，多领域中，包含最少2-5个领域。70%的对话超过10个会和，其中单领域平均轮数为8.93，多领域为15.39。在数据里，对话的序号前面是SNG的就是单轮，MUL的就是多轮。</p><p>·数据结构：每个对话包含a goal，multiple user，system utterances(系统话语)，belief state（？信度状态），dialogue acts and slots（可能需要结合具体数据进一步理解下）</p><p>·Belief state：有三个部分，分别是semi，book，booked、其中semi是特定领域里的槽值；book在特定领域的booking slots；booked是book的一个子集，在book这个字典里，是booked entity</p><p>↑这段话不太好理解，感觉还得从具体数据内容来看</p><h2 id="4-MultiWOZ-as-a-New-Benchmark"><a href="#4-MultiWOZ-as-a-New-Benchmark" class="headerlink" title="4. MultiWOZ as a New Benchmark"></a>4. MultiWOZ as a New Benchmark</h2><p>MultiWOZ作为新的benchmark，提供了三个子任务，分别是，dialogue state tracking、dialogue-act-to-text generation，dialogue context-to-text generation</p><p>其中<br>·Dialogue state tracking：用在餐厅子领域的overall和joint goals的accuracy作为评价指标</p><p>相关指标更新见：<a href="https://github.com/budzianowski/multiwoz">https://github.com/budzianowski/multiwoz</a></p><p>感觉理解的还不是很清楚，还需要进一步看下对话相关的任务一类的来理解吧</p><h1 id="2021-10-24-笔记补充-MultiWOZ2-2以及MultiWOZ系列的前世今生"><a href="#2021-10-24-笔记补充-MultiWOZ2-2以及MultiWOZ系列的前世今生" class="headerlink" title="2021.10.24 笔记补充 MultiWOZ2.2以及MultiWOZ系列的前世今生"></a>2021.10.24 笔记补充 MultiWOZ2.2以及MultiWOZ系列的前世今生</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>MultiWOZ2.2数据集发表在ACL2020上，发布了MultiWOZ数据集的升级版，作者来自google和伊利诺伊大学芝加哥分校</p><blockquote><p><a href="https://aclanthology.org/2020.nlp4convai-1.13/">https://aclanthology.org/2020.nlp4convai-1.13/</a></p></blockquote><h2 id="MultiWOZ发展史"><a href="#MultiWOZ发展史" class="headerlink" title="MultiWOZ发展史"></a>MultiWOZ发展史</h2><ol><li>NewWOZ（ACL2018），但好像用的人不多？</li><li>MultiWOZ2.0（EMNLP2018）</li><li>MultiWOZ2.1 针对2.0中的一些错误进行修正，添加了对槽位的解释和对对话行为的标注，亚马逊研究人员。<blockquote><p>Eric M, Goel R, Paul S, et al. MultiWOZ 2.1: A Consolidated Multi-Domain Dialogue Dataset with State Corrections and State Tracking Baselines[C]&#x2F;&#x2F;Proceedings of the 12th Language Resources and Evaluation Conference. 2020: 422-428.</p></blockquote></li><li>MultiWOZ2.2（ACL 2020），是2.1的进一步升级版</li></ol><h2 id="标注错误"><a href="#标注错误" class="headerlink" title="标注错误"></a>标注错误</h2><p>下面开始介绍2.2对2.1的改进，首先是标注错误。<br>在了解标注错误之前，首先了解一下什么是<strong>Wizard-of-Oz setup</strong>。<br>Wizard-of-Oz setup是由两个众包工人组成一队，一个扮演user，一个扮演agent。<br>每组对话由一个特定的目标来驱动。<br>在每轮user对话结束后，扮演agent的众包工会标注出更新后的对话状态，并依此生成一个回复。<br>由于这种方法是完全靠人工去标注的，那么就会容易产生噪声。</p><h2 id="Hallucinated-Values（直译为“幻觉价值观”）"><a href="#Hallucinated-Values（直译为“幻觉价值观”）" class="headerlink" title="Hallucinated Values（直译为“幻觉价值观”）"></a>Hallucinated Values（直译为“幻觉价值观”）</h2><p>作者将标注中错误的value分为4类。如下的4种</p><ol><li><p>Early Markup：未来会出现的槽值被agent标注为了当前的值，如图所示，User说了：Help me find a moderate price british food place please，此时系统回复了restaurant one seven is a nice place. Do you want to book? 此时应该意图还没有锁在r-name&#x3D;one seven上<br><img src="/images/2021-10-24-22-05-41.png"></p></li><li><p>Annotation from Database：这些值没有在对话中出现，而是被程序错误的从数据库中抽取出来的。<br><img src="/images/2021-10-24-22-12-29.png"></p></li><li><p>Typo：一些印刷或者排版书写错误<br><img src="/images/2021-10-24-22-33-29.png"></p></li><li><p>Implicit Time Processing：一些隐式的时间表示，有可能是根据前面的相对时间加减计算出来的时间，也有时候会四舍五入到最接近的时间。这样会家中模型学习的负担<br><img src="/images/2021-10-24-22-33-40.png"></p></li></ol><h2 id="状态更新不一致"><a href="#状态更新不一致" class="headerlink" title="状态更新不一致"></a>状态更新不一致</h2><p>状态更新不一致的主要原因有两种：</p><ol><li><p>value来源有多个：一个槽值在对话状态可能有各种来源：由用户提供、由系统提供、从对话状态中不同的domain下的值继承过来的、来源于本体中定义的。</p></li><li><p>value的释义不规范：多个value其实含义是一样的。2.1在定义这些内容的时候缺乏一个显式的规则。这就使得模型训练的时候造成困惑，比如说同时有18：00和6pm，其实都是对的，但是训练过程中ground truth只有一个，那么就会错误的惩罚另一个<br><img src="/images/2021-10-25-00-00-53.png"></p></li><li><p>跟踪策略不一致：众包工人标注时的标准不一致，有的只标注了用户提到的value，有的将用户统一的agent提到的value也标了进来<br><img src="/images/2021-10-25-09-13-23.png"></p></li></ol><h2 id="本体中的问题"><a href="#本体中的问题" class="headerlink" title="本体中的问题"></a>本体中的问题</h2><p>在MultiWOZ2.0中定义了一个本体，他声称美居乐所有slot的value。但是后来的研究人员发现这个本体其实是很不完整的，所以为了达到很好的效果，研究人员往往要自己再重新定义一个自己的本体。为了解决这个问题，2.1试图列出对话状态中的所有值来重建本体，但是仍然存在一些未解决的问题。</p><p>比如说：</p><ol><li>在同一槽位中具有相同语义的多个value</li></ol><ul><li>8pm&#x3D;20:00，a and b guesthouse &#x3D; a and b guest house</li></ul><ol start="2"><li>本体中多个slot-value无法与数据库中的实体相关联<strong>（这个地方不是很理解）</strong></li></ol><h2 id="纠正程序"><a href="#纠正程序" class="headerlink" title="纠正程序"></a>纠正程序</h2><p><strong>为了解决上面提到了这些问题，作者这里提到了一套纠正程序</strong></p><p>首先，关于本体。在本体为slot枚举所有可能的value是一件很不现实的事情。比如餐馆的名称，订餐的时间。</p><p>因此这里沿用了一种Schema的概念，也就是categorical和non-categorical的区别</p><p>categorical：slot中value有限（数量小于50），value列举出所有可能的值<br>non-categorical：具有大量possible values的slot，value从对话历史中提取出来</p><p>schema将所有slot分成两类，一类叫做non-categorical，另一类叫做categorical</p><p>non-categorical包括那些具有大量可能value的slot，schema中对这些slot不去预定义一个value的list，对于这类slot的value是从对话历史中提取出来的</p><p>categorical包含了那些value有限的slot，以及在训练数据中具体value数量少于50个的slot。在schema里头对这类slot会列举出所有可能的value<br><img src="/images/2021-10-25-09-40-25.png"></p><p>自：MWZ2.0数据集中的schema好像是比较明显的。</p><h2 id="Categorical-Slots"><a href="#Categorical-Slots" class="headerlink" title="Categorical Slots"></a>Categorical Slots</h2><p>对于分类槽位，所有可能的值都是由2.1的数据库构建的。</p><p>其中有两个特殊的词，dont-care和unknown</p><ul><li>don’t care是用户在对某一个值没有偏好的时候使用的</li><li>unknown指的是那些在schema中的值无法满足用户特定的需求</li></ul><p>例如：<br><img src="/images/2021-10-25-09-43-09.png"></p><h2 id="Non-categorical-Slots"><a href="#Non-categorical-Slots" class="headerlink" title="Non-categorical Slots"></a>Non-categorical Slots</h2><p>对于非分类槽位。上面已经说过，它的value是从历史对话中提取出来的。作者这里使用一种字符串匹配的方式找到对话历史中语义最接近的值。如果有多个，就取最近提到的那个</p><p>在2.2中，在标注中允许一个slot有多个value，模型预测出来任意一个都算对<br><img src="/images/2021-10-25-09-48-10.png"></p><p>当多个slot对应的是同一个value的时候，作者这里采用链式存储的思想。后来的slot不标注span，而是标注这个value对应的原始的slot</p><p><img src="/images/2021-10-25-09-54-53.png"></p><p>这个图也显示了有在categorical和non-categorical上分别计算JointAcc的习惯</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Dialogue State Tracking</tag>
      
      <tag>Dataset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的首篇github博客!</title>
    <link href="/2021/09/13/mixed/hexo/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/09/13/mixed/hexo/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>何老版推荐的github.io+hexo好用啊</strong></p><p><strong>个人代码管理+笔记博客什么的都可以写在github这里了</strong></p><p>主要写了hexo + github.io的双分支部署说明和步骤，以及本地运维和新建修改，切换主题等操作。</p><span id="more"></span><p>References：</p><blockquote><p>简易部署相关：<a href="https://www.jianshu.com/p/390f202c5b0e">https://www.jianshu.com/p/390f202c5b0e</a><br>多分支部署相关：<a href="https://blog.csdn.net/sherlockyb/article/details/94180548">https://blog.csdn.net/sherlockyb/article/details/94180548</a><br>切换主题相关：<a href="https://github.com/stkevintan/hexo-theme-material-flow">https://github.com/stkevintan/hexo-theme-material-flow</a> </p></blockquote><h2 id="1-hexo-github-io的双分支部署的说明"><a href="#1-hexo-github-io的双分支部署的说明" class="headerlink" title="1. hexo + github.io的双分支部署的说明"></a>1. hexo + github.io的双分支部署的说明</h2><p>简易部署带来的问题：</p><p>如果使用简单的hexo配置，那么本地的一些md等文件将丢失，所以现在有master（存储hexo生成的）和coding-pages（静态的）两个分支；</p><p>master用来存储hexo生成的+yixuan004.github.io页面显示的内容（html），而coding-pages存放了一些原本的markdown文件，还有一些_config.yml等，这样如果未来某一天本地环境崩溃了，还可以很快的git clone恢复；</p><h2 id="2-hexo-github-io的双分支部署步骤"><a href="#2-hexo-github-io的双分支部署步骤" class="headerlink" title="2. hexo + github.io的双分支部署步骤"></a>2. hexo + github.io的双分支部署步骤</h2><ol><li><p>在github建立一个包含README.md的项目，命名为 username.github.io，主分支为master分支；</p></li><li><p>直接在github branch的位置处新建一个coding-pages分支，并将其设置为默认分支。此时master分支和coding-pages分支应该都会有一个README.md文件，但实际上是不需要的，在后边可能需要用强制推分支的方法把这个README覆盖掉</p></li><li><p>在本地的一个文件夹中（例如yixuan004.github.io文件夹）中初始化一个hexo项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo init</span><br></code></pre></td></tr></table></figure></li><li><p>将本地的hexo项目与远程仓库关联，在本地的那个地方使用git init生成隐藏的.git文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git init</span><br></code></pre></td></tr></table></figure></li></ol><p>在之后通过如下命令将远程的那个git关联上的感觉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote add origin https://github.com/yixuan004/yixuan004.github.io.git</span><br></code></pre></td></tr></table></figure><p>在之后，由于远程的默认分支是coding-pages，所以本地也需要新建一个coding-pages分支（<strong>注：本地的操作因为仅需要向coding-pages同步，所以本地工作也要切换到这个分支的感觉</strong>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git checkout -b coding-pages</span><br></code></pre></td></tr></table></figure><p>由于远程之前可能有一个没什么用处的README，这里可以使用强制推的方法解决，但这个应该不是合理的解决办法，只是自己用来省事解决一下了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把本地的所有内容都加入git（hexo会自动生成一个git init，那些内容每次可能hexo clean会clean掉，所以要忽略那些）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push -u origin coding-pages -f</span><br></code></pre></td></tr></table></figure><ol start="5"><li><p>安装hexo向git推送的包（在文件夹下操作）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">npm install hexo-deployer-git --save</span><br></code></pre></td></tr></table></figure></li><li><p>修改hexo项目中的_config.yml，这里要写上master分支，因为貌似hexo在github.io上默认显示master分支的内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/yixuan004/yixuan004.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure></li><li><p>推送相关（联合第4步使用）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin coding-pages</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean <span class="hljs-comment"># 这个步骤放在第一步也可以，但是感觉有gitignore在应该这样就可以了</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo d</span><br></code></pre></td></tr></table></figure><p><strong>个人感觉远程的master分支是通过这个hexo自动推送，而远程的coding-pages分支是自己手工推送的感觉</strong></p></li></ol><h2 id="3-hexo-github-io的本地操作说明"><a href="#3-hexo-github-io的本地操作说明" class="headerlink" title="3. hexo + github.io的本地操作说明"></a>3. hexo + github.io的本地操作说明</h2><h3 id="3-1-新增博客文章"><a href="#3-1-新增博客文章" class="headerlink" title="3.1 新增博客文章"></a>3.1 新增博客文章</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new [文章名称]<br></code></pre></td></tr></table></figure><p>在这之后，会在source&#x2F;_posts目录下生成[文章名称].md文件，对其进行编写即可进行博客书写，注意在最开始会自动生成如下内容，可以通过自己编辑增加tags和categories</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 我的首篇github博客!<br>date: 2021-09-13 08:01:04<br>tags: <br><span class="hljs-bullet">    -</span> hexo相关<br>categories:<br><span class="hljs-section">    - 编程开发</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="3-2-本地修改运维操作"><a href="#3-2-本地修改运维操作" class="headerlink" title="3.2 本地修改运维操作"></a>3.2 本地修改运维操作</h3><p>在本地完成一些修改后，建议顺序执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git commit -m <span class="hljs-string">&quot;update ...&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git push origin coding-pages</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo clean</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo g</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">hexo d</span><br></code></pre></td></tr></table></figure><h2 id="4-切换hexo主题"><a href="#4-切换hexo主题" class="headerlink" title="4. 切换hexo主题"></a>4. 切换hexo主题</h2><p>可参考：</p><blockquote><p><a href="https://github.com/stkevintan/hexo-theme-material-flow">https://github.com/stkevintan/hexo-theme-material-flow</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Crsenal</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
