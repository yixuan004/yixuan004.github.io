<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curious;的个人划水博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-20T01:50:08.891Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Curious;</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修改hosts文件使得服务器可以访问github</title>
    <link href="http://example.com/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/"/>
    <id>http://example.com/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/</id>
    <published>2022-11-19T08:48:51.000Z</published>
    <updated>2022-11-20T01:50:08.891Z</updated>
    
    <content type="html"><![CDATA[<p>之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用</p><p>在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改<code>/etc/hosts</code>文件的方式</p><span id="more"></span><h1 id="修改hosts文件使得服务器可以访问github"><a href="#修改hosts文件使得服务器可以访问github" class="headerlink" title="修改hosts文件使得服务器可以访问github"></a>修改hosts文件使得服务器可以访问github</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>首先登录如下网站，找到一个可以ping到的github ip地址：<a href="https://ping.chinaz.com/github.com">https://ping.chinaz.com/github.com</a></p><p><img src="/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119200639129.png" alt="image-20221119200639129"></p><p>通过root账号修改<code>/etc/hosts</code>文件，加入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.3www.github.com</span><br><span class="line">140.82.113.3github.com</span><br></pre></td></tr></table></figure><p>加入后效果如下，再次<code>ping www.github.com</code>，可以得到响应，证明正确</p><img src="/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119200931544.png" alt="image-20221119200931544" style="zoom:50%;"><img src="/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/image-20221119201002658.png" alt="image-20221119201002658" style="zoom:50%;">]]></content>
    
    
    <summary type="html">&lt;p&gt;之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用&lt;/p&gt;
&lt;p&gt;在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改&lt;code&gt;/etc/hosts&lt;/code&gt;文件的方式&lt;/p&gt;</summary>
    
    
    
    <category term="Crsenal" scheme="http://example.com/categories/Crsenal/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo图片路径的配置</title>
    <link href="http://example.com/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-19T08:19:33.000Z</published>
    <updated>2022-11-20T01:50:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>在使用hexo搭建博客的时候，<code>./source/images</code>路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到</p><p>但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在</p><p>所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移</p><span id="more"></span><h1 id="hexo图片路径的配置"><a href="#hexo图片路径的配置" class="headerlink" title="hexo图片路径的配置"></a>hexo图片路径的配置</h1><h2 id="1-安装插件hexo-asset-image"><a href="#1-安装插件hexo-asset-image" class="headerlink" title="1. 安装插件hexo-asset-image"></a>1. 安装插件hexo-asset-image</h2><h3 id="1-1-reference"><a href="#1-1-reference" class="headerlink" title="1.1 reference"></a>1.1 reference</h3><p><a href="https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2">https://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2</a></p><h3 id="1-2-操作"><a href="#1-2-操作" class="headerlink" title="1.2 操作"></a>1.2 操作</h3><p>使用npm进行安装，命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>注意，这里很多其他博客提供的安装命令如下，但实际尝试的时候可能由于版本等问题，导致无法生效，这些命令可能不好使</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-marked --save</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>之后，将<code>_config.yml</code>文件的做如下修改（注：后面的marked可能是不需要的，可能是对应<code>hexo-render-marked</code>的配置）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure><p>在上述配置后，在执行<code>hexo new [FILENAME]</code>的时候，会自动生成这个文件名字的md和对应的文件名字的文件夹，这里可以在文件夹后加入<code>.assets</code>，和目前我自己本机的typora环境对应上</p><p>至此操作完成</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在使用hexo搭建博客的时候，&lt;code&gt;./source/images&lt;/code&gt;路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到&lt;/p&gt;
&lt;p&gt;但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在&lt;/p&gt;
&lt;p&gt;所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移&lt;/p&gt;</summary>
    
    
    
    <category term="Crsenal" scheme="http://example.com/categories/Crsenal/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>BERT源代码阅读学习</title>
    <link href="http://example.com/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-11-19T03:30:41.000Z</published>
    <updated>2022-11-20T01:50:08.929Z</updated>
    
    <content type="html"><![CDATA[<p>BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习</p><span id="more"></span><h1 id="BERT源代码阅读学习"><a href="#BERT源代码阅读学习" class="headerlink" title="BERT源代码阅读学习"></a>BERT源代码阅读学习</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>BERT源代码学习：<a href="https://zhuanlan.zhihu.com/p/360988428">https://zhuanlan.zhihu.com/p/360988428</a></p><p>Attention is all you need： <a href="https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf">https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf</a></p><p>BERT：<a href="https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ">https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ</a></p><p>Attention机制详解：<a href="https://zhuanlan.zhihu.com/p/47282410">https://zhuanlan.zhihu.com/p/47282410</a></p><p>positional embedding absolute/relative等不同方式：<a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>torch中的einsum：<a href="https://zhuanlan.zhihu.com/p/361209187">https://zhuanlan.zhihu.com/p/361209187</a></p><p>Self-Attention with Relative Position Representations: <a href="https://arxiv.org/pdf/1803.02155.pdf">https://arxiv.org/pdf/1803.02155.pdf</a></p><h2 id="1-模型结构（论文-amp-Transformer架构截图）"><a href="#1-模型结构（论文-amp-Transformer架构截图）" class="headerlink" title="1. 模型结构（论文&amp;Transformer架构截图）"></a>1. 模型结构（论文&amp;Transformer架构截图）</h2><h3 id="1-1-论文-amp-Transformer架构截图"><a href="#1-1-论文-amp-Transformer架构截图" class="headerlink" title="1.1 论文&amp;Transformer架构截图"></a>1.1 论文&amp;Transformer架构截图</h3><h4 id="1-1-1-Transformer架构图"><a href="#1-1-1-Transformer架构图" class="headerlink" title="1.1.1 Transformer架构图"></a>1.1.1 Transformer架构图</h4><p>左边代表Encoder部分，右边代表Decoder部分。两边的区别个人理解是：</p><ul><li>Encoder是作为NLU（Natrual Language Understanding）来使用的，所以在输入的时候Encoder是能看到全局信息的。从目前接触到的任务来说还是Encoder这边的结构更加常用一些，大部分任务感觉还是属于在NLU的范畴，NLG那边的有些就显得不太好评测或者不是很靠谱；</li><li>但是在输入Decoder的时候，因为Decoder一般被NLG（Natural Language Generation）类的任务来使用，所以其需要根据上文来生成下文，故在输入的时候需要加mask，即 <code>Masked Multi-Head Attention</code>。此外在decoder部分中还有一个接收来自Encoder那边信息的Multi-Head Attention，也被称作 <code>encoder-decoder attention layer</code>，这个地方query来自于前一级的decoder层输出，但其key和value来自于encoder的输出，那么理解来说就是decoder的每一个位置作为key和encoder那边key计算相似度，然后聚合来自encoder那边的value信息；</li><li><font color="red">和同学讨论后补充：对于Transformer架构的信息，像T5这样的encoder-decoder模型，或者说像是一类依据文本生成文本的，比如翻译任务，那就是使用到整个Transformer架构，其中的encoder-decoder attention可以理解为我需要看着原来的文本来做生成，然后把query看做普通RNN架构中的x，这样x需要聚合来自全部输入文本的信息做attention；对于BERT这类就是只用到Encoder架构；对于GPT类的可能就只是用Decoder部分，里面就没有encoder-decoder attention那个部分了；</font></li></ul><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711105616573.png" alt="image-20220711105616573" style="zoom:50%;"><h4 id="1-1-2-Multi-Head-Self-Attention"><a href="#1-1-2-Multi-Head-Self-Attention" class="headerlink" title="1.1.2 Multi-Head Self Attention"></a>1.1.2 Multi-Head Self Attention</h4><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711105642016.png" alt="image-20220711105642016"></p><h4 id="1-1-3-BERT-Embedding"><a href="#1-1-3-BERT-Embedding" class="headerlink" title="1.1.3 BERT Embedding"></a>1.1.3 BERT Embedding</h4><p>这个是bert模型结构的embedding输入，也需要联合代码看一下这个过程是怎么实现的。</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711110109758.png" alt="image-20220711110109758"></p><p>这里补充贴一张LUKE的图，虽然没看过但是看起来加了一个Entity Type Embedding，好像还是个比较有名的工作</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712195033334.png" alt="image-20220712195033334"></p><h2 id="2-代码学习"><a href="#2-代码学习" class="headerlink" title="2. 代码学习"></a>2. 代码学习</h2><h3 id="2-1-基础简化pipeline代码"><a href="#2-1-基础简化pipeline代码" class="headerlink" title="2.1 基础简化pipeline代码"></a>2.1 基础简化pipeline代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel, BertConfig</span><br><span class="line"><span class="keyword">from</span> transformers.models.bert <span class="keyword">import</span> modeling_bert  <span class="comment"># 从这里看源代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预训练模型加载</span></span><br><span class="line">tokenizer = BertTokenizer.from_pretrained(<span class="string">&quot;./bert_base_uncased&quot;</span>)</span><br><span class="line">model = BertModel.from_pretrained(<span class="string">&quot;./bert_base_uncased&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入&amp;输出</span></span><br><span class="line">text = <span class="string">&quot;Germany beat Argentina 2-0 in the World Cup Final.&quot;</span></span><br><span class="line">encoded_input = tokenizer(text, return_tensors=<span class="string">&#x27;pt&#x27;</span>)</span><br><span class="line">output = model(**encoded_input)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取一句话的输出，还有cls token的输出</span></span><br><span class="line"><span class="built_in">print</span>(output[<span class="string">&#x27;pooler_output&#x27;</span>].shape)  <span class="comment"># torch.Size([1, 768])</span></span><br><span class="line"><span class="built_in">print</span>(output[<span class="string">&#x27;last_hidden_state&#x27;</span>].shape)  <span class="comment"># torch.Size([1, 14, 768])</span></span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>总结：加载<strong>config.json</strong>、<strong>vocab.txt</strong>还有<strong>pytorch_model.bin</strong>三个文件。其中通过 <code>from_pretrained(&quot;./bert_base_uncased&quot;)</code>进行指定路径，如果不指定路径的话好像会从huggingface那边下载model，指定路径的话就需要文件夹下有这三个文件；</p><h3 id="2-2-model"><a href="#2-2-model" class="headerlink" title="2.2 model"></a>2.2 model</h3><h4 id="2-2-1-embeddings、encoder、pooler（※重点）"><a href="#2-2-1-embeddings、encoder、pooler（※重点）" class="headerlink" title="2.2.1 embeddings、encoder、pooler（※重点）"></a>2.2.1 embeddings、encoder、pooler（※重点）</h4><p>通过<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code>加载模型后，首先可以在这里调试model这个对象包含的内容，model是BertModel的实例化，模型结构主要由<code>model.embeddings </code>（BERTEmbeddings类对象），<code>model.encoder</code>（BertEncoder类对象），<code>model.pooler</code>（BertPooler对象）组成。点开后可以看到各个地方的模型结构与层数，之后会随着模型调试查看数据流向和数据维度的变化。</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711135726421.png" alt="image-20220711135726421"></p><h5 id="·-class-BertEmbeddings层结构"><a href="#·-class-BertEmbeddings层结构" class="headerlink" title="· class BertEmbeddings层结构"></a>· class BertEmbeddings层结构</h5><blockquote><p>/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertEmbeddings</span>(nn.Module):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Construct the embeddings from word, position and token_type embeddings.&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h6 id="1-init"><a href="#1-init" class="headerlink" title="1) init"></a>1) <strong>init</strong></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=config.pad_token_id)</span><br><span class="line">    self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size)</span><br><span class="line">    self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load</span></span><br><span class="line">    <span class="comment"># any TensorFlow checkpoint file</span></span><br><span class="line">    self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)</span><br><span class="line">    self.dropout = nn.Dropout(config.hidden_dropout_prob)</span><br><span class="line">    <span class="comment"># position_ids (1, len position emb) is contiguous in memory and exported when serialized</span></span><br><span class="line">    self.position_embedding_type = <span class="built_in">getattr</span>(config, <span class="string">&quot;position_embedding_type&quot;</span>, <span class="string">&quot;absolute&quot;</span>)</span><br><span class="line">    self.register_buffer(<span class="string">&quot;position_ids&quot;</span>, torch.arange(config.max_position_embeddings).expand((<span class="number">1</span>, -<span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> version.parse(torch.__version__) &gt; version.parse(<span class="string">&quot;1.6.0&quot;</span>):</span><br><span class="line">        self.register_buffer(</span><br><span class="line">            <span class="string">&quot;token_type_ids&quot;</span>,</span><br><span class="line">            torch.zeros(self.position_ids.size(), dtype=torch.long),</span><br><span class="line">            persistent=<span class="literal">False</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>简单对init进行解释，这里有三个<code>nn.Embedding</code>层：</p><ul><li>self.word_embeddings：维度从vocab_size（30522）到hidden_size（768）转化，<font color="red">TODO：padding_idx的参数是做什么用的？</font> </li><li>self.position_embeddings：维度从max_position_embeddings（512）到hidden_size（768）转化；</li><li>self.token_type_embeddings：维度从config.type_vocab_size（2，这里的2代表的是有两种类别的，第一个[SEP]前都是0，第二个[SEP]前都是1，这样交叉的）到到hidden_size（768），或者是用来表示padding地方的差异；</li></ul><p>这里的<code>self.LayerNorm</code>和<code>self.dropout</code>是剩下两个和forward比较相关的层，初始化都比较正常</p><p><font color="red">和同学讨论下这个nn.Embedding层的用处，之前对这个层一直不是太理解，大概目前的理解是传入的一个比如input_ids是[1, 14]这个shape的，首先其被转化成一个one-hot的表示也就是[1, 14, 30522(这个维度类似一个词典大小)]，然后过一个[30522, 768]的，两个乘在一起就有一种对应位把元素取出来的感觉，这样就得到了最终的embedding表示[1, 14, 768]</font> </p><p><font color="red">词表大小30522是针对input_ids embedding的，那么针对positional embedding就是max_seq_len，针对token type的就是2（只有0和1代表两类交替的）</font></p><h6 id="2-forward"><a href="#2-forward" class="headerlink" title="2) forward"></a>2) forward</h6><p>forward传入的参数中</p><ul><li>input_ids **[1, seq_len]**：tensor([[ 101, 2762, 3786, 5619, 1016, 1011, 1014, 1998, 2180, 1996, 2088, 2452, 2345,  102]])，这是tokenizer.convert_tokens_to_ids()的结果应该，那边BERT好像还对应了个wordpiecetoken，101是[CLS]，102是[PAD]</li><li>token_type_ids **[1, seq_len]**：tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])，传入的没有[SEP]，只有一类token</li><li>position_ids：暂时为None</li><li>inputs_embeds：暂时为None</li></ul><p>step1：根据input_ids提取得到的seq_len长度，初始化position_ids **[1, seq_len]**：tensor([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13]])</p><p>step2：获取input_embeds和token_type_embeddings，通过上面的传入参数以及nn.Embedding层，并把这两个加在一起</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> inputs_embeds <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    inputs_embeds = self.word_embeddings(input_ids)</span><br><span class="line">token_type_embeddings = self.token_type_embeddings(token_type_ids)</span><br><span class="line"></span><br><span class="line">embeddings = inputs_embeds + token_type_embeddings</span><br></pre></td></tr></table></figure><p>embeddings.shape <strong>[1, seq_len, hidden_dim]</strong></p><p>step3：如果self.position_embedding_type是”absolute”绝对的话，就传入后加上position_embeddings，此时embeddings.shape **[1, seq_len, hidden_dim]**没有变化；absolute就是绝对位置编码，理解是[0, 1, 2, 3…]这样的绝对位置；<font color="red">还有一种position_embedding是相对位置编码的embedding，部分代码整合在了BertSelfAttention这个类中，博客参考：<a href="https://blog.csdn.net/chenf1995/article/details/122971023">https://blog.csdn.net/chenf1995/article/details/122971023</a></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self.position_embedding_type == <span class="string">&quot;absolute&quot;</span>:</span><br><span class="line">    position_embeddings = self.position_embeddings(position_ids)</span><br><span class="line">    embeddings += position_embeddings</span><br></pre></td></tr></table></figure><p>step4：过LayerNorm和dropout，维度不会改变，BertEmbeddings这个类最终输出了一个embeddings <strong>[1, seq_len, hidden_dim]<strong>的信息，代表将要输入进入encoder结构部分的embedding</strong>input_embedding+token_type_embedding+position_embedding</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">embeddings = self.LayerNorm(embeddings)</span><br><span class="line">embeddings = self.dropout(embeddings)</span><br><span class="line"><span class="keyword">return</span> embeddings</span><br></pre></td></tr></table></figure><h6 id="3-综合别人博客做一个总结"><a href="#3-综合别人博客做一个总结" class="headerlink" title="3) 综合别人博客做一个总结"></a>3) 综合别人博客做一个总结</h6><p>word_embeddings是上文中subword tokenization对应的词嵌入；</p><p>token_type_embeddings是用于表示当前词所在的句子，辅助区别句子与padding，句子对通过[SEP]分隔之间的差异；</p><p>position_embeddings是句子中每个词的位置嵌入，用于区别词的顺序，博客说这个地方是训练出来的（从代码看确实如此），而不是计算得到固定嵌入，可能固定嵌入不利于拓展；</p><p>三个embedding层不带权重直接加在一起，过LayerNorm+dropout后产生输出，大小为**[batch_size, seq_len, hidden_size]**</p><h6 id="4-补充：positional-embedding的不同方式"><a href="#4-补充：positional-embedding的不同方式" class="headerlink" title="4) 补充：positional embedding的不同方式"></a>4) 补充：positional embedding的不同方式</h6><p><a href="https://zhuanlan.zhihu.com/p/121126531">https://zhuanlan.zhihu.com/p/121126531</a></p><p>背景：</p><p>词与词之间的顺序关系往往影响整个句子的含义，因此在对文本数据进行建模的时候需要考虑词与词之间的顺序关系；</p><p>建模文本中的顺序关系必须要使用positional encoding吗？-&gt; 不一定，只有使用位置不敏感的模型对文本数据进行建模的时候，才需要额外使用positional encoding；如果模型的输出会随着输入文本数据顺序的变化而变化，那么这个模型就是关于位置敏感的，反之则是位置不敏感的；</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713092751251.png" alt="image-20220713092751251"></p><p>在常用的文本模型中，RNN类的就是关于位置敏感的，使用RNN类模型对文本数据建模的时候，模型结构天然考虑了文本中词与词之间的顺序关系。<strong>而以attention机制为核心的transformer则是位置不敏感的，使用这一类位置不敏感的模型的时候需要额外加入positional encoding引入文本中词与词的顺序关系；</strong></p><p>具体操作：</p><p>对于transformer模型的positional encoding有两种主流方式：即绝对位置编码和相对位置编码</p><p>其中<strong>absolute positional embedding（绝对位置编码）</strong>是相对简单理解的，直接对不同位置随机初始化一个positional embedding，加到word embedding和token_type embedding上输入模型作为参数进行训练</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711110109758.png" alt="image-20220711110109758"></p><p>另一种是<strong>relative positional embedding（相对位置编码）</strong>，首先motivation是不同位置的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1 2和3 4距离都只差1，这些关于位置的<strong>相对含义</strong>模型通过绝对位置编码是否能够学习？绝对位置编码没有约束位置之间这些隐含关系，只能期待他隐式的学习到，所以是否有更合理的方法能够显式的让模型理解位置的相对关系？</p><p><font color="blue">11111</font> </p><p>详细看一下huggingface transformer代码中的这个部分，参数有”absolute”、”relative_key”和”relative_key_query”三种，这些参数在<code>class BertSelfAttention(nn.Module)</code>这个类中，而不是在最开始的<code>BertEmbedding</code>那块的</p><ul><li><code>absolute</code>：默认值，这部分就不用处理（对这个地方的处理在Embedding层）</li><li><code>relative_key</code>：对key_layer作处理，将其与这里的<code>positional_embedding</code>和key矩阵相乘作为key相关的位置编码；</li><li><code>relative_key_query</code>：对key和value都进行相乘以作为位置编码。</li></ul><p><font color="red">用下面代码简单加一下注释</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertSelfAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config, position_embedding_type=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> self.position_embedding_type == <span class="string">&quot;relative_key&quot;</span> <span class="keyword">or</span> self.position_embedding_type == <span class="string">&quot;relative_key_query&quot;</span>:</span><br><span class="line">          self.max_position_embeddings = config.max_position_embeddings  <span class="comment"># 512</span></span><br><span class="line">          self.distance_embedding = nn.Embedding(<span class="number">2</span> * config.max_position_embeddings - <span class="number">1</span>, self.attention_head_size)  <span class="comment"># [512*2-1, 64 (即hidden//head_num)]</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span></span><br><span class="line">attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="number">1</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> self.position_embedding_type == <span class="string">&quot;relative_key&quot;</span> <span class="keyword">or</span> self.position_embedding_type == <span class="string">&quot;relative_key_query&quot;</span>:</span><br><span class="line">    seq_length = hidden_states.size()[<span class="number">1</span>]  <span class="comment"># 14</span></span><br><span class="line">    position_ids_l = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(-<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># [14, 1]shape的tensor</span></span><br><span class="line">    position_ids_r = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(<span class="number">1</span>, -<span class="number">1</span>) <span class="comment"># [1, 14]</span></span><br><span class="line">    distance = position_ids_l - position_ids_r  <span class="comment"># [seqlen, seq_len]</span></span><br><span class="line">    positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - <span class="number">1</span>)  <span class="comment"># [seqlen, seqlen, hidden_size]</span></span><br><span class="line">    positional_embedding = positional_embedding.to(dtype=query_layer.dtype)  <span class="comment"># fp16 compatibility</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># query_layer : batchsize, seqlen, hidden -&gt; batchsize, head_num, seqlen, hidden//head_num【multi-head】</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># bhld,lrd -&gt; bhld不变，lrd去掉一个维度变成rd -&gt; bhld不变, rd转置变成dr -&gt; 乘 -&gt; bhlr</span></span><br><span class="line">    <span class="keyword">if</span> self.position_embedding_type == <span class="string">&quot;relative_key&quot;</span>:</span><br><span class="line">        relative_position_scores = torch.einsum(<span class="string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)</span><br><span class="line">        attention_scores = attention_scores + relative_position_scores</span><br><span class="line">    <span class="keyword">elif</span> self.position_embedding_type == <span class="string">&quot;relative_key_query&quot;</span>:</span><br><span class="line">        relative_position_scores_query = torch.einsum(<span class="string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)</span><br><span class="line">        relative_position_scores_key = torch.einsum(<span class="string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)</span><br><span class="line">        attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key</span><br></pre></td></tr></table></figure><ul><li><code>seq_length</code>：这句话的长度，比如14</li><li><code>position_ids_l</code>：初始化是一个例如[14, 1]的向量，存储的类似于[[0], [1], [2] …]这样的</li><li><code>position_ids_r</code>：初始化是一个例如[1, 14]的向量，存储的类似于[[0, 1, 2, 3, 4]]这样的</li><li><code>distance</code>：初始化直接用<code>position_ids_l</code>-<code>position_ids_r</code>，这里直接广播减法，是一个[14, 14]维度的</li></ul><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713165208863.png" alt="image-20220713165208863"></p><p>因为这个地方是在attention这块来做的embedding，attention那边的scoreshape是[batch, head, seq_len, seq_len]的，代表query每个位置处对于key的注意力，那么可以在这里对query和key都搞positional embedding</p><p>通过上面几个做操作搞了一个<code>positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1)</code>，这个有点不为什么每个要把512-1给加上，这样处理完后distance变成了如下所示的tensor</p><p><font color="red">两个距离相隔最远是512，那么这样处理后能保证所有数字都是&gt;=0的，因为离的最远的也就是512了，然后最远的将会到达1023那个感觉</font> </p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220713170145685.png" alt="image-20220713170145685"></p><p>positional_embedding由distance_embedding层后得到，distance_embedding层的传入参数是[512<em>2-1, 64 (即hidden//head_num)]也能理解了，因为词表大小是差不多0-1023的；；positional_embedding的shape是</em>*[seq_len, seq_len, hidden]**的，如果是一个batch的话，那么应该是这个batch里面最大的那个seq_len？</p><p>下面代码把query_layer[1, 12, 14, 64]和positional_embedding[14, 14, 64]作为这个<code>torch.einsum</code>的输入，这个地方参考文档<a href="https://zhuanlan.zhihu.com/p/361209187%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%8A%8A%E5%BD%A2%E7%8A%B6bhld,lrd%E7%9A%84%E4%B8%A4%E4%B8%AAtensor%E5%8A%A0%E6%88%90%E4%B8%80%E4%B8%AAbhlr%E7%9A%84%EF%BC%8C%E8%BF%99%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E7%94%A8%E4%B8%A4%E4%B8%AAl%E5%8F%AF%E8%83%BD%E6%98%AF%E5%9B%A0%E4%B8%BA%E5%89%8D%E9%9D%A2%E4%B8%A4%E4%B8%AAseq_len%E6%9C%AC%E8%B4%A8%E4%B8%8A%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Equery%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9D%A5%E8%87%AA%E4%BA%8Ekey%EF%BC%8C%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E9%95%BF%E7%9A%84%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E8%88%AC%E6%93%8D%E4%BD%9C%E9%BB%98%E8%AE%A4%E4%B8%BA%E7%AD%89%E9%95%BF%E7%9A%84%E4%BA%86%EF%BC%9B">https://zhuanlan.zhihu.com/p/361209187，就是把形状bhld,lrd的两个tensor加成一个bhlr的，这里为什么没用两个l可能是因为前面两个seq_len本质上一个来自于query，一个来自于key，而实际上是不需要等长的，只是一般操作默认为等长的了；</a></p><p>重点：这里以第一个作为示例，l和d在前后的箭头中都出现了，那就是在这两个维度上操作,query_layer[1, 12, <strong>14</strong>, <strong>64</strong>]和positional_embedding[<strong>14</strong>, 14, <strong>64</strong>]，转置乘，出来一个relative_position_scores_query**[1, 12, 14, 14]**的，聚合来自position的信息</p><p><font color="red">TODO：还弄得没那么明白，大概明白个意思，之后还要详细看看</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">relative_position_scores_query = torch.einsum(<span class="string">&quot;bhld,lrd-&gt;bhlr&quot;</span>, query_layer, positional_embedding)</span><br><span class="line">relative_position_scores_key = torch.einsum(<span class="string">&quot;bhrd,lrd-&gt;bhlr&quot;</span>, key_layer, positional_embedding)</span><br></pre></td></tr></table></figure><p>最后，执行下述代码，注意这个<strong>相对位置编码</strong>过程可以只对query做，也可以对query和key同时做</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key</span><br></pre></td></tr></table></figure><p><font color="red">TODO：</font> <a href="https://zhuanlan.zhihu.com/p/121126531%E8%BF%99%E9%87%8C%E8%BF%98%E4%BB%8B%E7%BB%8D%E5%88%B0%E4%BA%86%EF%BC%9ASinusoidal">https://zhuanlan.zhihu.com/p/121126531这里还介绍到了：Sinusoidal</a> Position Encoding和Complex embedding</p><h5 id="·class-BertSelfAttention：被BertAttention调用（※重点）"><a href="#·class-BertSelfAttention：被BertAttention调用（※重点）" class="headerlink" title="·class BertSelfAttention：被BertAttention调用（※重点）"></a>·class BertSelfAttention：被BertAttention调用（※重点）</h5><h6 id="1-init-1"><a href="#1-init-1" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertSelfAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config, position_embedding_type=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> config.hidden_size % config.num_attention_heads != <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(config, <span class="string">&quot;embedding_size&quot;</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f&quot;The hidden size (<span class="subst">&#123;config.hidden_size&#125;</span>) is not a multiple of the number of attention &quot;</span></span><br><span class="line">                <span class="string">f&quot;heads (<span class="subst">&#123;config.num_attention_heads&#125;</span>)&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        self.num_attention_heads = config.num_attention_heads</span><br><span class="line">        self.attention_head_size = <span class="built_in">int</span>(config.hidden_size / config.num_attention_heads)</span><br><span class="line">        self.all_head_size = self.num_attention_heads * self.attention_head_size</span><br><span class="line"></span><br><span class="line">        self.query = nn.Linear(config.hidden_size, self.all_head_size)</span><br><span class="line">        self.key = nn.Linear(config.hidden_size, self.all_head_size)</span><br><span class="line">        self.value = nn.Linear(config.hidden_size, self.all_head_size)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(config.attention_probs_dropout_prob)</span><br><span class="line">        self.position_embedding_type = position_embedding_type <span class="keyword">or</span> <span class="built_in">getattr</span>(</span><br><span class="line">            config, <span class="string">&quot;position_embedding_type&quot;</span>, <span class="string">&quot;absolute&quot;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> self.position_embedding_type == <span class="string">&quot;relative_key&quot;</span> <span class="keyword">or</span> self.position_embedding_type == <span class="string">&quot;relative_key_query&quot;</span>:</span><br><span class="line">            self.max_position_embeddings = config.max_position_embeddings</span><br><span class="line">            self.distance_embedding = nn.Embedding(<span class="number">2</span> * config.max_position_embeddings - <span class="number">1</span>, self.attention_head_size)</span><br><span class="line"></span><br><span class="line">        self.is_decoder = config.is_decoder</span><br></pre></td></tr></table></figure><p>这个地方是整个BERT架构中非常核心的区域</p><ul><li>self.num_attention_heads = config.num_attention_heads：几头注意力机制，在config文件里这里设置为12（一般BERT也是12）</li><li>self.attention_head_size = int(config.hidden_size / config.num_attention_heads)：config.hidden_size是768，所以每个头的hidden_size将会是768/12=64；</li><li>self.all_head_size是self.num_attention_heads（12）再乘回self.attention_head_size（64），猜测这样的原因是因为整除造成的可能回来后就不是768了；<font color="red">从其他博客也看到和剪枝有关</font> </li><li>self.query、self.key、self.value三个权重矩阵，都是一个hidden_size（768）到内部这个all_head_size（可能是768，也可能有损失）的转化；</li><li>self.dropout = nn.Dropout(config.attention_probs_dropout_prob)：简单的dropout层；</li><li>self.position_embedding_type：这与相对/绝对位置编码有关，如果是绝对位置编码那么在BertEmbedding层里面已经给结合进去了，<font color="blue">如果是相对位置编码要在这里实现，不过这个地方暂时先跳过了</font>；</li><li>self.is_decoder = config.is_decoder：标识是否decoder，BERT只是一个encoder就不涉及到这个部分了；</li></ul><h6 id="2-forward-1"><a href="#2-forward-1" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">transpose_for_scores</span>(<span class="params">self, x</span>):</span><br><span class="line">    new_x_shape = x.size()[:-<span class="number">1</span>] + (self.num_attention_heads, self.attention_head_size)</span><br><span class="line">    x = x.view(new_x_shape)</span><br><span class="line">    <span class="keyword">return</span> x.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>首先是这个函数，这个函数是拆多头用的，输入的x是[batch, seq_len, hidden]的，先指定new_shape是[batch, seq_len, num_attention_heads, attention_head_size]（一般可以认为是[batch, seq_len, 12, 64]），然后.view转化，然后再通过permute改变顺序为**[batch, attention_head_size, seq_len, num_attention_heads]**，这样是因为attention_head_size可以归为”batch“那边的维度了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    hidden_states: torch.Tensor,</span></span><br><span class="line"><span class="params">    attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    head_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_hidden_states: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    past_key_value: <span class="type">Optional</span>[<span class="type">Tuple</span>[<span class="type">Tuple</span>[torch.FloatTensor]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    output_attentions: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor]:</span><br><span class="line">    mixed_query_layer = self.query(hidden_states)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略了cross-attention部分</span></span><br><span class="line">    <span class="comment"># hidden_states [batch, seqlen, hidden]</span></span><br><span class="line">    key_layer = self.transpose_for_scores(self.key(hidden_states))  <span class="comment"># [batch, num_head, seqlen_key, hidden//num_head]</span></span><br><span class="line">    value_layer = self.transpose_for_scores(self.value(hidden_states))</span><br><span class="line">    query_layer = self.transpose_for_scores(mixed_query_layer) <span class="comment"># [batch, num_head, seqlen_query, hidden//num_head]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span></span><br><span class="line">    attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="number">1</span>, -<span class="number">2</span>))  <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 忽略了相对位置编码的处理</span></span><br><span class="line"></span><br><span class="line">    attention_scores = attention_scores / math.sqrt(self.attention_head_size)</span><br><span class="line">    <span class="keyword">if</span> attention_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span></span><br><span class="line">        attention_scores = attention_scores + attention_mask</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Normalize the attention scores to probabilities.</span></span><br><span class="line">    attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This is actually dropping out entire tokens to attend to, which might</span></span><br><span class="line">    <span class="comment"># seem a bit unusual, but is taken from the original Transformer paper.</span></span><br><span class="line">    attention_probs = self.dropout(attention_probs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Mask heads if we want to</span></span><br><span class="line">    <span class="keyword">if</span> head_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        attention_probs = attention_probs * head_mask</span><br><span class="line"></span><br><span class="line">    context_layer = torch.matmul(attention_probs, value_layer)  <span class="comment"># [batch, num_head, seqlen, hidden//num_head]</span></span><br><span class="line"></span><br><span class="line">    context_layer = context_layer.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).contiguous()</span><br><span class="line">    new_context_layer_shape = context_layer.size()[:-<span class="number">2</span>] + (self.all_head_size,)</span><br><span class="line">    context_layer = context_layer.view(new_context_layer_shape)</span><br><span class="line"></span><br><span class="line">    outputs = (context_layer, attention_probs) <span class="keyword">if</span> output_attentions <span class="keyword">else</span> (context_layer,)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 忽略了is_decoder部分</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><p>上面贴出来的这段代码省略了针对<code>is_cross_attention</code>（即encoder-decoder attention那个部分的一些处理），此外还忽略了<code>if self.is_decoder:</code>部分的处理，并且忽略了<code>if self.position_embedding_type == &quot;relative_key&quot; </code>相对位置编码部分的处理；</p><p>step1：首先是这个部分，hidden_states**[batch, seq_len, hidden_size]<strong>这个tensor过了self.query、self.value、self.key三个linear矩阵，由于这三个linear一般不改变hidden_size，这样得到的是三个</strong>[batch, seq_len, hidden_size]<strong>形状的tensor，通过上面提到的transpose_for_scores进行reshape，得到三个</strong>[batch, head_num, seq_len, attention_head_size]**（一般可以是[1, 12, seq_len, 768]）这样的tensor，并且被命名为key_layer、value_layer、query_layer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mixed_query_layer = self.query(hidden_states)</span><br><span class="line">key_layer = self.transpose_for_scores(self.key(hidden_states))</span><br><span class="line">value_layer = self.transpose_for_scores(self.value(hidden_states))</span><br><span class="line">query_layer = self.transpose_for_scores(mixed_query_layer)</span><br></pre></td></tr></table></figure><p>step2：这里就是Q·K^T那个部分了，转置就是在后两个维度上转置，输出的attention_scores是**[batch, head_num, seq_len, seq_len]**形状的tensor，代表query中每个位置处对key全局所有的注意力（后面要过softmax）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="number">1</span>, -<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>step3：依照博客简单理解一下不同的positional_embedding_type，<font color="blue">这个部分暂时忽略了</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">absolute：默认值，这部分就不用处理；</span><br><span class="line">relative_key：对key_layer作处理，将其与这里的positional_embedding和key矩阵相乘作为key相关的位置编码；</span><br><span class="line">relative_key_query：对key和value都进行相乘以作为位置编码。</span><br></pre></td></tr></table></figure><p>step4：计算attention_scores，attention_probs；attention_scores在计算query和key的点乘后除以根号下d_k，<strong>注意这里的self.attention_head_size是64那个地方的，也就是分成12个头后每个头的hidden_size</strong>，如果带有attention_mask的话<font color="red">（注意，一般来说肯定是会有atttention_mask的，应该会在调用这个BertAttention的时候传给他，因为一个batch中大家不等长，肯定要通过mask padding到512这种感觉的）</font> ；；在计算attention_scores时候用的是加法，因为softmax那块要一个很大的负数，比如-1e9这样的，然后过softmax，注意softmax的维度是-1代表query中每个token对所有key位置处的token的attention；；；最后过一个self.dropout，<font color="red">TODO：暂时有点没理解为什么在这里过dropout，而不是乘了之后</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.</span></span><br><span class="line">attention_scores = torch.matmul(query_layer, key_layer.transpose(-<span class="number">1</span>, -<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略了相对位置编码的处理</span></span><br><span class="line"></span><br><span class="line">attention_scores = attention_scores / math.sqrt(self.attention_head_size)</span><br><span class="line"><span class="keyword">if</span> attention_mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># Apply the attention mask is (precomputed for all layers in BertModel forward() function)</span></span><br><span class="line">    attention_scores = attention_scores + attention_mask</span><br><span class="line"></span><br><span class="line"><span class="comment"># Normalize the attention scores to probabilities.</span></span><br><span class="line">attention_probs = nn.functional.softmax(attention_scores, dim=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is actually dropping out entire tokens to attend to, which might</span></span><br><span class="line"><span class="comment"># seem a bit unusual, but is taken from the original Transformer paper.</span></span><br><span class="line">attention_probs = self.dropout(attention_probs)</span><br></pre></td></tr></table></figure><p>step5：这里主要就是输出整合了，再reshape回去，变成了**[batch, seq_len, hidden_size]**的这个形状，另外看到config中output_attentions那个参数的作用，要不要把每层的这个attention返回回去，至此<code>class BertSelfAttention(nn.Module)</code>这个地方的forward结束了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context_layer = torch.matmul(attention_probs, value_layer)</span><br><span class="line"></span><br><span class="line">context_layer = context_layer.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>).contiguous()</span><br><span class="line">new_context_layer_shape = context_layer.size()[:-<span class="number">2</span>] + (self.all_head_size,)</span><br><span class="line">context_layer = context_layer.view(new_context_layer_shape)</span><br><span class="line"></span><br><span class="line">outputs = (context_layer, attention_probs) <span class="keyword">if</span> output_attentions <span class="keyword">else</span> (context_layer,)</span><br><span class="line"><span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><h5 id="·class-BertSelfOutput-被BertAttention调用"><a href="#·class-BertSelfOutput-被BertAttention调用" class="headerlink" title="·class BertSelfOutput: 被BertAttention调用"></a>·class BertSelfOutput: 被BertAttention调用</h5><h6 id="1-init-amp-forward"><a href="#1-init-amp-forward" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertSelfOutput</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.hidden_size, config.hidden_size)</span><br><span class="line">        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)</span><br><span class="line">        self.dropout = nn.Dropout(config.hidden_dropout_prob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:</span><br><span class="line">        hidden_states = self.dense(hidden_states)</span><br><span class="line">        hidden_states = self.dropout(hidden_states)</span><br><span class="line">        hidden_states = self.LayerNorm(hidden_states + input_tensor)</span><br><span class="line">        <span class="keyword">return</span> hidden_states</span><br></pre></td></tr></table></figure><p>这个地方代码结构是相对比较简单的，<font color="red"><strong>这里也展现出了BERT中存在的一层add&amp;norm操作，这里应该还只是attention这个部分的内容</strong></font> </p><h5 id="·class-BertAttention：被BertLayer调用"><a href="#·class-BertAttention：被BertLayer调用" class="headerlink" title="·class BertAttention：被BertLayer调用"></a>·class BertAttention：被BertLayer调用</h5><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712110214629.png" alt="image-20220712110214629" style="zoom:50%;"><h6 id="1-init-2"><a href="#1-init-2" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertAttention</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config, position_embedding_type=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.self = BertSelfAttention(config, position_embedding_type=position_embedding_type)</span><br><span class="line">        self.output = BertSelfOutput(config)</span><br><span class="line">        self.pruned_heads = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><p>attention的实现还是不在这里，self.self这个是multi-head self attention机制的实现，self.output的操作是第一个这里完成的部分；</p><p>该层中使用到了<code>self.pruned_heads = set()</code>这样一种节约显存的技术，暂时没有了解太深；</p><h6 id="2-forward-2"><a href="#2-forward-2" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    hidden_states: torch.Tensor,</span></span><br><span class="line"><span class="params">    attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    head_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_hidden_states: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    past_key_value: <span class="type">Optional</span>[<span class="type">Tuple</span>[<span class="type">Tuple</span>[torch.FloatTensor]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    output_attentions: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor]:</span><br><span class="line">    self_outputs = self.self(</span><br><span class="line">        hidden_states,</span><br><span class="line">        attention_mask,</span><br><span class="line">        head_mask,</span><br><span class="line">        encoder_hidden_states,</span><br><span class="line">        encoder_attention_mask,</span><br><span class="line">        past_key_value,</span><br><span class="line">        output_attentions,</span><br><span class="line">    )</span><br><span class="line">    attention_output = self.output(self_outputs[<span class="number">0</span>], hidden_states)</span><br><span class="line">    outputs = (attention_output,) + self_outputs[<span class="number">1</span>:]  <span class="comment"># add attentions if we output them</span></span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><p>有了上面的<code>BertSelfAttention</code>和<code>BertSelfOutput</code>后，这个组件就比较好理解了</p><h5 id="·class-BertIntermediate-被BertLayer调用"><a href="#·class-BertIntermediate-被BertLayer调用" class="headerlink" title="·class BertIntermediate: 被BertLayer调用"></a>·class BertIntermediate: 被BertLayer调用</h5><p>在BertAttention这个模块后，还有一个FFNN的操作，这里包含有激活函数；<font color="red">TODO：为什么有些地方需要激活函数，有些地方就不用？像CV那边的话，经常几个层过后就来一个激活，但是这里比如BertAttention里面就没有激活</font> </p><h6 id="1-init-amp-forward-1"><a href="#1-init-amp-forward-1" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertIntermediate</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.hidden_size, config.intermediate_size)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(config.hidden_act, <span class="built_in">str</span>):</span><br><span class="line">            self.intermediate_act_fn = ACT2FN[config.hidden_act]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.intermediate_act_fn = config.hidden_act</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:</span><br><span class="line">        hidden_states = self.dense(hidden_states)</span><br><span class="line">        hidden_states = self.intermediate_act_fn(hidden_states)</span><br><span class="line">        <span class="keyword">return</span> hidden_states</span><br></pre></td></tr></table></figure><p>这个里面调用了<code>config.hidden_act</code>，在config文件那边的话这个地方是<code>&quot;gelu&quot;</code>，对应的也就是gelu激活函数，整体来看这个层结构还是很简单的，<font color="red">其中注意dense这个层把768转化为一个config.intermediate_size3072了</font> </p><h5 id="·class-BertOutput-被BertLayer调用"><a href="#·class-BertOutput-被BertLayer调用" class="headerlink" title="·class BertOutput: 被BertLayer调用"></a>·class BertOutput: 被BertLayer调用</h5><p><font color="red">注意这里不是BertSelfOutput，刚才那个是中间层的，这个是一个BLOCK的</font> </p><h6 id="1-init-amp-forward-2"><a href="#1-init-amp-forward-2" class="headerlink" title="1) init&amp;forward"></a>1) init&amp;forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertOutput</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.intermediate_size, config.hidden_size)</span><br><span class="line">        self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps)</span><br><span class="line">        self.dropout = nn.Dropout(config.hidden_dropout_prob)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden_states: torch.Tensor, input_tensor: torch.Tensor</span>) -&gt; torch.Tensor:</span><br><span class="line">        hidden_states = self.dense(hidden_states)</span><br><span class="line">        hidden_states = self.dropout(hidden_states)</span><br><span class="line">        hidden_states = self.LayerNorm(hidden_states + input_tensor)</span><br><span class="line">        <span class="keyword">return</span> hidden_states</span><br></pre></td></tr></table></figure><p>主要负责的也是一些整合，还有residual的部分，<font color="red">其中注意dense层把intermidiate_size又转化会config.hidden_size了</font> </p><h5 id="·-class-BertLayer-nn-Module-：被BertEncoder调用"><a href="#·-class-BertLayer-nn-Module-：被BertEncoder调用" class="headerlink" title="· class BertLayer(nn.Module)：被BertEncoder调用"></a>· class BertLayer(nn.Module)：被BertEncoder调用</h5><h6 id="1-init-3"><a href="#1-init-3" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.chunk_size_feed_forward = config.chunk_size_feed_forward</span><br><span class="line">    self.seq_len_dim = <span class="number">1</span></span><br><span class="line">    self.attention = BertAttention(config)</span><br><span class="line">    self.is_decoder = config.is_decoder</span><br><span class="line">    self.add_cross_attention = config.add_cross_attention</span><br><span class="line">    <span class="keyword">if</span> self.add_cross_attention:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.is_decoder:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f&quot;<span class="subst">&#123;self&#125;</span> should be used as a decoder model if cross attention is added&quot;</span>)</span><br><span class="line">        self.crossattention = BertAttention(config, position_embedding_type=<span class="string">&quot;absolute&quot;</span>)</span><br><span class="line">    self.intermediate = BertIntermediate(config)</span><br><span class="line">    self.output = BertOutput(config)</span><br></pre></td></tr></table></figure><p>可以简单理解为，依次调用了BertAttention、BertIntermediate、BertOutput完成了一个BLOCK的操作</p><h6 id="2-forward-3"><a href="#2-forward-3" class="headerlink" title="2) forward"></a>2) forward</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params"></span></span><br><span class="line"><span class="params">    self,</span></span><br><span class="line"><span class="params">    hidden_states: torch.Tensor,</span></span><br><span class="line"><span class="params">    attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    head_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_hidden_states: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    encoder_attention_mask: <span class="type">Optional</span>[torch.FloatTensor] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    past_key_value: <span class="type">Optional</span>[<span class="type">Tuple</span>[<span class="type">Tuple</span>[torch.FloatTensor]]] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    output_attentions: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">False</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="type">Tuple</span>[torch.Tensor]:</span><br><span class="line">    <span class="comment"># decoder uni-directional self-attention cached key/values tuple is at positions 1,2</span></span><br><span class="line">    self_attn_past_key_value = past_key_value[:<span class="number">2</span>] <span class="keyword">if</span> past_key_value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">    self_attention_outputs = self.attention(</span><br><span class="line">        hidden_states,</span><br><span class="line">        attention_mask,</span><br><span class="line">        head_mask,</span><br><span class="line">        output_attentions=output_attentions,</span><br><span class="line">        past_key_value=self_attn_past_key_value,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 忽略一些is_decoder的操作</span></span><br><span class="line">    </span><br><span class="line">    attention_output = self_attention_outputs[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    outputs = self_attention_outputs[<span class="number">1</span>:]  <span class="comment"># add self attentions if we output attention weights</span></span><br><span class="line"></span><br><span class="line">    layer_output = apply_chunking_to_forward(</span><br><span class="line">        self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output</span><br><span class="line">    )</span><br><span class="line">    outputs = (layer_output,) + outputs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if decoder, return the attn key/values as the last output</span></span><br><span class="line">    <span class="keyword">if</span> self.is_decoder:</span><br><span class="line">        outputs = outputs + (present_key_value,)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outputs</span><br></pre></td></tr></table></figure><p>组装起来</p><h5 id="·-class-BertEncoder-nn-Module-层结构"><a href="#·-class-BertEncoder-nn-Module-层结构" class="headerlink" title="· class BertEncoder(nn.Module)层结构"></a>· class BertEncoder(nn.Module)层结构</h5><h6 id="1-init-4"><a href="#1-init-4" class="headerlink" title="1) init"></a>1) init</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self.config = config</span><br><span class="line">    self.layer = nn.ModuleList([BertLayer(config) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(config.num_hidden_layers)])</span><br><span class="line">    self.gradient_checkpointing = <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>在这里通过<code>config.num_hidden_layers</code>指定了这个<code>BertLayer</code>结构的层数，进一步详细查看<code>BertLayer</code>层的代码，应该对应的就是Transformer架构中如图所示的N×这个部分</p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712093703201.png" alt="image-20220712093703201" style="zoom:50%;"><h6 id="2-forward-4"><a href="#2-forward-4" class="headerlink" title="2) forward"></a>2) forward</h6><p>主要是把N个Layer串接起来forward，返回值封装了一个类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_outputs.py</span></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseModelOutputWithPastAndCrossAttentions</span>(<span class="title class_ inherited__">ModelOutput</span>):</span><br></pre></td></tr></table></figure><h5 id="·-class-BertPooler："><a href="#·-class-BertPooler：" class="headerlink" title="· class BertPooler："></a>· class BertPooler：</h5><p>这个主要是针对[CLS]token又过了一个pooler</p><p>禁用的话：bertmodel初始化有一个配置add_pooling_layer默认为True，改成false就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertPooler</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.dense = nn.Linear(config.hidden_size, config.hidden_size)</span><br><span class="line">        self.activation = nn.Tanh()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden_states: torch.Tensor</span>) -&gt; torch.Tensor:</span><br><span class="line">        <span class="comment"># We &quot;pool&quot; the model by simply taking the hidden state corresponding</span></span><br><span class="line">        <span class="comment"># to the first token.</span></span><br><span class="line">        first_token_tensor = hidden_states[:, <span class="number">0</span>]</span><br><span class="line">        pooled_output = self.dense(first_token_tensor)</span><br><span class="line">        pooled_output = self.activation(pooled_output)</span><br><span class="line">        <span class="keyword">return</span> pooled_output</span><br></pre></td></tr></table></figure><p><font color="red">TODO：这里还有些内容不是很明白，待和zkh讨论，比如说为什么叫pool，然后[CLS]这个token为什么要做这些的操作</font> </p><h5 id="·-class-BertModel-各层组合在一起整体的说明"><a href="#·-class-BertModel-各层组合在一起整体的说明" class="headerlink" title="· class BertModel(): 各层组合在一起整体的说明"></a>· class BertModel(): 各层组合在一起整体的说明</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BertModel</span>(<span class="title class_ inherited__">BertPreTrainedModel</span>):</span><br><span class="line">embedding_output = self.embeddings(</span><br><span class="line">    input_ids=input_ids,</span><br><span class="line">    position_ids=position_ids,</span><br><span class="line">    token_type_ids=token_type_ids,</span><br><span class="line">    inputs_embeds=inputs_embeds,</span><br><span class="line">    past_key_values_length=past_key_values_length,</span><br><span class="line">)</span><br><span class="line">encoder_outputs = self.encoder(</span><br><span class="line">    embedding_output,</span><br><span class="line">    attention_mask=extended_attention_mask,</span><br><span class="line">    head_mask=head_mask,</span><br><span class="line">    encoder_hidden_states=encoder_hidden_states,</span><br><span class="line">    encoder_attention_mask=encoder_extended_attention_mask,</span><br><span class="line">    past_key_values=past_key_values,</span><br><span class="line">    use_cache=use_cache,</span><br><span class="line">    output_attentions=output_attentions,</span><br><span class="line">    output_hidden_states=output_hidden_states,</span><br><span class="line">    return_dict=return_dict,</span><br><span class="line">)</span><br><span class="line">sequence_output = encoder_outputs[<span class="number">0</span>]</span><br><span class="line">pooled_output = self.pooler(sequence_output) <span class="keyword">if</span> self.pooler <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>重点代码感觉在这个部分，其他部分在制作一些mask类的地方</p><h4 id="2-2-2-model-state-dict"><a href="#2-2-2-model-state-dict" class="headerlink" title="2.2.2 model.state_dict()"></a>2.2.2 model.state_dict()</h4><h5 id="·-加载预训练model"><a href="#·-加载预训练model" class="headerlink" title="· 加载预训练model"></a>· 加载预训练model</h5><p><font color="red">这里加载的时候应该是用到了config.json文件和pytorch_model.bin这两个文件，而vocab.txt应该是tokenizer.from_pretrained()时候用到的，这里详细看一下config.json文件和pytorch_model.bin这两个文件是怎么被用到的</font> </p><p>在加载模型后，可以通过打印<code>model.state_dict()</code>调试看到模型的各个参数，这里因为是from_pretrained的，所以已经加载了pytorch_model.bin文件中的内容，而且每次加载出来的结果也都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预训练版本</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel, BertConfig</span><br><span class="line">config = BertConfig()</span><br><span class="line">model = BertModel.from_pretrained(<span class="string">&quot;./bert_base_uncased&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711141124709.png" alt="image-20220711141124709"></p><p>加载model，也就是<code>BertModel.from_pretrained(pretrained_model_name_or_path)</code>对应的函数在如下路径，<strong>这个地方只要是bert的模型结构，不管是bert-base还是bert-large</strong>是都可以通过这里加载的，主要就是读取对应的<strong>config.json文件和pytorch_model.bin这两个文件</strong>：</p><blockquote><p>/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_pretrained</span>(<span class="params">cls, pretrained_model_name_or_path: <span class="type">Optional</span>[<span class="type">Union</span>[<span class="built_in">str</span>, os.PathLike]], *model_args, **kwargs</span>):</span><br></pre></td></tr></table></figure><h6 id="1-注解说明"><a href="#1-注解说明" class="headerlink" title="1) 注解说明"></a>1) 注解说明</h6><ul><li><p>从预训练的模型配置中实例化预训练的pytorch模型，该模型默认使用 <code>model.eval()</code>设置为评估模式；</p><p><font color="red">和同学讨论后补充：model.eval()一般涉及到dropout层与normalization层；；；在BERT和这种NLP领域下，因为BN不怎么用，所以LN实际上只是单个样本内部在seq_len这个维度上做norm，就不涉及到eval这块了，也就是说在NLP任务的eval这里可能只影响到dropout层；</font> </p><p><font color="red">再补充一些BN上的细节，BN在做训练的时候，均值和方差来自于这一组batch的计算，在inference的时候，使用<strong>全局</strong>的均值和方差，这个全局的均值和方差由之前的每个mini-batch记录而来。</font> </p><p><font color="red">设是[batch, seq_len, hidden]，那么BN会计算出来一个[1, seq_len, hidden]的均值；；；LN就会计算出来一个[batch, 1, hidden]的均值，然后怎么怎么处理</font> </p></li><li><p>输出的警告<code>Weights from XXX not initialized from pretrained model</code>表示XXX部分的权重没有出现，将使用模型其余部分进行训练，可以通过下游任务来微调这些权重：</p><p>如果把config文件的层数增加，比如从12层增加到14层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of BertModel were not initialized from the model checkpoint at ./bert_base_uncased and are newly initialized: [‘bert.encoder.layer.13.attention.output.dense.weight’, ‘bert.encoder.layer.12.intermediate.dense.bias’, ‘bert.encoder.layer.13.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.dense.bias’, ‘bert.encoder.layer.13.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.weight’, ‘bert.encoder.layer.13.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.13.output.dense.bias’, ‘bert.encoder.layer.13.intermediate.dense.bias’, ‘bert.encoder.layer.13.output.LayerNorm.bias’, ‘bert.encoder.layer.13.output.dense.weight’, ‘bert.encoder.layer.12.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.bias’, ‘bert.encoder.layer.13.output.LayerNorm.weight’, ‘bert.encoder.layer.12.output.LayerNorm.weight’, ‘bert.encoder.layer.13.attention.self.query.bias’, ‘bert.encoder.layer.13.attention.self.query.weight’, ‘bert.encoder.layer.12.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.12.attention.output.dense.bias’, ‘bert.encoder.layer.12.attention.self.key.bias’, ‘bert.encoder.layer.12.output.dense.weight’, ‘bert.encoder.layer.12.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.13.intermediate.dense.weight’, ‘bert.encoder.layer.12.output.LayerNorm.bias’, ‘bert.encoder.layer.13.attention.self.key.bias’, ‘bert.encoder.layer.12.intermediate.dense.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.12.output.dense.bias’, ‘bert.encoder.layer.12.attention.output.dense.weight’]</p></blockquote></li><li><p>输出的警告<code>Weights from XXX not used in YYY</code>表示预训练文件中的层XXX不被YYY使用，因此那些权重将被丢弃；</p><p>如果把config文件的层数减少，比如从12层减小到10层的hidden layer结构，可以触发这个Warning</p><blockquote><p>Some weights of the model checkpoint at ./bert_base_uncased were not used when initializing BertModel: [‘bert.encoder.layer.10.intermediate.dense.weight’, ‘cls.predictions.decoder.weight’, ‘cls.predictions.transform.dense.bias’, ‘bert.encoder.layer.11.attention.self.value.bias’, ‘bert.encoder.layer.11.attention.output.dense.bias’, ‘bert.encoder.layer.10.output.dense.bias’, ‘bert.encoder.layer.10.attention.self.key.bias’, ‘bert.encoder.layer.10.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.value.weight’, ‘bert.encoder.layer.11.attention.self.key.bias’, ‘bert.encoder.layer.11.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.LayerNorm.bias’, ‘bert.encoder.layer.11.output.dense.bias’, ‘cls.predictions.transform.LayerNorm.weight’, ‘bert.encoder.layer.10.attention.output.dense.bias’, ‘cls.seq_relationship.bias’, ‘bert.encoder.layer.10.attention.self.value.bias’, ‘bert.encoder.layer.10.attention.output.dense.weight’, ‘cls.predictions.bias’, ‘bert.encoder.layer.10.attention.self.query.weight’, ‘bert.encoder.layer.11.attention.self.query.bias’, ‘cls.predictions.transform.LayerNorm.bias’, ‘bert.encoder.layer.11.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.query.bias’, ‘cls.predictions.transform.dense.weight’, ‘bert.encoder.layer.10.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.dense.weight’, ‘bert.encoder.layer.11.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.self.query.weight’, ‘cls.seq_relationship.weight’, ‘bert.encoder.layer.11.attention.self.value.weight’, ‘bert.encoder.layer.11.intermediate.dense.weight’, ‘bert.encoder.layer.10.output.LayerNorm.weight’, ‘bert.encoder.layer.11.attention.output.dense.weight’, ‘bert.encoder.layer.10.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.dense.weight’, ‘bert.encoder.layer.11.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.output.LayerNorm.weight’]</p></blockquote><p>这里额外输出了几个<code>cls.xxx</code>，就是说没有使用这些检查点的权重，从一些解释来看这些内容应该是要被下游分类器用到的，这些内容将被初始化重新训练。目前代码里只是直接简单应用了这个的输出，而没有针对下游任务fine-tune那些的过程；</p></li></ul><h6 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2) 参数说明"></a>2) 参数说明</h6><ul><li><p><code> pretrained_model_name_or_path (`str` or `os.PathLike`, *optional*)</code></p><p>1）可以是一个字符串代表<code>model id</code>，这个model id可以从huggingface.co上获取，比如直接使用<code>bert-base-uncased</code>，或者使用带有用户名称的这个model id例如<code>hfl/chinese-macbert-base</code>，这种使用方法下可能会从huggingface那边完成下载；</p><p>2）可以是一个包含有pytorch_model.bin和config.json文件的路径，例如<code>./bert_base_uncased/</code>，注意这个目录下的内容需要通过<code>PreTrainedModel.save_pretrained</code>方法来得到，否则保存出来的文件可能和transformer（huggingface这一套）不太配合；</p><p>3）其余用法不太常见或者一般不使用，好像可以从tensorflow和flax的checkpoint进行加载，如果设置为None的话就是通过其他办法已经把config和state_dict给加载进去了；</p></li><li><p><code>output_attentions</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)</code></p><p>这是一个可能相对再常用一点的参数，模型输出的output包含了一个<code>output[&#39;attentions&#39;]</code>的参数输出，在调试的时候发现他是一个长度为12的tuple（这里的长度12是bert的层数），tuple中每个位置上是 <code>shape[1,12, seq_len, seq_len]</code>（这里的长度12应该是multi-head的头数目），output_attentions应该是 <code>softmax((query · key)/sqrt(d_k))</code>的结果；注意<code>shape[1,12, seq_len, seq_len]</code>这个地方，softmax应该是在-1dim上做的，代表<strong>query中的每个位置处，对于每一个key的attention score</strong>，所以来做求和的话，应该能得到一个1的结果；</p><p><font color="red">在后面看forward代码的时候，还要回来看一下这个地方</font> </p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711172228802.png" alt="image-20220711172228802"></p></li><li><p><code>hidden_states</code></p><p>用法：<code>model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;, output_hidden_states=True)</code></p><p>这是中间层（隐层）tensor的output输出，<font color="red">和output_attentions一样，这些内容既可以在from_pretrained中给带过去，<strong>也可以直接写在config.json</strong>文件里</font></p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711173534108.png" alt="image-20220711173534108"></p></li><li><p>上面可能是一些相对常用的参数，暂时理解来说在<code>.from_pretrained(&quot;./bert_base_uncased&quot;)</code>这个方法中带的其他一些参数可以和config加参数起到同样的效果，也就证明这个方法用到了config.json这个文件</p></li></ul><h6 id="3-内部流程说明（※重点）"><a href="#3-内部流程说明（※重点）" class="headerlink" title="3) 内部流程说明（※重点）"></a>3) 内部流程说明（※重点）</h6><p>内部这个地方还是写的比较详细的，像各种Exception也都实现的非常完整，大概理解一下其中的重点部分，主要目标就是加载config.json和pytorch_model.bin两个文件。</p><p><font color="red"><strong>config.json和pytorch_model.bin应该只有model这边用到，tokenizer那边只用到vocab.txt；；从model.from_pretrained接收参数是一个路径，而tokenizer.from_pretrained接收参数是一个vocab.txt文件的路径或者上级路径感觉也能证明这一点</strong></font> </p><ul><li><p>首先加载config.json</p><p>在下面这段代码中，config_path加载到了pretrained_model_name_or_path中的内容，也就是<code>&quot;./bert_base_uncased&quot;</code>，向下层<code>cls.config_class.from_pretrained</code>传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span></span><br><span class="line"><span class="comment"># Load config if we don&#x27;t provide a configuration</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(config, PretrainedConfig):</span><br><span class="line">    config_path = config <span class="keyword">if</span> config <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> pretrained_model_name_or_path</span><br><span class="line">    config, model_kwargs = cls.config_class.from_pretrained(</span><br><span class="line">        config_path,</span><br><span class="line">        cache_dir=cache_dir,</span><br><span class="line">        return_unused_kwargs=<span class="literal">True</span>,</span><br><span class="line">        force_download=force_download,</span><br><span class="line">        resume_download=resume_download,</span><br><span class="line">        proxies=proxies,</span><br><span class="line">        local_files_only=local_files_only,</span><br><span class="line">        use_auth_token=use_auth_token,</span><br><span class="line">        revision=revision,</span><br><span class="line">        _from_auto=from_auto_class,</span><br><span class="line">        _from_pipeline=from_pipeline,</span><br><span class="line">        **kwargs,</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    model_kwargs = kwargs</span><br></pre></td></tr></table></figure><p>这里debug调试了一下<code>cls.config_class</code>：<code>&lt;class &#39;transformers.models.bert.configuration_bert.BertConfig&#39;&gt;</code>，于是在去看<code>BertConfig</code>这块的<code>.from_pretrained</code>，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_pretrained</span>(<span class="params">cls, pretrained_model_name_or_path: <span class="type">Union</span>[<span class="built_in">str</span>, os.PathLike], **kwargs</span>) -&gt; <span class="string">&quot;PretrainedConfig&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一些注释，为了放在md里暂时删除了</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;model_type&quot;</span> <span class="keyword">in</span> config_dict <span class="keyword">and</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;model_type&quot;</span>) <span class="keyword">and</span> config_dict[<span class="string">&quot;model_type&quot;</span>] != cls.model_type:</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;You are using a model of type <span class="subst">&#123;config_dict[<span class="string">&#x27;model_type&#x27;</span>]&#125;</span> to instantiate a model of type &quot;</span></span><br><span class="line">            <span class="string">f&quot;<span class="subst">&#123;cls.model_type&#125;</span>. This is not supported for all configurations of models and can yield errors.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls.from_dict(config_dict, **kwargs)</span><br></pre></td></tr></table></figure><p>在往下看，调用了<code>cls.get_config_dict</code>这个函数，最后一路往下找，直到找到这里，加载json文件，返回一个dict对象，在上面那段代码里最后return了一个<code>cls.from_dict</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_dict_from_json_file</span>(<span class="params">cls, json_file: <span class="type">Union</span>[<span class="built_in">str</span>, os.PathLike]</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(json_file, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> reader:</span><br><span class="line">        text = reader.read()</span><br><span class="line">    <span class="keyword">return</span> json.loads(text)</span><br></pre></td></tr></table></figure><p>看了一下<code>cls.from_dict</code>，应该是这里最终返回了一个BertConfig类的对象，<font color="red">这里字典前面加两个*号是将字典解开成为独立的元素作为形参</font> </p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711232228890.png" alt="image-20220711232228890" style="zoom:50%;"></li><li><p>其次加载pytorch_model.bin文件</p><p>通过在<code>config_path</code>目录下寻找文件，命中了<code>pytorch_model.bin</code>这个pytorch的checkpoint文件</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711224750910.png" alt="image-20220711224750910"></p><p>找到这个文件后，这里做了一个和cache判断的操作，这个和huggingface这里实现可以到远程下载有关，如果过了这个函数后还是本地的路径，那就说明是用的本地的文件实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span></span><br><span class="line"><span class="comment"># Load from URL or cache if already cached</span></span><br><span class="line">resolved_archive_file = cached_path(</span><br><span class="line">    archive_file,</span><br><span class="line">    cache_dir=cache_dir,</span><br><span class="line">    force_download=force_download,</span><br><span class="line">    proxies=proxies,</span><br><span class="line">    resume_download=resume_download,</span><br><span class="line">    local_files_only=local_files_only,</span><br><span class="line">    use_auth_token=use_auth_token,</span><br><span class="line">    user_agent=user_agent,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为是pytorch形式的checkpoint，在这里<code>load_state_dict()</code></p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711233904281.png" alt="image-20220711233904281"></p><p>把<code>state_dict</code>传入这里，进一步进行处理，这里返回就会有<code>missing unexpect</code>这些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span></span><br><span class="line"><span class="keyword">elif</span> from_pt:</span><br><span class="line">    <span class="keyword">if</span> low_cpu_mem_usage:</span><br><span class="line">        cls._load_pretrained_model_low_mem(model, loaded_state_dict_keys, resolved_archive_file)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        model, missing_keys, unexpected_keys, mismatched_keys, error_msgs = cls._load_pretrained_model(</span><br><span class="line">            model,</span><br><span class="line">            state_dict,</span><br><span class="line">            resolved_archive_file,</span><br><span class="line">            pretrained_model_name_or_path,</span><br><span class="line">            ignore_mismatched_sizes=ignore_mismatched_sizes,</span><br><span class="line">            sharded_metadata=sharded_metadata,</span><br><span class="line">            _fast_init=_fast_init,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>在如下函数中完成比对操作，<strong>这里一些的输出错误经过<code>state_dict</code>的比对而发现，也就对应了“2.2.2节中，加载预训练model中第一部分，作者在开头给出的注解说明”</strong>，至此这两个文件</p><p><font color="blue"></font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_load_pretrained_model</span>(<span class="params"></span></span><br><span class="line"><span class="params">    cls,</span></span><br><span class="line"><span class="params">    model,</span></span><br><span class="line"><span class="params">    state_dict,</span></span><br><span class="line"><span class="params">    resolved_archive_file,</span></span><br><span class="line"><span class="params">    pretrained_model_name_or_path,</span></span><br><span class="line"><span class="params">    ignore_mismatched_sizes=<span class="literal">False</span>,</span></span><br><span class="line"><span class="params">    sharded_metadata=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">    _fast_init=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment"># Retrieve missing &amp; unexpected_keys</span></span><br><span class="line">    model_state_dict = model.state_dict()</span><br><span class="line">    expected_keys = <span class="built_in">list</span>(model_state_dict.keys())</span><br><span class="line">    loaded_keys = <span class="built_in">list</span>(state_dict.keys()) <span class="keyword">if</span> state_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> sharded_metadata[<span class="string">&quot;all_checkpoint_keys&quot;</span>]</span><br><span class="line">    prefix = model.base_model_prefix</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_fix_key</span>(<span class="params">key</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;beta&quot;</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> key.replace(<span class="string">&quot;beta&quot;</span>, <span class="string">&quot;bias&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;gamma&quot;</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> key.replace(<span class="string">&quot;gamma&quot;</span>, <span class="string">&quot;weight&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> key</span><br><span class="line"></span><br><span class="line">    loaded_keys = [_fix_key(key) <span class="keyword">for</span> key <span class="keyword">in</span> loaded_keys]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(prefix) &gt; <span class="number">0</span>:</span><br><span class="line">        has_prefix_module = <span class="built_in">any</span>(s.startswith(prefix) <span class="keyword">for</span> s <span class="keyword">in</span> loaded_keys)</span><br><span class="line">        expects_prefix_module = <span class="built_in">any</span>(s.startswith(prefix) <span class="keyword">for</span> s <span class="keyword">in</span> expected_keys)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        has_prefix_module = <span class="literal">False</span></span><br><span class="line">        expects_prefix_module = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># key re-naming operations are never done on the keys</span></span><br><span class="line">    <span class="comment"># that are loaded, but always on the keys of the newly initialized model</span></span><br><span class="line">    remove_prefix_from_model = <span class="keyword">not</span> has_prefix_module <span class="keyword">and</span> expects_prefix_module</span><br><span class="line">    add_prefix_to_model = has_prefix_module <span class="keyword">and</span> <span class="keyword">not</span> expects_prefix_module</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> remove_prefix_from_model:</span><br><span class="line">        expected_keys_not_prefixed = [s <span class="keyword">for</span> s <span class="keyword">in</span> expected_keys <span class="keyword">if</span> <span class="keyword">not</span> s.startswith(prefix)]</span><br><span class="line">        expected_keys = [<span class="string">&quot;.&quot;</span>.join(s.split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>:]) <span class="keyword">if</span> s.startswith(prefix) <span class="keyword">else</span> s <span class="keyword">for</span> s <span class="keyword">in</span> expected_keys]</span><br><span class="line">    <span class="keyword">elif</span> add_prefix_to_model:</span><br><span class="line">        expected_keys = [<span class="string">&quot;.&quot;</span>.join([prefix, s]) <span class="keyword">for</span> s <span class="keyword">in</span> expected_keys]</span><br><span class="line"></span><br><span class="line">    missing_keys = <span class="built_in">list</span>(<span class="built_in">set</span>(expected_keys) - <span class="built_in">set</span>(loaded_keys))</span><br><span class="line">    unexpected_keys = <span class="built_in">list</span>(<span class="built_in">set</span>(loaded_keys) - <span class="built_in">set</span>(expected_keys))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Some models may have keys that are not in the state by design, removing them before needlessly warning</span></span><br><span class="line">    <span class="comment"># the user.</span></span><br><span class="line">    <span class="keyword">if</span> cls._keys_to_ignore_on_load_missing <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> pat <span class="keyword">in</span> cls._keys_to_ignore_on_load_missing:</span><br><span class="line">            missing_keys = [k <span class="keyword">for</span> k <span class="keyword">in</span> missing_keys <span class="keyword">if</span> re.search(pat, k) <span class="keyword">is</span> <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> cls._keys_to_ignore_on_load_unexpected <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> pat <span class="keyword">in</span> cls._keys_to_ignore_on_load_unexpected:</span><br><span class="line">            unexpected_keys = [k <span class="keyword">for</span> k <span class="keyword">in</span> unexpected_keys <span class="keyword">if</span> re.search(pat, k) <span class="keyword">is</span> <span class="literal">None</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> _fast_init:</span><br><span class="line">        <span class="comment"># retrieve unintialized modules and initialize</span></span><br><span class="line">        uninitialized_modules = model.retrieve_modules_from_names(</span><br><span class="line">            missing_keys, add_prefix=add_prefix_to_model, remove_prefix=remove_prefix_from_model</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">for</span> module <span class="keyword">in</span> uninitialized_modules:</span><br><span class="line">            model._init_weights(module)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure we are able to load base models as well as derived models (with heads)</span></span><br><span class="line">    start_prefix = <span class="string">&quot;&quot;</span></span><br><span class="line">    model_to_load = model</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cls.base_model_prefix) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(model, cls.base_model_prefix) <span class="keyword">and</span> has_prefix_module:</span><br><span class="line">        start_prefix = cls.base_model_prefix + <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cls.base_model_prefix) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">hasattr</span>(model, cls.base_model_prefix) <span class="keyword">and</span> <span class="keyword">not</span> has_prefix_module:</span><br><span class="line">        model_to_load = <span class="built_in">getattr</span>(model, cls.base_model_prefix)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">any</span>(key <span class="keyword">in</span> expected_keys_not_prefixed <span class="keyword">for</span> key <span class="keyword">in</span> loaded_keys):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">&quot;The state dictionary of the model you are training to load is corrupted. Are you sure it was &quot;</span></span><br><span class="line">                <span class="string">&quot;properly saved?&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state_dict <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># Whole checkpoint</span></span><br><span class="line">        mismatched_keys = []</span><br><span class="line">        <span class="keyword">if</span> ignore_mismatched_sizes:</span><br><span class="line">            <span class="keyword">for</span> checkpoint_key <span class="keyword">in</span> loaded_keys:</span><br><span class="line">                model_key = checkpoint_key</span><br><span class="line">                <span class="keyword">if</span> remove_prefix_from_model:</span><br><span class="line">                    <span class="comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span></span><br><span class="line">                    model_key = <span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span>.<span class="subst">&#123;checkpoint_key&#125;</span>&quot;</span></span><br><span class="line">                <span class="keyword">elif</span> add_prefix_to_model:</span><br><span class="line">                    <span class="comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span></span><br><span class="line">                    model_key = <span class="string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    model_key <span class="keyword">in</span> model_state_dict</span><br><span class="line">                    <span class="keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape</span><br><span class="line">                ):</span><br><span class="line">                    mismatched_keys.append(</span><br><span class="line">                        (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)</span><br><span class="line">                    )</span><br><span class="line">                    <span class="keyword">del</span> state_dict[checkpoint_key]</span><br><span class="line"></span><br><span class="line">        error_msgs = _load_state_dict_into_model(model_to_load, state_dict, start_prefix)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Sharded checkpoint</span></span><br><span class="line">        <span class="comment"># This should always be a list but, just to be sure.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(resolved_archive_file, <span class="built_in">list</span>):</span><br><span class="line">            resolved_archive_file = [resolved_archive_file]</span><br><span class="line"></span><br><span class="line">        error_msgs = []</span><br><span class="line">        <span class="keyword">for</span> shard_file <span class="keyword">in</span> resolved_archive_file:</span><br><span class="line">            state_dict = load_state_dict(shard_file)</span><br><span class="line">            <span class="comment"># Mistmatched keys contains tuples key/shape1/shape2 of weights in the checkpoint that have a shape not</span></span><br><span class="line">            <span class="comment"># matching the weights in the model.</span></span><br><span class="line">            mismatched_keys = []</span><br><span class="line">            <span class="keyword">if</span> ignore_mismatched_sizes:</span><br><span class="line">                <span class="keyword">for</span> checkpoint_key <span class="keyword">in</span> loaded_keys:</span><br><span class="line">                    model_key = checkpoint_key</span><br><span class="line">                    <span class="keyword">if</span> remove_prefix_from_model:</span><br><span class="line">                        <span class="comment"># The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it.</span></span><br><span class="line">                        model_key = <span class="string">f&quot;<span class="subst">&#123;prefix&#125;</span>.<span class="subst">&#123;checkpoint_key&#125;</span>&quot;</span></span><br><span class="line">                    <span class="keyword">elif</span> add_prefix_to_model:</span><br><span class="line">                        <span class="comment"># The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it.</span></span><br><span class="line">                        model_key = <span class="string">&quot;.&quot;</span>.join(checkpoint_key.split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        model_key <span class="keyword">in</span> model_state_dict</span><br><span class="line">                        <span class="keyword">and</span> state_dict[checkpoint_key].shape != model_state_dict[model_key].shape</span><br><span class="line">                    ):</span><br><span class="line">                        mismatched_keys.append(</span><br><span class="line">                            (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape)</span><br><span class="line">                        )</span><br><span class="line">                        <span class="keyword">del</span> state_dict[checkpoint_key]</span><br><span class="line"></span><br><span class="line">            error_msgs += _load_state_dict_into_model(model_to_load, state_dict, start_prefix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(error_msgs) &gt; <span class="number">0</span>:</span><br><span class="line">        error_msg = <span class="string">&quot;\n\t&quot;</span>.join(error_msgs)</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;Error(s) in loading state_dict for <span class="subst">&#123;model.__class__.__name__&#125;</span>:\n\t<span class="subst">&#123;error_msg&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(unexpected_keys) &gt; <span class="number">0</span>:</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;Some weights of the model checkpoint at <span class="subst">&#123;pretrained_model_name_or_path&#125;</span> were not used when &quot;</span></span><br><span class="line">            <span class="string">f&quot;initializing <span class="subst">&#123;model.__class__.__name__&#125;</span>: <span class="subst">&#123;unexpected_keys&#125;</span>\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;- This IS expected if you are initializing <span class="subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model trained on another task &quot;</span></span><br><span class="line">            <span class="string">f&quot;or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;- This IS NOT expected if you are initializing <span class="subst">&#123;model.__class__.__name__&#125;</span> from the checkpoint of a model that you expect &quot;</span></span><br><span class="line">            <span class="string">f&quot;to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        logger.info(<span class="string">f&quot;All model checkpoint weights were used when initializing <span class="subst">&#123;model.__class__.__name__&#125;</span>.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(missing_keys) &gt; <span class="number">0</span>:</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;Some weights of <span class="subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span></span><br><span class="line">            <span class="string">f&quot;and are newly initialized: <span class="subst">&#123;missing_keys&#125;</span>\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(mismatched_keys) == <span class="number">0</span>:</span><br><span class="line">        logger.info(</span><br><span class="line">            <span class="string">f&quot;All the weights of <span class="subst">&#123;model.__class__.__name__&#125;</span> were initialized from the model checkpoint at <span class="subst">&#123;pretrained_model_name_or_path&#125;</span>.\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;If your task is similar to the task the model of the checkpoint was trained on, &quot;</span></span><br><span class="line">            <span class="string">f&quot;you can already use <span class="subst">&#123;model.__class__.__name__&#125;</span> for predictions without further training.&quot;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(mismatched_keys) &gt; <span class="number">0</span>:</span><br><span class="line">        mismatched_warning = <span class="string">&quot;\n&quot;</span>.join(</span><br><span class="line">            [</span><br><span class="line">                <span class="string">f&quot;- <span class="subst">&#123;key&#125;</span>: found shape <span class="subst">&#123;shape1&#125;</span> in the checkpoint and <span class="subst">&#123;shape2&#125;</span> in the model instantiated&quot;</span></span><br><span class="line">                <span class="keyword">for</span> key, shape1, shape2 <span class="keyword">in</span> mismatched_keys</span><br><span class="line">            ]</span><br><span class="line">        )</span><br><span class="line">        logger.warning(</span><br><span class="line">            <span class="string">f&quot;Some weights of <span class="subst">&#123;model.__class__.__name__&#125;</span> were not initialized from the model checkpoint at <span class="subst">&#123;pretrained_model_name_or_path&#125;</span> &quot;</span></span><br><span class="line">            <span class="string">f&quot;and are newly initialized because the shapes did not match:\n<span class="subst">&#123;mismatched_warning&#125;</span>\n&quot;</span></span><br><span class="line">            <span class="string">f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> model, missing_keys, unexpected_keys, mismatched_keys, error_msgs</span><br></pre></td></tr></table></figure></li></ul><h6 id="4-额外补充"><a href="#4-额外补充" class="headerlink" title="4) 额外补充"></a>4) 额外补充</h6><p>应该是这里的实例化把config给model传进去了，于是model需要的key可能少于、或者多于提供给他的key（pytorch_model.bin）,这里是一个<code>super().__init__()</code>，可能是调用到<code>nn.Module</code>这个上层了，然后依据传入的config不知道怎么操作，把层数什么的网络结构给拼上了；<font color="red">另：也有可能是要加载到这个/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py里面的BertModel类，这样BertModel类是super代表的上层？</font> </p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712001457966.png" alt="image-20220712001457966"></p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712001307673.png" alt="image-20220712001307673"></p><h5 id="·-通过config加载空模型并设置seed"><a href="#·-通过config加载空模型并设置seed" class="headerlink" title="· 通过config加载空模型并设置seed"></a>· 通过config加载空模型并设置seed</h5><p>如果是没有from_pretrained，而是通过<code>model = BertModel()</code>加载空模型的话，打印会看到初始化的参数，如下所示（另外注意，这种不从预训练文件中读取的话，需要加载config参数）：<br><font color="blue">BertConfig、BertModel、BertTokenizer</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 空模型加载版本</span></span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> BertTokenizer, BertModel, BertConfig</span><br><span class="line">config = BertConfig()</span><br><span class="line">model = BertModel(config)</span><br></pre></td></tr></table></figure><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711141742912.png" alt="image-20220711141742912"></p><p>这里如果再次尝试加载空模型的时候，因为参数是随机初始化的，所以参数初始化结果可能有所不同，如下图所示</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220711142519040.png" alt="image-20220711142519040"></p><p>通过set_seed进行指定，可以保证每次加载空模型时初始化的参数是一样的，set_seed的代码段如下，（实际使用上来说其实不一定需要写成这种函数的方式，直接写个几行就可以）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">setup_seed</span>(<span class="params">seed</span>):</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    torch.cuda.manual_seed_all(seed)</span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    random.seed(seed)</span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">setup_seed(<span class="number">42</span>)  <span class="comment"># 设置随机数种子</span></span><br></pre></td></tr></table></figure><p><font color="red">这个地方加载config的时候直接用到的是config = BertConfig()，也就是BertConfig类中的内容，对这里进行了一下详细的调试，目前的理解是他实现了一个BertConfig类，继承自PretrainedConfig这个大类。平常在fine-tune阶段直接用到的config.json文件应该是从这个BertConfig保存而来的；；；如果要是自己训练的话，可能可以实现一个新的<strong>XxxConfig</strong>类，然后内部把参数什么的都设置为自己想要的，比如层数减少一些什么的</font> </p><blockquote><p>/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/configuration_bert.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BertConfig</span>(<span class="title class_ inherited__">PretrainedConfig</span>):</span><br><span class="line">  ...</span><br><span class="line">    model_type = <span class="string">&quot;bert&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        vocab_size=<span class="number">30522</span>,</span></span><br><span class="line"><span class="params">        hidden_size=<span class="number">768</span>,</span></span><br><span class="line"><span class="params">        num_hidden_layers=<span class="number">12</span>,</span></span><br><span class="line"><span class="params">        num_attention_heads=<span class="number">12</span>,</span></span><br><span class="line"><span class="params">        intermediate_size=<span class="number">3072</span>,</span></span><br><span class="line"><span class="params">        hidden_act=<span class="string">&quot;gelu&quot;</span>,</span></span><br><span class="line"><span class="params">        hidden_dropout_prob=<span class="number">0.1</span>,</span></span><br><span class="line"><span class="params">        attention_probs_dropout_prob=<span class="number">0.1</span>,</span></span><br><span class="line"><span class="params">        max_position_embeddings=<span class="number">512</span>,</span></span><br><span class="line"><span class="params">        type_vocab_size=<span class="number">2</span>,</span></span><br><span class="line"><span class="params">        initializer_range=<span class="number">0.02</span>,</span></span><br><span class="line"><span class="params">        layer_norm_eps=<span class="number">1e-12</span>,</span></span><br><span class="line"><span class="params">        pad_token_id=<span class="number">0</span>,</span></span><br><span class="line"><span class="params">        position_embedding_type=<span class="string">&quot;absolute&quot;</span>,</span></span><br><span class="line"><span class="params">        use_cache=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        classifier_dropout=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        **kwargs</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(pad_token_id=pad_token_id, **kwargs)</span><br><span class="line"></span><br><span class="line">        self.vocab_size = vocab_size</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.num_hidden_layers = num_hidden_layers</span><br><span class="line">        self.num_attention_heads = num_attention_heads</span><br><span class="line">        self.hidden_act = hidden_act</span><br><span class="line">        self.intermediate_size = intermediate_size</span><br><span class="line">        self.hidden_dropout_prob = hidden_dropout_prob</span><br><span class="line">        self.attention_probs_dropout_prob = attention_probs_dropout_prob</span><br><span class="line">        self.max_position_embeddings = max_position_embeddings</span><br><span class="line">        self.type_vocab_size = type_vocab_size</span><br><span class="line">        self.initializer_range = initializer_range</span><br><span class="line">        self.layer_norm_eps = layer_norm_eps</span><br><span class="line">        self.position_embedding_type = position_embedding_type</span><br><span class="line">        self.use_cache = use_cache</span><br><span class="line">        self.classifier_dropout = classifier_dropout</span><br></pre></td></tr></table></figure><h5 id="·-保存模型"><a href="#·-保存模型" class="headerlink" title="· 保存模型"></a>· 保存模型</h5><p>通过如下命令可以完成一个模型的保存，这样会在目录下生成<strong>config.json</strong>、<strong>pytorch_model.bin</strong>这两个文件，结合上面的BertConfig，如果有一个自己的模型的话，就可以魔改一下那边的XxxConfig，比如减小一些层数训练什么的，下次通过from_pretrained应该就可以加载回来了；；；这里也要集合下上面那个<strong>加载预训练model</strong>来一起看；；；</p><p><font color="red">或者说，这套BertConfig和<code>from transformers.models.bert import modeling_bert </code>那边的bert模型是对应的，只要修改BertConfig这些参数就可以制作自己的bert了，比如可能有BertTiny，或者其他版本的，都可以通过Bert这边的pipeline来走这样一个流程</font> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.save_pretrained(<span class="string">&quot;directory_on_my_computer&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-3-tokenizer"><a href="#2-3-tokenizer" class="headerlink" title="2.3 tokenizer"></a>2.3 tokenizer</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = BertTokenizer(&quot;./bert_base_uncased/vocab.txt&quot;)</span><br></pre></td></tr></table></figure><p>tokenizer的from_pretrain在这里</p><blockquote><p>/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/tokenization_utils_base.py</p></blockquote><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712122136461.png" alt="image-20220712122136461"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">from_pretrained</span>(<span class="params">cls, pretrained_model_name_or_path: <span class="type">Union</span>[<span class="built_in">str</span>, os.PathLike], *init_inputs, **kwargs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里省略了一些类似于本地没读到就远程下载的操作，绥中得到一个resolved_vocab_files文件向_from_pretrained传递</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls._from_pretrained(</span><br><span class="line">      resolved_vocab_files,</span><br><span class="line">      pretrained_model_name_or_path,</span><br><span class="line">      init_configuration,</span><br><span class="line">      *init_inputs,</span><br><span class="line">      use_auth_token=use_auth_token,</span><br><span class="line">      cache_dir=cache_dir,</span><br><span class="line">      **kwargs,</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><font color="red">TODO：这里是不是还有些加入特殊token的操作，曾经在一些论文代码里见过</font> </p><p>tokenizer的作用就是把一句话按照vocab中转成一个id那个感觉，tokenizer.tokenize、tokenizer.convert_tokens_to_ids()和其反向的tokenizer_convert_ids_to_tokens比较常用；</p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712123154538.png" alt="image-20220712123154538"></p><h2 id="3-Transformer-amp-BERT论文阅读中的重点记录"><a href="#3-Transformer-amp-BERT论文阅读中的重点记录" class="headerlink" title="3. Transformer&amp;BERT论文阅读中的重点记录"></a>3. Transformer&amp;BERT论文阅读中的重点记录</h2><h3 id="3-1-Attention-is-all-you-need"><a href="#3-1-Attention-is-all-you-need" class="headerlink" title="3.1 Attention is all you need"></a>3.1 Attention is all you need</h3><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214108979.png" alt="image-20220712214108979"></p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214133925.png" alt="image-20220712214133925"></p><p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214114211.png" alt="image-20220712214114211"></p><img src="/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/image-20220712214155672.png" alt="image-20220712214155672" style="zoom:50%;"><p>就是那个指数，如果有一个特别大的，他softmax算出来就很趋向于1了</p><p>这个现象会随着指数的增大而明显，比如指数是3的时候，就不明显，指数是20的时候就很明显</p><h3 id="3-2-BERT"><a href="#3-2-BERT" class="headerlink" title="3.2 BERT"></a>3.2 BERT</h3><p>TODO</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>服务器连接github与token的配置</title>
    <link href="http://example.com/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-18T08:23:08.000Z</published>
    <updated>2022-11-20T01:50:08.892Z</updated>
    
    <content type="html"><![CDATA[<p>有时候换了常用的git开发环境，在一个新环境上<code>git clone</code>，<code>git push</code>项目的时候，需要重新输入用户名和密码（token）</p><p>在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存</p><span id="more"></span><h1 id="服务器连接github与token配置"><a href="#服务器连接github与token配置" class="headerlink" title="服务器连接github与token配置"></a>服务器连接github与token配置</h1><h2 id="1-操作"><a href="#1-操作" class="headerlink" title="1. 操作"></a>1. 操作</h2><p>在github头像 -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens -&gt; Generate new token</p><p>这里生成一个新的token，clone等操作的时候用这个token就可以</p><p><img src="/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/2022-11-18-16-42-36.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时候换了常用的git开发环境，在一个新环境上&lt;code&gt;git clone&lt;/code&gt;，&lt;code&gt;git push&lt;/code&gt;项目的时候，需要重新输入用户名和密码（token）&lt;/p&gt;
&lt;p&gt;在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存&lt;/p&gt;</summary>
    
    
    
    <category term="Crsenal" scheme="http://example.com/categories/Crsenal/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>295场LeetCode周赛</title>
    <link href="http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-06-19T09:42:21.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1299)+t2(1577)；</p><p>这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧；</p><p>第一题：简单字典计数；</p><p>第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>第三题：咕咕QAQ；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2287-重排字符形成目标字符串【难度：1299】"><a href="#第一题：2287-重排字符形成目标字符串【难度：1299】" class="headerlink" title="第一题：2287.重排字符形成目标字符串【难度：1299】"></a>第一题：2287.重排字符形成目标字符串【难度：1299】</h1><p><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 <code>s</code> 取出一些字符并将其重排，得到若干新的字符串。</p><p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 <strong>最大</strong> 副本数。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ilovecodingonleetcode&quot;, target = &quot;code&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">对于 &quot;code&quot; 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。</span><br><span class="line">对于 &quot;code&quot; 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。</span><br><span class="line">形成的字符串分别是 &quot;ecod&quot; 和 &quot;code&quot; ，都可以重排为 &quot;code&quot; 。</span><br><span class="line">可以形成最多 2 个 &quot;code&quot; 的副本，所以返回 2 。</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcba&quot;, target = &quot;abc&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">选取下标为 0 、1 和 2 的字符，可以形成 &quot;abc&quot; 的 1 个副本。 </span><br><span class="line">可以形成最多 1 个 &quot;abc&quot; 的副本，所以返回 1 。</span><br><span class="line">注意，尽管下标 3 和 4 分别有额外的 &#x27;a&#x27; 和 &#x27;b&#x27; ，但不能重用下标 2 处的 &#x27;c&#x27; ，所以无法形成 &quot;abc&quot; 的第 2 个副本。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abbaccaddaeea&quot;, target = &quot;aaaaa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 &quot;aaaaa&quot; 的 1 个副本。</span><br><span class="line">可以形成最多 1 个 &quot;aaaaa&quot; 的副本，所以返回 1 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= target.length &lt;= 10</code></li><li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>简单字典计数；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rearrangeCharacters</span>(<span class="params">self, s, target</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type target: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt_s = Counter(s)</span><br><span class="line">        cnt_target = Counter(target)</span><br><span class="line">        </span><br><span class="line">        res = <span class="number">1e9</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> cnt_target.items():</span><br><span class="line">            res = <span class="built_in">min</span>(res, cnt_s[key]//value)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第二题：2288-价格减免【难度：1577】"><a href="#第二题：2288-价格减免【难度：1577】" class="headerlink" title="第二题：2288.价格减免【难度：1577】"></a>第二题：2288.价格减免【难度：1577】</h1><p><a href="https://leetcode.cn/problems/apply-discount-to-prices/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 <code>&#39;$&#39;</code> 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。</p><ul><li>例如 <code>&quot;$100&quot;</code>、<code>&quot;$23&quot;</code> 和 <code>&quot;$6.75&quot;</code> 表示价格，而 <code>&quot;100&quot;</code>、<code>&quot;$&quot;</code> 和 <code>&quot;2$3&quot;</code> 不是。</li></ul><p><strong>注意</strong>：本题输入中的价格均为整数。</p><p>给你一个字符串 <code>sentence</code>  和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 <strong>更新</strong> 该单词到句子中。所有更新后的价格应该表示为一个 <strong>恰好保留小数点后两位</strong> 的数字。</p><p>返回表示修改后句子的字符串。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = &quot;there are $1 $2 and 5$ candies in the shop&quot;, discount = 50</span><br><span class="line">输出：&quot;there are $0.50 $1.00 and 5$ candies in the shop&quot;</span><br><span class="line">解释：</span><br><span class="line">表示价格的单词是 &quot;$1&quot; 和 &quot;$2&quot; 。 </span><br><span class="line">- &quot;$1&quot; 减免 50% 为 &quot;$0.50&quot; ，所以 &quot;$1&quot; 替换为 &quot;$0.50&quot; 。</span><br><span class="line">- &quot;$2&quot; 减免 50% 为 &quot;$1&quot; ，所以 &quot;$1&quot; 替换为 &quot;$1.00&quot; 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = &quot;1 2 $3 4 $5 $6 7 8$ $9 $10$&quot;, discount = 100</span><br><span class="line">输出：&quot;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$&quot;</span><br><span class="line">解释：</span><br><span class="line">任何价格减免 100% 都会得到 0 。</span><br><span class="line">表示价格的单词分别是 &quot;$3&quot;、&quot;$5&quot;、&quot;$6&quot; 和 &quot;$9&quot;。</span><br><span class="line">每个单词都替换为 &quot;$0.00&quot;。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 10^5</code></li><li><code>sentence</code> 由小写英文字母、数字、<code>&#39; &#39;</code> 和 <code>&#39;$&#39;</code> 组成</li><li><code>sentence</code> 不含前导和尾随空格</li><li><code>sentence</code> 的所有单词都用单个空格分隔</li><li>所有价格都是 <strong>正</strong> 整数且不含前导零</li><li>所有价格 <strong>最多</strong> 为  <code>10</code> 位数字</li><li><code>0 &lt;= discount &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；</p><p>P.S. 借这个题想说好讨厌这种描述又长，又带着小数的题啊，感觉不像是正路的题目；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">discountPrices</span>(<span class="params">self, sentence, discount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type sentence: str</span></span><br><span class="line"><span class="string">        :type discount: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        tmp_list = sentence.split()</span><br><span class="line">        res_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp_list)):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> tmp_list[i][<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    tmp = <span class="built_in">int</span>(tmp_list[i][<span class="number">1</span>:])</span><br><span class="line">                    tmp = tmp - (tmp * discount * <span class="number">1.0</span> /<span class="number">100</span>)</span><br><span class="line">                    tmp = <span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(tmp)</span><br><span class="line">                    tmp = <span class="string">&#x27;$&#x27;</span> + tmp</span><br><span class="line">                    res_list.append(tmp)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    res_list.append(tmp_list[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res_list.append(tmp_list[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(res_list)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;题目难度：t1(1299)+t2(1577)；&lt;/p&gt;
&lt;p&gt;这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧；&lt;/p&gt;
&lt;p&gt;第一题：简单字典计数；&lt;/p&gt;
&lt;p&gt;第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。；&lt;/p&gt;
&lt;p&gt;第三题：咕咕QAQ；&lt;/p&gt;
&lt;p&gt;第四题：咕咕QAQ；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="计数" scheme="http://example.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>296场LeetCode周赛</title>
    <link href="http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-06-19T08:56:36.000Z</published>
    <updated>2022-11-20T01:50:08.888Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1241)+t2(1416)+t3(1445)；</p><p>难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟/贪心就可以完成了；</p><p>第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><p>第二题：排序后贪心，维护一个组内的最大最小值；</p><p>第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2293-极大极小游戏【难度：1241】"><a href="#第一题：2293-极大极小游戏【难度：1241】" class="headerlink" title="第一题：2293.极大极小游戏【难度：1241】"></a>第一题：2293.极大极小游戏【难度：1241】</h1><p><a href="https://leetcode.cn/problems/min-max-game/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p><p>对 <code>nums</code> 执行下述算法：</p><ol><li>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1</code> ，<strong>终止</strong> 算法过程。否则，<strong>创建</strong> 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <strong>0</strong> 开始。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>偶数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>min(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>对于满足 <code>0 &lt;= i &lt; n / 2</code> 的每个 <strong>奇数</strong> 下标 <code>i</code> ，将 <code>newNums[i]</code> <strong>赋值</strong> 为 <code>max(nums[2 * i], nums[2 * i + 1])</code> 。</li><li>用 <code>newNums</code> 替换 <code>nums</code> 。</li><li>从步骤 1 开始 <strong>重复</strong> 整个过程。</li></ol><p>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</p><p>示例1：</p><p><img src="/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-06-19-17-05-41.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,5,2,4,8,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：重复执行算法会得到下述数组。</span><br><span class="line">第一轮：nums = [1,5,4,2]</span><br><span class="line">第二轮：nums = [1,4]</span><br><span class="line">第三轮：nums = [1]</span><br><span class="line">1 是最后剩下的那个数字，返回 1 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 就是最后剩下的数字，返回 3 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1024</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums.length</code> 是 <code>2</code> 的幂</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMaxGame</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            tmp = []</span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums), <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> idx % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    tmp.append(<span class="built_in">min</span>(nums[i], nums[i+<span class="number">1</span>]))</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(<span class="built_in">max</span>(nums[i], nums[i+<span class="number">1</span>]))</span><br><span class="line">                    idx += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(tmp)</span></span><br><span class="line">            nums = copy.deepcopy(tmp)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(tmp)</span></span><br><span class="line">        <span class="keyword">return</span> tmp[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h1 id="第二题：2294-划分数组使最大差为-K【难度：1416】"><a href="#第二题：2294-划分数组使最大差为-K【难度：1416】" class="headerlink" title="第二题：2294.划分数组使最大差为 K【难度：1416】"></a>第二题：2294.划分数组使最大差为 K【难度：1416】</h1><p><a href="https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 <strong>子序列</strong> ，使 <code>nums</code> 中的每个元素都 <strong>恰好</strong> 出现在一个子序列中。</p><p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 <strong>最少</strong> 子序列数目。</p><p><strong>子序列</strong> 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,6,1,2,5], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。</span><br><span class="line">由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为两个子序列 [1,2] 和 [3] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。</span><br><span class="line">由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,4,5], k = 0</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。</span><br><span class="line">第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。</span><br><span class="line">由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>排序后贪心，维护一个组内的最大最小值；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionArray</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line"> </span><br><span class="line">        now_min = nums[<span class="number">0</span>]</span><br><span class="line">        now_max = nums[<span class="number">0</span>]</span><br><span class="line">        tmp = [nums[<span class="number">0</span>]]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            now_min = <span class="built_in">min</span>(now_min, nums[i])</span><br><span class="line">            now_max = <span class="built_in">max</span>(now_max, nums[i])</span><br><span class="line">            chazhi = <span class="built_in">abs</span>(now_max-now_min)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> chazhi &lt;= k:</span><br><span class="line">                tmp.append(nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(tmp)</span><br><span class="line">                tmp = [nums[i]]</span><br><span class="line">                now_min = nums[i]</span><br><span class="line">                now_max = nums[i]</span><br><span class="line">        </span><br><span class="line">        res.append(tmp)</span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></figure><h1 id="第三题：2295-替换数组中的元素【难度：1445】"><a href="#第三题：2295-替换数组中的元素【难度：1445】" class="headerlink" title="第三题：2295.替换数组中的元素【难度：1445】"></a>第三题：2295.替换数组中的元素【难度：1445】</h1><p><a href="https://leetcode.cn/problems/replace-elements-in-an-array/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，它包含 <code>n</code> 个 <strong>互不相同</strong> 的正整数。请你对这个数组执行 <code>m</code> 个操作，在第 <code>i</code> 个操作中，你需要将数字 <code>operations[i][0]</code> 替换成 <code>operations[i][1]</code> 。</p><p>题目保证在第 <code>i</code> 个操作中：</p><ul><li><code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li><code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><p>请你返回执行完所有操作后的数组。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]</span><br><span class="line">输出：[3,2,7,1]</span><br><span class="line">解释：我们对 nums 执行以下操作：</span><br><span class="line">- 将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。</span><br><span class="line">- 将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。</span><br><span class="line">- 将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。</span><br><span class="line">返回最终数组 [3,2,7,1] 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]]</span><br><span class="line">输出：[2,1]</span><br><span class="line">解释：我们对 nums 执行以下操作：</span><br><span class="line">- 将数字 1 替换为 3 。nums 变为 [3,2] 。</span><br><span class="line">- 将数字 2 替换为 1 。nums 变为 [3,1] 。</span><br><span class="line">- 将数字 3 替换为 2 。nums 变为 [2,1] 。</span><br><span class="line">返回最终数组 [2,1] 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>m == operations.length</code></li><li><code>1 &lt;= n, m &lt;= 10^5</code></li><li><code>nums</code> 中所有数字 <strong>互不相同</strong> 。</li><li><code>operations[i].length == 2</code></li><li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10^6</code></li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li><li>在执行第 <code>i</code> 个操作时，<code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">arrayChange</span>(<span class="params">self, nums, operations</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type operations: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            d[nums[i]] = [nums[i], nums[i], i]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(d)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(operations)):</span><br><span class="line">            old, new = operations[i][<span class="number">0</span>], operations[i][<span class="number">1</span>]</span><br><span class="line">            tmp_list = d[old]</span><br><span class="line">            </span><br><span class="line">            d[old] = [new, tmp_list[<span class="number">1</span>], tmp_list[<span class="number">2</span>]]</span><br><span class="line">            d[new] = d[old]</span><br><span class="line">            <span class="keyword">del</span> d[old]</span><br><span class="line">        </span><br><span class="line">        tmp_res = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            tmp_res.append([value[<span class="number">0</span>], value[<span class="number">2</span>]])</span><br><span class="line">        tmp_res.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># print(tmp_res)</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp_res)):</span><br><span class="line">            res.append(tmp_res[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;题目难度：t1(1241)+t2(1416)+t3(1445)；&lt;/p&gt;
&lt;p&gt;难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟/贪心就可以完成了；&lt;/p&gt;
&lt;p&gt;第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环；&lt;/p&gt;
&lt;p&gt;第二题：排序后贪心，维护一个组内的最大最小值；&lt;/p&gt;
&lt;p&gt;第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化；&lt;/p&gt;
&lt;p&gt;第四题：咕咕QAQ；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>297场LeetCode周赛</title>
    <link href="http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-06-19T07:54:36.000Z</published>
    <updated>2022-11-20T01:50:08.888Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1283)+t2(1658)+t3(1886)；</p><p>这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧；</p><p>第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><p>第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><p>第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2303-计算应缴税款总额【难度：1283】"><a href="#第一题：2303-计算应缴税款总额【难度：1283】" class="headerlink" title="第一题：2303.计算应缴税款总额【难度：1283】"></a>第一题：2303.计算应缴税款总额【难度：1283】</h1><p><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 <strong>从低到高排序</strong>（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p><p>税款计算方式如下：</p><ul><li>不超过 <code>upper0</code> 的收入按税率 <code>percent0</code> 缴纳</li><li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li><li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳</li><li>以此类推</li></ul><p>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10^-5</code> 的结果将被视作正确答案。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：brackets = [[3,50],[7,10],[12,25]], income = 10</span><br><span class="line">输出：2.65000</span><br><span class="line">解释：</span><br><span class="line">前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。</span><br><span class="line">接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。</span><br><span class="line">最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。</span><br><span class="line">需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：brackets = [[1,0],[4,25],[5,50]], income = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：</span><br><span class="line">前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。</span><br><span class="line">剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。</span><br><span class="line">需要支付的税款总计 $0 + $0.25 = $0.25 。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：brackets = [[2,50]], income = 0</span><br><span class="line">输出：0.00000</span><br><span class="line">解释：</span><br><span class="line">没有收入，无需纳税，需要支付的税款总计 $0 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= brackets.length &lt;= 100</code></li><li><code>1 &lt;= upperi &lt;= 1000</code></li><li><code>0 &lt;= percenti &lt;= 100</code></li><li><code>0 &lt;= income &lt;= 1000</code></li><li><code>upperi</code> 按递增顺序排列</li><li><code>upperi</code> 中的所有值 互不相同</li><li>最后一个税级的上限大于等于 <code>income</code></li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculateTax</span>(<span class="params">self, brackets, income</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type brackets: List[List[int]]</span></span><br><span class="line"><span class="string">        :type income: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(brackets)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            brackets[i][<span class="number">0</span>] = brackets[i][<span class="number">0</span>] - brackets[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># print(brackets)</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(brackets)):</span><br><span class="line">            <span class="keyword">if</span> income &gt;= brackets[i][<span class="number">0</span>]:</span><br><span class="line">                res +=  ((brackets[i][<span class="number">0</span>] * brackets[i][<span class="number">1</span>] * <span class="number">1.0</span>) / <span class="number">100</span>)</span><br><span class="line">                income -= brackets[i][<span class="number">0</span>]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                </span><br><span class="line">                res +=  ((income * brackets[i][<span class="number">1</span>] * <span class="number">1.0</span>) / <span class="number">100</span>)</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第二题：2304-网格中的最小路径代价【难度：1658】"><a href="#第二题：2304-网格中的最小路径代价【难度：1658】" class="headerlink" title="第二题：2304.网格中的最小路径代价【难度：1658】"></a>第二题：2304.网格中的最小路径代价【难度：1658】</h1><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 <strong>下一行</strong> 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1)</code> 中的任何一个单元格。<strong>注意</strong>： 在最后一行中的单元格不能触发移动。</p><p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <strong>0</strong> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p><p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 <strong>值之和</strong> 加上 所有移动的 <strong>代价之和</strong> 。从 <strong>第一行</strong> 任意单元格出发，返回到达 <strong>最后一行</strong> 任意单元格的最小路径代价。</p><p>示例1：</p><p><img src="/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-06-19-16-46-14.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</span><br><span class="line">输出：17</span><br><span class="line">解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。</span><br><span class="line">- 路径途经单元格值之和 5 + 0 + 1 = 6 。</span><br><span class="line">- 从 5 移动到 0 的代价为 3 。</span><br><span class="line">- 从 0 移动到 1 的代价为 8 。</span><br><span class="line">路径总代价为 6 + 3 + 8 = 17 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">最小代价的路径是 2 -&gt; 3 。 </span><br><span class="line">- 路径途经单元格值之和 2 + 3 = 5 。 </span><br><span class="line">- 从 2 移动到 3 的代价为 1 。 </span><br><span class="line">路径总代价为 5 + 1 = 6 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li><li><code>moveCost.length == m * n</code></li><li><code>moveCost[i].length == n</code></li><li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathCost</span>(<span class="params">self, grid, moveCost</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :type moveCost: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        base = grid[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):  <span class="comment"># 遍历m行</span></span><br><span class="line">            new_base = [<span class="number">1e99</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  <span class="comment"># n个</span></span><br><span class="line">            <span class="comment"># 下面是一个从当前n个状态（base，用j代表）到下n个状态（用k表示）的转移，从上一行的n个转移到下一行的n个，每个地方取最优的dp</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    new_base[k] = <span class="built_in">min</span>(new_base[k], base[j]+grid[i][k]+moveCost[grid[i-<span class="number">1</span>][j]][k])  <span class="comment"># 选一个所有状态转移里最小的</span></span><br><span class="line">            </span><br><span class="line">            base = new_base</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(base)</span><br></pre></td></tr></table></figure><h1 id="第三题：2305-公平分发饼干【难度：1886】"><a href="#第三题：2305-公平分发饼干【难度：1886】" class="headerlink" title="第三题：2305.公平分发饼干【难度：1886】"></a>第三题：2305.公平分发饼干【难度：1886】</h1><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，<strong>所有</strong> 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p><p>分发的 <strong>不公平程度</strong> 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p><p>返回所有分发的最小不公平程度。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：cookies = [8,15,10,20,8], k = 2</span><br><span class="line">输出：31</span><br><span class="line">解释：一种最优方案是 [8,15,8] 和 [10,20] 。</span><br><span class="line">- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。</span><br><span class="line">- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。</span><br><span class="line">分发的不公平程度为 max(31,30) = 31 。</span><br><span class="line">可以证明不存在不公平程度小于 31 的分发方案。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：cookies = [6,1,3,2,2,4,1,2], k = 3</span><br><span class="line">输出：7</span><br><span class="line">解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。</span><br><span class="line">- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 </span><br><span class="line">- 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。</span><br><span class="line">- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。</span><br><span class="line">分发的不公平程度为 max(7,7,7) = 7 。</span><br><span class="line">可以证明不存在不公平程度小于 7 的分发方案。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= cookies.length &lt;= 8</code></li><li><code>1 &lt;= cookies[i] &lt;= 10^5</code></li><li><code>2 &lt;= k &lt;= cookies.length</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 超时解法27/36</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">distributeCookies</span>(<span class="params">self, cookies, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cookies: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">1e99</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">n, x, padding_len</span>):</span><br><span class="line">            <span class="comment">#n为待转换的十进制数，x为机制，取值为2-16</span></span><br><span class="line">            a=[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;F&#x27;</span>]</span><br><span class="line">            b=[]</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                s=n//x  <span class="comment"># 商</span></span><br><span class="line">                y=n%x  <span class="comment"># 余数</span></span><br><span class="line">                b=b+[y]</span><br><span class="line">                <span class="keyword">if</span> s==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                n=s</span><br><span class="line">            b.reverse()</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">                tmp.append(a[i])</span><br><span class="line">            <span class="keyword">return</span> tmp + [<span class="number">0</span>] * (padding_len - <span class="built_in">len</span>(tmp))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k**<span class="built_in">len</span>(cookies)):</span><br><span class="line">            tmp = f(i, k, <span class="built_in">len</span>(cookies))</span><br><span class="line">            d = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">            tmp_max = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">                d[tmp[i]] += cookies[i]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># print(d)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(d) != k:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_max = <span class="built_in">max</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> d.values()])</span><br><span class="line"></span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp_max)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;题目难度：t1(1283)+t2(1658)+t3(1886)；&lt;/p&gt;
&lt;p&gt;这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧；&lt;/p&gt;
&lt;p&gt;第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来；&lt;/p&gt;
&lt;p&gt;第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉；&lt;/p&gt;
&lt;p&gt;第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对；&lt;/p&gt;
&lt;p&gt;第四题：咕咕QAQ；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="矩阵" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="状态压缩" scheme="http://example.com/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>298场LeetCode周赛</title>
    <link href="http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-06-19T06:58:33.000Z</published>
    <updated>2022-11-20T01:50:08.888Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>题目难度：t1(1427)+t2(1646)+t3(1871)；</p><p>近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧；</p><p>第一题：小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><p>第二题：思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><p>第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：5242-兼具大小写的最好英文字母【难度：1427】"><a href="#第一题：5242-兼具大小写的最好英文字母【难度：1427】" class="headerlink" title="第一题：5242.兼具大小写的最好英文字母【难度：1427】"></a>第一题：5242.兼具大小写的最好英文字母【难度：1427】</h1><p><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 <strong>最好</strong> 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p><p><strong>最好</strong> 英文字母的大写和小写形式必须 <strong>都</strong> 在 <code>s</code> 中出现。</p><p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> 更好 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 后 出现。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;lEeTcOdE&quot;</span><br><span class="line">输出：&quot;E&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;arRAzFif&quot;</span><br><span class="line">输出：&quot;R&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。</span><br><span class="line">注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AbCdEfGhIjK&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：</span><br><span class="line">不存在大写和小写形式都出现的字母。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 由小写和大写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>小偷了一鸡，直接用 <code>lower</code> 和 <code>upper</code> 转了一下，如果是其他语言可能会想用一下 <code>&#39;A&#39;-&#39;a&#39;</code> 那类的操作吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greatestLetter</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            d[s[i]] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">            <span class="keyword">if</span> d.get(key.upper()) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> d.get(key.lower()) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                res += key.upper()</span><br><span class="line">        </span><br><span class="line">        res.sort()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(res):</span><br><span class="line">            <span class="keyword">return</span> res[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="第二题：5218-个位数字为-K-的整数之和【难度：1646】"><a href="#第二题：5218-个位数字为-K-的整数之和【难度：1646】" class="headerlink" title="第二题：5218.个位数字为 K 的整数之和【难度：1646】"></a>第二题：5218.个位数字为 K 的整数之和【难度：1646】</h1><p><a href="https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你两个整数 <code>num</code> 和 <code>k</code> ，考虑具有以下属性的正整数多重集：</p><ul><li>每个整数个位数字都是 <code>k</code> 。</li><li>所有整数之和是 <code>num</code> 。</li></ul><p>返回该多重集的最小大小，如果不存在这样的多重集，返回 <code>-1</code> 。</p><p>注意：</p><ul><li>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。</li><li><code>个位数字</code> 是数字最右边的数位。</li></ul><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 58, k = 9</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。</span><br><span class="line">另一个满足条件的多重集是 [19,39] 。</span><br><span class="line">可以证明 2 是满足题目条件的多重集的最小长度。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 37, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：个位数字为 2 的整数无法相加得到 37 。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 0, k = 7</span><br><span class="line">输出：0</span><br><span class="line">解释：空多重集的和为 0 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= num &lt;= 3000</code></li><li><code>0 &lt;= k &lt;= 9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>思路主要是想 <code>num</code> 减几次那个数字后，能变成一个 <code>mod10 = 0</code> 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumNumbers</span>(<span class="params">self, num, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k != <span class="number">0</span>:</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                cnt = -<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> cnt == <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                num -= k</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> num % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> num != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num % <span class="number">10</span> == <span class="number">0</span> <span class="keyword">and</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】"><a href="#第三题：6099-小于等于-K-的最长二进制子序列【难度：1871】" class="headerlink" title="第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】"></a>第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】</h1><p><a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p><p>请你返回 <code>s</code> 的 <strong>最长</strong> 子序列，且该子序列对应的 <strong>二进制</strong> 数字小于等于 <code>k</code> 。</p><p>注意：</p><ul><li>子序列可以有 <strong>前导 0</strong> 。</li><li>空字符串视为 <code>0</code> 。</li><li><code>子序列</code> 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li></ul><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1001010&quot;, k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：s 中小于等于 5 的最长子序列是 &quot;00010&quot; ，对应的十进制数字是 2 。</span><br><span class="line">注意 &quot;00100&quot; 和 &quot;00101&quot; 也是可行的最长子序列，十进制分别对应 4 和 5 。</span><br><span class="line">最长子序列的长度为 5 ，所以返回 5 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;00101001&quot;, k = 1</span><br><span class="line">输出：6</span><br><span class="line">解释：&quot;000001&quot; 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。</span><br><span class="line">最长子序列的长度为 6 ，所以返回 6 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubsequence</span>(<span class="params">self, s, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        summ = <span class="number">0</span></span><br><span class="line">        remove = <span class="number">0</span></span><br><span class="line">        s = s[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> summ &gt;= k:</span><br><span class="line">                    remove += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> summ + (<span class="number">1</span> &lt;&lt; i) &gt; k:</span><br><span class="line">                        remove += <span class="number">1</span></span><br><span class="line">                    summ += (<span class="number">1</span> &lt;&lt; i)  <span class="comment"># 左移i位置，优先加小位置的</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s) - remove</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;题目难度：t1(1427)+t2(1646)+t3(1871)；&lt;/p&gt;
&lt;p&gt;近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧；&lt;/p&gt;
&lt;p&gt;第一题：小偷了一鸡，直接用 &lt;code&gt;lower&lt;/code&gt; 和 &lt;code&gt;upper&lt;/code&gt; 转了一下，如果是其他语言可能会想用一下 &lt;code&gt;&amp;#39;A&amp;#39;-&amp;#39;a&amp;#39;&lt;/code&gt; 那类的操作吧；&lt;/p&gt;
&lt;p&gt;第二题：思路主要是想 &lt;code&gt;num&lt;/code&gt; 减几次那个数字后，能变成一个 &lt;code&gt;mod10 = 0&lt;/code&gt; 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了；&lt;/p&gt;
&lt;p&gt;第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧；&lt;/p&gt;
&lt;p&gt;第四题：咕咕QAQ；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
  </entry>
  
  <entry>
    <title>294场LeetCode周赛</title>
    <link href="http://example.com/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-05-24T08:06:58.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 <code>from decimal import Decimal</code>，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG；</p><p>第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><p>第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><p>第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><p>第四题：咕咕QAQ；</p><span id="more"></span><h1 id="第一题：2278-字母在字符串中的百分比"><a href="#第一题：2278-字母在字符串中的百分比" class="headerlink" title="第一题：2278.字母在字符串中的百分比"></a>第一题：2278.字母在字符串中的百分比</h1><p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 <strong>百分比</strong> ，向下取整到最接近的百分比。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;foobar&quot;, letter = &quot;o&quot;</span><br><span class="line">输出：33</span><br><span class="line">解释：</span><br><span class="line">等于字母 &#x27;o&#x27; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;jjjj&quot;, letter = &quot;k&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">等于字母 &#x27;k&#x27; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">percentageLetter</span>(<span class="params">self, s, letter</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type letter: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] == letter:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt * <span class="number">100</span> // <span class="built_in">len</span>(s)</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        res = (cnt * 1.0 / len(s) ) * 100</span></span><br><span class="line"><span class="string">        r = int(str(res).split(&#x27;.&#x27;)[0])</span></span><br><span class="line"><span class="string">        return r</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="第二题：2279-装满石头的背包的最大数量"><a href="#第二题：2279-装满石头的背包的最大数量" class="headerlink" title="第二题：2279.装满石头的背包的最大数量"></a>第二题：2279.装满石头的背包的最大数量</h1><p><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 <strong>0</strong> 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 <strong>任意</strong> 背包中放置。</p><p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 <strong>最大</strong> 数量。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">1 块石头放入背包 0 ，1 块石头放入背包 1 。</span><br><span class="line">每个背包中的石头总数是 [2,3,4,4] 。</span><br><span class="line">背包 0 、背包 1 和 背包 2 都装满石头。</span><br><span class="line">总计 3 个背包装满石头，所以返回 3 。</span><br><span class="line">可以证明不存在超过 3 个背包装满石头的情况。</span><br><span class="line">注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">8 块石头放入背包 0 ，2 块石头放入背包 2 。</span><br><span class="line">每个背包中的石头总数是 [10,2,2] 。</span><br><span class="line">背包 0 、背包 1 和背包 2 都装满石头。</span><br><span class="line">总计 3 个背包装满石头，所以返回 3 。</span><br><span class="line">可以证明不存在超过 3 个背包装满石头的情况。</span><br><span class="line">注意，不必用完所有的额外石头。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>n == capacity.length == rocks.length</code></li><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li><li><code>1 &lt;= capacity[i] &lt;= 10^9</code></li><li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li><li><code>1 &lt;= additionalRocks &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumBags</span>(<span class="params">self, capacity, rocks, additionalRocks</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: List[int]</span></span><br><span class="line"><span class="string">        :type rocks: List[int]</span></span><br><span class="line"><span class="string">        :type additionalRocks: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        cha = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(capacity)):</span><br><span class="line">            cha.append(capacity[i]-rocks[i])</span><br><span class="line">        </span><br><span class="line">        cha.sort()</span><br><span class="line"></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cha)):</span><br><span class="line">            <span class="keyword">if</span> cha[i] &lt;= additionalRocks:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                additionalRocks -= cha[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h1 id="第三题：2280-表示一个折线图的最少线段数"><a href="#第三题：2280-表示一个折线图的最少线段数" class="headerlink" title="第三题：2280.表示一个折线图的最少线段数"></a>第三题：2280.表示一个折线图的最少线段数</h1><p><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [day_i, price_i]</code> 表示股票在 <code>day_i</code> 的价格为 <code>price_i</code> 。<strong>折线图</strong> 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p><p><img src="/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-25-00-57-12.png"></p><p>请你返回要表示一个折线图所需要的 <strong>最少线段数</strong> 。</p><p>示例1：</p><p><img src="/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-25-00-58-50.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">上图为输入对应的图，横坐标表示日期，纵坐标表示价格。</span><br><span class="line">以下 3 个线段可以表示折线图：</span><br><span class="line">- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。</span><br><span class="line">- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。</span><br><span class="line">- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。</span><br><span class="line">可以证明，无法用少于 3 条线段表示这个折线图。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-25-00-59-13.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">如上图所示，折线图可以用一条线段表示。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= stockPrices.length &lt;= 10^5</code></li><li><code>stockPrices[i].length == 2</code></li><li><code>1 &lt;= day_i, price_i &lt;= 10^9</code></li><li>所有 <code>day_i</code> 互不相同 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：<code>[[1,1],[500000000,499999999],[1000000000,999999998]]</code> 实际上差值是非常接近的；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumLines</span>(<span class="params">self, stockPrices: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(stockPrices) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        stockPrices.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>], x[<span class="number">1</span>]))</span><br><span class="line">        <span class="comment"># print(stockPrices)</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(stockPrices)):</span><br><span class="line">            tmp = Decimal(stockPrices[i][<span class="number">1</span>] - stockPrices[i-<span class="number">1</span>][<span class="number">1</span>]) / Decimal((stockPrices[i][<span class="number">0</span>] - stockPrices[i-<span class="number">1</span>][<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            prev = Decimal(stockPrices[i-<span class="number">1</span>][<span class="number">1</span>] - stockPrices[i-<span class="number">2</span>][<span class="number">1</span>])/ Decimal(stockPrices[i-<span class="number">1</span>][<span class="number">0</span>] - stockPrices[i-<span class="number">2</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> prev == tmp:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 &lt;code&gt;from decimal import Decimal&lt;/code&gt;，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG；&lt;/p&gt;
&lt;p&gt;第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己；&lt;/p&gt;
&lt;p&gt;第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死；&lt;/p&gt;
&lt;p&gt;第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：&lt;code&gt;[[1,1],[500000000,499999999],[1000000000,999999998]]&lt;/code&gt; 实际上差值是非常接近的；&lt;/p&gt;
&lt;p&gt;第四题：咕咕QAQ；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="几何" scheme="http://example.com/tags/%E5%87%A0%E4%BD%95/"/>
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>293场LeetCode周赛</title>
    <link href="http://example.com/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-05-15T08:24:58.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh</p><p>第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><p>第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><p>第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p>第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了；</p><span id="more"></span><h1 id="第一题：5234-移除字母异位词后的结果数组"><a href="#第一题：5234-移除字母异位词后的结果数组" class="headerlink" title="第一题：5234.移除字母异位词后的结果数组"></a>第一题：5234.移除字母异位词后的结果数组</h1><p><a href="https://leetcode.cn/problems/find-resultant-array-after-removing-anagrams/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>words</code> ，其中 <code>words[i]</code> 由小写英文字符组成。</p><p>在一步操作中，需要选出任一下标 <code>i</code> ，从 <code>words</code> 中 <strong>删除</strong> <code>words[i]</code> 。其中下标 <code>i</code> 需要同时满足下述两个条件：</p><ol><li><code>0 &lt; i &lt; words.length</code></li><li><code>words[i - 1]</code> 和 <code>words[i]</code> 是 <strong>字母异位词</strong> 。</li></ol><p>只要可以选出满足条件的下标，就一直执行这个操作。</p><p>在执行所有操作后，返回 <code>words</code> 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。</p><p><strong>字母异位词</strong> 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，<code>&quot;dacb&quot;</code> 是 <code>&quot;abdc&quot;</code> 的一个字母异位词。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]</span><br><span class="line">输出：[&quot;abba&quot;,&quot;cd&quot;]</span><br><span class="line">解释：</span><br><span class="line">获取结果数组的方法之一是执行下述步骤：</span><br><span class="line">- 由于 words[2] = &quot;bbaa&quot; 和 words[1] = &quot;baba&quot; 是字母异位词，选择下标 2 并删除 words[2] 。</span><br><span class="line">  现在 words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;] 。</span><br><span class="line">- 由于 words[1] = &quot;baba&quot; 和 words[0] = &quot;abba&quot; 是字母异位词，选择下标 1 并删除 words[1] 。</span><br><span class="line">  现在 words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;] 。</span><br><span class="line">- 由于 words[2] = &quot;cd&quot; 和 words[1] = &quot;cd&quot; 是字母异位词，选择下标 2 并删除 words[2] 。</span><br><span class="line">  现在 words = [&quot;abba&quot;,&quot;cd&quot;] 。</span><br><span class="line">无法再执行任何操作，所以 [&quot;abba&quot;,&quot;cd&quot;] 是最终答案。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]</span><br><span class="line">解释：</span><br><span class="line">words 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 10</code></li><li><code>words[i]</code> 由小写英文字母组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 <code>i</code> 和 <code>i-1</code> 之间不相同就可以了，python的话可以用 <code>Counter</code> 小偷一鸡，其他语言可以用字符串排序后做比较；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeAnagrams</span>(<span class="params">self, words</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        init_cnt = Counter(words[<span class="number">0</span>])</span><br><span class="line">        res.append(words[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(words):</span><br><span class="line">            <span class="keyword">if</span> Counter(words[i]) == init_cnt:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                init_cnt = Counter(words[i])</span><br><span class="line">                res.append(words[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第二题：6064-不含特殊楼层的最大连续楼层数"><a href="#第二题：6064-不含特殊楼层的最大连续楼层数" class="headerlink" title="第二题：6064.不含特殊楼层的最大连续楼层数"></a>第二题：6064.不含特殊楼层的最大连续楼层数</h1><p><a href="https://leetcode.cn/problems/maximum-consecutive-floors-without-special-floors/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 <strong>特殊楼层</strong> ，仅用于放松。</p><p>给你两个整数 <code>bottom</code> 和 <code>top</code> ，表示 Alice 租用了从 <code>bottom</code> 到 <code>top</code>（含 <code>bottom</code> 和 <code>top</code> 在内）的所有楼层。另给你一个整数数组 <code>special</code> ，其中 <code>special[i]</code> 表示  Alice 指定用于放松的特殊楼层。</p><p>返回不含特殊楼层的 <strong>最大</strong> 连续楼层数。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bottom = 2, top = 9, special = [4,6]</span><br><span class="line">输出：3</span><br><span class="line">解释：下面列出的是不含特殊楼层的连续楼层范围：</span><br><span class="line">- (2, 3) ，楼层数为 2 。</span><br><span class="line">- (5, 5) ，楼层数为 1 。</span><br><span class="line">- (7, 9) ，楼层数为 3 。</span><br><span class="line">因此，返回最大连续楼层数 3 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bottom = 6, top = 8, special = [7,6,8]</span><br><span class="line">输出：0</span><br><span class="line">解释：每层楼都被规划为特殊楼层，所以返回 0 。</span><br></pre></td></tr></table></figure><p>提示</p><ul><li><code>1 &lt;= special.length &lt;= 10^5</code></li><li><code>1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10^9</code></li><li><code>special</code> 中的所有值 互不相同</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 <code>10^9</code> 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxConsecutive</span>(<span class="params">self, bottom, top, special</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type bottom: int</span></span><br><span class="line"><span class="string">        :type top: int</span></span><br><span class="line"><span class="string">        :type special: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        special.append(bottom-<span class="number">1</span>)</span><br><span class="line">        special.append(top+<span class="number">1</span>)</span><br><span class="line">        special.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(special)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(special)):</span><br><span class="line">            res = <span class="built_in">max</span>(res, special[i]-special[i-<span class="number">1</span>]-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第三题：6065-按位与结果大于零的最长组合"><a href="#第三题：6065-按位与结果大于零的最长组合" class="headerlink" title="第三题：6065.按位与结果大于零的最长组合"></a>第三题：6065.按位与结果大于零的最长组合</h1><p><a href="https://leetcode.cn/problems/largest-combination-with-bitwise-and-greater-than-zero/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>对数组 <code>nums</code> 执行 <strong>按位与</strong> 相当于对数组 <code>nums</code> 中的所有整数执行 <strong>按位与</strong> 。</p><ul><li>例如，对 <code>nums = [1, 5, 3]</code> 来说，按位与等于 <code>1 &amp; 5 &amp; 3 = 1</code> 。</li><li>同样，对 <code>nums = [7]</code> 而言，按位与等于 <code>7</code> 。</li></ul><p>给你一个正整数数组 <code>candidates</code> 。计算 <code>candidates</code> 中的数字每种组合下 <strong>按位与</strong> 的结果。 <code>candidates</code> 中的每个数字在每种组合中只能使用 <strong>一次</strong> 。</p><p>返回按位与结果大于 <code>0</code> 的 <strong>最长</strong> 组合的长度。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [16,17,71,62,12,24,14]</span><br><span class="line">输出：4</span><br><span class="line">解释：组合 [16,17,62,24] 的按位与结果是 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0 。</span><br><span class="line">组合长度是 4 。</span><br><span class="line">可以证明不存在按位与结果大于 0 且长度大于 4 的组合。</span><br><span class="line">注意，符合长度最大的组合可能不止一种。</span><br><span class="line">例如，组合 [62,12,24,14] 的按位与结果是 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：candidates = [8,8]</span><br><span class="line">输出：2</span><br><span class="line">解释：最长组合是 [8,8] ，按位与结果 8 &amp; 8 = 8 &gt; 0 。</span><br><span class="line">组合长度是 2 ，所以返回 2 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= candidates.length &lt;= 10^5</code></li><li><code>1 &lt;= candidates[i] &lt;= 10^7</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 <code>for j in range(len(a[0]))</code> 放在 <code>for i in range(len(a))</code> 之外，但是内部循环还是 <code>a[i][j]</code> 就可以了；</p><p><img src="/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-16-10-17-08.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestCombination</span>(<span class="params">self, candidates</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">convert_to_bin</span>(<span class="params">num, pad=<span class="number">31</span></span>):</span><br><span class="line">            tmp_list = []</span><br><span class="line">            <span class="keyword">while</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                tmp_list.append(num&amp;<span class="number">1</span>)</span><br><span class="line">                num &gt;&gt;= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            tmp_list.reverse()</span><br><span class="line">            tmp_list = [<span class="number">0</span>] * (pad-<span class="built_in">len</span>(tmp_list)) + tmp_list</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> tmp_list</span><br><span class="line">        </span><br><span class="line">        a = []</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(candidates)):</span><br><span class="line">            a.append(convert_to_bin(candidates[i]))</span><br><span class="line">            <span class="comment"># print(candidates[i], convert_to_bin(candidates[i]))</span></span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a[<span class="number">0</span>])):</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">                <span class="keyword">if</span> a[i][j] == <span class="number">1</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, tmp)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh&lt;/p&gt;
&lt;p&gt;第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;i-1&lt;/code&gt; 之间不相同就可以了，python的话可以用 &lt;code&gt;Counter&lt;/code&gt; 小偷一鸡，其他语言可以用字符串排序后做比较；&lt;/p&gt;
&lt;p&gt;第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 &lt;code&gt;10^9&lt;/code&gt; 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了；&lt;/p&gt;
&lt;p&gt;第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 &lt;code&gt;for j in range(len(a[0]))&lt;/code&gt; 放在 &lt;code&gt;for i in range(len(a))&lt;/code&gt; 之外，但是内部循环还是 &lt;code&gt;a[i][j]&lt;/code&gt; 就可以了；&lt;/p&gt;
&lt;p&gt;第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="HARD" scheme="http://example.com/tags/HARD/"/>
    
    <category term="位运算" scheme="http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="计数" scheme="http://example.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>292场LeetCode周赛</title>
    <link href="http://example.com/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-05-08T12:39:50.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 <code>22222</code> 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 <code>@lru_cache(1000*1000)</code> 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg</p><p>第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p>第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a>，<strong>注意这个题的优化剪枝！</strong></p><span id="more"></span><h1 id="第一题：6056-字符串中最大的-3-位相同数字"><a href="#第一题：6056-字符串中最大的-3-位相同数字" class="headerlink" title="第一题：6056.字符串中最大的 3 位相同数字"></a>第一题：6056.字符串中最大的 3 位相同数字</h1><p><a href="https://leetcode.cn/problems/largest-3-same-digit-number-in-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个字符串 <code>num</code> ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 <strong>优质整数</strong> ：</p><ul><li>该整数是 <code>num</code> 的一个长度为 <code>3</code> 的 <strong>子字符串</strong> 。</li><li>该整数由唯一一个数字重复 <code>3</code> 次组成。</li></ul><p>以字符串形式返回 <strong>最大的优质整数</strong> 。如果不存在满足要求的整数，则返回一个空字符串 <code>&quot;&quot;</code> 。</p><p>注意：</p><ul><li><strong>子字符串</strong> 是字符串中的一个连续字符序列。</li><li><code>num</code> 或优质整数中可能存在 <strong>前导零</strong> 。</li></ul><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;6777133339&quot;</span><br><span class="line">输出：&quot;777&quot;</span><br><span class="line">解释：num 中存在两个优质整数：&quot;777&quot; 和 &quot;333&quot; 。</span><br><span class="line">&quot;777&quot; 是最大的那个，所以返回 &quot;777&quot; 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;2300019&quot;</span><br><span class="line">输出：&quot;000&quot;</span><br><span class="line">解释：&quot;000&quot; 是唯一一个优质整数。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = &quot;42352338&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>3 &lt;= num.length &lt;= 1000</code></li><li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；</p><p>另外来说的话，三个数是一样的，水仙花数hh！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestGoodInteger</span>(<span class="params">self, num</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num)-<span class="number">2</span>):</span><br><span class="line">            tmp = num[i:i+<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> tmp[<span class="number">0</span>] == tmp[<span class="number">1</span>] <span class="keyword">and</span> tmp[<span class="number">1</span>] == tmp[<span class="number">2</span>]:</span><br><span class="line">                res = <span class="built_in">max</span>(<span class="built_in">int</span>(tmp), res)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">3</span> - <span class="built_in">len</span>(<span class="built_in">str</span>(res))) * <span class="string">&quot;0&quot;</span> + <span class="built_in">str</span>(res)</span><br></pre></td></tr></table></figure><h1 id="第二题：6057-统计值等于子树平均值的节点数"><a href="#第二题：6057-统计值等于子树平均值的节点数" class="headerlink" title="第二题：6057.统计值等于子树平均值的节点数"></a>第二题：6057.统计值等于子树平均值的节点数</h1><p><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一棵二叉树的根节点 <code>root</code> ，找出并返回满足要求的节点数，要求节点的值等于其 <strong>子树</strong> 中值的 <strong>平均值</strong> 。</p><p>注意：</p><ul><li><code>n</code> 个元素的平均值可以由 <code>n</code> 个元素 <strong>求和</strong> 然后再除以 <code>n</code> ，并 <strong>向下舍入</strong> 到最近的整数。</li><li><code>root</code> 的 <strong>子树</strong> 由 <code>root</code> 和它的所有后代组成。</li></ul><p>示例 1：</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-27-52.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,8,5,0,1,null,6]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。</span><br><span class="line">对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。</span><br><span class="line">对值为 0 的节点：子树的平均值 0 / 1 = 0 。</span><br><span class="line">对值为 1 的节点：子树的平均值 1 / 1 = 1 。</span><br><span class="line">对值为 6 的节点：子树的平均值 6 / 1 = 6 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-28-58.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br><span class="line">解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；</p><p>写一个函数是 <code>count_mean</code> 然后再在dfs中把这个套进去！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">        self.val_sum = <span class="number">0</span></span><br><span class="line">        self.res = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">averageOfSubtree</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: Optional[TreeNode]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">count_mean</span>(<span class="params">root</span>):  <span class="comment"># 统计一个子树的均值</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            self.val_sum += root.val</span><br><span class="line">            self.cnt += <span class="number">1</span></span><br><span class="line">            count_mean(root.left)</span><br><span class="line">            count_mean(root.right)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 外面再套一层dfs？</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            self.val_sum = <span class="number">0</span></span><br><span class="line">            self.cnt = <span class="number">0</span></span><br><span class="line">            count_mean(root)</span><br><span class="line">            <span class="keyword">if</span> self.val_sum/self.cnt == root.val:</span><br><span class="line">                self.res += <span class="number">1</span></span><br><span class="line">            <span class="comment"># print(self.cnt)</span></span><br><span class="line">            <span class="comment"># print(self.val_sum)</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        </span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure><h1 id="第三题：6058-统计打字方案数"><a href="#第三题：6058-统计打字方案数" class="headerlink" title="第三题：6058.统计打字方案数"></a>第三题：6058.统计打字方案数</h1><p><a href="https://leetcode.cn/problems/count-number-of-texts/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 在给 Bob 用手机打字。数字到字母的 <strong>对应</strong> 如下图所示。</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-36-14.png"></p><p>为了 <strong>打出</strong> 一个字母，Alice 需要 <strong>按</strong> 对应字母 <code>i</code> 次，<code>i</code> 是该字母在这个按键上所处的位置。</p><ul><li>比方说，为了按出字母 <code>&#39;s&#39;</code> ，Alice 需要按 <code>&#39;7&#39;</code> 四次。类似的， Alice 需要按 <code>&#39;5&#39;</code> 两次得到字母  <code>&#39;k&#39;</code> 。</li><li>注意，数字 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 不映射到任何字母，所以 Alice <strong>不</strong> 使用它们。</li></ul><p>但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 <strong>按键的字符串信息</strong> 。</p><ul><li>比方说，Alice 发出的信息为 <code>&quot;bob&quot;</code> ，Bob 将收到字符串 <code>&quot;2266622&quot;</code> 。</li></ul><p>给你一个字符串 <code>pressedKeys</code> ，表示 Bob 收到的字符串，请你返回 Alice <strong>总共可能发出多少种文字信息</strong> 。</p><p>由于答案可能很大，将它对 <code>10^9 + 7</code> <strong>取余</strong> 后返回。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：pressedKeys = &quot;22233&quot;</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">Alice 可能发出的文字信息包括：</span><br><span class="line">&quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot; 和 &quot;ce&quot; 。</span><br><span class="line">由于总共有 8 种可能的信息，所以我们返回 8 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;</span><br><span class="line">输出：82876089</span><br><span class="line">解释：</span><br><span class="line">总共有 2082876103 种 Alice 可能发出的文字信息。</span><br><span class="line">由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= pressedKeys.length &lt;= 10^5</code></li><li><code>pressedKeys</code> 只包含数字 <code>&#39;2&#39;</code> 到 <code>&#39;9&#39;</code> 。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-43-04.png"></p><p>另外在代码实现上，发现直接初始化所有的这种类似于离线的操作可能会超时，所以来说的话还是写了一版动态的思路，参照之前的经验，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countTexts</span>(<span class="params">self, pressedKeys</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type pressedKeys: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">        # 写法1，方法应该没问题，但是初始化的时候太耗时了，可能就被边界卡了</span></span><br><span class="line"><span class="string">        if len(pressedKeys) == 0:</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        max_len = len(pressedKeys) + 5</span></span><br><span class="line"><span class="string">        MOD = 10**9 + 7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        # 这个过程有点太耗时了，这里可能要换一种动态的写法，因为太多位置是没用的了？</span></span><br><span class="line"><span class="string">        # 非7，9的递推方程</span></span><br><span class="line"><span class="string">        f_1 = [0] * max_len  # 写不写成for好像没区别</span></span><br><span class="line"><span class="string">        f_1[1], f_1[2], f_1[3] = 1, 2, 4</span></span><br><span class="line"><span class="string">        # 7，9的递推方程</span></span><br><span class="line"><span class="string">        f_2 = [0] * max_len</span></span><br><span class="line"><span class="string">        f_2[1], f_2[2], f_2[3], f_2[4] = 1, 2, 4, 8</span></span><br><span class="line"><span class="string">        # 简化为一个循环</span></span><br><span class="line"><span class="string">        for i in range(4, max_len):</span></span><br><span class="line"><span class="string">            f_1[i] = f_1[i-1] + f_1[i-2] + f_1[i-3]</span></span><br><span class="line"><span class="string">            if i != 4:</span></span><br><span class="line"><span class="string">                f_2[i] = f_2[i-1] + f_2[i-2] + f_2[i-3] + f_2[i-4]</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        # 开始分组统计</span></span><br><span class="line"><span class="string">        res = 1</span></span><br><span class="line"><span class="string">        pressedKeys += &#x27;#&#x27;  # 哨兵</span></span><br><span class="line"><span class="string">        now_str = pressedKeys[0]</span></span><br><span class="line"><span class="string">        cnt = 1</span></span><br><span class="line"><span class="string">        i = 1</span></span><br><span class="line"><span class="string">        while i &lt; len(pressedKeys):</span></span><br><span class="line"><span class="string">            if pressedKeys[i] == now_str:</span></span><br><span class="line"><span class="string">                cnt += 1</span></span><br><span class="line"><span class="string">            else:</span></span><br><span class="line"><span class="string">                if now_str == &#x27;7&#x27; or now_str == &#x27;9&#x27;:</span></span><br><span class="line"><span class="string">                    res *= f_2[cnt] % MOD</span></span><br><span class="line"><span class="string">                else:</span></span><br><span class="line"><span class="string">                    res *= f_1[cnt] % MOD</span></span><br><span class="line"><span class="string">                cnt = 1</span></span><br><span class="line"><span class="string">                now_str = pressedKeys[i]</span></span><br><span class="line"><span class="string">            i += 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        return res % MOD</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写法2，把写法1的方法转成动态的，或者相对更加记忆化一点</span></span><br><span class="line">        f_1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]  <span class="comment"># 角标直接对应上</span></span><br><span class="line">        f_2 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        pressedKeys += <span class="string">&#x27;#&#x27;</span></span><br><span class="line">        now_str = pressedKeys[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(pressedKeys):</span><br><span class="line">            <span class="keyword">if</span> pressedKeys[i] == now_str:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> now_str == <span class="string">&#x27;7&#x27;</span> <span class="keyword">or</span> now_str == <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        res *= f_2[cnt]</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f_2), cnt+<span class="number">1</span>):</span><br><span class="line">                            <span class="comment"># 注，这里实际上不推荐append的写法，最好是初始化一个很长的，往里填</span></span><br><span class="line">                            f_2.append(f_2[j-<span class="number">1</span>] + f_2[j-<span class="number">2</span>] + f_2[j-<span class="number">3</span>] + f_2[j-<span class="number">4</span>])</span><br><span class="line">                        res *= f_2[cnt]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        res *= f_1[cnt]</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(f_1), cnt+<span class="number">1</span>):</span><br><span class="line">                            f_1.append(f_1[j-<span class="number">1</span>] + f_1[j-<span class="number">2</span>] + f_1[j-<span class="number">3</span>])</span><br><span class="line">                        res *= f_1[cnt]</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">                now_str = pressedKeys[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h1 id="第四题：6059-检查是否有合法括号字符串路径"><a href="#第四题：6059-检查是否有合法括号字符串路径" class="headerlink" title="第四题：6059.检查是否有合法括号字符串路径"></a>第四题：6059.检查是否有合法括号字符串路径</h1><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>一个括号字符串是一个 <strong>非空</strong> 且只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串。如果下面 <strong>任意</strong> 条件为 <strong>真</strong> ，那么这个括号字符串就是 <strong>合法的</strong> 。</p><ul><li>字符串是 <code>()</code> 。</li><li>字符串可以表示为 <code>AB</code>（<code>A</code> 连接 <code>B</code>），<code>A</code> 和 <code>B</code> 都是合法括号序列。</li><li>字符串可以表示为 <code>(A)</code> ，其中 <code>A</code> 是合法括号序列。</li></ul><p>给你一个 <code>m x n</code> 的括号网格图矩阵 <code>grid</code> 。网格图中一个 <strong>合法括号路径</strong> 是满足以下所有条件的一条路径：</p><ul><li>路径开始于左上角格子 <code>(0, 0)</code> 。</li><li>路径结束于右下角格子 <code>(m - 1, n - 1)</code> 。</li><li>路径每次只会向 <strong>下</strong> 或者向 <strong>右</strong> 移动。</li><li>路径经过的格子组成的括号字符串是 <strong>合法</strong> 的。</li></ul><p>如果网格图中存在一条 <strong>合法括号路径</strong> ，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-49-28.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]</span><br><span class="line">输出：true</span><br><span class="line">解释：上图展示了两条路径，它们都是合法括号字符串路径。</span><br><span class="line">第一条路径得到的合法字符串是 &quot;()(())&quot; 。</span><br><span class="line">第二条路径得到的合法字符串是 &quot;((()))&quot; 。</span><br><span class="line">注意可能有其他的合法括号字符串路径。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-50-00.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两条可行路径分别得到 &quot;))(&quot; 和 &quot;)((&quot; 。由于它们都不是合法括号字符串，我们返回 false 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>grid[i][j]</code> 要么是 <code>&#39;(&#39;</code> ，要么是 <code>&#39;)&#39;</code> 。</li></ul><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！<a href="https://leetcode.cn/problems/longest-valid-parentheses/">32.最长有效括号</a></p><p>在优化剪枝上，一种是 <code>@lru_cache(1000*1000)</code> 靠着编译器来优化，另外一种是记录visited数组，类似于下面图里写的意思，还有就是说匹配上的括号长度一定是 <strong>偶数</strong> 的：</p><p><img src="/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-08-21-56-39.png"></p><p>这个题还遇到很多玄学问题，就是说两个优化都加上就过不了，但是只留其中一个优化就可以。。。dfs结构还是比较简单的！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.flag = <span class="literal">False</span></span><br><span class="line">        self.already_true = &#123;&#125;</span><br><span class="line">        self.grid = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasValidPath</span>(<span class="params">self, grid:<span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 只能往下，或者往右移动</span></span><br><span class="line">        dx = [<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">        dy = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        m = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        self.grid = grid  <span class="comment"># n,m实际上也可以搞到self.里去</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n+m) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="number">1000</span>*<span class="number">1000</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x:<span class="built_in">int</span>, y:<span class="built_in">int</span>, left_kh_cnt:<span class="built_in">int</span>, n:<span class="built_in">int</span>, m:<span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> left_kh_cnt &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 剪枝条件是，路径上某个位置，在相同left_kh_cnt条件下，是否出现过了</span></span><br><span class="line">            <span class="comment"># 这里原理上的解释是</span></span><br><span class="line">            <span class="keyword">if</span> self.already_true.get((x,y,left_kh_cnt)) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                self.already_true[(x,y,left_kh_cnt)] = <span class="literal">True</span></span><br><span class="line">                <span class="comment"># print(&quot;self.already_true: &quot;, self.already_true)</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> x == n-<span class="number">1</span> <span class="keyword">and</span> y == m-<span class="number">1</span> <span class="keyword">and</span> left_kh_cnt == <span class="number">0</span>:  <span class="comment"># 恰好匹配</span></span><br><span class="line">                self.flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1. 先写dfs逻辑，剩下逻辑随之适配</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                nx = x + dx[i]</span><br><span class="line">                ny = y + dy[i]</span><br><span class="line">                <span class="keyword">if</span> nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; n <span class="keyword">and</span> ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; m: </span><br><span class="line">                    <span class="keyword">if</span> self.grid[nx][ny] == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                        dfs(nx, ny, left_kh_cnt+<span class="number">1</span>, n, m)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dfs(nx, ny, left_kh_cnt-<span class="number">1</span>, n, m)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> self.grid[-<span class="number">1</span>][-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, n, m)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.flag</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 &lt;code&gt;22222&lt;/code&gt; 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 &lt;code&gt;@lru_cache(1000*1000)&lt;/code&gt; 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg&lt;/p&gt;
&lt;p&gt;第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快；&lt;/p&gt;
&lt;p&gt;第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的；&lt;/p&gt;
&lt;p&gt;第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了；&lt;/p&gt;
&lt;p&gt;第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！&lt;a href=&quot;https://leetcode.cn/problems/longest-valid-parentheses/&quot;&gt;32.最长有效括号&lt;/a&gt;，&lt;strong&gt;注意这个题的优化剪枝！&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="HARD" scheme="http://example.com/tags/HARD/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="矩阵" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="二叉搜索树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习</title>
    <link href="http://example.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-05-06T02:59:58.000Z</published>
    <updated>2022-11-20T01:50:08.929Z</updated>
    
    <content type="html"><![CDATA[<p>在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~</p><p>另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~</p><p><a href="https://c.runoob.com/front-end/854/">菜鸟工具在线正则表达式验证工具</a></p><span id="more"></span><p>菜鸟工具在线正则表达式验证工具:<a href="https://c.runoob.com/front-end/854/">https://c.runoob.com/front-end/854/</a></p><h1 id="正则总结"><a href="#正则总结" class="headerlink" title="正则总结"></a>正则总结</h1><h2 id="匹配数字相关"><a href="#匹配数字相关" class="headerlink" title="匹配数字相关"></a>匹配数字相关</h2><p><code>\d</code> 是匹配一个数字（0到9），在程序实现上一般需要再用 <code>\</code> 转义一下，即 <code>\\d</code></p><p>如果要匹配多个数字的话，就使用 <code>\\d+</code>，这里 <code>+</code> 代表一个或者多个</p><p>如果要匹配小数，中间带着小数点 <code>.</code> 的话，就是 <code>\\d+.\\d+</code>，注意这里还没有加入正负号的匹配</p><h2 id="加号-与乘号"><a href="#加号-与乘号" class="headerlink" title="加号 + 与乘号 *"></a>加号 <code>+</code> 与乘号 <code>*</code></h2><p><code>*</code> 表示匹配前面的字符0个或多个</p><p><code>+</code> 表示前面的字符1个或多个</p><h2 id="问号"><a href="#问号" class="headerlink" title="问号 ?"></a>问号 <code>?</code></h2><p>直接跟在表达式后面，表示匹配前面的一次或者零次，类似于{0, 1}的用法，<code>[+-]&#123;0,1&#125;\\d+.\\d+</code> 和  <code>[+-]?\\d+.\\d+</code> 应该是等价的意思，匹配前面有没有+-这些符号</p><h2 id="指数符-和-dollar符"><a href="#指数符-和-dollar符" class="headerlink" title="指数符^ 和 dollar符 $"></a>指数符<code>^</code> 和 dollar符 <code>$</code></h2><p><code>^</code> 用来匹配起始位置，<code>$</code> 用来匹配结束位置，配合使用一般用作检验，比如检验一段文本是否只包含数字 <code>^[0-9]*$</code></p><p>如果 <code>^</code> 使用在中括号中，则有一种not的感觉</p><h2 id="小括号"><a href="#小括号" class="headerlink" title="小括号 ()"></a>小括号 <code>()</code></h2><p>小括号起到了一种组的概念，首先可以按照顺序使用 <code>\\1</code>，<code>\\2</code> 进行访问匹配，例如在html/xml标签的匹配中，可以用 <code>&lt;(div)&gt;[^&lt;]*&lt;/\\1&gt;</code> 来进行匹配div标签，这样中间 <code>[^&lt;]*</code> 的意思就是匹配不是 <code>&lt;</code> 的任意字符，后边的 <code>&lt;/\\1&gt;</code> 能够自动对应到尾部标签去；注意这样的可能存在的嵌套关系匹配替换，可以每次循环迭代把内层的不断替换成一些特殊字符或者空，直到匹配不到为止；</p><p><img src="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/2022-05-06-15-11-31.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text: &lt;div&gt;&lt;font color=&#x27;red&#x27;&gt;hello, world&lt;/font&gt;&lt;div&gt;tmp2&lt;/div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">re: &lt;(div)&gt;[^&lt;]*&lt;/\1&gt;</span><br><span class="line"></span><br><span class="line">result: &lt;div&gt;tmp2&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="中括号-与竖线"><a href="#中括号-与竖线" class="headerlink" title="中括号 [] 与竖线 |"></a>中括号 <code>[]</code> 与竖线 <code>|</code></h2><p>中括号用来匹配单个字符，是否属于中括号中的一个字符 <code>[0-9]</code> <code>[A-Z]</code> 这样都也是可以的，注意如果待正则匹配的内容中已经具有中括号（其他括号也是同理），需要用 <code>\[</code> 把其他待匹配的做一个转义的感觉</p><p>竖线 <code>|</code> 就是一个或的意思，虽然不知道为什么要和中括号写在一个类别hhh，感觉使用场景上来说还是很灵活的</p><h2 id="大括号"><a href="#大括号" class="headerlink" title="大括号 {}"></a>大括号 <code>&#123;&#125;</code></h2><p>匹配出现几次那种感觉，例如 <code>\\d&#123;1,3&#125;</code> 就是匹配出现一段文本中1次到3次的数字，这里还可以补充一下问号 <code>?</code> 的作用，有一种最小匹配的感觉</p><p><img src="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/2022-05-06-15-33-31.png"></p><p><img src="/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/2022-05-06-15-33-47.png"></p><p><font color="red">好了，1+1=2学会（废）了！开始搞题！</font></p><h1 id="BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断"><a href="#BJUTACM-OJ-2017年12月蓝桥杯预选赛题目ip地址判断" class="headerlink" title="BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断"></a>BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断</h1><p><a href="http://bjutacm.openjudge.cn/lianxi/lq17I/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>于是由于各种各样的原因, 出现了一个叹号。</p><p>我们都已经看到了工具下载及比赛规则的地址是 <a href="http://172.21.17.211/">http://172.21.17.211/</a></p><p>下面你就来判断一下一个网址是否符合 <a href="http://a.b.c.d/">http://a.b.c.d/</a> 的格式吧。 (a, b, c, d 均为长度在 [1, 5] 且由数字 0-9 构成的字符串)</p><p>输入<br>一行字符串。 长度小于50。</p><p>输出<br>如果输入符合要求。 输出 “Yes”。<br>否则输出 “No” 。</p><p>(输出不含引号)</p><p>样例输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://172.21.17.211/</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题对自己影响是真的大，当年蓝桥预选赛靠着这个题在大一上从毫无基础的小白就到学校预选赛的前30名，用C语言一条规则一条规则的适配，AC的那一刻真是最难忘的会议之一~</p><p>现在再来做这个题的话，过了这么多年了，发现用非常简单的正则就能写出来，也就把题总结在这里了~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;http://[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;\.[0-9]&#123;1,5&#125;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    input_str = <span class="built_in">str</span>(<span class="built_in">input</span>())</span><br><span class="line">    tmp_str = re.sub(pattern, <span class="string">&#x27;&#x27;</span>, input_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tmp_str) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Yes&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="65-有效数字"><a href="#65-有效数字" class="headerlink" title="65.有效数字"></a>65.有效数字</h1><p><a href="https://leetcode.cn/problems/valid-number/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><strong>有效数字</strong>（按顺序）可以分成以下几个部分：</p><ol><li>一个 <strong>小数</strong> 或者 <strong>整数</strong></li><li>（可选）一个 <code>&#39;e&#39;</code> 或 <code>&#39;E&#39;</code> ，后面跟着一个 <strong>整数</strong></li></ol><p><strong>小数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>下述格式之一：<ol><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code></li><li>至少一位数字，后面跟着一个点 <code>&#39;.&#39;</code> ，后面再跟着至少一位数字</li><li>一个点 <code>&#39;.&#39;</code> ，后面跟着至少一位数字</li></ol></li></ol><p><strong>整数</strong>（按顺序）可以分成以下几个部分：</p><ol><li>（可选）一个符号字符（<code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code>）</li><li>至少一位数字</li></ol><p>部分有效数字列举如下：<code>[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;]</code></p><p>部分无效数字列举如下：<code>[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;]</code></p><p>给你一个字符串 <code>s</code> ，如果 <code>s</code> 是一个 <strong>有效数字</strong> ，请返回 <code>true</code> 。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;e&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;.&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>s</code> 仅含英文字母（大写和小写），数字（<code>0-9</code>），加号 <code>&#39;+&#39;</code> ，减号 <code>&#39;-&#39;</code> ，或者点 <code>&#39;.&#39;</code> 。</li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题要分两部分考虑，首先考虑单独表示一个整数或者小数，然后再考虑科学计数法的内容，科学计数法就是 <code>e-5</code> 或者 <code>e10</code> 这样的</p><p>单独考虑整数： <code>[+-]&#123;0,1&#125;\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代）， <code>&#123;0,1&#125;</code>，<code>\\d+</code> 匹配整数；</p><p>考虑小数，情况1： <code>[+-]&#123;0,1&#125;\\d+\\.\\d+</code><br>解释：<code>+-</code> 号可以出现0次或者1次（也可以用 <code>?</code> 替代），后面是 <code>x.x</code> 形式的小数；</p><p>考虑小数，情况2： <code>[+-]&#123;0,1&#125;\\d+\\.</code><br>解释：后面是 <code>x.</code> 形式的小数；</p><p>考虑小数，情况3： <code>[+-]&#123;0,1&#125;\\.\\d+</code><br>解释：后面是 <code>.x</code> 形式的小数；</p><p>然后考虑科学计数法，即 <strong>从e开始后面的位置</strong> ，情况有： </p><p><code>[eE][+-]?×</code> -&gt; 不能带小数点，因为不能是e2.5次方这样的，所以正则的写法为 <code>([eE][+-]?\\d+)?</code> ，这里只能匹配一次，所以要把整体的带上括号</p><p><font color="red">※</font>合并上述内容，前边的必须有，科学计数法不一定要有：</p><p><code>(([+-]?\\d+)|([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>这里还有个坑的内容，例如对于 <code>3.</code> 这种case，如果把整数的匹配写在前面，那么只会优先匹配到 <code>3</code> 了，所以要把小数写在前面，整数写在后面</p><p><code>(([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+)|([+-]?\\d+))([eE][+-]?\\d+)?</code></p><p><font color="red">※</font>补充还有个坑的地方，就是说 <code>1+3</code> 这种case，在后面的话小数部分应该写成 <code>([eE][+-]?\\d+)?</code> ，而不能写成多一个问号 <code>([eE]?[+-]?\\d+)?</code> 只有出现了e或者E，才能让+-出现0或1次</p><p>非转义的final写法： <code>(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?</code></p><p>代码如下所示，这里的注意点是</p><ol><li><code>re.compile(ur&#39;&#39;)</code> 就可以不用转义各个字符了，转义还是个考虑的重点问题；</li><li>替换成一个特殊字符 <code>#</code> ，最后可以用这个特殊字符做一些判断，避免单个 <code>e</code> 一类的问题；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isNumber</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line">        </span><br><span class="line">        pattern = re.<span class="built_in">compile</span>(u<span class="string">r&#x27;(([+-]?\d+\.\d+)|([+-]?\d+\.)|([+-]?\.\d+)|([+-]?\d+))([eE][+-]?\d+)?&#x27;</span>)  <span class="comment"># 这里不用转义了</span></span><br><span class="line">        tmp_s = re.sub(pattern, <span class="string">&quot;#&quot;</span>, s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> tmp_s != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h1 id="591-标签验证器"><a href="#591-标签验证器" class="headerlink" title="591.标签验证器"></a>591.标签验证器</h1><p><a href="https://leetcode.cn/problems/tag-validator/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：</p><ol><li>代码必须被 <strong>合法的闭合标签包围</strong> 。否则，代码是无效的。</li><li><strong>闭合标签</strong> （不一定合法）要严格符合格式：<code>&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt;</code> 。其中，<code>&lt;TAG_NAME&gt;</code> 是起始标签，<code>&lt;/TAG_NAME&gt;</code> 是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是 <strong>合法的</strong> 。</li><li><strong>合法的</strong> <code>TAG_NAME</code> <strong>仅含有大写字母</strong>，长度在范围 [1,9] 之间。否则，该 <code>TAG_NAME</code> 是不合法的。</li><li><strong>合法的</strong> <code>TAG_CONTENT</code> 可以包含其他 <strong>合法的闭合标签</strong> ，<strong>cdata</strong> （请参考规则7）和任意字符（注意参考规则1）除了不匹配的 <code>&lt;</code> 、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，<code>TAG_CONTENT</code> <strong>是不合法的</strong> 。</li><li>一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。</li><li>一个 <code>&lt;</code> ，如果你找不到一个后续的 <code>&gt;</code> 与之匹配，是不合法的。并且当你找到一个 <code>&lt;</code> 或 <code>&lt;/</code> 时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。</li><li>cdata 有如下格式：<code>&lt;![CDATA[CDATA_CONTENT]]&gt;</code>。CDATA_CONTENT 的范围被定义成 <code>&lt;![CDATA[</code> <strong>和后续的第一个</strong> <code>]]&gt;</code> 之间的字符。</li><li><code>CDATA_CONTENT</code> 可以包含 <strong>任意字符</strong> 。cdata 的功能是阻止验证器解析 <code>CDATA_CONTENT</code> ，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为 <strong>常规字符</strong> 。</li></ol><p>合法代码的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。</span><br><span class="line"></span><br><span class="line">TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 </span><br><span class="line"></span><br><span class="line">即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。</span><br><span class="line"></span><br><span class="line">所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;&gt;&gt;  ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">我们首先将代码分割为： start_tag|tag_content|end_tag 。</span><br><span class="line"></span><br><span class="line">start_tag -&gt; &quot;&lt;DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">end_tag -&gt; &quot;&lt;/DIV&gt;&quot;</span><br><span class="line"></span><br><span class="line">tag_content 也可被分割为： text1|cdata|text2 。</span><br><span class="line"></span><br><span class="line">text1 -&gt; &quot;&gt;&gt;  ![cdata[]] &quot;</span><br><span class="line"></span><br><span class="line">cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;&lt;div&gt;]&gt;&quot;</span><br><span class="line"></span><br><span class="line">text2 -&gt; &quot;]]&gt;&gt;]&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_tag 不是 &quot;&lt;DIV&gt;&gt;&gt;&quot; 的原因参照规则 6 。</span><br><span class="line">cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。</span><br></pre></td></tr></table></figure><p>不合法代码的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&lt;A&gt;  &lt;B&gt; &lt;/A&gt;   &lt;/B&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line">解释: 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  div tag is not closed  &lt;DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt; closed tags with invalid tag name  &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt; unmatched tags with invalid tag name  &lt;/1234567890&gt; and &lt;CDATA[[]]&gt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br><span class="line"></span><br><span class="line">输入: &quot;&lt;DIV&gt;  unmatched start tag &lt;B&gt;  and unmatched end tag &lt;/C&gt;  &lt;/DIV&gt;&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>为简明起见，你可以假设输入的代码（包括提到的 <strong>任意字符</strong> ）只包含 <code>数字</code>, <code>字母</code>, <code>&#39;&lt;&#39;</code>,<code>&#39;&gt;&#39;</code>,<code>&#39;/&#39;</code>,<code>&#39;!&#39;</code>,<code>&#39;[&#39;</code>,<code>&#39;]&#39;</code>和<code>&#39; &#39;</code>。</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题还是挺难的，也是一种正则表达式的练习吧，总之对正则表达式又熟了一分，想法和题解就写在代码的注释里了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValid</span>(<span class="params">self, code</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用正则表达式偷鸡了，正好作为一个正则表达式题目的练习了</span></span><br><span class="line">        <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 去掉CDATA字段变化为空，注意由于&#x27;[&#x27;括号字符在正则表达式中具有特殊的含义，所以要&#x27;\&#x27;字符完成转义</span></span><br><span class="line">        <span class="comment"># 【badcase4】CDATA必须被标签包含</span></span><br><span class="line">        <span class="comment"># 【badcase5】.*?和.*的区别？</span></span><br><span class="line">        code_remove_cdata = re.sub(<span class="string">r&quot;&lt;!\[CDATA\[.*?\]\]&gt;&quot;</span>, <span class="string">&quot;#&quot;</span>, code)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 【badcase2】如果全是CDATA匹配到的就返回False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(code_remove_cdata) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span></span><br><span class="line">        <span class="comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span></span><br><span class="line">        prev = code_remove_cdata</span><br><span class="line">        code_remove_cdata_tag = re.sub(<span class="string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="string">&quot;#&quot;</span>, code_remove_cdata)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;code_remove_cdata: &quot;</span>, code_remove_cdata)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一直正则替换</span></span><br><span class="line">        <span class="keyword">while</span> prev != code_remove_cdata_tag:  </span><br><span class="line">            prev = code_remove_cdata_tag</span><br><span class="line">            <span class="comment"># 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键</span></span><br><span class="line">            <span class="comment"># 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面</span></span><br><span class="line">            code_remove_cdata_tag = re.sub(<span class="string">r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\1&gt;&quot;</span>, <span class="string">&quot;#&quot;</span>, code_remove_cdata_tag)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;code_remove_cdata_tag: &quot;</span>, code_remove_cdata_tag)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> code_remove_cdata_tag == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &#x27;__main__&#x27;:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     s = Solution()</span></span><br><span class="line"><span class="comment">#     code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     # badcase1</span></span><br><span class="line"><span class="comment">#     # &quot;&lt;DIV&gt;  unmatched &lt;  &lt;/DIV&gt;&quot;  -&gt;  [^&lt;]*的问题，要求中甲不能匹配&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     # badcase2</span></span><br><span class="line"><span class="comment">#     # &quot;&lt;![CDATA[wahaha]]]&gt;&lt;![CDATA[]&gt; wahaha]]&gt;&quot; -&gt; 如果经过第一步处理后就空了，那就要返回False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     # badcase3</span></span><br><span class="line"><span class="comment">#     # &quot;&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt;&quot; 要输出False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     # badcase4</span></span><br><span class="line"><span class="comment">#     # &quot;&lt;![CDATA[ABC]]&gt;&lt;TAG&gt;sometext&lt;/TAG&gt;&quot;  CDATA必须被标签包含</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     # badcase5，.*和.*?还是有区别的，</span></span><br><span class="line"><span class="comment">#     # &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt;   ]]&gt;  &lt;DIV&gt; &lt;A&gt;  &lt;![CDATA[&lt;b&gt;]]&gt;  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;&quot;</span></span><br><span class="line"><span class="comment">#     # 如果是.*匹配（贪婪匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span></span><br><span class="line"><span class="comment">#     # 如果是.*?匹配（最小匹配），会替换成：&lt;DIV&gt;This is the first line #  &lt;DIV&gt; &lt;A&gt;  #  &lt;/A&gt;  &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt;    &lt;/DIV&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#     print(&quot;output res: &quot;, s.isValid(code))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~&lt;/p&gt;
&lt;p&gt;另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://c.runoob.com/front-end/854/&quot;&gt;菜鸟工具在线正则表达式验证工具&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Crsenal" scheme="http://example.com/categories/Crsenal/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="正则表达式" scheme="http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>273-283场LeetCode周赛总结</title>
    <link href="http://example.com/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-04T09:44:54.000Z</published>
    <updated>2022-11-20T01:50:08.885Z</updated>
    
    <content type="html"><![CDATA[<p>273-283场LeetCode周赛综述&amp;总结：</p><p>LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢；</p><p>温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~</p><p>另外这里相对整理一下需要数据结构/特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容；</p><p>总结来看主要有这些操作：</p><p>【前后缀和】【数学&amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;构造】【链表】【二分】【字符串】【水题】</p><span id="more"></span><h1 id="前后缀和"><a href="#前后缀和" class="headerlink" title="前后缀和"></a>前后缀和</h1><blockquote><p>前后缀和大概是因为每次都要统计相同的位置，那么就是每次在基础上做累加的操作来避免每次对于相同位置的统计；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><h1 id="数学-amp-找规律"><a href="#数学-amp-找规律" class="headerlink" title="数学&amp;找规律"></a>数学&amp;找规律</h1><blockquote><p>数学和找规律的题一般都要现场推，自己动手模拟下看看，也没什么太多复盘的思路，每次遇到的感觉都不会太一样；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><strong>283场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/append-k-integers-with-minimal-sum/">2195.向数组中追加 K 个整数</a>，暴力哈希的思路还是比较好像，但实际上不能这样，还要往后补的思路，总结数学题来说就是每次现场推就行了，复盘的时候不用想的太明白；</p><h1 id="哈希表mapping"><a href="#哈希表mapping" class="headerlink" title="哈希表mapping"></a>哈希表mapping</h1><blockquote><p>哈希表是个简化时间复杂度的好东西，万物皆可哈希hhhh；</p></blockquote><p><font color="red">※</font><strong>273场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/intervals-between-identical-elements/">2121.相同元素的间隔之和</a>，这个题同时被归入了 <code>前后缀和</code> 、 <code>数学&amp;找规律</code> 和 <code>哈希表mapping</code> 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 <code>&#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125;</code> 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路；</p><p><font color="red">※</font><strong>275场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/">2135.统计追加字母可以获得的单词数</a>，这个题主要就是哈希表的思想，一方面来说 <strong>重排</strong> 这个事情可以在最开始的时候把大家都重排了这样一种预处理得到，另一方面来说set起到判重的作用，差一个字符上就是截断的拼接问题 <code>word[:i] + word[i+1:]</code> 这样可以把第i位的字符忽略掉，还是很难的这个题，这么看来说275场周赛的三个题都好难啊；</p><p><strong>277场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">2150.找出数组中的所有孤独数字</a>，这个题哈希表也太明显了，甚至有些情况够不上平常周赛第一题，第二题的难度，包装的也比较简单，其实可以算在水题里了；</p><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><blockquote><p>贪心的事情，不用想的那么明白哈哈哈哈；</p></blockquote><p><strong>274场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/destroying-asteroids/">2126.摧毁小行星</a>，这个题算是很简单的第三题啊，274场周赛没有实时做，不然来说的话应该是一个靠前三题能rank前1000内的比赛，就是直接暴力贪心就可以了，中间带一个简单的排序，名言之贪心的事情不用搞那么明白！；</p><p><strong>276场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">2139.得到目标值的最少行动次数</a>，从大往小贪心就可以了，如果是偶数就除，如果是奇数就减就行了；</p><p><strong>279场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/smallest-value-of-the-rearranged-number/">2165.重排数字的最小值</a>，这个题分正数负数贪心就可以了，前导0还是个约束条件；</p><p><strong>280场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/">2170.使数组变成交替数组的最少操作数</a>，第二题还是不能想太复杂了，奇数偶数位，选出分别两边出现最多的，但是 <strong>不能相等的</strong>，当时把自己坑惨了啊，还是要仔细读题，读歪了那可真是掉沟里了；</p><p><font color="red">※</font><strong>280场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/removing-minimum-number-of-magic-beans/">2171.拿出最少数目的魔法豆</a>，这个题同时被归入了 <code>前后缀和</code> 和 <code>贪心</code> 的思路，排序后前缀拿过去就可以了；</p><p><font color="red">※</font><strong>281场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/construct-string-with-repeat-limit/">2182.构造限制重复的字符串</a>，这个题真的难，不是特殊情况下一定不要往原地交换的思路想，要想往新构造的思路想，剩下就是贪心和随缘的面向答案编程了；</p><h1 id="Counter计数"><a href="#Counter计数" class="headerlink" title="Counter计数"></a>Counter计数</h1><blockquote><p>Counter是个很常用的数据结构，任何涉及到统计的的题目都可能会用到这个，不知道在其他语言Counter的对应是什么；</p></blockquote><p><font color="red">※</font><strong>275场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-every-row-and-column-contains-all-numbers/">2133.检查是否每一行每一列都包含全部整数</a>，是个比较难的第一题，甚至感觉很多情况下难度超过了第二题，一方面是对一行/一列取Counter计数的时候，应该是 <code>第i行：Counter(matrix[i])</code> 和 <code>第i列：Counter([matrix[x][i] for x in range(n)])</code>，另一方面来说Counter是可以加减，还有相比较的，这个是个很方便的特性不知道在其他语言里怎么使用这个内容，这个题的特色点在于只要遍历一次主对角线做Counter，就可以涵盖所有情况了；</p><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p>282场周赛第2题 <a href="https://leetcode-cn.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/">2186.使两字符串互为字母异位词的最少步骤数</a>，经典Counter加减，莽过去！；</p><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><blockquote><p>主要看题目是否本身暗含了一种窗口的思想在里面；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><h1 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h1><blockquote><p>主要是简化实现上的操作，比如把环变成数组，还有就是针对起始位置还有终点位置的特殊处理；</p></blockquote><p><font color="red">※</font><strong>275场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/">2134.最少交换次数来组合所有的 1 II</a>，这个题同时被归入了 <code>滑动窗口</code>，<code>哨兵</code> 和 <code>Counter计数</code> 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！；</p><p><strong>276场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">2138.将字符串拆分为若干长度为 k 的组</a>，也是水题但是可以通过哨兵补齐的思想，这样最后切分起来就很容易了，看了下当时的代码，不知道为什么当时能写那么复杂。。。；</p><h1 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h1><blockquote><p>一般按照题目来，跟着题目操作就可以；</p></blockquote><p><strong>273场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/">2120.执行所有后缀指令</a>，使用 <code>[1:]</code> 不断截断，然后按照操作要求来模拟就行，这种题感觉也是不能着急，争取能在5分钟内完成第二题和第一题，要爆一下手速，第二题一般不会太难，不要太考虑时间复杂度的事情，想到方法基本就差不多了；</p><p><strong>274场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/number-of-laser-beams-in-a-bank/">2125.银行中的激光束数量</a>，感觉是题目理解相对比较长的第二题，第二题可能存在题面复杂类的问题，但是通过这个题来看不能着急读题，读完题最好一遍能理解题意，尽快做出来；</p><p><strong>280场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-operations-to-obtain-zero/">2169. 得到 0 的操作数</a>，两边来回减，按照题目的要求模拟就可以了；</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>还是要多刷，包括普通dp，区间dp等等，跟一波wls了；</p></blockquote><p><font color="red">※</font><strong>276场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">2140.解决智力问题</a>，这个题dp还是相对能看出来的？每个位置是选和不选两种状态，但是这个题只能让自己觉得自己智力有问题，dp第三题还是难，看来276和275场周赛是把自己给虐了，这个题要存 <strong>截止到当前位置的状态值！</strong></p><h1 id="状态压缩（2-n那种类型的题目）"><a href="#状态压缩（2-n那种类型的题目）" class="headerlink" title="状态压缩（2^n那种类型的题目）"></a>状态压缩（2^n那种类型的题目）</h1><blockquote><p>看数据范围有可能可以看出来是不是这类型的题目，特点就是每个状态下验证合理性的感觉吧；</p></blockquote><p><font color="red">※</font><strong>277场周赛第4题</strong> <a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">2151.基于陈述统计最多好人数</a>，还是比较难的，首先看数据范围如果是8，15这样比较小的数，那可能就要想能不能往2^n这种方向上做一做，这个题的关键思路还是当时室友给的，就是说：只需要判断假定所有说真话的人是否和条件有冲突就可以了，这种2^n很多情况都是判断每种情况是否合理的;</p><h1 id="设计-amp-构造"><a href="#设计-amp-构造" class="headerlink" title="设计&amp;构造"></a>设计&amp;构造</h1><blockquote><p>设计构造题目比较思路型，可能也是面试常考的题目，包括LRU也是设计类题目；</p></blockquote><p><strong>279场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/design-bitset/">2166.设计位集</a>，依照时间复杂度把一些能简化时间复杂度的操作转化为全局的，在 <code>__init__</code> 的时候设计全局变量，然后后边依照这个全局变量简化时间复杂度即可，设计的时候来说边设计应该就是能想到的；</p><p><font color="red">※</font><strong>283场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/create-binary-tree-from-descriptions/">2196.根据描述创建二叉树</a>，这种设计的题，要把每个节点做成一个哈希，然后用哈希再往里插入就可以了，构造的题目好像要用这种哈希是比较普遍的思路；</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote><p>链表题还没在周赛见过太多，这个题是比较水的链表题；</p></blockquote><p><strong>281场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/merge-nodes-in-between-zeros/">2181.合并零之间的节点</a>，链表模拟操作，操作过去就行了；</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><blockquote><p>二分边界情况判断，最后是left还是right是真的难，二分也可以做在每个情况下，O(n)的合理性验证吧；</p></blockquote><p><font color="red">※</font><strong>282场周赛第3题</strong> <a href="https://leetcode-cn.com/problems/minimum-time-to-complete-trips/">2187.完成旅途的最少时间</a>，自己想的时候没有看出来哪里可以二分，在大佬的提醒下二分验证每个时刻，O(n)判断judge是否合理，实际上有点像2^n那种题的验证思路了；</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><blockquote><p>字符串题目还是很多的，一方面要会a-z A-Z这种ord chr的转化，另外一方面也要自己多练习一些正则的题目；</p></blockquote><p><font color="red">※</font><strong>283场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/cells-in-a-range-on-an-excel-sheet/">2194.Excel 表中某个范围内的单元格</a>，本来是个简单的二维遍历问题，但是居然不知道python怎么遍历字符。。。查了下是 <code>ord()</code> 把字符转数字, <code>chr()</code> 把数字转字符，这个还是要记住的，特别是一些a-z，A-Z的遍历题目；</p><h1 id="水题"><a href="#水题" class="headerlink" title="水题"></a>水题</h1><p><strong>273场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/a-number-after-a-double-reversal/">2119.反转两次的数字</a>，稍微操作一下就可以完成这个模拟操作了，第一题千万注意的就是不要急躁，耐下心来一遍把题读完，然后2分钟之内刷出来；</p><p><strong>274场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/check-if-all-as-appears-before-all-bs/">2124.检查是否所有 A 都在 B 之前</a>，标准水题，这种题感觉要半分钟读题，一分半内手速搞定暴力出来；</p><p><strong>277场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">2148.元素计数</a>，能看出来是和最大最小比就很容易了，读题还是要细心呀；</p><p><strong>277场周赛第2题</strong> <a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">2149.按符号重排数组</a>，甚至比很多第一题还简单，是相对比较简单的第二题了，直接拆成两个，不做原地操作就还是很简单的；</p><p><strong>279场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/sort-even-and-odd-indices-independently/">2164.对奇偶下标分别排序</a>，这个题虽然是水题，但是可以学习python奇数偶数 <strong>下标位置</strong> 取值方法，<code>nums[::2]</code>取偶数，<code>nums[1:;2]</code>取奇数；</p><p><strong>281场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/count-integers-with-even-digit-sum/">2180.统计各位数字之和为偶数的整数个数</a>，水题，写个judge函数搞过去就可以了；</p><p><strong>282场周赛第1题</strong> <a href="https://leetcode-cn.com/problems/counting-words-with-a-given-prefix/">2185.统计包含给定前缀的字符串</a>，python有 <code>str.startswith()</code> 函数，用这个就可以了；</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;273-283场LeetCode周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢；&lt;/p&gt;
&lt;p&gt;温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~&lt;/p&gt;
&lt;p&gt;另外这里相对整理一下需要数据结构/特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容；&lt;/p&gt;
&lt;p&gt;总结来看主要有这些操作：&lt;/p&gt;
&lt;p&gt;【前后缀和】【数学&amp;amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;amp;构造】【链表】【二分】【字符串】【水题】&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="HARD" scheme="http://example.com/tags/HARD/"/>
    
  </entry>
  
  <entry>
    <title>291场LeetCode周赛</title>
    <link href="http://example.com/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-05-02T01:07:10.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题；</p><p>感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙</p><p>第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><p>第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了；</p><p>第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了；</p><span id="more"></span><p>希望下次前1000名来得快一点，这次确实是题简单了</p><p><img src="/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-02-09-13-42.png"></p><h1 id="第一题：6047-移除指定数字得到的最大结果"><a href="#第一题：6047-移除指定数字得到的最大结果" class="headerlink" title="第一题：6047.移除指定数字得到的最大结果"></a>第一题：6047.移除指定数字得到的最大结果</h1><p><a href="https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个表示某个正整数的字符串 <code>number</code> 和一个字符 <code>digit</code> 。</p><p>从 <code>number</code> 中 <strong>恰好</strong> 移除 <strong>一个</strong> 等于 <code>digit</code> 的字符后，找出并返回按 <strong>十进制</strong> 表示 <strong>最大</strong> 的结果字符串。生成的测试用例满足 <code>digit</code> 在 <code>number</code> 中出现至少一次。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：number = &quot;123&quot;, digit = &quot;3&quot;</span><br><span class="line">输出：&quot;12&quot;</span><br><span class="line">解释：&quot;123&quot; 中只有一个 &#x27;3&#x27; ，在移除 &#x27;3&#x27; 之后，结果为 &quot;12&quot; 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：number = &quot;1231&quot;, digit = &quot;1&quot;</span><br><span class="line">输出：&quot;231&quot;</span><br><span class="line">解释：可以移除第一个 &#x27;1&#x27; 得到 &quot;231&quot; 或者移除第二个 &#x27;1&#x27; 得到 &quot;123&quot; 。</span><br><span class="line">由于 231 &gt; 123 ，返回 &quot;231&quot; 。</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：number = &quot;551&quot;, digit = &quot;5&quot;</span><br><span class="line">输出：&quot;51&quot;</span><br><span class="line">解释：可以从 &quot;551&quot; 中移除第一个或者第二个 &#x27;5&#x27; 。</span><br><span class="line">两种方案的结果都是 &quot;51&quot; 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= number.length &lt;= 100</code></li><li><code>number</code> 由数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 组成</li><li><code>digit</code> 是 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 中的一个数字</li><li><code>digit</code> 在 <code>number</code> 中出现至少一次</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDigit</span>(<span class="params">self, number, digit</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type number: str</span></span><br><span class="line"><span class="string">        :type digit: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(number)):</span><br><span class="line">            <span class="keyword">if</span> number[i] == digit:</span><br><span class="line">                tmp_list = <span class="string">&#x27;&#x27;</span>.join(number[:i] + number[i+<span class="number">1</span>:])</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">int</span>(tmp_list))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(res)</span><br></pre></td></tr></table></figure><h1 id="第二题：6048-必须拿起的最小连续卡牌数"><a href="#第二题：6048-必须拿起的最小连续卡牌数" class="headerlink" title="第二题：6048.必须拿起的最小连续卡牌数"></a>第二题：6048.必须拿起的最小连续卡牌数</h1><p><a href="https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>cards</code> ，其中 <code>cards[i]</code> 表示第 <code>i</code> 张卡牌的 <strong>值</strong> 。如果两张卡牌的值相同，则认为这一对卡牌 <strong>匹配</strong> 。</p><p>返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 <code>-1</code> 。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [3,4,2,3,4,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [1,0,5,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法找出含一对匹配卡牌的一组连续卡牌。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= cards.length &lt;= 10^5</code></li><li><code>0 &lt;= cards[i] &lt;= 10^6</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了，还是比较好想到这个思路的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumCardPickup</span>(<span class="params">self, cards</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type cards: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">        tmp_dict = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cards)):</span><br><span class="line">            tmp_dict[cards[i]].append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(tmp_dict)</span></span><br><span class="line">        res = <span class="number">1e9</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> tmp_dict.values():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(value) &lt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(value)-<span class="number">1</span>):</span><br><span class="line">                res = <span class="built_in">min</span>(res, value[j+<span class="number">1</span>]-value[j])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> res != <span class="number">1e9</span>:</span><br><span class="line">            <span class="keyword">return</span> res+ <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="第三题：6049-含最多-K-个可整除元素的子数组"><a href="#第三题：6049-含最多-K-个可整除元素的子数组" class="headerlink" title="第三题：6049.含最多 K 个可整除元素的子数组"></a>第三题：6049.含最多 K 个可整除元素的子数组</h1><p><a href="https://leetcode.cn/problems/k-divisible-elements-subarrays/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>p</code> ，找出并返回满足要求的不同的子数组数，要求子数组中最多 <code>k</code> 个可被 <code>p</code> 整除的元素。</p><p>如果满足下述条件之一，则认为数组 <code>nums1</code> 和 <code>nums2</code> 是 <strong>不同</strong> 数组：</p><ul><li>两数组长度 <strong>不同</strong> ，或者</li><li>存在 <strong>至少</strong> 一个下标 <code>i</code> 满足 <code>nums1[i] != nums2[i]</code> 。</li></ul><p><strong>子数组</strong> 定义为：数组中的连续元素组成的一个 <strong>非空</strong> 序列。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,3,2,2], k = 2, p = 2</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">位于下标 0、3 和 4 的元素都可以被 p = 2 整除。</span><br><span class="line">共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：</span><br><span class="line">[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。</span><br><span class="line">注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。</span><br><span class="line">子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 4, p = 1</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">nums 中的所有元素都可以被 p = 1 整除。</span><br><span class="line">此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。</span><br><span class="line">因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 200</li><li>1 &lt;= nums[i], p &lt;= 200</li><li>1 &lt;= k &lt;= nums.length</li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；</p><p>另外还想说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j=i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countDistinct</span>(<span class="params">self, nums, k, p</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type p: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># preprocess</span></span><br><span class="line">        cnt_list = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] % p == <span class="number">0</span>:</span><br><span class="line">                cnt_list.append(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt_list.append(<span class="number">0</span>)</span><br><span class="line">        <span class="comment"># print(&quot;cnt_list: &quot;, cnt_list)</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># from collections import defaultdict</span></span><br><span class="line">        hash_set = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">                tmp_list = nums[i:j+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> hash_set.get(<span class="built_in">tuple</span>(tmp_list)) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                hash_set[<span class="built_in">tuple</span>(tmp_list)] = <span class="number">1</span></span><br><span class="line">                tmp = <span class="built_in">sum</span>(cnt_list[i:j+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> tmp &lt;= k:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="comment"># print(tmp_list)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第四题：6050-字符串的总引力"><a href="#第四题：6050-字符串的总引力" class="headerlink" title="第四题：6050.字符串的总引力"></a>第四题：6050.字符串的总引力</h1><p><a href="https://leetcode.cn/problems/total-appeal-of-a-string/">题目链接</a></p><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>字符串的 <strong>引力</strong> 定义为：字符串中 <strong>不同</strong> 字符的数量。</p><ul><li>例如，<code>&quot;abbca&quot;</code> 的引力为 <code>3</code> ，因为其中有 3 个不同字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code> 和 <code>&#39;c&#39;</code> 。</li></ul><p>给你一个字符串 <code>s</code> ，返回 <strong>其所有子字符串的总引力</strong> 。</p><p><strong>子字符串</strong> 定义为：字符串中的一个连续字符序列。</p><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，自己举的例子是下边这个图这样，这样能按照每个字符，来统计每个字符的贡献度：</p><p>非重复情况：<br><img src="/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-02-10-28-47.png"></p><p>重复情况：<br><img src="/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-05-02-10-29-13.png"></p><p>另外还想再次说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j=i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢</p><p>正确解答方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appealSum</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 一种每个字符贡献度的思想，还是很有特点的</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        char_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> char_dict.get(s[i]) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                res += (i + <span class="number">1</span>) * (<span class="built_in">len</span>(s)-i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += (i - char_dict[s[i]]) * (<span class="built_in">len</span>(s) - i)</span><br><span class="line">            char_dict[s[i]] = i</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这里也额外把自己当时写的暴力方法附上，一位缩减了时间复杂度，实际上像个小丑哈哈哈哈哈哈哈哈，dp了但没完全dp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appealSum</span>(<span class="params">self, s</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        d1 = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            d1[i] = &#123;s[i]: <span class="number">1</span>&#125;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init: &quot;</span>, d1)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        res_d = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 这里感觉是一个base基础上的dp，每次要取几位，有点不像平常的遍历思路1</span></span><br><span class="line">        <span class="comment"># 现在要开始每次取两位</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)-l+<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># base</span></span><br><span class="line">                base = s[i:i+l-<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># print(&quot;base: &quot;, base)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># now（要不要给他加一个标识？）</span></span><br><span class="line">                tmp_s = s[i:i+l]</span><br><span class="line">                <span class="comment"># print(&quot;tmp_s: &quot;, tmp_s)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 增量</span></span><br><span class="line">                upper = tmp_s[<span class="built_in">len</span>(base):]</span><br><span class="line">                <span class="comment"># print(&quot;upper: &quot;, upper)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 查看upper在不在</span></span><br><span class="line">                <span class="keyword">if</span> d1[i].get(upper) <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 不在，这样是一种累加的</span></span><br><span class="line">                    d1[i][tmp_s] = d1[i][base] + <span class="number">1</span></span><br><span class="line">                    d1[i][upper] = <span class="number">1</span></span><br><span class="line">                    res += d1[i][tmp_s]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    d1[i][tmp_s] = d1[i][base]</span><br><span class="line">                    res += d1[i][tmp_s]</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># continue</span></span><br><span class="line">                    <span class="comment"># res += d1[i][upper]</span></span><br><span class="line">                    <span class="comment"># d1[i][upper] = d1[i][upper] + 1</span></span><br><span class="line">                    <span class="comment"># continue</span></span><br><span class="line">                </span><br><span class="line">        <span class="comment"># print(d1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># print(res)</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题；&lt;/p&gt;
&lt;p&gt;感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙&lt;/p&gt;
&lt;p&gt;第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了；&lt;/p&gt;
&lt;p&gt;第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了；&lt;/p&gt;
&lt;p&gt;第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了；&lt;/p&gt;
&lt;p&gt;第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="HARD" scheme="http://example.com/tags/HARD/"/>
    
    <category term="字典树" scheme="http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="枚举" scheme="http://example.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
    <category term="哈希函数" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"/>
    
    <category term="滚动哈希" scheme="http://example.com/tags/%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>687.最长同值路径-python</title>
    <link href="http://example.com/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/"/>
    <id>http://example.com/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/</id>
    <published>2022-04-30T02:49:27.000Z</published>
    <updated>2022-11-20T01:50:08.885Z</updated>
    
    <content type="html"><![CDATA[<p>687.最长同值路径（中等）</p><p>题目大意：</p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">题目链接</a></p><p>给定一个二叉树的 <code>root</code> ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p><p><strong>两个节点之间的路径长度</strong> 由它们之间的边数表示。</p><p>示例1：</p><p><img src="/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/2022-04-30-10-51-58.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,5,1,1,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/2022-04-30-10-52-12.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,5,4,4,5]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>树的节点数的范围是 <code>[0, 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li><li>树的深度将不超过 <code>1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>比较经典能看出来是 <code>树中子结构dfs/dp的题目</code>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>对于这个题目来说，子结构下的返回值可能会有none的情况，另外也需要全局比较，总结来说和124题目比较像，如果再做到这题的话不知道能不能做出来了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    典型树中子结构搜索的题目</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.max_res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestUnivaluePath</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1. 先写dfs递归函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3. 子结构搜索任务要用后序遍历，这里写递归两次</span></span><br><span class="line">            left = dfs(root.left)</span><br><span class="line">            right = dfs(root.right)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 4. 写全局的那个逻辑，全局结构要把左右都考虑上</span></span><br><span class="line">            tmp_res = <span class="number">0</span>  <span class="comment"># 路径长度，所以这里是0开始</span></span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.left.val:</span><br><span class="line">                tmp_res += left</span><br><span class="line">            <span class="keyword">if</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.right.val:</span><br><span class="line">                tmp_res += right</span><br><span class="line">            self.max_res = <span class="built_in">max</span>(self.max_res, tmp_res)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 对于树中的子结构搜索任务，写返回值，看看不同种情况下子结构该怎么返回</span></span><br><span class="line">            <span class="keyword">if</span> (root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.left.val) <span class="keyword">and</span> (root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.right.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> root.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.left.val:</span><br><span class="line">                <span class="keyword">return</span> left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> root.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> root.val == root.right.val:</span><br><span class="line">                <span class="keyword">return</span> right + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>  <span class="comment"># 为什么是return1，只能暂时理解为每个的base都是1了</span></span><br><span class="line">        </span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;687.最长同值路径（中等）&lt;/p&gt;
&lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;给定一个二叉树的 &lt;code&gt;root&lt;/code&gt; ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个节点之间的路径长度&lt;/strong&gt; 由它们之间的边数表示。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>543.二叉树的直径-python</title>
    <link href="http://example.com/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/"/>
    <id>http://example.com/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/</id>
    <published>2022-04-30T02:20:42.000Z</published>
    <updated>2022-11-20T01:50:08.884Z</updated>
    
    <content type="html"><![CDATA[<p>543.二叉树的直径（简单）</p><p>题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">题目链接</a></p><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p>示例：<br>给定二叉树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>返回 <strong>3</strong>，它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]</p><p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>题目中给出了一个提示，就是说 <strong>这条路径可能穿过也可能不穿过根节点</strong>，那么换句话说，每个节点都有可能是 <strong>路径的根节点</strong>，这样应该可以判断出是经典的 <strong>树形子结构dfs/dp题目</strong>，关于该类型题目比较经典的感觉是<a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a></p><p><strong>题目类型</strong> 的细节总结和 <strong>相似题目分析</strong> 可见leetcode124题的博客</p><p>这个题目来说，坑点在于不是节点数目，而是边数目的表示，最后需要加减个1一般通过调试就可以完成了，然后路径上的话一般子结构返回值就是 <code>1+xxx</code> 这样的；另外想说的是这个题居然是简单题，和124本质上没有什么区别啊</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.max_len = -<span class="number">1e9</span>  <span class="comment"># 这里要新定义一个？</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            max_left_len = dfs(root.left)</span><br><span class="line">            max_right_len = dfs(root.right)</span><br><span class="line"></span><br><span class="line">            self.max_len = <span class="built_in">max</span>(self.max_len, <span class="number">1</span> + max_left_len + max_right_len)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(max_left_len, max_right_len)  <span class="comment"># 子结构的加上根</span></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_len - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;543.二叉树的直径（简单）&lt;/p&gt;
&lt;p&gt;题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>124.二叉树中的最大路径和-python</title>
    <link href="http://example.com/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/"/>
    <id>http://example.com/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/</id>
    <published>2022-04-30T01:38:40.000Z</published>
    <updated>2022-11-20T01:50:08.882Z</updated>
    
    <content type="html"><![CDATA[<p>124.二叉树中的最大路径和（困难）</p><p>题目大意：<strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><span id="more"></span><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">题目链接</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p>示例1：</p><p><img src="/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/2022-04-30-10-00-18.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/2022-04-30-10-00-43.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>树中节点数目范围是 [1, 3 * 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h1 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h1><p>经典的树形子结构dp题目，这个题带了一个最大路径和，这块是要有一个全局的变量，每个子结构的值要和这个全局的值来比取最大值；</p><p>树里的子结构，一般思路就是<strong>后序遍历</strong>的思想，把每个节点当做根节点，然后求出这个点左右和这个点的值加起来，和全局的来比；而其中比较关键的是在此之前，每个地方的递归出口，也就是后序遍历的出口要把子结构的值给返回回去，而这种路径的话，子结构实际上只能往左边或者右边，也就是<code>root.val + max(left_val, right_val)</code>，其中两边的val需要通过递归来完成返回</p><p>总结来说，一般的套路是如下几个步骤：</p><ol><li>写 <code>from function tools import lru_cache</code> ，在dfs函数前加上 <code>@lru_cache(1000*1000)</code> 的修饰，这样可以一定程度上减小时间占用（在笔试题目中可能会有奇效hh）；</li><li>写入口，入口一般有两种情况，像是笔试题目的话可能是 <code>def dfs(left, right)</code> 这样的，像是leetcode题目的话，可能就是 <code>def dfs(root)</code>；</li><li>写出口返回值，一般来说就是子结构的值，如果是像这个题一样树中路径的话，就是当前节点加上左边或者右边的；</li><li>写后续遍历的递归部分，将两边的子结构传入dfs函数中，来进一步往深度优先寻找；</li><li>写全局比较，这个步骤不一定存在，但是如果把每个节点像这个题一样当做“中转节点”的话，那就要和全局的值比较一下；</li><li>写递归出口条件，一般来说就是 <code>root is None</code> 或者 <code>left &gt;= right</code>这类的条件；</li></ol><p>这个模式感觉还挺套路的，几乎子结构或者带着树中路径的题目都可以这么做，也算是积累到一种做法吧，相似题目包括：</p><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a><br><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://www.nowcoder.com/test/28665343/summary">001场笔试练习 第四题.最优二叉树</a></p><p>通过上边的总结来说，这个题目基本已经可以做出来了，需要注意的是这个题目中可能有负数存在，路径上带上负数还不如不带这条路径，子结构返回的时候需要注意一下</p><p>补充：</p><p>543.二叉树直径 easy: <a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><p>124.二叉树中的最大路径和 hard: <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/</a></p><p>这两个题感觉是很像的，但是不太像树形dp，就像是在树里的dfs一样，感觉最主要的思路就是子结构</p><ul><li><p>在写dfs函数的时候，先写返回值，返回值是左右两个子结构中最大的一个加上当前节点的值；；这里说是子结构是因为他的父节点如果选了左边的就不能选右边的（题目特性决定）；；代表这个根作为子结构的条件下最大值</p></li><li><p>然后写结束条件，一般就是root is None的时候</p></li><li><p>然后写递归的两边，基本就是把root.left和root.right传进去</p></li><li><p>然后写全局的，全局的就是 当前+左子结构+右子结构，然后和现有比取最大的；；；代表按这个根作为真实根的情况下条件的最大值</p></li></ul><p>最后return回全局的这个最大的</p><p>树里子结构的dfs</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.max_res = -<span class="number">1e9</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxPathSum</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            left_max_val = dfs(root.left) <span class="comment"># 往左子树走，以左子树为根的最大子结构</span></span><br><span class="line">            right_max_val = dfs(root.right)  <span class="comment"># 往右子树走，右子树的最大子结构</span></span><br><span class="line"></span><br><span class="line">            tmp_value = root.val + left_max_val + right_max_val  <span class="comment"># 以root为根的最大子结构</span></span><br><span class="line">            self.max_res = <span class="built_in">max</span>(self.max_res, tmp_value)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 这个return是单一子结构的return，子结构下不能同时往左又往右走，只能选择一边，子结构的！！！</span></span><br><span class="line">            <span class="keyword">if</span> root.val + <span class="built_in">max</span>([<span class="number">0</span>, left_max_val, right_max_val]) &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> root.val + <span class="built_in">max</span>([<span class="number">0</span>, left_max_val, right_max_val]) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> self.max_res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;124.二叉树中的最大路径和（困难）&lt;/p&gt;
&lt;p&gt;题目大意：&lt;strong&gt;路径&lt;/strong&gt; 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 &lt;strong&gt;至多出现一次&lt;/strong&gt; 。该路径 &lt;strong&gt;至少包含一个&lt;/strong&gt; 节点，且不一定经过根节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径和&lt;/strong&gt; 是路径中各节点值的总和。&lt;/p&gt;
&lt;p&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ，返回其 &lt;strong&gt;最大路径和&lt;/strong&gt; 。&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    
    <category term="树" scheme="http://example.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="HARD" scheme="http://example.com/tags/HARD/"/>
    
  </entry>
  
  <entry>
    <title>001场笔试练习</title>
    <link href="http://example.com/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/</id>
    <published>2022-04-26T13:32:06.000Z</published>
    <updated>2022-11-20T01:50:08.881Z</updated>
    
    <content type="html"><![CDATA[<p>写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz；</p><p>笔试题目选择：<a href="https://www.nowcoder.com/test/28665343/summary">美团2021校招笔试-编程题(通用编程试题,第10场)</a></p><p>笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题/面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6/10，还加上了一个@lru_cache(1000*1000)；</p><span id="more"></span><h1 id="第一题：淘汰分数"><a href="#第一题：淘汰分数" class="headerlink" title="第一题：淘汰分数"></a>第一题：淘汰分数</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。</p><p>但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。</p><p>显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。</p><p>数据范围：1 ≤ n ≤ 50000，1 ≤ x ≤ y ≤ n<br>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入第一行仅包含三个正整数n,x,y，分别表示参赛的人数和晋级淘汰人数区间。(1&lt;=n&lt;=50000,1&lt;=x,y&lt;=n)</span><br><span class="line">输入第二行包含n个整数，中间用空格隔开，表示从1号选手到n号选手的成绩。(1&lt;=|a_i|&lt;=1000)</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出仅包含一个整数，如果不存在这样的m，则输出-1，否则输出符合条件的最小的值。</span><br></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 2 3</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题好像出的case比较弱，做的时候直接用前后缀偷鸡了，实际上可能需要考虑同分数的情况，所以自己的前后缀做法实际上是有问题的，不过既然偷过了，就先不管了哈哈哈，就当他是笔试题和leetcode的不同了；</p><p>笔试题模板就用类似这样的，写成leetcode的写法，也会相对比较熟练了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self, n, x, y, scores</span>):</span><br><span class="line">        scores.sort()</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        last = <span class="built_in">len</span>(scores)</span><br><span class="line"></span><br><span class="line">        m = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(scores)):  <span class="comment"># 二分优化</span></span><br><span class="line">            pre += <span class="number">1</span></span><br><span class="line">            last -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> pre &gt;= x <span class="keyword">and</span> pre &lt;= y <span class="keyword">and</span> last &gt;= x <span class="keyword">and</span> last &lt;= y:</span><br><span class="line">                m = scores[i]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># init solution    </span></span><br><span class="line">    s = Solution()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span></span><br><span class="line">    n, x, y = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    scores = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mock区域</span></span><br><span class="line">    <span class="comment"># n = 6</span></span><br><span class="line">    <span class="comment"># x = 2</span></span><br><span class="line">    <span class="comment"># y = 3</span></span><br><span class="line">    <span class="comment"># scores = [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    res = s.func(n, x, y, scores)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="第二题：正则序列"><a href="#第二题：正则序列" class="headerlink" title="第二题：正则序列"></a>第二题：正则序列</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p><font color="red">我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序</font></p><p>有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。</p><p>请问他最少用多少次操作可以把这个序列变成正则序列？</p><p>数据范围： 1 ≤ n ≤ 20000，0 ≤ abs(s_i) ≤ 10000<br>进阶：时间复杂度O(n)，空间复杂度O(n)  <strong>注：这里实际上是不是写错了，时间复杂度没法做到O(n)吧</strong></p><p>输入例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-1 2 3 10 100</span><br></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103</span><br></pre></td></tr></table></figure><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题也太简单了，感觉甚至不如平常周赛第一题的包装后的难度，排个序然后对位相减就可以，O(nlogn)的解法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self, n, nums</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            res += <span class="built_in">abs</span>(nums[i] - (i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># init solution    </span></span><br><span class="line">    s = Solution()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span></span><br><span class="line">    n = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mock区域</span></span><br><span class="line">    <span class="comment"># n = 5</span></span><br><span class="line">    <span class="comment"># nums = [-1, 2, 3, 10, 100]</span></span><br><span class="line">    </span><br><span class="line">    res = s.func(n, nums)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h1 id="第三题：公司食堂"><a href="#第三题：公司食堂" class="headerlink" title="第三题：公司食堂"></a>第三题：公司食堂</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌；</p><p><font color="red">当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌；</font></p><p>无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。</p><p>进阶：时间复杂度O(nlogn)，空间复杂度O(n)</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个整数T（1&lt;=T&lt;=10），表示数据组数。</span><br><span class="line"></span><br><span class="line">每组数据占四行，第一行输入一个整数N（1&lt;=N&lt;=500000）；</span><br><span class="line"></span><br><span class="line">第二行输入一个长度为N且仅包含数字0、1、2的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；</span><br><span class="line"></span><br><span class="line">第三行输入一个整数M（1&lt;=M&lt;=2N且保证排队的每个人进入食堂时都有可供选择的餐桌）；</span><br><span class="line"></span><br><span class="line">第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每组数据输出占M行，第i行输出一个整数j（1&lt;=j&lt;=N），表示排在第i的人将选择左起第j张餐桌用餐。</span><br></pre></td></tr></table></figure><p>输入示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">5</span><br><span class="line">01102</span><br><span class="line">6</span><br><span class="line">MFMMFF</span><br></pre></td></tr></table></figure><p>输入示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>感觉是个模拟题，本来以为笔试会经常出这种模拟题的，但是从今年来看好像不是这样啊。<strong>当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐</strong> 这感觉是一个提示，提示使用优先队列做模拟；</p><p>现在来看这个题好像一下想过去也不是能秒做的题目，但是感觉那天状态比较好吧？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self, n, sitdown_peoples, m, gender</span>):</span><br><span class="line">        res_list = []</span><br><span class="line">        have_zero_count = <span class="number">0</span></span><br><span class="line">        have_one_count = <span class="number">0</span></span><br><span class="line">        have_two_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        mapping = &#123;<span class="number">0</span>: [], <span class="number">1</span>: [], <span class="number">2</span>: []&#125;  <span class="comment"># 每个list是priority queue（heapq）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sitdown_peoples)):</span><br><span class="line">            mapping[sitdown_peoples[i]].append(i)</span><br><span class="line">        <span class="comment"># heapify一下，优先队列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            heapq.heapify(mapping[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(&quot;after mapping: &quot;, mapping)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gender)):</span><br><span class="line">            <span class="keyword">if</span> gender[i] == <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                <span class="comment"># 男员工会优先选择有一个人的地方坐，如果都有了就去坐两个空的</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(mapping[<span class="number">1</span>]) != <span class="number">0</span>:  <span class="comment"># 优先选择有一个人的地方坐</span></span><br><span class="line">                    <span class="comment"># 坐在这里</span></span><br><span class="line">                    tmp_idx = heapq.heappop(mapping[<span class="number">1</span>])</span><br><span class="line">                    res_list.append(tmp_idx)</span><br><span class="line">                    <span class="comment"># 修改状态</span></span><br><span class="line">                    heapq.heappush(mapping[<span class="number">2</span>], tmp_idx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 去坐两个空的</span></span><br><span class="line">                    tmp_idx = heapq.heappop(mapping[<span class="number">0</span>])</span><br><span class="line">                    res_list.append(tmp_idx)</span><br><span class="line">                    <span class="comment"># 修改状态</span></span><br><span class="line">                    heapq.heappush(mapping[<span class="number">1</span>], tmp_idx)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 女员工会优先选择都空的地方坐，如果没有了才会和别人拼桌</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(mapping[<span class="number">0</span>]) != <span class="number">0</span>:  <span class="comment"># 优先选择没有人的地方</span></span><br><span class="line">                    <span class="comment"># 坐在这里</span></span><br><span class="line">                    tmp_idx = heapq.heappop(mapping[<span class="number">0</span>])</span><br><span class="line">                    res_list.append(tmp_idx)</span><br><span class="line">                    <span class="comment"># 修改状态</span></span><br><span class="line">                    heapq.heappush(mapping[<span class="number">1</span>], tmp_idx)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 去坐有人的</span></span><br><span class="line">                    tmp_idx = heapq.heappop(mapping[<span class="number">1</span>])</span><br><span class="line">                    res_list.append(tmp_idx)</span><br><span class="line">                    <span class="comment"># 修改状态</span></span><br><span class="line">                    heapq.heappush(mapping[<span class="number">2</span>], tmp_idx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res_list</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># init solution    </span></span><br><span class="line">    s = Solution()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span></span><br><span class="line">    t = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(t):</span><br><span class="line">        n = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">        sitdown_peoples = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>()))</span><br><span class="line">        sitdown_peoples = [<span class="built_in">int</span>(item) <span class="keyword">for</span> item <span class="keyword">in</span> sitdown_peoples]</span><br><span class="line">        m = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">        gender = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># print(&quot;n: &quot;, n)</span></span><br><span class="line">        <span class="comment"># print(&quot;sitdown_peoples: &quot;, sitdown_peoples)</span></span><br><span class="line">        <span class="comment"># print(&quot;m: &quot;, m)</span></span><br><span class="line">        <span class="comment"># print(&quot;gender: &quot;, gender)</span></span><br><span class="line"></span><br><span class="line">        res_list = s.func(n, sitdown_peoples, m, gender)</span><br><span class="line">        <span class="comment"># print(&quot;res_list: &quot;, res_list)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res_list)):</span><br><span class="line">            <span class="built_in">print</span>(res_list[i]+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="第四题：最优二叉树II"><a href="#第四题：最优二叉树II" class="headerlink" title="第四题：最优二叉树II"></a>第四题：最优二叉树II</h1><h2 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h2><p>小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。</p><p>输入描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入一个整数N（1&lt;=N&lt;=300），表示二叉树的节点数。</span><br><span class="line">第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。</span><br></pre></td></tr></table></figure><p>输出描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数，表示最优二叉树的总开销。</span><br></pre></td></tr></table></figure><p>输入例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7 6 5 1 3</span><br></pre></td></tr></table></figure><p>输出例子1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45</span><br></pre></td></tr></table></figure><p>例子说明1：</p><p><img src="/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/2022-04-29-00-25-01.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最优二叉树如图所示，总开销为7*1+6*5+5*1+1*3=45。</span><br></pre></td></tr></table></figure><h2 id="分析和解答-3"><a href="#分析和解答-3" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题后来看了答案，好像是要区间dp的做法，但是区间dp感觉就是完全未知的领域了，树上的操作感觉实在是太多了，包括还有线段树一类的，说到这里也什么时候找个线段树的模板，以备之后套用吧</p><p>这个题也可以用树形dp直接暴力，而且这里学到一个lru_cache，对于笔试题感觉是一种偷鸡的操作，让本来只能过2/10的测试用例瞬间变到过6/10 ~ 7/10了，感觉就是dfs中的一个笔试偷鸡操作？应该所有dfs都可以用吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functiontools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params"><span class="number">1000</span>*<span class="number">1000</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>():</span><br><span class="line">    <span class="comment"># do sth</span></span><br></pre></td></tr></table></figure><p>这个题暂时只学习了下dfs暴力的方法了，和子结构树形dp很像，但是和leetcode那边的区别是这里的输入是一个数组，所以dfs的区间是 <code>(0, n)</code> 这种感觉，然后dfs的含义感觉就是把 <code>i</code> 作为<strong>子结构</strong>的根节点，然后i这个位置乘父亲的，再加上左边和右边的，就完成了一次内部的递归，此外，在内部递归中要遍历每个 <code>i</code> 位置，即每次（包括dfs下去的子层）都要把这个地方当做根节点试一下，最后记录一个局部子结构的ret最优作为返回值，而 <code>(0, n)</code> 这个子结构实际上就是父结构了，另外每次要把 <code>parent_value</code> 往下传下去；</p><p>子结构dp，LeetCode相似题目：</p><p><a href="https://leetcode-cn.com/problems/longest-univalue-path/">687.最长同值路径 medium</a><br><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124.二叉树中的最大路径和 hard</a><br><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">543.二叉树直径 easy</a></p><p>如下代码可以通过6/10 ~ 7/10组测试用例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self, n, values</span>):</span><br><span class="line">        <span class="comment"># 输出的values是一个global的数组，这里lru_cache大幅优化效率</span></span><br><span class="line"><span class="meta">        @lru_cache(<span class="params"><span class="number">1000</span>*<span class="number">1000</span></span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">left, right, parent_val</span>):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 3. 写出口，这里等于的话，就0</span></span><br><span class="line">            <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span></span><br><span class="line">            res = <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 2. 递归这个left,right区间下的最优子结构</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, right):</span><br><span class="line">                left_val = dfs(left, i, values[i])</span><br><span class="line">                right_val = dfs(i+<span class="number">1</span>, right, values[i])</span><br><span class="line">                res = <span class="built_in">min</span>(res, values[i] * parent_val + left_val + right_val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># init solution    </span></span><br><span class="line">    s = Solution()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773</span></span><br><span class="line">    n = <span class="built_in">int</span>(<span class="built_in">input</span>().strip())</span><br><span class="line">    <span class="keyword">global</span> values</span><br><span class="line">    values = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(&quot;n: &quot;, n)</span></span><br><span class="line">    <span class="comment"># print(&quot;values: &quot;, values)</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用以及output</span></span><br><span class="line">    res = s.func(n, values)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz；&lt;/p&gt;
&lt;p&gt;笔试题目选择：&lt;a href=&quot;https://www.nowcoder.com/test/28665343/summary&quot;&gt;美团2021校招笔试-编程题(通用编程试题,第10场)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题/面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6/10，还加上了一个@lru_cache(1000*1000)；&lt;/p&gt;</summary>
    
    
    
    <category term="笔试练习-python" scheme="http://example.com/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0-python/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆" scheme="http://example.com/tags/%E5%A0%86/"/>
    
    <category term="优先队列" scheme="http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode2022春季战队赛</title>
    <link href="http://example.com/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/"/>
    <id>http://example.com/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/</id>
    <published>2022-04-23T11:47:54.000Z</published>
    <updated>2022-11-20T01:50:08.888Z</updated>
    
    <content type="html"><![CDATA[<p>比赛综述&amp;总结：</p><p>这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了，</p><p>另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的</p><span id="more"></span><h1 id="第一题：LCP-55-采集果实"><a href="#第一题：LCP-55-采集果实" class="headerlink" title="第一题：LCP 55.采集果实"></a>第一题：LCP 55.采集果实</h1><p><a href="https://leetcode-cn.com/problems/PTXy4P/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。</p><p>在新手村中，各位勇者需要采集一些果实来制作药剂。<code>time[i]</code> 表示勇者每次采集 <code>1～limit</code> 颗第 <code>i</code> 种类型的果实需要的时间（即每次最多可以采集 <code>limit</code> 颗果实）。</p><p>当前勇者需要完成「采集若干批果实」的任务， <code>fruits[j] = [type, num]</code> 表示第 <code>j</code> 批需要采集 <code>num</code> 颗 <code>type</code> 类型的果实。采集规则如下：</p><ul><li>按 <code>fruits</code> 给定的顺序<strong>依次</strong>采集每一批次</li><li>采集完当前批次的果实才能开始采集下一批次</li><li>勇者完成当前批次的采集后将<strong>清空背包</strong>（即多余的果实将清空）</li></ul><p>请计算并返回勇者完成采集任务最少需要的时间。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3</span><br><span class="line"></span><br><span class="line">输出：10</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">由于单次最多采集 3 颗</span><br><span class="line">第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2*1=2</span><br><span class="line">第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3*2=6</span><br><span class="line">第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2*1=2</span><br><span class="line">返回总耗时 2+6+2=10</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [1], fruits = [[0,3],[0,5]], limit = 2</span><br><span class="line"></span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">由于单次最多采集 2 颗</span><br><span class="line">第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1*2=2</span><br><span class="line">第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1*3=3</span><br><span class="line">需按照顺序依次采集，返回 2+3=5</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= time.length &lt;= 100</li><li>1 &lt;= time[i] &lt;= 100</li><li>1 &lt;= fruits.length &lt;= 10^3</li><li>0 &lt;= fruits[i][0] &lt; time.length</li><li>1 &lt;= fruits[i][1] &lt; 10^3</li><li>1 &lt;= limit &lt;= 100</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题一上来就让人读题困难了，简单概括来说就是一个套角标，然后看看是否能整除，除完了向上取整吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumTime</span>(<span class="params">self, time, fruits, limit</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type time: List[int]</span></span><br><span class="line"><span class="string">        :type fruits: List[List[int]]</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fruits)):</span><br><span class="line">            <span class="keyword">if</span> fruits[i][<span class="number">1</span>] % limit != <span class="number">0</span>:</span><br><span class="line">                res += ((fruits[i][<span class="number">1</span>]//limit) + <span class="number">1</span>) * time[fruits[i][<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                 res += (fruits[i][<span class="number">1</span>]//limit) * time[fruits[i][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第二题：LCP-56-信物传送"><a href="#第二题：LCP-56-信物传送" class="headerlink" title="第二题：LCP 56.信物传送"></a>第二题：LCP 56.信物传送</h1><p><a href="https://leetcode-cn.com/problems/6UEx57/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。</p><p>本次试炼场地设有若干传送带，<code>matrix[i][j]</code> 表示第 <code>i</code> 行 <code>j</code> 列的传送带运作方向，<code>&quot;^&quot;,&quot;v&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;</code> 这四种符号分别表示 <strong>上</strong>、<strong>下</strong>、<strong>左</strong>、<strong>右</strong> 四个方向。信物会随传送带的方向移动。勇者<strong>每一次</strong>施法操作，可<strong>临时</strong>变更一处传送带的方向，在物品经过后传送带恢复原方向。</p><p><img src="/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/2022-04-23-20-10-49.png"></p><p>通关信物初始位于坐标 <code>start</code> 处，勇者需要将其移动到坐标 <code>end</code> 处，请返回勇者施法操作的最少次数。</p><p>注意：</p><ul><li><code>start</code> 和 <code>end</code> 的格式均为 <code>[i,j]</code></li></ul><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [&quot;&gt;&gt;v&quot;,&quot;v^&lt;&quot;,&quot;&lt;&gt;&lt;&quot;], start = [0,1], end = [2,0]</span><br><span class="line"></span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">如上图所示</span><br><span class="line">当信物移动到 [1,1] 时，勇者施法一次将 [1,1] 的传送方向 ^ 从变更为 &lt;</span><br><span class="line">从而信物移动到 [1,0]，后续到达 end 位置</span><br><span class="line">因此勇者最少需要施法操作 1 次</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [&quot;&gt;&gt;v&quot;,&quot;&gt;&gt;v&quot;,&quot;^&lt;&lt;&quot;], start = [0,0], end = [1,1]</span><br><span class="line"></span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">解释：勇者无需施法，信物将自动传送至 end 位置</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [&quot;&gt;^^&gt;&quot;,&quot;&lt;^v&gt;&quot;,&quot;^v^&lt;&quot;], start = [0,0], end = [1,3]</span><br><span class="line"></span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>matrix</code> 中仅包含 <code>&#39;^&#39;、&#39;v&#39;、&#39;&lt;&#39;、&#39;&gt;&#39;</code></li><li><code>0 &lt; matrix.length &lt;= 100</code></li><li><code>0 &lt; matrix[i].length &lt;= 100</code></li><li><code>0 &lt;= start[0],end[0] &lt; matrix.length</code></li><li><code>0 &lt;= start[1],end[1] &lt; matrix[i].length</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>这个题感觉有平常周赛里相对难一点第三题的感觉，比赛的时候没有想到太好的做法就直接超级暴力了，赛后看只过了2/32个测试用例，这也是这个比赛没法面向答案编程的难度吧hhhh</p><p>实际上要用bfs+dp的做法来做，当时能想到bfs，但是还是忽略和dp结合到一起了</p><p>这个题不需要记录vis了，就是说只把更小的入队，也好像不能纯优先队列，因为有些地方有好几个方向能走到，另外不用优先队列也可以做，但是用优先队列好像耗时会快一些</p><p>优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conveyorBelt</span>(<span class="params">self, matrix, start, end</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type matrix: List[str]</span></span><br><span class="line"><span class="string">:type start: List[int]</span></span><br><span class="line"><span class="string">:type end: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dx = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span></span><br><span class="line">dp = [[<span class="number">1e9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态初始化</span></span><br><span class="line">sx, sy = start</span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">pq = []</span><br><span class="line">heapq.heappush(pq, (<span class="number">0</span>, [sx, sy]))  <span class="comment"># 优先队列</span></span><br><span class="line">dp[sx][sy] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(pq) != <span class="number">0</span>:</span><br><span class="line">tmp = heapq.heappop(pq)</span><br><span class="line">x, y = tmp[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">nx = x + dx[i]</span><br><span class="line">ny = y + dy[i]</span><br><span class="line"><span class="keyword">if</span> nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="comment"># 这里不用设置visited数组是关键</span></span><br><span class="line"><span class="keyword">if</span> (matrix[x][y] == <span class="string">&#x27;^&#x27;</span> <span class="keyword">and</span> i == <span class="number">2</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;v&#x27;</span> <span class="keyword">and</span> i == <span class="number">0</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">and</span> i == <span class="number">3</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">and</span> i == <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> dp[x][y] &lt; dp[nx][ny]:</span><br><span class="line"><span class="comment"># 只有更小的才入队，貌似不是优先队列也行</span></span><br><span class="line">dp[nx][ny] = dp[x][y]</span><br><span class="line">heapq.heappush(pq, (tmp[<span class="number">0</span>], [nx, ny]))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> dp[x][y] + <span class="number">1</span> &lt; dp[nx][ny]:</span><br><span class="line"><span class="comment"># 只有更小的才入队，貌似不是优先队列也行</span></span><br><span class="line">dp[nx][ny] = dp[x][y] + <span class="number">1</span></span><br><span class="line">heapq.heappush(pq, (tmp[<span class="number">0</span>]+<span class="number">1</span>, [nx, ny]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[end[<span class="number">0</span>]][end[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>非优先队列方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">conveyorBelt</span>(<span class="params">self, matrix, start, end</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type matrix: List[str]</span></span><br><span class="line"><span class="string">:type start: List[int]</span></span><br><span class="line"><span class="string">:type end: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dx = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维dp，代表从每个点到x y位置处的最小消耗</span></span><br><span class="line">dp = [[<span class="number">1e9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态初始化</span></span><br><span class="line">sx, sy = start</span><br><span class="line">queue = [[sx, sy]]</span><br><span class="line">dp[sx][sy] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(queue) != <span class="number">0</span>:</span><br><span class="line">x, y = queue[<span class="number">0</span>]</span><br><span class="line">queue = queue[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">nx = x + dx[i]</span><br><span class="line">ny = y + dy[i]</span><br><span class="line"><span class="keyword">if</span> nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="comment"># 这里不用设置visited数组是关键</span></span><br><span class="line"><span class="keyword">if</span> (matrix[x][y] == <span class="string">&#x27;^&#x27;</span> <span class="keyword">and</span> i == <span class="number">2</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;v&#x27;</span> <span class="keyword">and</span> i == <span class="number">0</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">and</span> i == <span class="number">3</span>) <span class="keyword">or</span> (matrix[x][y] == <span class="string">&#x27;&gt;&#x27;</span> <span class="keyword">and</span> i == <span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> dp[x][y] &lt; dp[nx][ny]:</span><br><span class="line"><span class="comment"># 只有更小的才入队，貌似不是优先队列也行</span></span><br><span class="line">dp[nx][ny] = dp[x][y]</span><br><span class="line">queue.append([nx, ny])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">if</span> dp[x][y] + <span class="number">1</span> &lt; dp[nx][ny]:</span><br><span class="line"><span class="comment"># 只有更小的才入队，貌似不是优先队列也行</span></span><br><span class="line">dp[nx][ny] = dp[x][y] + <span class="number">1</span></span><br><span class="line">queue.append([nx, ny])</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp[end[<span class="number">0</span>]][end[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure><p>比赛时候的超时做法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conveyorBelt</span>(<span class="params">self, matrix, start, end</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">:type matrix: List[str]</span></span><br><span class="line"><span class="string">:type start: List[int]</span></span><br><span class="line"><span class="string">:type end: List[int]</span></span><br><span class="line"><span class="string">:rtype: int</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">dx = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">dy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">record = [[[-<span class="number">1</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">visited = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(matrix))]</span><br><span class="line">total_vis = <span class="number">0</span></span><br><span class="line">target_vis = <span class="built_in">len</span>(matrix[<span class="number">0</span>]) * <span class="built_in">len</span>(matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次从start开始走，把所有能走到的位置都标记上，如果走到了end则跳出并且输出0</span></span><br><span class="line"><span class="comment"># x纵向，y横向</span></span><br><span class="line">sx, sy = start</span><br><span class="line">nx, ny = sx, sy</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> visited[nx][ny] == <span class="number">0</span> <span class="keyword">and</span> nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line"><span class="comment"># 如果走到了end则跳出，并且输出0</span></span><br><span class="line"><span class="keyword">if</span> nx == end[<span class="number">0</span>] <span class="keyword">and</span> ny == end[<span class="number">1</span>]:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标记访问过的</span></span><br><span class="line">visited[nx][ny] = <span class="number">1</span></span><br><span class="line">total_vis += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改状态</span></span><br><span class="line">record[nx][ny][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">record[nx][ny][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照当前的格子走</span></span><br><span class="line"><span class="keyword">if</span> matrix[nx][ny] == <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">ny = ny + <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">ny = ny - <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">nx = nx - <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">nx = nx + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;total_vis: &quot;, total_vis)</span></span><br><span class="line"><span class="comment"># print(&quot;target_vis: &quot;, target_vis)</span></span><br><span class="line"><span class="comment"># print(&quot;record: &quot;, record)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力走</span></span><br><span class="line">now_status = <span class="number">0</span></span><br><span class="line">jilu_i = <span class="number">0</span></span><br><span class="line">jilu_j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> total_vis != target_vis:</span><br><span class="line"><span class="comment"># 找到一个与now_status相邻的位置</span></span><br><span class="line">break_flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(jilu_i, <span class="built_in">len</span>(matrix)):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(jilu_j, <span class="built_in">len</span>(matrix[<span class="number">0</span>])):</span><br><span class="line">can_flag = <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> visited[i][j] == <span class="number">0</span>:  <span class="comment"># 如果还没有访问过</span></span><br><span class="line"><span class="comment"># 如果临近的可达状态有上一个now_status的</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">nnx = i + dx[k]</span><br><span class="line">nny = j + dy[k]</span><br><span class="line"><span class="keyword">if</span> nnx &gt;= <span class="number">0</span> <span class="keyword">and</span> nnx &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> nny &gt;= <span class="number">0</span> <span class="keyword">and</span> nny &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">and</span> record[nnx][nny][<span class="number">0</span>] == now_status:  <span class="comment"># </span></span><br><span class="line">can_flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> can_flag:</span><br><span class="line">break_flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> break_flag:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> break_flag:  <span class="comment"># 还能找到</span></span><br><span class="line"></span><br><span class="line">jilu_i = i</span><br><span class="line">jilu_j = j</span><br><span class="line"></span><br><span class="line">nx, ny = i, j</span><br><span class="line"><span class="keyword">while</span> nx &gt;= <span class="number">0</span> <span class="keyword">and</span> nx &lt; <span class="built_in">len</span>(matrix) <span class="keyword">and</span> ny &gt;= <span class="number">0</span> <span class="keyword">and</span> ny &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) <span class="keyword">and</span> visited[nx][ny] == <span class="number">0</span>:</span><br><span class="line"><span class="comment"># 修改状态</span></span><br><span class="line">record[nx][ny][<span class="number">0</span>] = now_status + <span class="number">1</span></span><br><span class="line">record[nx][ny][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加</span></span><br><span class="line">visited[i][j] = <span class="number">1</span></span><br><span class="line">total_vis += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照当前的格子走</span></span><br><span class="line"><span class="keyword">if</span> matrix[nx][ny] == <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">ny = ny + <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">ny = ny - <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;^&#x27;</span>:</span><br><span class="line">nx = nx - <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> matrix[nx][ny] == <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">nx = nx + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(record)</span></span><br><span class="line"><span class="comment"># print(&quot;=============&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">now_status += <span class="number">1</span>  <span class="comment"># 再多一跳才能跳到的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> record[end[<span class="number">0</span>]][end[<span class="number">1</span>]][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;比赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了，&lt;/p&gt;
&lt;p&gt;另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
  </entry>
  
  <entry>
    <title>289场LeetCode周赛</title>
    <link href="http://example.com/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/"/>
    <id>http://example.com/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/</id>
    <published>2022-04-18T10:03:00.000Z</published>
    <updated>2022-11-20T01:50:08.887Z</updated>
    
    <content type="html"><![CDATA[<p>周赛综述&amp;总结：</p><p>这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了；</p><p>第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… <a href="http://bjutacm.openjudge.cn/lianxi/193E/">吃饭时的怪癖</a></p><p>好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh</p><p>第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><p>第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多；</p><p>第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><p>第四题：未来有机会再试了TAT（周常鸽第四题）；</p><span id="more"></span><h1 id="第一题：6070-计算字符串的数字和"><a href="#第一题：6070-计算字符串的数字和" class="headerlink" title="第一题：6070.计算字符串的数字和"></a>第一题：6070.计算字符串的数字和</h1><p><a href="https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/">题目链接</a></p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个由若干数字（<code>0</code> - <code>9</code>）组成的字符串 <code>s</code> ，和一个整数。</p><p>如果 <code>s</code> 的长度大于 <code>k</code> ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：</p><ol><li>将 <code>s</code> <strong>拆分</strong> 成长度为 <code>k</code> 的若干 <strong>连续数字组</strong> ，使得前 <code>k</code> 个字符都分在第一组，接下来的 <code>k</code> 个字符都分在第二组，依此类推。<strong>注意</strong>，最后一个数字组的长度可以小于 <code>k</code> 。</li><li>用表示每个数字组中所有数字之和的字符串来 <strong>替换</strong> 对应的数字组。例如，<code>&quot;346&quot;</code> 会替换为 <code>&quot;13&quot;</code> ，因为 <code>3 + 4 + 6 = 13</code> 。</li><li>合并 所有组以形成一个新字符串。如果新字符串的长度大于 <code>k</code> 则重复第一步。</li></ol><p>返回在完成所有轮操作后的 <code>s</code> 。</p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;11111222223&quot;, k = 3</span><br><span class="line">输出：&quot;135&quot;</span><br><span class="line">解释：</span><br><span class="line">- 第一轮，将 s 分成：&quot;111&quot;、&quot;112&quot;、&quot;222&quot; 和 &quot;23&quot; 。</span><br><span class="line">  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 </span><br><span class="line">  这样，s 在第一轮之后变成 &quot;3&quot; + &quot;4&quot; + &quot;6&quot; + &quot;5&quot; = &quot;3465&quot; 。</span><br><span class="line">- 第二轮，将 s 分成：&quot;346&quot; 和 &quot;5&quot; 。</span><br><span class="line">  接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。</span><br><span class="line">  这样，s 在第二轮之后变成 &quot;13&quot; + &quot;5&quot; = &quot;135&quot; 。 </span><br><span class="line">现在，s.length &lt;= k ，所以返回 &quot;135&quot; 作为答案。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;00000000&quot;, k = 3</span><br><span class="line">输出：&quot;000&quot;</span><br><span class="line">解释：</span><br><span class="line">将 &quot;000&quot;, &quot;000&quot;, and &quot;00&quot;.</span><br><span class="line">接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 </span><br><span class="line">s 变为 &quot;0&quot; + &quot;0&quot; + &quot;0&quot; = &quot;000&quot; ，其长度等于 k ，所以返回 &quot;000&quot; 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li><li><code>s</code> 仅由数字（<code>0</code> - <code>9</code>）组成。</li></ul><h2 id="分析和解答"><a href="#分析和解答" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">digitSum</span>(<span class="params">self, s, k</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s) &gt; k:</span><br><span class="line">            tmp_list = []</span><br><span class="line">            ttmp_list = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">                ttmp_list.append(s[i])</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                    tmp_list.append(ttmp_list)</span><br><span class="line">                    ttmp_list = []</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ttmp_list):</span><br><span class="line">                tmp_list.append(ttmp_list)</span><br><span class="line">            <span class="comment"># print(tmp_list)</span></span><br><span class="line">            tttmp_list = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp_list)):</span><br><span class="line">                tsum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp_list[i])):</span><br><span class="line">                    tsum += <span class="built_in">int</span>(tmp_list[i][j])</span><br><span class="line">                tttmp_list.append(<span class="built_in">str</span>(tsum))</span><br><span class="line">            s = <span class="string">&#x27;&#x27;</span>.join(tttmp_list)</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h1 id="第二题：6071-完成所有任务需要的最少轮数"><a href="#第二题：6071-完成所有任务需要的最少轮数" class="headerlink" title="第二题：6071.完成所有任务需要的最少轮数"></a>第二题：6071.完成所有任务需要的最少轮数</h1><p><a href="https://leetcode-cn.com/problems/minimum-rounds-to-complete-all-tasks/">题目链接</a></p><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>tasks</code> ，其中 <code>tasks[i]</code> 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 <strong>相同难度级别</strong> 的任务。</p><p>返回完成所有任务需要的 <strong>最少</strong> 轮数，如果无法完成所有任务，返回 <code>-1</code></p><p>示例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [2,2,3,3,2,4,4,4,4,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：要想完成所有任务，一个可能的计划是：</span><br><span class="line">- 第一轮，完成难度级别为 2 的 3 个任务。 </span><br><span class="line">- 第二轮，完成难度级别为 3 的 2 个任务。 </span><br><span class="line">- 第三轮，完成难度级别为 4 的 3 个任务。 </span><br><span class="line">- 第四轮，完成难度级别为 4 的 2 个任务。 </span><br><span class="line">可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= tasks.length &lt;= 10^5</code></li><li><code>1 &lt;= tasks[i] &lt;= 10^9</code></li></ul><h2 id="分析和解答-1"><a href="#分析和解答-1" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumRounds</span>(<span class="params">self, tasks</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type tasks: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        cnt_tasks = Counter(tasks)</span><br><span class="line">        <span class="built_in">print</span>(cnt_tasks)  <span class="comment"># Counter(&#123;4: 5, 2: 3, 3: 2&#125;)</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> cnt_tasks.items():</span><br><span class="line">            <span class="keyword">if</span> value == <span class="number">1</span>:  <span class="comment"># 中间跳出</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">            t_value = value</span><br><span class="line">            cnt_nums = t_value // <span class="number">3</span></span><br><span class="line">            t_value -= cnt_nums * <span class="number">3</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> t_value == <span class="number">1</span>:</span><br><span class="line">                cnt_nums = cnt_nums - <span class="number">1</span> + <span class="number">2</span>  <span class="comment"># 去掉一次搞3，然后搞两次2</span></span><br><span class="line">            <span class="keyword">elif</span> t_value == <span class="number">2</span>:</span><br><span class="line">                cnt_nums += <span class="number">1</span></span><br><span class="line">                t_value -= <span class="number">2</span></span><br><span class="line">            <span class="comment"># print(t_value)</span></span><br><span class="line">            res += cnt_nums</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1 id="第三题：6072-转角路径的乘积中最多能有几个尾随零"><a href="#第三题：6072-转角路径的乘积中最多能有几个尾随零" class="headerlink" title="第三题：6072.转角路径的乘积中最多能有几个尾随零"></a>第三题：6072.转角路径的乘积中最多能有几个尾随零</h1><p><a href="https://leetcode-cn.com/problems/maximum-trailing-zeros-in-a-cornered-path/">题目链接</a></p><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个二维整数数组 <code>grid</code> ，大小为 <code>m x n</code>，其中每个单元格都含一个正整数。</p><p><strong>转角路径</strong> 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 <strong>向水平方向</strong> 或者 <strong>向竖直方向</strong> 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 <strong>另一个</strong> 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。</p><p>一条路径的 <strong>乘积</strong> 定义为：路径上所有值的乘积。</p><p>请你从 <code>grid</code> 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。</p><p>注意：</p><ul><li><strong>水平</strong> 移动是指向左或右移动。</li><li><strong>竖直</strong> 移动是指向上或下移动。</li></ul><p>示例1：</p><p><img src="/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-04-18-18-31-09.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]</span><br><span class="line">输出：3</span><br><span class="line">解释：左侧的图展示了一条有效的转角路径。</span><br><span class="line">其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。</span><br><span class="line">可以证明在这条转角路径的乘积中尾随零数目最多。</span><br><span class="line"></span><br><span class="line">中间的图不是一条有效的转角路径，因为它有不止一个弯。</span><br><span class="line">右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。</span><br></pre></td></tr></table></figure><p>示例2：</p><p><img src="/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/2022-04-18-18-31-15.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[4,3,2],[7,6,1],[8,8,8]]</span><br><span class="line">输出：0</span><br><span class="line">解释：网格如上图所示。</span><br><span class="line">不存在乘积含尾随零的转角路径。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10^5</code></li><li><code>1 &lt;= m * n &lt;= 10^5</code></li><li><code>1 &lt;= grid[i][j] &lt;= 1000</code></li></ul><h2 id="分析和解答-2"><a href="#分析和解答-2" class="headerlink" title="分析和解答"></a>分析和解答</h2><p>一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxTrailingZeros</span>(<span class="params">self, grid</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_num_five</span>(<span class="params">num</span>):</span><br><span class="line">            cnt = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">while</span> num%<span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">5</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_num_two</span>(<span class="params">num</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> num%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                num /= <span class="number">2</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从上到下的前缀矩阵，从下到上的前缀矩阵</span></span><br><span class="line">        grid_up_to_down_prefix = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">        grid_down_to_up_prefix = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># 第一行</span></span><br><span class="line">                    grid_up_to_down_prefix[i][j][<span class="number">0</span>] = get_num_two(grid[i][j])</span><br><span class="line">                    grid_up_to_down_prefix[i][j][<span class="number">1</span>] = get_num_five(grid[i][j])</span><br><span class="line"></span><br><span class="line">                    grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>][j][<span class="number">0</span>] = get_num_two(grid[<span class="built_in">len</span>(grid)-<span class="number">1</span>][j])</span><br><span class="line">                    grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>][j][<span class="number">1</span>] = get_num_five(grid[<span class="built_in">len</span>(grid)-<span class="number">1</span>][j])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid_up_to_down_prefix[i][j][<span class="number">0</span>] = grid_up_to_down_prefix[i-<span class="number">1</span>][j][<span class="number">0</span>] + get_num_two(grid[i][j])</span><br><span class="line">                    grid_up_to_down_prefix[i][j][<span class="number">1</span>] = grid_up_to_down_prefix[i-<span class="number">1</span>][j][<span class="number">1</span>] + get_num_five(grid[i][j])</span><br><span class="line"></span><br><span class="line">                    grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">0</span>] = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-i][j][<span class="number">0</span>] + get_num_two(grid[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j])</span><br><span class="line">                    grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">1</span>] = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-i][j][<span class="number">1</span>] + get_num_five(grid[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从左到右的前缀矩阵，从右到左的前缀矩阵</span></span><br><span class="line">        grid_left_to_right_prefix = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">        grid_right_to_left_prefix = [[[<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>]))] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:  <span class="comment"># 第一列</span></span><br><span class="line">                    grid_left_to_right_prefix[i][j][<span class="number">0</span>] = get_num_two(grid[i][j])</span><br><span class="line">                    grid_left_to_right_prefix[i][j][<span class="number">1</span>] = get_num_five(grid[i][j])</span><br><span class="line"></span><br><span class="line">                    grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>][<span class="number">0</span>] = get_num_two(grid[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>])</span><br><span class="line">                    grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>][<span class="number">1</span>] = get_num_five(grid[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    grid_left_to_right_prefix[i][j][<span class="number">0</span>] = grid_left_to_right_prefix[i][j-<span class="number">1</span>][<span class="number">0</span>] + get_num_two(grid[i][j])</span><br><span class="line">                    grid_left_to_right_prefix[i][j][<span class="number">1</span>] = grid_left_to_right_prefix[i][j-<span class="number">1</span>][<span class="number">1</span>] + get_num_five(grid[i][j])</span><br><span class="line"></span><br><span class="line">                    grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>-j][<span class="number">0</span>] = grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-j][<span class="number">0</span>] + get_num_two(grid[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>-j])</span><br><span class="line">                    grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>-j][<span class="number">1</span>] = grid_right_to_left_prefix[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-j][<span class="number">1</span>] + get_num_five(grid[i][<span class="built_in">len</span>(grid[<span class="number">0</span>])-<span class="number">1</span>-j])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># for i in range(len(grid)):</span></span><br><span class="line">        <span class="comment">#     for j in range(len(grid[0])):</span></span><br><span class="line">        <span class="comment">#         print(grid_right_to_left_prefix[i][j])</span></span><br><span class="line">        <span class="comment">#     print(&quot;\n&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从上往下走，从下往上走同时</span></span><br><span class="line">        max_zero_last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(grid[<span class="number">0</span>])):</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 上往下，然后往右看</span></span><br><span class="line">                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="number">0</span>] + grid_left_to_right_prefix[i][-<span class="number">1</span>][<span class="number">0</span>] - grid_left_to_right_prefix[i][j][<span class="number">0</span>]</span><br><span class="line">                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="number">1</span>] + grid_left_to_right_prefix[i][-<span class="number">1</span>][<span class="number">1</span>] - grid_left_to_right_prefix[i][j][<span class="number">1</span>]</span><br><span class="line">                max_zero_last = <span class="built_in">max</span>(max_zero_last, <span class="built_in">min</span>(cnt_num_2, cnt_num_5))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 下往上，然后往右看</span></span><br><span class="line">                cnt_num_2 = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">0</span>] + grid_left_to_right_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][-<span class="number">1</span>][<span class="number">0</span>] - grid_left_to_right_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">0</span>]</span><br><span class="line">                cnt_num_5 = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">1</span>] + grid_left_to_right_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][-<span class="number">1</span>][<span class="number">1</span>] - grid_left_to_right_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">1</span>]</span><br><span class="line">                max_zero_last = <span class="built_in">max</span>(max_zero_last, <span class="built_in">min</span>(cnt_num_2, cnt_num_5))</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 上往下，然后往左看</span></span><br><span class="line">                cnt_num_2 = grid_up_to_down_prefix[i][j][<span class="number">0</span>] + grid_right_to_left_prefix[i][<span class="number">0</span>][<span class="number">0</span>] - grid_right_to_left_prefix[i][j][<span class="number">0</span>]</span><br><span class="line">                cnt_num_5 = grid_up_to_down_prefix[i][j][<span class="number">1</span>] + grid_right_to_left_prefix[i][<span class="number">0</span>][<span class="number">1</span>] - grid_right_to_left_prefix[i][j][<span class="number">1</span>]</span><br><span class="line">                max_zero_last = <span class="built_in">max</span>(max_zero_last, <span class="built_in">min</span>(cnt_num_2, cnt_num_5))</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 下往上，然后往左看</span></span><br><span class="line">                cnt_num_2 = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">0</span>] + grid_right_to_left_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][<span class="number">0</span>][<span class="number">0</span>] - grid_right_to_left_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">0</span>]</span><br><span class="line">                cnt_num_5 = grid_down_to_up_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">1</span>] + grid_right_to_left_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][<span class="number">0</span>][<span class="number">1</span>] - grid_right_to_left_prefix[<span class="built_in">len</span>(grid)-<span class="number">1</span>-i][j][<span class="number">1</span>]</span><br><span class="line">                max_zero_last = <span class="built_in">max</span>(max_zero_last, <span class="built_in">min</span>(cnt_num_2, cnt_num_5))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max_zero_last</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;周赛综述&amp;amp;总结：&lt;/p&gt;
&lt;p&gt;这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了；&lt;/p&gt;
&lt;p&gt;第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… &lt;a href=&quot;http://bjutacm.openjudge.cn/lianxi/193E/&quot;&gt;吃饭时的怪癖&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh&lt;/p&gt;
&lt;p&gt;第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了；&lt;/p&gt;
&lt;p&gt;第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多；&lt;/p&gt;
&lt;p&gt;第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了；&lt;/p&gt;
&lt;p&gt;第四题：未来有机会再试了TAT（周常鸽第四题）；&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode-python" scheme="http://example.com/categories/LeetCode-python/"/>
    
    <category term="LeetCode周赛" scheme="http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"/>
    
    
    <category term="模拟" scheme="http://example.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
    <category term="数组" scheme="http://example.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="EASY" scheme="http://example.com/tags/EASY/"/>
    
    <category term="MEDIUM" scheme="http://example.com/tags/MEDIUM/"/>
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="哈希表" scheme="http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="矩阵" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="前缀和" scheme="http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="计数" scheme="http://example.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
</feed>
