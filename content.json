{"meta":{"title":"Curious;的个人划水博客","subtitle":"","description":"","author":"Curious;","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"修改hosts文件使得服务器可以访问github","slug":"mixed/git/修改hosts文件使得服务器可以访问github","date":"2022-11-19T08:48:51.000Z","updated":"2022-11-20T01:50:08.891Z","comments":true,"path":"2022/11/19/mixed/git/修改hosts文件使得服务器可以访问github/","link":"","permalink":"http://example.com/2022/11/19/mixed/git/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E4%BD%BF%E5%BE%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AEgithub/","excerpt":"之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用 在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改/etc/hosts文件的方式","text":"之前有过在本机上如何访问github的操作，原理上来说是让git相关的时候走本机代理配置的端口，但是在该服务器上操作的时候这个不是很好用 在服务器上，可以通过首先网站查询可以ping到的github ip，然后再修改/etc/hosts文件的方式 修改hosts文件使得服务器可以访问github1. 操作首先登录如下网站，找到一个可以ping到的github ip地址：https://ping.chinaz.com/github.com 通过root账号修改/etc/hosts文件，加入如下内容： 12140.82.113.3 www.github.com140.82.113.3 github.com 加入后效果如下，再次ping www.github.com，可以得到响应，证明正确","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"hexo图片路径的配置","slug":"mixed/hexo/hexo图片路径的配置","date":"2022-11-19T08:19:33.000Z","updated":"2022-11-20T01:50:08.892Z","comments":true,"path":"2022/11/19/mixed/hexo/hexo图片路径的配置/","link":"","permalink":"http://example.com/2022/11/19/mixed/hexo/hexo%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"在使用hexo搭建博客的时候，./source/images路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到 但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在 所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移","text":"在使用hexo搭建博客的时候，./source/images路径是一个全局的路径，放在这里的图片可以被博客中的内容检测到 但是这样会导致所有博客的图片内容全都混在一块，同时在本地用typora等看图片的时候，因为路径配置的不一样也会有问题存在 所以，目标是统一这边的路径配置，让博客推到github上成功的同时，也能在本地typora看到，并方便迁移 hexo图片路径的配置1. 安装插件hexo-asset-image1.1 referencehttps://blog.csdn.net/Strong997/article/details/97767929?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-97767929-blog-100524856.pc_relevant_multi_platform_whitelistv4&amp;utm_relevant_index=2 1.2 操作使用npm进行安装，命令如下 1npm install https://github.com/CodeFalling/hexo-asset-image --save 注意，这里很多其他博客提供的安装命令如下，但实际尝试的时候可能由于版本等问题，导致无法生效，这些命令可能不好使 12npm install hexo-renderer-marked --savenpm install hexo-asset-image --save 之后，将_config.yml文件的做如下修改（注：后面的marked可能是不需要的，可能是对应hexo-render-marked的配置） 12345_config.ymlpost_asset_folder: truemarked: prependRoot: true postAsset: true 在上述配置后，在执行hexo new [FILENAME]的时候，会自动生成这个文件名字的md和对应的文件名字的文件夹，这里可以在文件夹后加入.assets，和目前我自己本机的typora环境对应上 至此操作完成","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"BERT源代码阅读学习","slug":"research/others/BERT源代码阅读学习","date":"2022-11-19T03:30:41.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2022/11/19/research/others/BERT源代码阅读学习/","link":"","permalink":"http://example.com/2022/11/19/research/others/BERT%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0/","excerpt":"BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习","text":"BERT源代码阅读学习，主要是Transformer架构中的Encoder部分，各层的源代码理解与阅读学习 BERT源代码阅读学习ReferencesBERT源代码学习：https://zhuanlan.zhihu.com/p/360988428 Attention is all you need： https://proceedings.neurips.cc/paper/2017/file/3f5ee243547dee91fbd053c1c4a845aa-Paper.pdf BERT：https://arxiv.org/pdf/1810.04805.pdf&amp;usg=ALkJrhhzxlCL6yTht2BRmH9atgvKFxHsxQ Attention机制详解：https://zhuanlan.zhihu.com/p/47282410 positional embedding absolute/relative等不同方式：https://zhuanlan.zhihu.com/p/121126531 torch中的einsum：https://zhuanlan.zhihu.com/p/361209187 Self-Attention with Relative Position Representations: https://arxiv.org/pdf/1803.02155.pdf 1. 模型结构（论文&amp;Transformer架构截图）1.1 论文&amp;Transformer架构截图1.1.1 Transformer架构图左边代表Encoder部分，右边代表Decoder部分。两边的区别个人理解是： Encoder是作为NLU（Natrual Language Understanding）来使用的，所以在输入的时候Encoder是能看到全局信息的。从目前接触到的任务来说还是Encoder这边的结构更加常用一些，大部分任务感觉还是属于在NLU的范畴，NLG那边的有些就显得不太好评测或者不是很靠谱； 但是在输入Decoder的时候，因为Decoder一般被NLG（Natural Language Generation）类的任务来使用，所以其需要根据上文来生成下文，故在输入的时候需要加mask，即 Masked Multi-Head Attention。此外在decoder部分中还有一个接收来自Encoder那边信息的Multi-Head Attention，也被称作 encoder-decoder attention layer，这个地方query来自于前一级的decoder层输出，但其key和value来自于encoder的输出，那么理解来说就是decoder的每一个位置作为key和encoder那边key计算相似度，然后聚合来自encoder那边的value信息； 和同学讨论后补充：对于Transformer架构的信息，像T5这样的encoder-decoder模型，或者说像是一类依据文本生成文本的，比如翻译任务，那就是使用到整个Transformer架构，其中的encoder-decoder attention可以理解为我需要看着原来的文本来做生成，然后把query看做普通RNN架构中的x，这样x需要聚合来自全部输入文本的信息做attention；对于BERT这类就是只用到Encoder架构；对于GPT类的可能就只是用Decoder部分，里面就没有encoder-decoder attention那个部分了； 1.1.2 Multi-Head Self Attention 1.1.3 BERT Embedding这个是bert模型结构的embedding输入，也需要联合代码看一下这个过程是怎么实现的。 这里补充贴一张LUKE的图，虽然没看过但是看起来加了一个Entity Type Embedding，好像还是个比较有名的工作 2. 代码学习2.1 基础简化pipeline代码12345678910111213141516from transformers import BertTokenizer, BertModel, BertConfigfrom transformers.models.bert import modeling_bert # 从这里看源代码# 预训练模型加载tokenizer = BertTokenizer.from_pretrained(&quot;./bert_base_uncased&quot;)model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)# 输入&amp;输出text = &quot;Germany beat Argentina 2-0 in the World Cup Final.&quot;encoded_input = tokenizer(text, return_tensors=&#x27;pt&#x27;)output = model(**encoded_input)# 获取一句话的输出，还有cls token的输出print(output[&#x27;pooler_output&#x27;].shape) # torch.Size([1, 768])print(output[&#x27;last_hidden_state&#x27;].shape) # torch.Size([1, 14, 768])print(output) 总结：加载config.json、vocab.txt还有pytorch_model.bin三个文件。其中通过 from_pretrained(&quot;./bert_base_uncased&quot;)进行指定路径，如果不指定路径的话好像会从huggingface那边下载model，指定路径的话就需要文件夹下有这三个文件； 2.2 model2.2.1 embeddings、encoder、pooler（※重点）通过model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;)加载模型后，首先可以在这里调试model这个对象包含的内容，model是BertModel的实例化，模型结构主要由model.embeddings （BERTEmbeddings类对象），model.encoder（BertEncoder类对象），model.pooler（BertPooler对象）组成。点开后可以看到各个地方的模型结构与层数，之后会随着模型调试查看数据流向和数据维度的变化。 · class BertEmbeddings层结构 /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py 12class BertEmbeddings(nn.Module): &quot;&quot;&quot;Construct the embeddings from word, position and token_type embeddings.&quot;&quot;&quot; 1) init12345678910111213141516171819def __init__(self, config): super().__init__() self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=config.pad_token_id) self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size) self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size) # self.LayerNorm is not snake-cased to stick with TensorFlow model variable name and be able to load # any TensorFlow checkpoint file self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) # position_ids (1, len position emb) is contiguous in memory and exported when serialized self.position_embedding_type = getattr(config, &quot;position_embedding_type&quot;, &quot;absolute&quot;) self.register_buffer(&quot;position_ids&quot;, torch.arange(config.max_position_embeddings).expand((1, -1))) if version.parse(torch.__version__) &gt; version.parse(&quot;1.6.0&quot;): self.register_buffer( &quot;token_type_ids&quot;, torch.zeros(self.position_ids.size(), dtype=torch.long), persistent=False, ) 简单对init进行解释，这里有三个nn.Embedding层： self.word_embeddings：维度从vocab_size（30522）到hidden_size（768）转化，TODO：padding_idx的参数是做什么用的？ self.position_embeddings：维度从max_position_embeddings（512）到hidden_size（768）转化； self.token_type_embeddings：维度从config.type_vocab_size（2，这里的2代表的是有两种类别的，第一个[SEP]前都是0，第二个[SEP]前都是1，这样交叉的）到到hidden_size（768），或者是用来表示padding地方的差异； 这里的self.LayerNorm和self.dropout是剩下两个和forward比较相关的层，初始化都比较正常 和同学讨论下这个nn.Embedding层的用处，之前对这个层一直不是太理解，大概目前的理解是传入的一个比如input_ids是[1, 14]这个shape的，首先其被转化成一个one-hot的表示也就是[1, 14, 30522(这个维度类似一个词典大小)]，然后过一个[30522, 768]的，两个乘在一起就有一种对应位把元素取出来的感觉，这样就得到了最终的embedding表示[1, 14, 768] 词表大小30522是针对input_ids embedding的，那么针对positional embedding就是max_seq_len，针对token type的就是2（只有0和1代表两类交替的） 2) forwardforward传入的参数中 input_ids **[1, seq_len]**：tensor([[ 101, 2762, 3786, 5619, 1016, 1011, 1014, 1998, 2180, 1996, 2088, 2452, 2345, 102]])，这是tokenizer.convert_tokens_to_ids()的结果应该，那边BERT好像还对应了个wordpiecetoken，101是[CLS]，102是[PAD] token_type_ids **[1, seq_len]**：tensor([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])，传入的没有[SEP]，只有一类token position_ids：暂时为None inputs_embeds：暂时为None step1：根据input_ids提取得到的seq_len长度，初始化position_ids **[1, seq_len]**：tensor([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]]) step2：获取input_embeds和token_type_embeddings，通过上面的传入参数以及nn.Embedding层，并把这两个加在一起 12345if inputs_embeds is None: inputs_embeds = self.word_embeddings(input_ids)token_type_embeddings = self.token_type_embeddings(token_type_ids)embeddings = inputs_embeds + token_type_embeddings embeddings.shape [1, seq_len, hidden_dim] step3：如果self.position_embedding_type是”absolute”绝对的话，就传入后加上position_embeddings，此时embeddings.shape **[1, seq_len, hidden_dim]**没有变化；absolute就是绝对位置编码，理解是[0, 1, 2, 3…]这样的绝对位置；还有一种position_embedding是相对位置编码的embedding，部分代码整合在了BertSelfAttention这个类中，博客参考：https://blog.csdn.net/chenf1995/article/details/122971023 123if self.position_embedding_type == &quot;absolute&quot;: position_embeddings = self.position_embeddings(position_ids) embeddings += position_embeddings step4：过LayerNorm和dropout，维度不会改变，BertEmbeddings这个类最终输出了一个embeddings [1, seq_len, hidden_dim]的信息，代表将要输入进入encoder结构部分的embeddinginput_embedding+token_type_embedding+position_embedding 123embeddings = self.LayerNorm(embeddings)embeddings = self.dropout(embeddings)return embeddings 3) 综合别人博客做一个总结word_embeddings是上文中subword tokenization对应的词嵌入； token_type_embeddings是用于表示当前词所在的句子，辅助区别句子与padding，句子对通过[SEP]分隔之间的差异； position_embeddings是句子中每个词的位置嵌入，用于区别词的顺序，博客说这个地方是训练出来的（从代码看确实如此），而不是计算得到固定嵌入，可能固定嵌入不利于拓展； 三个embedding层不带权重直接加在一起，过LayerNorm+dropout后产生输出，大小为**[batch_size, seq_len, hidden_size]** 4) 补充：positional embedding的不同方式https://zhuanlan.zhihu.com/p/121126531 背景： 词与词之间的顺序关系往往影响整个句子的含义，因此在对文本数据进行建模的时候需要考虑词与词之间的顺序关系； 建模文本中的顺序关系必须要使用positional encoding吗？-&gt; 不一定，只有使用位置不敏感的模型对文本数据进行建模的时候，才需要额外使用positional encoding；如果模型的输出会随着输入文本数据顺序的变化而变化，那么这个模型就是关于位置敏感的，反之则是位置不敏感的； 在常用的文本模型中，RNN类的就是关于位置敏感的，使用RNN类模型对文本数据建模的时候，模型结构天然考虑了文本中词与词之间的顺序关系。而以attention机制为核心的transformer则是位置不敏感的，使用这一类位置不敏感的模型的时候需要额外加入positional encoding引入文本中词与词的顺序关系； 具体操作： 对于transformer模型的positional encoding有两种主流方式：即绝对位置编码和相对位置编码 其中absolute positional embedding（绝对位置编码）是相对简单理解的，直接对不同位置随机初始化一个positional embedding，加到word embedding和token_type embedding上输入模型作为参数进行训练 另一种是relative positional embedding（相对位置编码），首先motivation是不同位置的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1 2和3 4距离都只差1，这些关于位置的相对含义模型通过绝对位置编码是否能够学习？绝对位置编码没有约束位置之间这些隐含关系，只能期待他隐式的学习到，所以是否有更合理的方法能够显式的让模型理解位置的相对关系？ 11111 详细看一下huggingface transformer代码中的这个部分，参数有”absolute”、”relative_key”和”relative_key_query”三种，这些参数在class BertSelfAttention(nn.Module)这个类中，而不是在最开始的BertEmbedding那块的 absolute：默认值，这部分就不用处理（对这个地方的处理在Embedding层） relative_key：对key_layer作处理，将其与这里的positional_embedding和key矩阵相乘作为key相关的位置编码； relative_key_query：对key和value都进行相乘以作为位置编码。 用下面代码简单加一下注释 12345678class BertSelfAttention(nn.Module): def __init__(self, config, position_embedding_type=None): super().__init__() ... if self.position_embedding_type == &quot;relative_key&quot; or self.position_embedding_type == &quot;relative_key_query&quot;: self.max_position_embeddings = config.max_position_embeddings # 512 self.distance_embedding = nn.Embedding(2 * config.max_position_embeddings - 1, self.attention_head_size) # [512*2-1, 64 (即hidden//head_num)] ... 12345678910111213141516171819202122# Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))if self.position_embedding_type == &quot;relative_key&quot; or self.position_embedding_type == &quot;relative_key_query&quot;: seq_length = hidden_states.size()[1] # 14 position_ids_l = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(-1, 1) # [14, 1]shape的tensor position_ids_r = torch.arange(seq_length, dtype=torch.long, device=hidden_states.device).view(1, -1) # [1, 14] distance = position_ids_l - position_ids_r # [seqlen, seq_len] positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1) # [seqlen, seqlen, hidden_size] positional_embedding = positional_embedding.to(dtype=query_layer.dtype) # fp16 compatibility # query_layer : batchsize, seqlen, hidden -&gt; batchsize, head_num, seqlen, hidden//head_num【multi-head】 # bhld,lrd -&gt; bhld不变，lrd去掉一个维度变成rd -&gt; bhld不变, rd转置变成dr -&gt; 乘 -&gt; bhlr if self.position_embedding_type == &quot;relative_key&quot;: relative_position_scores = torch.einsum(&quot;bhld,lrd-&gt;bhlr&quot;, query_layer, positional_embedding) attention_scores = attention_scores + relative_position_scores elif self.position_embedding_type == &quot;relative_key_query&quot;: relative_position_scores_query = torch.einsum(&quot;bhld,lrd-&gt;bhlr&quot;, query_layer, positional_embedding) relative_position_scores_key = torch.einsum(&quot;bhrd,lrd-&gt;bhlr&quot;, key_layer, positional_embedding) attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key seq_length：这句话的长度，比如14 position_ids_l：初始化是一个例如[14, 1]的向量，存储的类似于[[0], [1], [2] …]这样的 position_ids_r：初始化是一个例如[1, 14]的向量，存储的类似于[[0, 1, 2, 3, 4]]这样的 distance：初始化直接用position_ids_l-position_ids_r，这里直接广播减法，是一个[14, 14]维度的 因为这个地方是在attention这块来做的embedding，attention那边的scoreshape是[batch, head, seq_len, seq_len]的，代表query每个位置处对于key的注意力，那么可以在这里对query和key都搞positional embedding 通过上面几个做操作搞了一个positional_embedding = self.distance_embedding(distance + self.max_position_embeddings - 1)，这个有点不为什么每个要把512-1给加上，这样处理完后distance变成了如下所示的tensor 两个距离相隔最远是512，那么这样处理后能保证所有数字都是&gt;=0的，因为离的最远的也就是512了，然后最远的将会到达1023那个感觉 positional_embedding由distance_embedding层后得到，distance_embedding层的传入参数是[5122-1, 64 (即hidden//head_num)]也能理解了，因为词表大小是差不多0-1023的；；positional_embedding的shape是*[seq_len, seq_len, hidden]**的，如果是一个batch的话，那么应该是这个batch里面最大的那个seq_len？ 下面代码把query_layer[1, 12, 14, 64]和positional_embedding[14, 14, 64]作为这个torch.einsum的输入，这个地方参考文档https://zhuanlan.zhihu.com/p/361209187，就是把形状bhld,lrd的两个tensor加成一个bhlr的，这里为什么没用两个l可能是因为前面两个seq_len本质上一个来自于query，一个来自于key，而实际上是不需要等长的，只是一般操作默认为等长的了； 重点：这里以第一个作为示例，l和d在前后的箭头中都出现了，那就是在这两个维度上操作,query_layer[1, 12, 14, 64]和positional_embedding[14, 14, 64]，转置乘，出来一个relative_position_scores_query**[1, 12, 14, 14]**的，聚合来自position的信息 TODO：还弄得没那么明白，大概明白个意思，之后还要详细看看 12relative_position_scores_query = torch.einsum(&quot;bhld,lrd-&gt;bhlr&quot;, query_layer, positional_embedding)relative_position_scores_key = torch.einsum(&quot;bhrd,lrd-&gt;bhlr&quot;, key_layer, positional_embedding) 最后，执行下述代码，注意这个相对位置编码过程可以只对query做，也可以对query和key同时做 1attention_scores = attention_scores + relative_position_scores_query + relative_position_scores_key TODO： https://zhuanlan.zhihu.com/p/121126531这里还介绍到了：Sinusoidal Position Encoding和Complex embedding ·class BertSelfAttention：被BertAttention调用（※重点）1) init1234567891011121314151617181920212223242526class BertSelfAttention(nn.Module): def __init__(self, config, position_embedding_type=None): super().__init__() if config.hidden_size % config.num_attention_heads != 0 and not hasattr(config, &quot;embedding_size&quot;): raise ValueError( f&quot;The hidden size (&#123;config.hidden_size&#125;) is not a multiple of the number of attention &quot; f&quot;heads (&#123;config.num_attention_heads&#125;)&quot; ) self.num_attention_heads = config.num_attention_heads self.attention_head_size = int(config.hidden_size / config.num_attention_heads) self.all_head_size = self.num_attention_heads * self.attention_head_size self.query = nn.Linear(config.hidden_size, self.all_head_size) self.key = nn.Linear(config.hidden_size, self.all_head_size) self.value = nn.Linear(config.hidden_size, self.all_head_size) self.dropout = nn.Dropout(config.attention_probs_dropout_prob) self.position_embedding_type = position_embedding_type or getattr( config, &quot;position_embedding_type&quot;, &quot;absolute&quot; ) if self.position_embedding_type == &quot;relative_key&quot; or self.position_embedding_type == &quot;relative_key_query&quot;: self.max_position_embeddings = config.max_position_embeddings self.distance_embedding = nn.Embedding(2 * config.max_position_embeddings - 1, self.attention_head_size) self.is_decoder = config.is_decoder 这个地方是整个BERT架构中非常核心的区域 self.num_attention_heads = config.num_attention_heads：几头注意力机制，在config文件里这里设置为12（一般BERT也是12） self.attention_head_size = int(config.hidden_size / config.num_attention_heads)：config.hidden_size是768，所以每个头的hidden_size将会是768/12=64； self.all_head_size是self.num_attention_heads（12）再乘回self.attention_head_size（64），猜测这样的原因是因为整除造成的可能回来后就不是768了；从其他博客也看到和剪枝有关 self.query、self.key、self.value三个权重矩阵，都是一个hidden_size（768）到内部这个all_head_size（可能是768，也可能有损失）的转化； self.dropout = nn.Dropout(config.attention_probs_dropout_prob)：简单的dropout层； self.position_embedding_type：这与相对/绝对位置编码有关，如果是绝对位置编码那么在BertEmbedding层里面已经给结合进去了，如果是相对位置编码要在这里实现，不过这个地方暂时先跳过了； self.is_decoder = config.is_decoder：标识是否decoder，BERT只是一个encoder就不涉及到这个部分了； 2) forward1234def transpose_for_scores(self, x): new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size) x = x.view(new_x_shape) return x.permute(0, 2, 1, 3) 首先是这个函数，这个函数是拆多头用的，输入的x是[batch, seq_len, hidden]的，先指定new_shape是[batch, seq_len, num_attention_heads, attention_head_size]（一般可以认为是[batch, seq_len, 12, 64]），然后.view转化，然后再通过permute改变顺序为**[batch, attention_head_size, seq_len, num_attention_heads]**，这样是因为attention_head_size可以归为”batch“那边的维度了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def forward( self, hidden_states: torch.Tensor, attention_mask: Optional[torch.FloatTensor] = None, head_mask: Optional[torch.FloatTensor] = None, encoder_hidden_states: Optional[torch.FloatTensor] = None, encoder_attention_mask: Optional[torch.FloatTensor] = None, past_key_value: Optional[Tuple[Tuple[torch.FloatTensor]]] = None, output_attentions: Optional[bool] = False,) -&gt; Tuple[torch.Tensor]: mixed_query_layer = self.query(hidden_states) # 忽略了cross-attention部分 # hidden_states [batch, seqlen, hidden] key_layer = self.transpose_for_scores(self.key(hidden_states)) # [batch, num_head, seqlen_key, hidden//num_head] value_layer = self.transpose_for_scores(self.value(hidden_states)) query_layer = self.transpose_for_scores(mixed_query_layer) # [batch, num_head, seqlen_query, hidden//num_head] # Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores. attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) # # 忽略了相对位置编码的处理 attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # Apply the attention mask is (precomputed for all layers in BertModel forward() function) attention_scores = attention_scores + attention_mask # Normalize the attention scores to probabilities. attention_probs = nn.functional.softmax(attention_scores, dim=-1) # This is actually dropping out entire tokens to attend to, which might # seem a bit unusual, but is taken from the original Transformer paper. attention_probs = self.dropout(attention_probs) # Mask heads if we want to if head_mask is not None: attention_probs = attention_probs * head_mask context_layer = torch.matmul(attention_probs, value_layer) # [batch, num_head, seqlen, hidden//num_head] context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(new_context_layer_shape) outputs = (context_layer, attention_probs) if output_attentions else (context_layer,) # 忽略了is_decoder部分 return outputs 上面贴出来的这段代码省略了针对is_cross_attention（即encoder-decoder attention那个部分的一些处理），此外还忽略了if self.is_decoder:部分的处理，并且忽略了if self.position_embedding_type == &quot;relative_key&quot; 相对位置编码部分的处理； step1：首先是这个部分，hidden_states**[batch, seq_len, hidden_size]这个tensor过了self.query、self.value、self.key三个linear矩阵，由于这三个linear一般不改变hidden_size，这样得到的是三个[batch, seq_len, hidden_size]形状的tensor，通过上面提到的transpose_for_scores进行reshape，得到三个[batch, head_num, seq_len, attention_head_size]**（一般可以是[1, 12, seq_len, 768]）这样的tensor，并且被命名为key_layer、value_layer、query_layer 1234mixed_query_layer = self.query(hidden_states)key_layer = self.transpose_for_scores(self.key(hidden_states))value_layer = self.transpose_for_scores(self.value(hidden_states))query_layer = self.transpose_for_scores(mixed_query_layer) step2：这里就是Q·K^T那个部分了，转置就是在后两个维度上转置，输出的attention_scores是**[batch, head_num, seq_len, seq_len]**形状的tensor，代表query中每个位置处对key全局所有的注意力（后面要过softmax） 1attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) step3：依照博客简单理解一下不同的positional_embedding_type，这个部分暂时忽略了 123absolute：默认值，这部分就不用处理；relative_key：对key_layer作处理，将其与这里的positional_embedding和key矩阵相乘作为key相关的位置编码；relative_key_query：对key和value都进行相乘以作为位置编码。 step4：计算attention_scores，attention_probs；attention_scores在计算query和key的点乘后除以根号下d_k，注意这里的self.attention_head_size是64那个地方的，也就是分成12个头后每个头的hidden_size，如果带有attention_mask的话（注意，一般来说肯定是会有atttention_mask的，应该会在调用这个BertAttention的时候传给他，因为一个batch中大家不等长，肯定要通过mask padding到512这种感觉的） ；；在计算attention_scores时候用的是加法，因为softmax那块要一个很大的负数，比如-1e9这样的，然后过softmax，注意softmax的维度是-1代表query中每个token对所有key位置处的token的attention；；；最后过一个self.dropout，TODO：暂时有点没理解为什么在这里过dropout，而不是乘了之后 12345678910111213141516# Take the dot product between &quot;query&quot; and &quot;key&quot; to get the raw attention scores.attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2))# 忽略了相对位置编码的处理attention_scores = attention_scores / math.sqrt(self.attention_head_size)if attention_mask is not None: # Apply the attention mask is (precomputed for all layers in BertModel forward() function) attention_scores = attention_scores + attention_mask# Normalize the attention scores to probabilities.attention_probs = nn.functional.softmax(attention_scores, dim=-1)# This is actually dropping out entire tokens to attend to, which might# seem a bit unusual, but is taken from the original Transformer paper.attention_probs = self.dropout(attention_probs) step5：这里主要就是输出整合了，再reshape回去，变成了**[batch, seq_len, hidden_size]**的这个形状，另外看到config中output_attentions那个参数的作用，要不要把每层的这个attention返回回去，至此class BertSelfAttention(nn.Module)这个地方的forward结束了； 12345678context_layer = torch.matmul(attention_probs, value_layer)context_layer = context_layer.permute(0, 2, 1, 3).contiguous()new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,)context_layer = context_layer.view(new_context_layer_shape)outputs = (context_layer, attention_probs) if output_attentions else (context_layer,)return outputs ·class BertSelfOutput: 被BertAttention调用1) init&amp;forward123456789101112class BertSelfOutput(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states: torch.Tensor, input_tensor: torch.Tensor) -&gt; torch.Tensor: hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states 这个地方代码结构是相对比较简单的，这里也展现出了BERT中存在的一层add&amp;norm操作，这里应该还只是attention这个部分的内容 ·class BertAttention：被BertLayer调用 1) init123456class BertAttention(nn.Module): def __init__(self, config, position_embedding_type=None): super().__init__() self.self = BertSelfAttention(config, position_embedding_type=position_embedding_type) self.output = BertSelfOutput(config) self.pruned_heads = set() attention的实现还是不在这里，self.self这个是multi-head self attention机制的实现，self.output的操作是第一个这里完成的部分； 该层中使用到了self.pruned_heads = set()这样一种节约显存的技术，暂时没有了解太深； 2) forward12345678910111213141516171819202122def forward( self, hidden_states: torch.Tensor, attention_mask: Optional[torch.FloatTensor] = None, head_mask: Optional[torch.FloatTensor] = None, encoder_hidden_states: Optional[torch.FloatTensor] = None, encoder_attention_mask: Optional[torch.FloatTensor] = None, past_key_value: Optional[Tuple[Tuple[torch.FloatTensor]]] = None, output_attentions: Optional[bool] = False,) -&gt; Tuple[torch.Tensor]: self_outputs = self.self( hidden_states, attention_mask, head_mask, encoder_hidden_states, encoder_attention_mask, past_key_value, output_attentions, ) attention_output = self.output(self_outputs[0], hidden_states) outputs = (attention_output,) + self_outputs[1:] # add attentions if we output them return outputs 有了上面的BertSelfAttention和BertSelfOutput后，这个组件就比较好理解了 ·class BertIntermediate: 被BertLayer调用在BertAttention这个模块后，还有一个FFNN的操作，这里包含有激活函数；TODO：为什么有些地方需要激活函数，有些地方就不用？像CV那边的话，经常几个层过后就来一个激活，但是这里比如BertAttention里面就没有激活 1) init&amp;forward12345678910111213class BertIntermediate(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.intermediate_size) if isinstance(config.hidden_act, str): self.intermediate_act_fn = ACT2FN[config.hidden_act] else: self.intermediate_act_fn = config.hidden_act def forward(self, hidden_states: torch.Tensor) -&gt; torch.Tensor: hidden_states = self.dense(hidden_states) hidden_states = self.intermediate_act_fn(hidden_states) return hidden_states 这个里面调用了config.hidden_act，在config文件那边的话这个地方是&quot;gelu&quot;，对应的也就是gelu激活函数，整体来看这个层结构还是很简单的，其中注意dense这个层把768转化为一个config.intermediate_size3072了 ·class BertOutput: 被BertLayer调用注意这里不是BertSelfOutput，刚才那个是中间层的，这个是一个BLOCK的 1) init&amp;forward123456789101112class BertOutput(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.intermediate_size, config.hidden_size) self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states: torch.Tensor, input_tensor: torch.Tensor) -&gt; torch.Tensor: hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states 主要负责的也是一些整合，还有residual的部分，其中注意dense层把intermidiate_size又转化会config.hidden_size了 · class BertLayer(nn.Module)：被BertEncoder调用1) init12345678910111213def __init__(self, config): super().__init__() self.chunk_size_feed_forward = config.chunk_size_feed_forward self.seq_len_dim = 1 self.attention = BertAttention(config) self.is_decoder = config.is_decoder self.add_cross_attention = config.add_cross_attention if self.add_cross_attention: if not self.is_decoder: raise ValueError(f&quot;&#123;self&#125; should be used as a decoder model if cross attention is added&quot;) self.crossattention = BertAttention(config, position_embedding_type=&quot;absolute&quot;) self.intermediate = BertIntermediate(config) self.output = BertOutput(config) 可以简单理解为，依次调用了BertAttention、BertIntermediate、BertOutput完成了一个BLOCK的操作 2) forward1234567891011121314151617181920212223242526272829303132333435def forward( self, hidden_states: torch.Tensor, attention_mask: Optional[torch.FloatTensor] = None, head_mask: Optional[torch.FloatTensor] = None, encoder_hidden_states: Optional[torch.FloatTensor] = None, encoder_attention_mask: Optional[torch.FloatTensor] = None, past_key_value: Optional[Tuple[Tuple[torch.FloatTensor]]] = None, output_attentions: Optional[bool] = False,) -&gt; Tuple[torch.Tensor]: # decoder uni-directional self-attention cached key/values tuple is at positions 1,2 self_attn_past_key_value = past_key_value[:2] if past_key_value is not None else None self_attention_outputs = self.attention( hidden_states, attention_mask, head_mask, output_attentions=output_attentions, past_key_value=self_attn_past_key_value, ) # 忽略一些is_decoder的操作 attention_output = self_attention_outputs[0] outputs = self_attention_outputs[1:] # add self attentions if we output attention weights layer_output = apply_chunking_to_forward( self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output ) outputs = (layer_output,) + outputs # if decoder, return the attn key/values as the last output if self.is_decoder: outputs = outputs + (present_key_value,) return outputs 组装起来 · class BertEncoder(nn.Module)层结构1) init12345def __init__(self, config): super().__init__() self.config = config self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)]) self.gradient_checkpointing = False 在这里通过config.num_hidden_layers指定了这个BertLayer结构的层数，进一步详细查看BertLayer层的代码，应该对应的就是Transformer架构中如图所示的N×这个部分 2) forward主要是把N个Layer串接起来forward，返回值封装了一个类 123# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_outputs.py@dataclassclass BaseModelOutputWithPastAndCrossAttentions(ModelOutput): · class BertPooler：这个主要是针对[CLS]token又过了一个pooler 禁用的话：bertmodel初始化有一个配置add_pooling_layer默认为True，改成false就行 12345678910111213class BertPooler(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.activation = nn.Tanh() def forward(self, hidden_states: torch.Tensor) -&gt; torch.Tensor: # We &quot;pool&quot; the model by simply taking the hidden state corresponding # to the first token. first_token_tensor = hidden_states[:, 0] pooled_output = self.dense(first_token_tensor) pooled_output = self.activation(pooled_output) return pooled_output TODO：这里还有些内容不是很明白，待和zkh讨论，比如说为什么叫pool，然后[CLS]这个token为什么要做这些的操作 · class BertModel(): 各层组合在一起整体的说明1234567891011121314151617181920212223# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.pyclass BertModel(BertPreTrainedModel):embedding_output = self.embeddings( input_ids=input_ids, position_ids=position_ids, token_type_ids=token_type_ids, inputs_embeds=inputs_embeds, past_key_values_length=past_key_values_length,)encoder_outputs = self.encoder( embedding_output, attention_mask=extended_attention_mask, head_mask=head_mask, encoder_hidden_states=encoder_hidden_states, encoder_attention_mask=encoder_extended_attention_mask, past_key_values=past_key_values, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict,)sequence_output = encoder_outputs[0]pooled_output = self.pooler(sequence_output) if self.pooler is not None else None 重点代码感觉在这个部分，其他部分在制作一些mask类的地方 2.2.2 model.state_dict()· 加载预训练model这里加载的时候应该是用到了config.json文件和pytorch_model.bin这两个文件，而vocab.txt应该是tokenizer.from_pretrained()时候用到的，这里详细看一下config.json文件和pytorch_model.bin这两个文件是怎么被用到的 在加载模型后，可以通过打印model.state_dict()调试看到模型的各个参数，这里因为是from_pretrained的，所以已经加载了pytorch_model.bin文件中的内容，而且每次加载出来的结果也都是一样的。 1234# 预训练版本from transformers import BertTokenizer, BertModel, BertConfigconfig = BertConfig()model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;) 加载model，也就是BertModel.from_pretrained(pretrained_model_name_or_path)对应的函数在如下路径，这个地方只要是bert的模型结构，不管是bert-base还是bert-large是都可以通过这里加载的，主要就是读取对应的config.json文件和pytorch_model.bin这两个文件： /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py 12@classmethoddef from_pretrained(cls, pretrained_model_name_or_path: Optional[Union[str, os.PathLike]], *model_args, **kwargs): 1) 注解说明 从预训练的模型配置中实例化预训练的pytorch模型，该模型默认使用 model.eval()设置为评估模式； 和同学讨论后补充：model.eval()一般涉及到dropout层与normalization层；；；在BERT和这种NLP领域下，因为BN不怎么用，所以LN实际上只是单个样本内部在seq_len这个维度上做norm，就不涉及到eval这块了，也就是说在NLP任务的eval这里可能只影响到dropout层； 再补充一些BN上的细节，BN在做训练的时候，均值和方差来自于这一组batch的计算，在inference的时候，使用全局的均值和方差，这个全局的均值和方差由之前的每个mini-batch记录而来。 设是[batch, seq_len, hidden]，那么BN会计算出来一个[1, seq_len, hidden]的均值；；；LN就会计算出来一个[batch, 1, hidden]的均值，然后怎么怎么处理 输出的警告Weights from XXX not initialized from pretrained model表示XXX部分的权重没有出现，将使用模型其余部分进行训练，可以通过下游任务来微调这些权重： 如果把config文件的层数增加，比如从12层增加到14层的hidden layer结构，可以触发这个Warning Some weights of BertModel were not initialized from the model checkpoint at ./bert_base_uncased and are newly initialized: [‘bert.encoder.layer.13.attention.output.dense.weight’, ‘bert.encoder.layer.12.intermediate.dense.bias’, ‘bert.encoder.layer.13.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.dense.bias’, ‘bert.encoder.layer.13.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.weight’, ‘bert.encoder.layer.13.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.self.value.bias’, ‘bert.encoder.layer.12.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.13.output.dense.bias’, ‘bert.encoder.layer.13.intermediate.dense.bias’, ‘bert.encoder.layer.13.output.LayerNorm.bias’, ‘bert.encoder.layer.13.output.dense.weight’, ‘bert.encoder.layer.12.attention.self.value.weight’, ‘bert.encoder.layer.12.attention.self.query.bias’, ‘bert.encoder.layer.13.output.LayerNorm.weight’, ‘bert.encoder.layer.12.output.LayerNorm.weight’, ‘bert.encoder.layer.13.attention.self.query.bias’, ‘bert.encoder.layer.13.attention.self.query.weight’, ‘bert.encoder.layer.12.attention.self.key.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.12.attention.output.dense.bias’, ‘bert.encoder.layer.12.attention.self.key.bias’, ‘bert.encoder.layer.12.output.dense.weight’, ‘bert.encoder.layer.12.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.13.intermediate.dense.weight’, ‘bert.encoder.layer.12.output.LayerNorm.bias’, ‘bert.encoder.layer.13.attention.self.key.bias’, ‘bert.encoder.layer.12.intermediate.dense.weight’, ‘bert.encoder.layer.13.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.12.output.dense.bias’, ‘bert.encoder.layer.12.attention.output.dense.weight’] 输出的警告Weights from XXX not used in YYY表示预训练文件中的层XXX不被YYY使用，因此那些权重将被丢弃； 如果把config文件的层数减少，比如从12层减小到10层的hidden layer结构，可以触发这个Warning Some weights of the model checkpoint at ./bert_base_uncased were not used when initializing BertModel: [‘bert.encoder.layer.10.intermediate.dense.weight’, ‘cls.predictions.decoder.weight’, ‘cls.predictions.transform.dense.bias’, ‘bert.encoder.layer.11.attention.self.value.bias’, ‘bert.encoder.layer.11.attention.output.dense.bias’, ‘bert.encoder.layer.10.output.dense.bias’, ‘bert.encoder.layer.10.attention.self.key.bias’, ‘bert.encoder.layer.10.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.value.weight’, ‘bert.encoder.layer.11.attention.self.key.bias’, ‘bert.encoder.layer.11.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.LayerNorm.bias’, ‘bert.encoder.layer.11.output.dense.bias’, ‘cls.predictions.transform.LayerNorm.weight’, ‘bert.encoder.layer.10.attention.output.dense.bias’, ‘cls.seq_relationship.bias’, ‘bert.encoder.layer.10.attention.self.value.bias’, ‘bert.encoder.layer.10.attention.output.dense.weight’, ‘cls.predictions.bias’, ‘bert.encoder.layer.10.attention.self.query.weight’, ‘bert.encoder.layer.11.attention.self.query.bias’, ‘cls.predictions.transform.LayerNorm.bias’, ‘bert.encoder.layer.11.attention.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.query.bias’, ‘cls.predictions.transform.dense.weight’, ‘bert.encoder.layer.10.attention.output.LayerNorm.weight’, ‘bert.encoder.layer.10.output.dense.weight’, ‘bert.encoder.layer.11.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.self.query.weight’, ‘cls.seq_relationship.weight’, ‘bert.encoder.layer.11.attention.self.value.weight’, ‘bert.encoder.layer.11.intermediate.dense.weight’, ‘bert.encoder.layer.10.output.LayerNorm.weight’, ‘bert.encoder.layer.11.attention.output.dense.weight’, ‘bert.encoder.layer.10.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.dense.weight’, ‘bert.encoder.layer.11.intermediate.dense.bias’, ‘bert.encoder.layer.11.output.LayerNorm.bias’, ‘bert.encoder.layer.10.attention.self.key.weight’, ‘bert.encoder.layer.11.attention.output.LayerNorm.weight’] 这里额外输出了几个cls.xxx，就是说没有使用这些检查点的权重，从一些解释来看这些内容应该是要被下游分类器用到的，这些内容将被初始化重新训练。目前代码里只是直接简单应用了这个的输出，而没有针对下游任务fine-tune那些的过程； 2) 参数说明 pretrained_model_name_or_path (`str` or `os.PathLike`, *optional*) 1）可以是一个字符串代表model id，这个model id可以从huggingface.co上获取，比如直接使用bert-base-uncased，或者使用带有用户名称的这个model id例如hfl/chinese-macbert-base，这种使用方法下可能会从huggingface那边完成下载； 2）可以是一个包含有pytorch_model.bin和config.json文件的路径，例如./bert_base_uncased/，注意这个目录下的内容需要通过PreTrainedModel.save_pretrained方法来得到，否则保存出来的文件可能和transformer（huggingface这一套）不太配合； 3）其余用法不太常见或者一般不使用，好像可以从tensorflow和flax的checkpoint进行加载，如果设置为None的话就是通过其他办法已经把config和state_dict给加载进去了； output_attentions 用法：model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;) 这是一个可能相对再常用一点的参数，模型输出的output包含了一个output[&#39;attentions&#39;]的参数输出，在调试的时候发现他是一个长度为12的tuple（这里的长度12是bert的层数），tuple中每个位置上是 shape[1,12, seq_len, seq_len]（这里的长度12应该是multi-head的头数目），output_attentions应该是 softmax((query · key)/sqrt(d_k))的结果；注意shape[1,12, seq_len, seq_len]这个地方，softmax应该是在-1dim上做的，代表query中的每个位置处，对于每一个key的attention score，所以来做求和的话，应该能得到一个1的结果； 在后面看forward代码的时候，还要回来看一下这个地方 hidden_states 用法：model = BertModel.from_pretrained(&quot;./bert_base_uncased&quot;, output_hidden_states=True) 这是中间层（隐层）tensor的output输出，和output_attentions一样，这些内容既可以在from_pretrained中给带过去，也可以直接写在config.json文件里 上面可能是一些相对常用的参数，暂时理解来说在.from_pretrained(&quot;./bert_base_uncased&quot;)这个方法中带的其他一些参数可以和config加参数起到同样的效果，也就证明这个方法用到了config.json这个文件 3) 内部流程说明（※重点）内部这个地方还是写的比较详细的，像各种Exception也都实现的非常完整，大概理解一下其中的重点部分，主要目标就是加载config.json和pytorch_model.bin两个文件。 config.json和pytorch_model.bin应该只有model这边用到，tokenizer那边只用到vocab.txt；；从model.from_pretrained接收参数是一个路径，而tokenizer.from_pretrained接收参数是一个vocab.txt文件的路径或者上级路径感觉也能证明这一点 首先加载config.json 在下面这段代码中，config_path加载到了pretrained_model_name_or_path中的内容，也就是&quot;./bert_base_uncased&quot;，向下层cls.config_class.from_pretrained传递 1234567891011121314151617181920# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py# Load config if we don&#x27;t provide a configurationif not isinstance(config, PretrainedConfig): config_path = config if config is not None else pretrained_model_name_or_path config, model_kwargs = cls.config_class.from_pretrained( config_path, cache_dir=cache_dir, return_unused_kwargs=True, force_download=force_download, resume_download=resume_download, proxies=proxies, local_files_only=local_files_only, use_auth_token=use_auth_token, revision=revision, _from_auto=from_auto_class, _from_pipeline=from_pipeline, **kwargs, )else: model_kwargs = kwargs 这里debug调试了一下cls.config_class：&lt;class &#39;transformers.models.bert.configuration_bert.BertConfig&#39;&gt;，于是在去看BertConfig这块的.from_pretrained， 1234567891011121314# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py@classmethoddef from_pretrained(cls, pretrained_model_name_or_path: Union[str, os.PathLike], **kwargs) -&gt; &quot;PretrainedConfig&quot;: &quot;&quot;&quot; 一些注释，为了放在md里暂时删除了 &quot;&quot;&quot; config_dict, kwargs = cls.get_config_dict(pretrained_model_name_or_path, **kwargs) if &quot;model_type&quot; in config_dict and hasattr(cls, &quot;model_type&quot;) and config_dict[&quot;model_type&quot;] != cls.model_type: logger.warning( f&quot;You are using a model of type &#123;config_dict[&#x27;model_type&#x27;]&#125; to instantiate a model of type &quot; f&quot;&#123;cls.model_type&#125;. This is not supported for all configurations of models and can yield errors.&quot; ) return cls.from_dict(config_dict, **kwargs) 在往下看，调用了cls.get_config_dict这个函数，最后一路往下找，直到找到这里，加载json文件，返回一个dict对象，在上面那段代码里最后return了一个cls.from_dict 123456# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/configuration_utils.py@classmethoddef _dict_from_json_file(cls, json_file: Union[str, os.PathLike]): with open(json_file, &quot;r&quot;, encoding=&quot;utf-8&quot;) as reader: text = reader.read() return json.loads(text) 看了一下cls.from_dict，应该是这里最终返回了一个BertConfig类的对象，这里字典前面加两个*号是将字典解开成为独立的元素作为形参 其次加载pytorch_model.bin文件 通过在config_path目录下寻找文件，命中了pytorch_model.bin这个pytorch的checkpoint文件 找到这个文件后，这里做了一个和cache判断的操作，这个和huggingface这里实现可以到远程下载有关，如果过了这个函数后还是本地的路径，那就说明是用的本地的文件实现 123456789101112# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py# Load from URL or cache if already cachedresolved_archive_file = cached_path( archive_file, cache_dir=cache_dir, force_download=force_download, proxies=proxies, resume_download=resume_download, local_files_only=local_files_only, use_auth_token=use_auth_token, user_agent=user_agent,) 因为是pytorch形式的checkpoint，在这里load_state_dict() 把state_dict传入这里，进一步进行处理，这里返回就会有missing unexpect这些 1234567891011121314# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.pyelif from_pt: if low_cpu_mem_usage: cls._load_pretrained_model_low_mem(model, loaded_state_dict_keys, resolved_archive_file) else: model, missing_keys, unexpected_keys, mismatched_keys, error_msgs = cls._load_pretrained_model( model, state_dict, resolved_archive_file, pretrained_model_name_or_path, ignore_mismatched_sizes=ignore_mismatched_sizes, sharded_metadata=sharded_metadata, _fast_init=_fast_init, ) 在如下函数中完成比对操作，这里一些的输出错误经过state_dict的比对而发现，也就对应了“2.2.2节中，加载预训练model中第一部分，作者在开头给出的注解说明”，至此这两个文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176# /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/modeling_utils.py@classmethoddef _load_pretrained_model( cls, model, state_dict, resolved_archive_file, pretrained_model_name_or_path, ignore_mismatched_sizes=False, sharded_metadata=None, _fast_init=True,): # Retrieve missing &amp; unexpected_keys model_state_dict = model.state_dict() expected_keys = list(model_state_dict.keys()) loaded_keys = list(state_dict.keys()) if state_dict is not None else sharded_metadata[&quot;all_checkpoint_keys&quot;] prefix = model.base_model_prefix def _fix_key(key): if &quot;beta&quot; in key: return key.replace(&quot;beta&quot;, &quot;bias&quot;) if &quot;gamma&quot; in key: return key.replace(&quot;gamma&quot;, &quot;weight&quot;) return key loaded_keys = [_fix_key(key) for key in loaded_keys] if len(prefix) &gt; 0: has_prefix_module = any(s.startswith(prefix) for s in loaded_keys) expects_prefix_module = any(s.startswith(prefix) for s in expected_keys) else: has_prefix_module = False expects_prefix_module = False # key re-naming operations are never done on the keys # that are loaded, but always on the keys of the newly initialized model remove_prefix_from_model = not has_prefix_module and expects_prefix_module add_prefix_to_model = has_prefix_module and not expects_prefix_module if remove_prefix_from_model: expected_keys_not_prefixed = [s for s in expected_keys if not s.startswith(prefix)] expected_keys = [&quot;.&quot;.join(s.split(&quot;.&quot;)[1:]) if s.startswith(prefix) else s for s in expected_keys] elif add_prefix_to_model: expected_keys = [&quot;.&quot;.join([prefix, s]) for s in expected_keys] missing_keys = list(set(expected_keys) - set(loaded_keys)) unexpected_keys = list(set(loaded_keys) - set(expected_keys)) # Some models may have keys that are not in the state by design, removing them before needlessly warning # the user. if cls._keys_to_ignore_on_load_missing is not None: for pat in cls._keys_to_ignore_on_load_missing: missing_keys = [k for k in missing_keys if re.search(pat, k) is None] if cls._keys_to_ignore_on_load_unexpected is not None: for pat in cls._keys_to_ignore_on_load_unexpected: unexpected_keys = [k for k in unexpected_keys if re.search(pat, k) is None] if _fast_init: # retrieve unintialized modules and initialize uninitialized_modules = model.retrieve_modules_from_names( missing_keys, add_prefix=add_prefix_to_model, remove_prefix=remove_prefix_from_model ) for module in uninitialized_modules: model._init_weights(module) # Make sure we are able to load base models as well as derived models (with heads) start_prefix = &quot;&quot; model_to_load = model if len(cls.base_model_prefix) &gt; 0 and not hasattr(model, cls.base_model_prefix) and has_prefix_module: start_prefix = cls.base_model_prefix + &quot;.&quot; if len(cls.base_model_prefix) &gt; 0 and hasattr(model, cls.base_model_prefix) and not has_prefix_module: model_to_load = getattr(model, cls.base_model_prefix) if any(key in expected_keys_not_prefixed for key in loaded_keys): raise ValueError( &quot;The state dictionary of the model you are training to load is corrupted. Are you sure it was &quot; &quot;properly saved?&quot; ) if state_dict is not None: # Whole checkpoint mismatched_keys = [] if ignore_mismatched_sizes: for checkpoint_key in loaded_keys: model_key = checkpoint_key if remove_prefix_from_model: # The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it. model_key = f&quot;&#123;prefix&#125;.&#123;checkpoint_key&#125;&quot; elif add_prefix_to_model: # The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it. model_key = &quot;.&quot;.join(checkpoint_key.split(&quot;.&quot;)[1:]) if ( model_key in model_state_dict and state_dict[checkpoint_key].shape != model_state_dict[model_key].shape ): mismatched_keys.append( (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape) ) del state_dict[checkpoint_key] error_msgs = _load_state_dict_into_model(model_to_load, state_dict, start_prefix) else: # Sharded checkpoint # This should always be a list but, just to be sure. if not isinstance(resolved_archive_file, list): resolved_archive_file = [resolved_archive_file] error_msgs = [] for shard_file in resolved_archive_file: state_dict = load_state_dict(shard_file) # Mistmatched keys contains tuples key/shape1/shape2 of weights in the checkpoint that have a shape not # matching the weights in the model. mismatched_keys = [] if ignore_mismatched_sizes: for checkpoint_key in loaded_keys: model_key = checkpoint_key if remove_prefix_from_model: # The model key starts with `prefix` but `checkpoint_key` doesn&#x27;t so we add it. model_key = f&quot;&#123;prefix&#125;.&#123;checkpoint_key&#125;&quot; elif add_prefix_to_model: # The model key doesn&#x27;t start with `prefix` but `checkpoint_key` does so we remove it. model_key = &quot;.&quot;.join(checkpoint_key.split(&quot;.&quot;)[1:]) if ( model_key in model_state_dict and state_dict[checkpoint_key].shape != model_state_dict[model_key].shape ): mismatched_keys.append( (checkpoint_key, state_dict[checkpoint_key].shape, model_state_dict[model_key].shape) ) del state_dict[checkpoint_key] error_msgs += _load_state_dict_into_model(model_to_load, state_dict, start_prefix) if len(error_msgs) &gt; 0: error_msg = &quot;\\n\\t&quot;.join(error_msgs) raise RuntimeError(f&quot;Error(s) in loading state_dict for &#123;model.__class__.__name__&#125;:\\n\\t&#123;error_msg&#125;&quot;) if len(unexpected_keys) &gt; 0: logger.warning( f&quot;Some weights of the model checkpoint at &#123;pretrained_model_name_or_path&#125; were not used when &quot; f&quot;initializing &#123;model.__class__.__name__&#125;: &#123;unexpected_keys&#125;\\n&quot; f&quot;- This IS expected if you are initializing &#123;model.__class__.__name__&#125; from the checkpoint of a model trained on another task &quot; f&quot;or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).\\n&quot; f&quot;- This IS NOT expected if you are initializing &#123;model.__class__.__name__&#125; from the checkpoint of a model that you expect &quot; f&quot;to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).&quot; ) else: logger.info(f&quot;All model checkpoint weights were used when initializing &#123;model.__class__.__name__&#125;.\\n&quot;) if len(missing_keys) &gt; 0: logger.warning( f&quot;Some weights of &#123;model.__class__.__name__&#125; were not initialized from the model checkpoint at &#123;pretrained_model_name_or_path&#125; &quot; f&quot;and are newly initialized: &#123;missing_keys&#125;\\n&quot; f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot; ) elif len(mismatched_keys) == 0: logger.info( f&quot;All the weights of &#123;model.__class__.__name__&#125; were initialized from the model checkpoint at &#123;pretrained_model_name_or_path&#125;.\\n&quot; f&quot;If your task is similar to the task the model of the checkpoint was trained on, &quot; f&quot;you can already use &#123;model.__class__.__name__&#125; for predictions without further training.&quot; ) if len(mismatched_keys) &gt; 0: mismatched_warning = &quot;\\n&quot;.join( [ f&quot;- &#123;key&#125;: found shape &#123;shape1&#125; in the checkpoint and &#123;shape2&#125; in the model instantiated&quot; for key, shape1, shape2 in mismatched_keys ] ) logger.warning( f&quot;Some weights of &#123;model.__class__.__name__&#125; were not initialized from the model checkpoint at &#123;pretrained_model_name_or_path&#125; &quot; f&quot;and are newly initialized because the shapes did not match:\\n&#123;mismatched_warning&#125;\\n&quot; f&quot;You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.&quot; ) return model, missing_keys, unexpected_keys, mismatched_keys, error_msgs 4) 额外补充应该是这里的实例化把config给model传进去了，于是model需要的key可能少于、或者多于提供给他的key（pytorch_model.bin）,这里是一个super().__init__()，可能是调用到nn.Module这个上层了，然后依据传入的config不知道怎么操作，把层数什么的网络结构给拼上了；另：也有可能是要加载到这个/Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/modeling_bert.py里面的BertModel类，这样BertModel类是super代表的上层？ · 通过config加载空模型并设置seed如果是没有from_pretrained，而是通过model = BertModel()加载空模型的话，打印会看到初始化的参数，如下所示（另外注意，这种不从预训练文件中读取的话，需要加载config参数）：BertConfig、BertModel、BertTokenizer 1234# 空模型加载版本from transformers import BertTokenizer, BertModel, BertConfigconfig = BertConfig()model = BertModel(config) 这里如果再次尝试加载空模型的时候，因为参数是随机初始化的，所以参数初始化结果可能有所不同，如下图所示 通过set_seed进行指定，可以保证每次加载空模型时初始化的参数是一样的，set_seed的代码段如下，（实际使用上来说其实不一定需要写成这种函数的方式，直接写个几行就可以）： 1234567def setup_seed(seed): torch.manual_seed(seed) torch.cuda.manual_seed_all(seed) np.random.seed(seed) random.seed(seed) torch.backends.cudnn.deterministic = Truesetup_seed(42) # 设置随机数种子 这个地方加载config的时候直接用到的是config = BertConfig()，也就是BertConfig类中的内容，对这里进行了一下详细的调试，目前的理解是他实现了一个BertConfig类，继承自PretrainedConfig这个大类。平常在fine-tune阶段直接用到的config.json文件应该是从这个BertConfig保存而来的；；；如果要是自己训练的话，可能可以实现一个新的XxxConfig类，然后内部把参数什么的都设置为自己想要的，比如层数减少一些什么的 /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/models/bert/configuration_bert.py 1234567891011121314151617181920212223242526272829303132333435363738394041class BertConfig(PretrainedConfig): ... model_type = &quot;bert&quot; def __init__( self, vocab_size=30522, hidden_size=768, num_hidden_layers=12, num_attention_heads=12, intermediate_size=3072, hidden_act=&quot;gelu&quot;, hidden_dropout_prob=0.1, attention_probs_dropout_prob=0.1, max_position_embeddings=512, type_vocab_size=2, initializer_range=0.02, layer_norm_eps=1e-12, pad_token_id=0, position_embedding_type=&quot;absolute&quot;, use_cache=True, classifier_dropout=None, **kwargs ): super().__init__(pad_token_id=pad_token_id, **kwargs) self.vocab_size = vocab_size self.hidden_size = hidden_size self.num_hidden_layers = num_hidden_layers self.num_attention_heads = num_attention_heads self.hidden_act = hidden_act self.intermediate_size = intermediate_size self.hidden_dropout_prob = hidden_dropout_prob self.attention_probs_dropout_prob = attention_probs_dropout_prob self.max_position_embeddings = max_position_embeddings self.type_vocab_size = type_vocab_size self.initializer_range = initializer_range self.layer_norm_eps = layer_norm_eps self.position_embedding_type = position_embedding_type self.use_cache = use_cache self.classifier_dropout = classifier_dropout · 保存模型通过如下命令可以完成一个模型的保存，这样会在目录下生成config.json、pytorch_model.bin这两个文件，结合上面的BertConfig，如果有一个自己的模型的话，就可以魔改一下那边的XxxConfig，比如减小一些层数训练什么的，下次通过from_pretrained应该就可以加载回来了；；；这里也要集合下上面那个加载预训练model来一起看；；； 或者说，这套BertConfig和from transformers.models.bert import modeling_bert 那边的bert模型是对应的，只要修改BertConfig这些参数就可以制作自己的bert了，比如可能有BertTiny，或者其他版本的，都可以通过Bert这边的pipeline来走这样一个流程 1model.save_pretrained(&quot;directory_on_my_computer&quot;) 2.3 tokenizer1tokenizer = BertTokenizer(&quot;./bert_base_uncased/vocab.txt&quot;) tokenizer的from_pretrain在这里 /Users/curious/opt/miniconda3/envs/venv2/lib/python3.9/site-packages/transformers/tokenization_utils_base.py 1234567891011121314@classmethoddef from_pretrained(cls, pretrained_model_name_or_path: Union[str, os.PathLike], *init_inputs, **kwargs): # 这里省略了一些类似于本地没读到就远程下载的操作，绥中得到一个resolved_vocab_files文件向_from_pretrained传递 return cls._from_pretrained( resolved_vocab_files, pretrained_model_name_or_path, init_configuration, *init_inputs, use_auth_token=use_auth_token, cache_dir=cache_dir, **kwargs, ) TODO：这里是不是还有些加入特殊token的操作，曾经在一些论文代码里见过 tokenizer的作用就是把一句话按照vocab中转成一个id那个感觉，tokenizer.tokenize、tokenizer.convert_tokens_to_ids()和其反向的tokenizer_convert_ids_to_tokens比较常用； 3. Transformer&amp;BERT论文阅读中的重点记录3.1 Attention is all you need 就是那个指数，如果有一个特别大的，他softmax算出来就很趋向于1了 这个现象会随着指数的增大而明显，比如指数是3的时候，就不明显，指数是20的时候就很明显 3.2 BERTTODO","categories":[],"tags":[]},{"title":"服务器连接github与token的配置","slug":"mixed/git/服务器连接github与token的配置","date":"2022-11-18T08:23:08.000Z","updated":"2022-11-20T01:50:08.892Z","comments":true,"path":"2022/11/18/mixed/git/服务器连接github与token的配置/","link":"","permalink":"http://example.com/2022/11/18/mixed/git/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9E%E6%8E%A5github%E4%B8%8Etoken%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"有时候换了常用的git开发环境，在一个新环境上git clone，git push项目的时候，需要重新输入用户名和密码（token） 在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存","text":"有时候换了常用的git开发环境，在一个新环境上git clone，git push项目的时候，需要重新输入用户名和密码（token） 在2021年9月的时候，好像github放弃了密码改为token的方式，需要自己生成token并保存 服务器连接github与token配置1. 操作在github头像 -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens -&gt; Tokens -&gt; Generate new token 这里生成一个新的token，clone等操作的时候用这个token就可以","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"295场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/295场LeetCode周赛","date":"2022-06-19T09:42:21.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/06/19/algorithms/leetcode-weekly-contest/295场LeetCode周赛/","link":"","permalink":"http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/295%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 题目难度：t1(1299)+t2(1577)； 这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧； 第一题：简单字典计数； 第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。； 第三题：咕咕QAQ； 第四题：咕咕QAQ；","text":"周赛综述&amp;总结： 题目难度：t1(1299)+t2(1577)； 这周好像是因为从学校回家还是怎么的，只后来虚拟竞赛做了前两个题了，之后看第三题的难度达到了惊人的2100+，可能正好躲开了一次坐牢吧； 第一题：简单字典计数； 第二题：这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。； 第三题：咕咕QAQ； 第四题：咕咕QAQ； 第一题：2287.重排字符形成目标字符串【难度：1299】题目链接 题目大意给你两个下标从 0 开始的字符串 s 和 target 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。 从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。 示例1： 1234567输入：s = &quot;ilovecodingonleetcode&quot;, target = &quot;code&quot;输出：2解释：对于 &quot;code&quot; 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。对于 &quot;code&quot; 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。形成的字符串分别是 &quot;ecod&quot; 和 &quot;code&quot; ，都可以重排为 &quot;code&quot; 。可以形成最多 2 个 &quot;code&quot; 的副本，所以返回 2 。 示例2 123456输入：s = &quot;abcba&quot;, target = &quot;abc&quot;输出：1解释：选取下标为 0 、1 和 2 的字符，可以形成 &quot;abc&quot; 的 1 个副本。 可以形成最多 1 个 &quot;abc&quot; 的副本，所以返回 1 。注意，尽管下标 3 和 4 分别有额外的 &#x27;a&#x27; 和 &#x27;b&#x27; ，但不能重用下标 2 处的 &#x27;c&#x27; ，所以无法形成 &quot;abc&quot; 的第 2 个副本。 示例3： 12345输入：s = &quot;abbaccaddaeea&quot;, target = &quot;aaaaa&quot;输出：1解释：选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 &quot;aaaaa&quot; 的 1 个副本。可以形成最多 1 个 &quot;aaaaa&quot; 的副本，所以返回 1 。 提示： 1 &lt;= s.length &lt;= 100 1 &lt;= target.length &lt;= 10 s 和 target 由小写英文字母组成 分析和解答简单字典计数； 123456789101112131415class Solution(object): def rearrangeCharacters(self, s, target): &quot;&quot;&quot; :type s: str :type target: str :rtype: int &quot;&quot;&quot; cnt_s = Counter(s) cnt_target = Counter(target) res = 1e9 for key, value in cnt_target.items(): res = min(res, cnt_s[key]//value) return res 第二题：2288.价格减免【难度：1577】题目链接 题目大意句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 &#39;$&#39; 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。 例如 &quot;$100&quot;、&quot;$23&quot; 和 &quot;$6.75&quot; 表示价格，而 &quot;100&quot;、&quot;$&quot; 和 &quot;2$3&quot; 不是。 注意：本题输入中的价格均为整数。 给你一个字符串 sentence 和一个整数 discount 。对于每个表示价格的单词，都在价格的基础上减免 discount% ，并 更新 该单词到句子中。所有更新后的价格应该表示为一个 恰好保留小数点后两位 的数字。 返回表示修改后句子的字符串。 示例1： 123456输入：sentence = &quot;there are $1 $2 and 5$ candies in the shop&quot;, discount = 50输出：&quot;there are $0.50 $1.00 and 5$ candies in the shop&quot;解释：表示价格的单词是 &quot;$1&quot; 和 &quot;$2&quot; 。 - &quot;$1&quot; 减免 50% 为 &quot;$0.50&quot; ，所以 &quot;$1&quot; 替换为 &quot;$0.50&quot; 。- &quot;$2&quot; 减免 50% 为 &quot;$1&quot; ，所以 &quot;$1&quot; 替换为 &quot;$1.00&quot; 。 示例2： 123456输入：sentence = &quot;1 2 $3 4 $5 $6 7 8$ $9 $10$&quot;, discount = 100输出：&quot;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$&quot;解释：任何价格减免 100% 都会得到 0 。表示价格的单词分别是 &quot;$3&quot;、&quot;$5&quot;、&quot;$6&quot; 和 &quot;$9&quot;。每个单词都替换为 &quot;$0.00&quot;。 提示： 1 &lt;= sentence.length &lt;= 10^5 sentence 由小写英文字母、数字、&#39; &#39; 和 &#39;$&#39; 组成 sentence 不含前导和尾随空格 sentence 的所有单词都用单个空格分隔 所有价格都是 正 整数且不含前导零 所有价格 最多 为 10 位数字 0 &lt;= discount &lt;= 100 分析和解答这个题加了很多限制，开始想用正则表达式整花活整了半天，最后发现还是模拟来得好。。。； P.S. 借这个题想说好讨厌这种描述又长，又带着小数的题啊，感觉不像是正路的题目； 12345678910111213141516171819202122232425class Solution(object): def discountPrices(self, sentence, discount): &quot;&quot;&quot; :type sentence: str :type discount: int :rtype: str &quot;&quot;&quot; tmp_list = sentence.split() res_list = [] for i in range(len(tmp_list)): if tmp_list[i][0] == &#x27;$&#x27;: try: tmp = int(tmp_list[i][1:]) tmp = tmp - (tmp * discount * 1.0 /100) tmp = &#x27;&#123;:.2f&#125;&#x27;.format(tmp) tmp = &#x27;$&#x27; + tmp res_list.append(tmp) except: res_list.append(tmp_list[i]) else: res_list.append(tmp_list[i]) return &#x27; &#x27;.join(res_list)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"}]},{"title":"296场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/296场LeetCode周赛","date":"2022-06-19T08:56:36.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/06/19/algorithms/leetcode-weekly-contest/296场LeetCode周赛/","link":"","permalink":"http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/296%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 题目难度：t1(1241)+t2(1416)+t3(1445)； 难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟/贪心就可以完成了； 第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环； 第二题：排序后贪心，维护一个组内的最大最小值； 第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化； 第四题：咕咕QAQ；","text":"周赛综述&amp;总结： 题目难度：t1(1241)+t2(1416)+t3(1445)； 难度非常小的一周周赛，半个小时做了三个题居然排名都到1716去了，第四个题还是日常咕咕了。对于前三个题的话没有什么太过于特殊的思路，基本按照题目要求模拟/贪心就可以完成了； 第一题：按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环； 第二题：排序后贪心，维护一个组内的最大最小值； 第三题：题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化； 第四题：咕咕QAQ； 第一题：2293.极大极小游戏【难度：1241】题目链接 题目大意给你一个下标从 0 开始的整数数组 nums ，其长度是 2 的幂。 对 nums 执行下述算法： 设 n 等于 nums 的长度，如果 n == 1 ，终止 算法过程。否则，创建 一个新的整数数组 newNums ，新数组长度为 n / 2 ，下标从 0 开始。 对于满足 0 &lt;= i &lt; n / 2 的每个 偶数 下标 i ，将 newNums[i] 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。 对于满足 0 &lt;= i &lt; n / 2 的每个 奇数 下标 i ，将 newNums[i] 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。 用 newNums 替换 nums 。 从步骤 1 开始 重复 整个过程。 执行算法后，返回 nums 中剩下的那个数字。 示例1： 1234567输入：nums = [1,3,5,2,4,8,2,2]输出：1解释：重复执行算法会得到下述数组。第一轮：nums = [1,5,4,2]第二轮：nums = [1,4]第三轮：nums = [1]1 是最后剩下的那个数字，返回 1 。 示例2： 123输入：nums = [3]输出：3解释：3 就是最后剩下的数字，返回 3 。 提示： 1 &lt;= nums.length &lt;= 1024 1 &lt;= nums[i] &lt;= 10^9 nums.length 是 2 的幂 分析和解答按照题目要求模拟即可，注意在这里使用了while 1 + 条件break的那种循环； 1234567891011121314151617181920212223242526class Solution(object): def minMaxGame(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 1: return nums[0] while 1: tmp = [] idx = 0 for i in range(0, len(nums), 2): if idx % 2 == 0: tmp.append(min(nums[i], nums[i+1])) idx += 1 else: tmp.append(max(nums[i], nums[i+1])) idx += 1 # print(tmp) nums = copy.deepcopy(tmp) if len(tmp) == 1: break # print(tmp) return tmp[0] 第二题：2294.划分数组使最大差为 K【难度：1416】题目链接 题目大意给你一个整数数组 nums 和一个整数 k 。你可以将 nums 划分成一个或多个 子序列 ，使 nums 中的每个元素都 恰好 出现在一个子序列中。 在满足每个子序列中最大值和最小值之间的差值最多为 k 的前提下，返回需要划分的 最少 子序列数目。 子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。 示例1： 1234567输入：nums = [3,6,1,2,5], k = 2输出：2解释：可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。 示例2： 1234567输入：nums = [1,2,3], k = 1输出：2解释：可以将 nums 划分为两个子序列 [1,2] 和 [3] 。第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。 示例3： 12345678输入：nums = [2,2,4,5], k = 0输出：3解释：可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^5 0 &lt;= k &lt;= 10^5 分析和解答排序后贪心，维护一个组内的最大最小值； 12345678910111213141516171819202122232425262728293031class Solution(object): def partitionArray(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; nums.sort() res = [] now_min = nums[0] now_max = nums[0] tmp = [nums[0]] for i in range(1, len(nums)): now_min = min(now_min, nums[i]) now_max = max(now_max, nums[i]) chazhi = abs(now_max-now_min) if chazhi &lt;= k: tmp.append(nums[i]) else: res.append(tmp) tmp = [nums[i]] now_min = nums[i] now_max = nums[i] res.append(tmp) # print(res) return len(res) 第三题：2295.替换数组中的元素【难度：1445】题目链接 题目大意给你一个下标从 0 开始的数组 nums ，它包含 n 个 互不相同 的正整数。请你对这个数组执行 m 个操作，在第 i 个操作中，你需要将数字 operations[i][0] 替换成 operations[i][1] 。 题目保证在第 i 个操作中： operations[i][0] 在 nums 中存在。 operations[i][1] 在 nums 中不存在。 请你返回执行完所有操作后的数组。 示例1： 1234567输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]输出：[3,2,7,1]解释：我们对 nums 执行以下操作：- 将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。- 将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。- 将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。返回最终数组 [3,2,7,1] 。 示例2： 1234567输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]]输出：[2,1]解释：我们对 nums 执行以下操作：- 将数字 1 替换为 3 。nums 变为 [3,2] 。- 将数字 2 替换为 1 。nums 变为 [3,1] 。- 将数字 3 替换为 2 。nums 变为 [2,1] 。返回最终数组 [2,1] 。 提示： n == nums.length m == operations.length 1 &lt;= n, m &lt;= 10^5 nums 中所有数字 互不相同 。 operations[i].length == 2 1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 10^6 在执行第 i 个操作时，operations[i][0] 在 nums 中存在。 在执行第 i 个操作时，operations[i][1] 在 nums 中不存在。 分析和解答题目加上了很多特殊的限制，限制了一些比较极端情况的出现，就显得比较人性化； 1234567891011121314151617181920212223242526272829303132class Solution(object): def arrayChange(self, nums, operations): &quot;&quot;&quot; :type nums: List[int] :type operations: List[List[int]] :rtype: List[int] &quot;&quot;&quot; d = &#123;&#125; for i in range(len(nums)): d[nums[i]] = [nums[i], nums[i], i] # print(d) for i in range(len(operations)): old, new = operations[i][0], operations[i][1] tmp_list = d[old] d[old] = [new, tmp_list[1], tmp_list[2]] d[new] = d[old] del d[old] tmp_res = [] for key, value in d.items(): tmp_res.append([value[0], value[2]]) tmp_res.sort(key=lambda x: x[1]) # print(tmp_res) res = [] for i in range(len(tmp_res)): res.append(tmp_res[i][0]) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"297场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/297场LeetCode周赛","date":"2022-06-19T07:54:36.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/06/19/algorithms/leetcode-weekly-contest/297场LeetCode周赛/","link":"","permalink":"http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/297%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 题目难度：t1(1283)+t2(1658)+t3(1886)； 这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧； 第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来； 第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉； 第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对； 第四题：咕咕QAQ；","text":"周赛综述&amp;总结： 题目难度：t1(1283)+t2(1658)+t3(1886)； 这周实在是人被虐傻了，一个半小时内只把第一个题坎坷的做出来了。第二个题问题定义很奇怪，还真是第一次见这么写转移的，没想到本质上不是搜索问题而是dp问题，后来给zy做那个周赛题的时候可能也积累到一种思路，就是说看起来像是dfs的问题如果数据范围比较奇怪的话，可能背后隐藏的就是dp类的问题。如果说第二题看起来像搜索但其实不是搜索，那么第三题就看起来不像搜索实际上是个搜索（略有点超出能力范围了），本来自己想了一种n进制的方法，但是无奈超时了，n进制状态压缩也算是给自己积累个思路吧； 第一题：理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来； 第二题：看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉； 第三题：暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对； 第四题：咕咕QAQ； 第一题：2303.计算应缴税款总额【难度：1283】题目链接 题目大意给你一个下标从 0 开始的二维整数数组 brackets ，其中 brackets[i] = [upperi, percenti] ，表示第 i 个税级的上限是 upperi ，征收的税率为 percenti 。税级按上限 从低到高排序（在满足 0 &lt; i &lt; brackets.length 的前提下，upperi-1 &lt; upperi）。 税款计算方式如下： 不超过 upper0 的收入按税率 percent0 缴纳 接着 upper1 - upper0 的部分按税率 percent1 缴纳 然后 upper2 - upper1 的部分按税率 percent2 缴纳 以此类推 给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 10^-5 的结果将被视作正确答案。 示例1： 1234567输入：brackets = [[3,50],[7,10],[12,25]], income = 10输出：2.65000解释：前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。 示例2： 123456输入：brackets = [[1,0],[4,25],[5,50]], income = 2输出：0.25000解释：前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。需要支付的税款总计 $0 + $0.25 = $0.25 。 示例3： 1234输入：brackets = [[2,50]], income = 0输出：0.00000解释：没有收入，无需纳税，需要支付的税款总计 $0 。 提示： 1 &lt;= brackets.length &lt;= 100 1 &lt;= upperi &lt;= 1000 0 &lt;= percenti &lt;= 100 0 &lt;= income &lt;= 1000 upperi 按递增顺序排列 upperi 中的所有值 互不相同 最后一个税级的上限大于等于 income 分析和解答理解下题意就可以，做一个差值的存储，这里差值的存储一开始搞错了，如果从前往后更新的话前边的变了后边的也就跟着变了，要用一个新的或者从后往前来； 123456789101112131415161718192021222324class Solution(object): def calculateTax(self, brackets, income): &quot;&quot;&quot; :type brackets: List[List[int]] :type income: int :rtype: float &quot;&quot;&quot; for i in range(len(brackets)-1, 0, -1): brackets[i][0] = brackets[i][0] - brackets[i-1][0] # print(brackets) res = 0 i = 0 for i in range(len(brackets)): if income &gt;= brackets[i][0]: res += ((brackets[i][0] * brackets[i][1] * 1.0) / 100) income -= brackets[i][0] i += 1 else: res += ((income * brackets[i][1] * 1.0) / 100) i += 1 break return res 第二题：2304.网格中的最小路径代价【难度：1658】题目链接 题目大意给你一个下标从 0 开始的整数矩阵 grid ，矩阵大小为 m x n ，由从 0 到 m * n - 1 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 (x, y) ，且满足 x &lt; m - 1 ，你可以移动到 (x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1) 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。 每次可能的移动都需要付出对应的代价，代价用一个下标从 0 开始的二维数组 moveCost 表示，该数组大小为 (m * n) x n ，其中 moveCost[i][j] 是从值为 i 的单元格移动到下一行第 j 列单元格的代价。从 grid 最后一行的单元格移动的代价可以忽略。 grid 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。 示例1： 1234567输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]输出：17解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。- 路径途经单元格值之和 5 + 0 + 1 = 6 。- 从 5 移动到 0 的代价为 3 。- 从 0 移动到 1 的代价为 8 。路径总代价为 6 + 3 + 8 = 17 。 示例2： 1234567输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]输出：6解释：最小代价的路径是 2 -&gt; 3 。 - 路径途经单元格值之和 2 + 3 = 5 。 - 从 2 移动到 3 的代价为 1 。 路径总代价为 5 + 1 = 6 。 提示： m == grid.length n == grid[i].length 2 &lt;= m, n &lt;= 50 grid 由从 0 到 m * n - 1 的不同整数组成 moveCost.length == m * n moveCost[i].length == n 1 &lt;= moveCost[i][j] &lt;= 100 分析和解答看上去像是dfs但实际上是个dp，也算提醒自己很多dfs题目但是看起来数据超范围的了，就可以用dp的思路给干掉； 123456789101112131415161718192021class Solution(object): def minPathCost(self, grid, moveCost): &quot;&quot;&quot; :type grid: List[List[int]] :type moveCost: List[List[int]] :rtype: int &quot;&quot;&quot; m, n = len(grid), len(grid[0]) base = grid[0] for i in range(1, m): # 遍历m行 new_base = [1e99 for _ in range(n)] # n个 # 下面是一个从当前n个状态（base，用j代表）到下n个状态（用k表示）的转移，从上一行的n个转移到下一行的n个，每个地方取最优的dp for j in range(n): for k in range(n): new_base[k] = min(new_base[k], base[j]+grid[i][k]+moveCost[grid[i-1][j]][k]) # 选一个所有状态转移里最小的 base = new_base return min(base) 第三题：2305.公平分发饼干【难度：1886】题目链接 题目大意给你一个整数数组 cookies ，其中 cookies[i] 表示在第 i 个零食包中的饼干数量。另给你一个整数 k 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。 分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。 返回所有分发的最小不公平程度。 示例1： 1234567输入：cookies = [8,15,10,20,8], k = 2输出：31解释：一种最优方案是 [8,15,8] 和 [10,20] 。- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。分发的不公平程度为 max(31,30) = 31 。可以证明不存在不公平程度小于 31 的分发方案。 示例2： 12345678输入：cookies = [6,1,3,2,2,4,1,2], k = 3输出：7解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 - 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。分发的不公平程度为 max(7,7,7) = 7 。可以证明不存在不公平程度小于 7 的分发方案。 提示： 2 &lt;= cookies.length &lt;= 8 1 &lt;= cookies[i] &lt;= 10^5 2 &lt;= k &lt;= cookies.length 分析和解答暂时不记录这个题的正确解法了，这种题能想到搜索的思路怎么都还是觉得有点怪，有点没找到突破口，记录一个自己的k进制状态转移方法，虽然超时了但是能保证暴力对； 12345678910111213141516171819202122232425262728293031323334353637383940414243# 超时解法27/36class Solution(object): def distributeCookies(self, cookies, k): &quot;&quot;&quot; :type cookies: List[int] :type k: int :rtype: int &quot;&quot;&quot; res = 1e99 def f(n, x, padding_len): #n为待转换的十进制数，x为机制，取值为2-16 a=[0,1,2,3,4,5,6,7,8,9,&#x27;A&#x27;,&#x27;b&#x27;,&#x27;C&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;F&#x27;] b=[] while True: s=n//x # 商 y=n%x # 余数 b=b+[y] if s==0: break n=s b.reverse() tmp = [] for i in b: tmp.append(a[i]) return tmp + [0] * (padding_len - len(tmp)) for i in range(k**len(cookies)): tmp = f(i, k, len(cookies)) d = defaultdict(int) tmp_max = 0 for i in range(len(tmp)): d[tmp[i]] += cookies[i] # print(d) if len(d) != k: continue else: tmp_max = max([x for x in d.values()]) res = min(res, tmp_max) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"}]},{"title":"298场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/298场LeetCode周赛","date":"2022-06-19T06:58:33.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/06/19/algorithms/leetcode-weekly-contest/298场LeetCode周赛/","link":"","permalink":"http://example.com/2022/06/19/algorithms/leetcode-weekly-contest/298%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 题目难度：t1(1427)+t2(1646)+t3(1871)； 近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧； 第一题：小偷了一鸡，直接用 lower 和 upper 转了一下，如果是其他语言可能会想用一下 &#39;A&#39;-&#39;a&#39; 那类的操作吧； 第二题：思路主要是想 num 减几次那个数字后，能变成一个 mod10 = 0 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了； 第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧； 第四题：咕咕QAQ；","text":"周赛综述&amp;总结： 题目难度：t1(1427)+t2(1646)+t3(1871)； 近几周周赛频繁被虐，属实有点打击自信了。前两个题不管怎么说还是用奇奇怪怪的方法给做出来了（这次第二个题感觉还是相对比较难一次AC的，可能需要面向badcase微调一下），第三个题又是直接卡住了，现在复盘来想一想自己的思路在哪里偏了，被题目的case有些迷惑了，然后对于这种数组保留的，有时候正着添加不如反着考虑删除吧； 第一题：小偷了一鸡，直接用 lower 和 upper 转了一下，如果是其他语言可能会想用一下 &#39;A&#39;-&#39;a&#39; 那类的操作吧； 第二题：思路主要是想 num 减几次那个数字后，能变成一个 mod10 = 0 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了； 第三题：比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧； 第四题：咕咕QAQ； 第一题：5242.兼具大小写的最好英文字母【难度：1427】题目链接 题目大意给你一个由英文字母组成的字符串 s ，请你找出并返回 s 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。 最好 英文字母的大写和小写形式必须 都 在 s 中出现。 英文字母 b 比另一个英文字母 a 更好 的前提是：英文字母表中，b 在 a 之 后 出现。 示例1： 1234输入：s = &quot;lEeTcOdE&quot;输出：&quot;E&quot;解释：字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。 示例2： 12345输入：s = &quot;arRAzFif&quot;输出：&quot;R&quot;解释：字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。 示例3： 1234输入：s = &quot;AbCdEfGhIjK&quot;输出：&quot;&quot;解释：不存在大写和小写形式都出现的字母。 提示： 1 &lt;= s.length &lt;= 1000 s 由小写和大写英文字母组成 分析和解答小偷了一鸡，直接用 lower 和 upper 转了一下，如果是其他语言可能会想用一下 &#39;A&#39;-&#39;a&#39; 那类的操作吧； 123456789101112131415161718192021class Solution(object): def greatestLetter(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; res = [] d = &#123;&#125; for i in range(len(s)): d[s[i]] = True for key, value in d.items(): if d.get(key.upper()) is not None and d.get(key.lower()) is not None: res += key.upper() res.sort() if len(res): return res[-1] else: return &quot;&quot; 第二题：5218.个位数字为 K 的整数之和【难度：1646】题目链接 题目大意给你两个整数 num 和 k ，考虑具有以下属性的正整数多重集： 每个整数个位数字都是 k 。 所有整数之和是 num 。 返回该多重集的最小大小，如果不存在这样的多重集，返回 -1 。 注意： 多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 0 。 个位数字 是数字最右边的数位。 示例1： 123456输入：num = 58, k = 9输出：2解释：多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。另一个满足条件的多重集是 [19,39] 。可以证明 2 是满足题目条件的多重集的最小长度。 示例2： 123输入：num = 37, k = 2输出：-1解释：个位数字为 2 的整数无法相加得到 37 。 示例3： 123输入：num = 0, k = 7输出：0解释：空多重集的和为 0 。 提示： 0 &lt;= num &lt;= 3000 0 &lt;= k &lt;= 9 分析和解答思路主要是想 num 减几次那个数字后，能变成一个 mod10 = 0 的数字，这样的话减几次那个数字就变成贪心了，主要一些比较偏的特殊case，面向答案调整下就过了； 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def minimumNumbers(self, num, k): &quot;&quot;&quot; :type num: int :type k: int :rtype: int &quot;&quot;&quot; if num == 0: return 0 if k != 0: cnt = 0 if num % 10 == 0: cnt = -1 res = 0 while num &gt; 0: if num % 10 == 0: cnt += 1 if cnt == 1: break num -= k res += 1 if num &lt; 0: return -1 return res else: if num % 10 == 0 and num != 0: return 1 elif num % 10 == 0 and num == 0: return 0 else: return -1 第三题：6099.小于等于 K 的最长二进制子序列【难度：1871】题目链接 题目大意给你一个二进制字符串 s 和一个正整数 k 。 请你返回 s 的 最长 子序列，且该子序列对应的 二进制 数字小于等于 k 。 注意： 子序列可以有 前导 0 。 空字符串视为 0 。 子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。 示例1： 12345输入：s = &quot;1001010&quot;, k = 5输出：5解释：s 中小于等于 5 的最长子序列是 &quot;00010&quot; ，对应的十进制数字是 2 。注意 &quot;00100&quot; 和 &quot;00101&quot; 也是可行的最长子序列，十进制分别对应 4 和 5 。最长子序列的长度为 5 ，所以返回 5 。 示例2： 1234输入：s = &quot;00101001&quot;, k = 1输出：6解释：&quot;000001&quot; 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。最长子序列的长度为 6 ，所以返回 6 。 提示： 1 &lt;= s.length &lt;= 1000 s[i] 要么是 &#39;0&#39; ，要么是 &#39;1&#39; 。 1 &lt;= k &lt;= 10^9 分析和解答比赛的时候还是没什么思路，现在感觉来说不要被题目的case迷惑住了，对于这种数组保留的有时候要反向着想一想转化成删除的问题。然后这题后来看到别人的思路就是说所有0都是可以被保留的，因为假设存在一种没有保存所有0的情况，那么一定可以用0替换掉一个最高位的1，这样这个数字还会是小于等于k的，只能说这种贪心思路不好想想到也不是很敢写吧； 1234567891011121314151617181920class Solution(object): def longestSubsequence(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: int &quot;&quot;&quot; summ = 0 remove = 0 s = s[::-1] for i in range(len(s)): if s[i] == &#x27;1&#x27;: if summ &gt;= k: remove += 1 else: if summ + (1 &lt;&lt; i) &gt; k: remove += 1 summ += (1 &lt;&lt; i) # 左移i位置，优先加小位置的 return len(s) - remove","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"}]},{"title":"294场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/294场LeetCode周赛","date":"2022-05-24T08:06:58.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/05/24/algorithms/leetcode-weekly-contest/294场LeetCode周赛/","link":"","permalink":"http://example.com/2022/05/24/algorithms/leetcode-weekly-contest/294%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 from decimal import Decimal，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG； 第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己； 第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死； 第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：[[1,1],[500000000,499999999],[1000000000,999999998]] 实际上差值是非常接近的； 第四题：咕咕QAQ；","text":"周赛综述&amp;总结： 快乐羽毛球就没有现场做这场周赛了hh，事后发现好像还是最好没有现场做这一场周赛，前三个题目都很简单但是各有各的坑，包括小数的向下取整保存，还有两个小数点后特别多位数精度比较的问题，要 from decimal import Decimal，然后用这样的对象来比，总之感觉就是一场奇奇怪怪的周赛哈哈哈哈，如果真的按时参加的话心态可能要崩，全都是奇奇怪怪的BUG； 第一题：按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己； 第二题：理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死； 第三题：好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：[[1,1],[500000000,499999999],[1000000000,999999998]] 实际上差值是非常接近的； 第四题：咕咕QAQ； 第一题：2278.字母在字符串中的百分比题目链接 题目大意给你一个字符串 s 和一个字符 letter ，返回在 s 中等于 letter 字符所占的 百分比 ，向下取整到最接近的百分比。 示例1： 1234输入：s = &quot;foobar&quot;, letter = &quot;o&quot;输出：33解释：等于字母 &#x27;o&#x27; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。 示例2： 1234输入：s = &quot;jjjj&quot;, letter = &quot;k&quot;输出：0解释：等于字母 &#x27;k&#x27; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。 提示： 1 &lt;= s.length &lt;= 100 s 由小写英文字母组成 letter 是一个小写英文字母 分析和解答按照题目的要求来统计就行，注意要向下取整实际上直接完成整除就可以，做的时候还在那小数点搞来搞去的也是服了自己； 12345678910111213141516171819class Solution(object): def percentageLetter(self, s, letter): &quot;&quot;&quot; :type s: str :type letter: str :rtype: int &quot;&quot;&quot; cnt = 0 for i in range(len(s)): if s[i] == letter: cnt += 1 return cnt * 100 // len(s) &quot;&quot;&quot; res = (cnt * 1.0 / len(s) ) * 100 r = int(str(res).split(&#x27;.&#x27;)[0]) return r &quot;&quot;&quot; 第二题：2279.装满石头的背包的最大数量题目链接 题目大意现有编号从 0 到 n - 1 的 n 个背包。给你两个下标从 0 开始的整数数组 capacity 和 rocks 。第 i 个背包最大可以装 capacity[i] 块石头，当前已经装了 rocks[i] 块石头。另给你一个整数 additionalRocks ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。 请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。 示例1： 123456789输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2输出：3解释：1 块石头放入背包 0 ，1 块石头放入背包 1 。每个背包中的石头总数是 [2,3,4,4] 。背包 0 、背包 1 和 背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。 示例2： 123456789输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100输出：3解释：8 块石头放入背包 0 ，2 块石头放入背包 2 。每个背包中的石头总数是 [10,2,2] 。背包 0 、背包 1 和背包 2 都装满石头。总计 3 个背包装满石头，所以返回 3 。可以证明不存在超过 3 个背包装满石头的情况。注意，不必用完所有的额外石头。 提示： n == capacity.length == rocks.length 1 &lt;= n &lt;= 5 * 10^4 1 &lt;= capacity[i] &lt;= 10^9 0 &lt;= rocks[i] &lt;= capacity[i] 1 &lt;= additionalRocks &lt;= 10^9 分析和解答理解题意后按照差值排个序贪心就可以，这题目写的带上背包也是笑死； 123456789101112131415161718192021class Solution(object): def maximumBags(self, capacity, rocks, additionalRocks): &quot;&quot;&quot; :type capacity: List[int] :type rocks: List[int] :type additionalRocks: int :rtype: int &quot;&quot;&quot; cha = [] for i in range(len(capacity)): cha.append(capacity[i]-rocks[i]) cha.sort() cnt = 0 for i in range(len(cha)): if cha[i] &lt;= additionalRocks: cnt += 1 additionalRocks -= cha[i] return cnt 第三题：2280.表示一个折线图的最少线段数题目链接 题目大意给你一个二维整数数组 stockPrices ，其中 stockPrices[i] = [day_i, price_i] 表示股票在 day_i 的价格为 price_i 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子： 请你返回要表示一个折线图所需要的 最少线段数 。 示例1： 123456789输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]输出：3解释：上图为输入对应的图，横坐标表示日期，纵坐标表示价格。以下 3 个线段可以表示折线图：- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。可以证明，无法用少于 3 条线段表示这个折线图。 示例2： 1234输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]输出：1解释：如上图所示，折线图可以用一条线段表示。 提示： 1 &lt;= stockPrices.length &lt;= 10^5 stockPrices[i].length == 2 1 &lt;= day_i, price_i &lt;= 10^9 所有 day_i 互不相同 。 分析和解答好几个坑点，首先需要按照days来排序否则顺序可能是乱的，其次注意每次days之间的差值不一定是1，再其次注意精度问题！精度这个问题属实是个大坑，出题人感觉也是瞄准了这一点的罚时，其中有一个badcase是：[[1,1],[500000000,499999999],[1000000000,999999998]] 实际上差值是非常接近的； 12345678910111213141516171819202122class Solution: def minimumLines(self, stockPrices: List[List[int]]) -&gt; int: from decimal import Decimal if len(stockPrices) == 1: return 0 stockPrices.sort(key=lambda x: (x[0], x[1])) # print(stockPrices) k = 0 res = 1 for i in range(1, len(stockPrices)): tmp = Decimal(stockPrices[i][1] - stockPrices[i-1][1]) / Decimal((stockPrices[i][0] - stockPrices[i-1][0])) if i == 1: continue prev = Decimal(stockPrices[i-1][1] - stockPrices[i-2][1])/ Decimal(stockPrices[i-1][0] - stockPrices[i-2][0]) if prev == tmp: continue else: res += 1 return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://example.com/tags/%E5%87%A0%E4%BD%95/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"293场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/293场LeetCode周赛","date":"2022-05-15T08:24:58.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/05/15/algorithms/leetcode-weekly-contest/293场LeetCode周赛/","link":"","permalink":"http://example.com/2022/05/15/algorithms/leetcode-weekly-contest/293%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh 第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 i 和 i-1 之间不相同就可以了，python的话可以用 Counter 小偷一鸡，其他语言可以用字符串排序后做比较； 第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 10^9 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了； 第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 for j in range(len(a[0])) 放在 for i in range(len(a)) 之外，但是内部循环还是 a[i][j] 就可以了； 第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了；","text":"周赛综述&amp;总结： 没想到一周过后学校就各个地方都封了，快乐没有了啊gg，感觉最近也是越来越没干劲，还是通过多刷一刷题缓解迷茫吧~ 周赛练思路，平常练面试基础题了，之前朋友说的“基础不牢，地动山摇”是真的太有道理了，上一周也是又被上了一课hhh 第一题：第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 i 和 i-1 之间不相同就可以了，python的话可以用 Counter 小偷一鸡，其他语言可以用字符串排序后做比较； 第二题：是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 10^9 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了； 第三题：二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 for j in range(len(a[0])) 放在 for i in range(len(a)) 之外，但是内部循环还是 a[i][j] 就可以了； 第四题：这种多次区间维护和查询的操作感觉看起来就很像是线段树的题目了，咕咕了； 第一题：5234.移除字母异位词后的结果数组题目链接 题目大意给你一个下标从 0 开始的字符串 words ，其中 words[i] 由小写英文字符组成。 在一步操作中，需要选出任一下标 i ，从 words 中 删除 words[i] 。其中下标 i 需要同时满足下述两个条件： 0 &lt; i &lt; words.length words[i - 1] 和 words[i] 是 字母异位词 。 只要可以选出满足条件的下标，就一直执行这个操作。 在执行所有操作后，返回 words 。可以证明，按任意顺序为每步操作选择下标都会得到相同的结果。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。例如，&quot;dacb&quot; 是 &quot;abdc&quot; 的一个字母异位词。 示例1： 1234567891011输入：words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]输出：[&quot;abba&quot;,&quot;cd&quot;]解释：获取结果数组的方法之一是执行下述步骤：- 由于 words[2] = &quot;bbaa&quot; 和 words[1] = &quot;baba&quot; 是字母异位词，选择下标 2 并删除 words[2] 。 现在 words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;] 。- 由于 words[1] = &quot;baba&quot; 和 words[0] = &quot;abba&quot; 是字母异位词，选择下标 1 并删除 words[1] 。 现在 words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;] 。- 由于 words[2] = &quot;cd&quot; 和 words[1] = &quot;cd&quot; 是字母异位词，选择下标 2 并删除 words[2] 。 现在 words = [&quot;abba&quot;,&quot;cd&quot;] 。无法再执行任何操作，所以 [&quot;abba&quot;,&quot;cd&quot;] 是最终答案。 示例2： 1234输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]解释：words 中不存在互为字母异位词的两个相邻字符串，所以无需执行任何操作。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length &lt;= 10 words[i] 由小写英文字母组成 分析和解答第一题还是要仔细读题，然后按照题目的内容模拟操作就可以了，这里开始开读错了一次题，应该是前后 i 和 i-1 之间不相同就可以了，python的话可以用 Counter 小偷一鸡，其他语言可以用字符串排序后做比较； 1234567891011121314151617181920class Solution(object): def removeAnagrams(self, words): &quot;&quot;&quot; :type words: List[str] :rtype: List[str] &quot;&quot;&quot; i = 1 res = [] init_cnt = Counter(words[0]) res.append(words[0]) while i &lt; len(words): if Counter(words[i]) == init_cnt: i += 1 continue else: init_cnt = Counter(words[i]) res.append(words[i]) i += 1 return res 第二题：6064.不含特殊楼层的最大连续楼层数题目链接 题目大意Alice 管理着一家公司，并租用大楼的部分楼层作为办公空间。Alice 决定将一些楼层作为 特殊楼层 ，仅用于放松。 给你两个整数 bottom 和 top ，表示 Alice 租用了从 bottom 到 top（含 bottom 和 top 在内）的所有楼层。另给你一个整数数组 special ，其中 special[i] 表示 Alice 指定用于放松的特殊楼层。 返回不含特殊楼层的 最大 连续楼层数。 示例1： 1234567输入：bottom = 2, top = 9, special = [4,6]输出：3解释：下面列出的是不含特殊楼层的连续楼层范围：- (2, 3) ，楼层数为 2 。- (5, 5) ，楼层数为 1 。- (7, 9) ，楼层数为 3 。因此，返回最大连续楼层数 3 。 示例2： 123输入：bottom = 6, top = 8, special = [7,6,8]输出：0解释：每层楼都被规划为特殊楼层，所以返回 0 。 提示 1 &lt;= special.length &lt;= 10^5 1 &lt;= bottom &lt;= special[i] &lt;= top &lt;= 10^9 special 中的所有值 互不相同 分析和解答是个哨兵的题，开始应该注意一下时间复杂度的，另外空间和时间复杂度一样应该是不能开到 10^9 这个级别的，应该注意下题目示例说明，那样感觉很容易就能想到是加哨兵然后遍历的思路了； 1234567891011121314151617181920class Solution(object): def maxConsecutive(self, bottom, top, special): &quot;&quot;&quot; :type bottom: int :type top: int :type special: List[int] :rtype: int &quot;&quot;&quot; special.append(bottom-1) special.append(top+1) special.sort() print(special) res = 0 for i in range(1, len(special)): res = max(res, special[i]-special[i-1]-1) return res 第三题：6065.按位与结果大于零的最长组合题目链接 题目大意对数组 nums 执行 按位与 相当于对数组 nums 中的所有整数执行 按位与 。 例如，对 nums = [1, 5, 3] 来说，按位与等于 1 &amp; 5 &amp; 3 = 1 。 同样，对 nums = [7] 而言，按位与等于 7 。 给你一个正整数数组 candidates 。计算 candidates 中的数字每种组合下 按位与 的结果。 candidates 中的每个数字在每种组合中只能使用 一次 。 返回按位与结果大于 0 的 最长 组合的长度。 示例1： 1234567输入：candidates = [16,17,71,62,12,24,14]输出：4解释：组合 [16,17,62,24] 的按位与结果是 16 &amp; 17 &amp; 62 &amp; 24 = 16 &gt; 0 。组合长度是 4 。可以证明不存在按位与结果大于 0 且长度大于 4 的组合。注意，符合长度最大的组合可能不止一种。例如，组合 [62,12,24,14] 的按位与结果是 62 &amp; 12 &amp; 24 &amp; 14 = 8 &gt; 0 。 示例2： 1234输入：candidates = [8,8]输出：2解释：最长组合是 [8,8] ，按位与结果 8 &amp; 8 = 8 &gt; 0 。组合长度是 2 ，所以返回 2 。 提示： 1 &lt;= candidates.length &lt;= 10^5 1 &lt;= candidates[i] &lt;= 10^7 分析和解答二进制的题目，本来开始的时候没有什么思路，后来边和同学讨论边做，同学说要不要先转化成二进制看看，然后转成二进制后发现只要纵向遍历，看看哪一列的1最多就可以了，根据之前刷题的经验，纵向遍历就是把 for j in range(len(a[0])) 放在 for i in range(len(a)) 之外，但是内部循环还是 a[i][j] 就可以了； 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def largestCombination(self, candidates): &quot;&quot;&quot; :type candidates: List[int] :rtype: int &quot;&quot;&quot; candidates.sort() def convert_to_bin(num, pad=31): tmp_list = [] while num &gt; 0: tmp_list.append(num&amp;1) num &gt;&gt;= 1 tmp_list.reverse() tmp_list = [0] * (pad-len(tmp_list)) + tmp_list return tmp_list a = [] for i in range(len(candidates)): a.append(convert_to_bin(candidates[i])) # print(candidates[i], convert_to_bin(candidates[i])) res = 0 for j in range(len(a[0])): tmp = 0 for i in range(len(a)): if a[i][j] == 1: tmp += 1 res = max(res, tmp) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"}]},{"title":"292场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/292场LeetCode周赛","date":"2022-05-08T12:39:50.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/05/08/algorithms/leetcode-weekly-contest/292场LeetCode周赛/","link":"","permalink":"http://example.com/2022/05/08/algorithms/leetcode-weekly-contest/292%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 22222 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 @lru_cache(1000*1000) 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg 第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快； 第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的； 第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了； 第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！32.最长有效括号，注意这个题的优化剪枝！","text":"周赛综述&amp;总结： 打完羽毛球的一场周赛哈哈哈，好累感觉思想敏捷度也跟着有点疲惫了hh，不过这也不是自己做不出来的理由！第三题自己把 22222 这种case的可能情况给推错了，也怪不了什么了hhhh，最后一题实际上就是个简单dfs，python有 @lru_cache(1000*1000) 可以偷鸡，总结来说还是第三题占用时间太长了，自己把规律推错了找错了，gg 第一题：第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快； 第二题：双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的； 第三题：像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了； 第四题：存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！32.最长有效括号，注意这个题的优化剪枝！ 第一题：6056.字符串中最大的 3 位相同数字题目链接 题目大意给你一个字符串 num ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 优质整数 ： 该整数是 num 的一个长度为 3 的 子字符串 。 该整数由唯一一个数字重复 3 次组成。 以字符串形式返回 最大的优质整数 。如果不存在满足要求的整数，则返回一个空字符串 &quot;&quot; 。 注意： 子字符串 是字符串中的一个连续字符序列。 num 或优质整数中可能存在 前导零 。 示例1： 1234输入：num = &quot;6777133339&quot;输出：&quot;777&quot;解释：num 中存在两个优质整数：&quot;777&quot; 和 &quot;333&quot; 。&quot;777&quot; 是最大的那个，所以返回 &quot;777&quot; 。 示例2： 123输入：num = &quot;2300019&quot;输出：&quot;000&quot;解释：&quot;000&quot; 是唯一一个优质整数。 示例3： 123输入：num = &quot;42352338&quot;输出：&quot;&quot;解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。 提示： 3 &lt;= num.length &lt;= 1000 num 仅由数字（0 - 9）组成 分析和解答第一题要慢慢读题，一次读明白然后就开始写，这次虽然2分半左右做完了，但是居然错了一次，好久好久没有第一次错过了。。。确实应该注意下边界条件和角标的，不能只追求快； 另外来说的话，三个数是一样的，水仙花数hh！ 12345678910111213141516class Solution(object): def largestGoodInteger(self, num): &quot;&quot;&quot; :type num: str :rtype: str &quot;&quot;&quot; res = -1 for i in range(len(num)-2): tmp = num[i:i+3] if tmp[0] == tmp[1] and tmp[1] == tmp[2]: res = max(int(tmp), res) if res == -1: return &quot;&quot; else: return (3 - len(str(res))) * &quot;0&quot; + str(res) 第二题：6057.统计值等于子树平均值的节点数题目链接 题目大意给你一棵二叉树的根节点 root ，找出并返回满足要求的节点数，要求节点的值等于其 子树 中值的 平均值 。 注意： n 个元素的平均值可以由 n 个元素 求和 然后再除以 n ，并 向下舍入 到最近的整数。 root 的 子树 由 root 和它的所有后代组成。 示例 1： 12345678输入：root = [4,8,5,0,1,null,6]输出：5解释：对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。对值为 0 的节点：子树的平均值 0 / 1 = 0 。对值为 1 的节点：子树的平均值 1 / 1 = 1 。对值为 6 的节点：子树的平均值 6 / 1 = 6 。 示例 2： 123输入：root = [1]输出：1解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。 提示： 树中节点数目在范围 [1, 1000] 内 0 &lt;= Node.val &lt;= 1000 分析和解答双重dfs（树的前序遍历）套在一起，非常暴力的做法了，这个题手速有点跟不上来了，主要还是树里的dfs没做的那么熟悉，每遇到一次就练习一下吧，这个题还是很暴力的； 写一个函数是 count_mean 然后再在dfs中把这个套进去！ 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def __init__(self): self.cnt = 0 self.val_sum = 0 self.res = 0 def averageOfSubtree(self, root): &quot;&quot;&quot; :type root: Optional[TreeNode] :rtype: int &quot;&quot;&quot; def count_mean(root): # 统计一个子树的均值 if root is None: return 0 self.val_sum += root.val self.cnt += 1 count_mean(root.left) count_mean(root.right) # 外面再套一层dfs？ def dfs(root): if root is None: return self.val_sum = 0 self.cnt = 0 count_mean(root) if self.val_sum/self.cnt == root.val: self.res += 1 # print(self.cnt) # print(self.val_sum) dfs(root.left) dfs(root.right) dfs(root) return self.res 第三题：6058.统计打字方案数题目链接 题目大意Alice 在给 Bob 用手机打字。数字到字母的 对应 如下图所示。 为了 打出 一个字母，Alice 需要 按 对应字母 i 次，i 是该字母在这个按键上所处的位置。 比方说，为了按出字母 &#39;s&#39; ，Alice 需要按 &#39;7&#39; 四次。类似的， Alice 需要按 &#39;5&#39; 两次得到字母 &#39;k&#39; 。 注意，数字 &#39;0&#39; 和 &#39;1&#39; 不映射到任何字母，所以 Alice 不 使用它们。 但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 按键的字符串信息 。 比方说，Alice 发出的信息为 &quot;bob&quot; ，Bob 将收到字符串 &quot;2266622&quot; 。 给你一个字符串 pressedKeys ，表示 Bob 收到的字符串，请你返回 Alice 总共可能发出多少种文字信息 。 由于答案可能很大，将它对 10^9 + 7 取余 后返回。 示例1： 123456输入：pressedKeys = &quot;22233&quot;输出：8解释：Alice 可能发出的文字信息包括：&quot;aaadd&quot;, &quot;abdd&quot;, &quot;badd&quot;, &quot;cdd&quot;, &quot;aaae&quot;, &quot;abe&quot;, &quot;bae&quot; 和 &quot;ce&quot; 。由于总共有 8 种可能的信息，所以我们返回 8 。 示例2： 12345输入：pressedKeys = &quot;222222222222222222222222222222222222&quot;输出：82876089解释：总共有 2082876103 种 Alice 可能发出的文字信息。由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。 提示： 1 &lt;= pressedKeys.length &lt;= 10^5 pressedKeys 只包含数字 &#39;2&#39; 到 &#39;9&#39; 。 分析和解答像是数学找规律的题目，背后隐藏的其实是dp的内容，有点像跳台阶那种做法，可惜自己规律找错了没有写出来，具体内容写在详解里的照片中了； 另外在代码实现上，发现直接初始化所有的这种类似于离线的操作可能会超时，所以来说的话还是写了一版动态的思路，参照之前的经验， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution(object): def countTexts(self, pressedKeys): &quot;&quot;&quot; :type pressedKeys: str :rtype: int &quot;&quot;&quot; &quot;&quot;&quot; # 写法1，方法应该没问题，但是初始化的时候太耗时了，可能就被边界卡了 if len(pressedKeys) == 0: return 0 max_len = len(pressedKeys) + 5 MOD = 10**9 + 7 # 这个过程有点太耗时了，这里可能要换一种动态的写法，因为太多位置是没用的了？ # 非7，9的递推方程 f_1 = [0] * max_len # 写不写成for好像没区别 f_1[1], f_1[2], f_1[3] = 1, 2, 4 # 7，9的递推方程 f_2 = [0] * max_len f_2[1], f_2[2], f_2[3], f_2[4] = 1, 2, 4, 8 # 简化为一个循环 for i in range(4, max_len): f_1[i] = f_1[i-1] + f_1[i-2] + f_1[i-3] if i != 4: f_2[i] = f_2[i-1] + f_2[i-2] + f_2[i-3] + f_2[i-4] # 开始分组统计 res = 1 pressedKeys += &#x27;#&#x27; # 哨兵 now_str = pressedKeys[0] cnt = 1 i = 1 while i &lt; len(pressedKeys): if pressedKeys[i] == now_str: cnt += 1 else: if now_str == &#x27;7&#x27; or now_str == &#x27;9&#x27;: res *= f_2[cnt] % MOD else: res *= f_1[cnt] % MOD cnt = 1 now_str = pressedKeys[i] i += 1 return res % MOD &quot;&quot;&quot; # 写法2，把写法1的方法转成动态的，或者相对更加记忆化一点 f_1 = [0, 1, 2, 4] # 角标直接对应上 f_2 = [0, 1, 2, 4, 8] i = 1 cnt = 1 pressedKeys += &#x27;#&#x27; now_str = pressedKeys[0] res = 1 while i &lt; len(pressedKeys): if pressedKeys[i] == now_str: cnt += 1 else: if now_str == &#x27;7&#x27; or now_str == &#x27;9&#x27;: try: res *= f_2[cnt] except: for j in range(len(f_2), cnt+1): # 注，这里实际上不推荐append的写法，最好是初始化一个很长的，往里填 f_2.append(f_2[j-1] + f_2[j-2] + f_2[j-3] + f_2[j-4]) res *= f_2[cnt] else: try: res *= f_1[cnt] except: for j in range(len(f_1), cnt+1): f_1.append(f_1[j-1] + f_1[j-2] + f_1[j-3]) res *= f_1[cnt] cnt = 1 now_str = pressedKeys[i] i += 1 return res % (10**9 + 7) 第四题：6059.检查是否有合法括号字符串路径题目链接 题目大意一个括号字符串是一个 非空 且只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串。如果下面 任意 条件为 真 ，那么这个括号字符串就是 合法的 。 字符串是 () 。 字符串可以表示为 AB（A 连接 B），A 和 B 都是合法括号序列。 字符串可以表示为 (A) ，其中 A 是合法括号序列。 给你一个 m x n 的括号网格图矩阵 grid 。网格图中一个 合法括号路径 是满足以下所有条件的一条路径： 路径开始于左上角格子 (0, 0) 。 路径结束于右下角格子 (m - 1, n - 1) 。 路径每次只会向 下 或者向 右 移动。 路径经过的格子组成的括号字符串是 合法 的。 如果网格图中存在一条 合法括号路径 ，请返回 true ，否则返回 false 。 示例 1： 123456输入：grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]输出：true解释：上图展示了两条路径，它们都是合法括号字符串路径。第一条路径得到的合法字符串是 &quot;()(())&quot; 。第二条路径得到的合法字符串是 &quot;((()))&quot; 。注意可能有其他的合法括号字符串路径。 示例2： 123输入：grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]输出：false解释：两条可行路径分别得到 &quot;))(&quot; 和 &quot;)((&quot; 。由于它们都不是合法括号字符串，我们返回 false 。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 100 grid[i][j] 要么是 &#39;(&#39; ，要么是 &#39;)&#39; 。 分析和解答存在，还有路径类的可以说是dfs的题目；而最小，走迷宫类的题目就是比较经典的bfs题目；这个题是个括号场景下的dfs题目，括号场景的题做多了就发现实际上不用栈什么的做匹配，而是直接记录左括号的数目，在一个右括号过来的时候看看左括号还有没有剩余可供匹配的就可以了，还可以参考这个题目，是个栈来判断最长满足条件的！32.最长有效括号 在优化剪枝上，一种是 @lru_cache(1000*1000) 靠着编译器来优化，另外一种是记录visited数组，类似于下面图里写的意思，还有就是说匹配上的括号长度一定是 偶数 的： 这个题还遇到很多玄学问题，就是说两个优化都加上就过不了，但是只留其中一个优化就可以。。。dfs结构还是比较简单的！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from functools import lru_cacheclass Solution(object): def __init__(self): self.flag = False self.already_true = &#123;&#125; self.grid = None def hasValidPath(self, grid:List[List[str]]) -&gt; bool: &quot;&quot;&quot; :type grid: List[List[str]] :rtype: bool &quot;&quot;&quot; # 只能往下，或者往右移动 dx = [1, 0] dy = [0, 1] n = len(grid) m = len(grid[0]) self.grid = grid # n,m实际上也可以搞到self.里去 if (n+m) % 2 == 0: return False @lru_cache(1000*1000) def dfs(x:int, y:int, left_kh_cnt:int, n:int, m:int) -&gt; None: if left_kh_cnt &lt; 0: return # 剪枝条件是，路径上某个位置，在相同left_kh_cnt条件下，是否出现过了 # 这里原理上的解释是 if self.already_true.get((x,y,left_kh_cnt)) is None: self.already_true[(x,y,left_kh_cnt)] = True # print(&quot;self.already_true: &quot;, self.already_true) else: return if x == n-1 and y == m-1 and left_kh_cnt == 0: # 恰好匹配 self.flag = True return # 1. 先写dfs逻辑，剩下逻辑随之适配 for i in range(2): nx = x + dx[i] ny = y + dy[i] if nx &gt;= 0 and nx &lt; n and ny &gt;= 0 and ny &lt; m: if self.grid[nx][ny] == &#x27;(&#x27;: dfs(nx, ny, left_kh_cnt+1, n, m) else: dfs(nx, ny, left_kh_cnt-1, n, m) if self.grid[0][0] == &#x27;(&#x27; or self.grid[-1][-1] != &#x27;(&#x27;: dfs(0, 0, 1, n, m) else: return False return self.flag","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"正则表达式学习","slug":"正则表达式学习","date":"2022-05-06T02:59:58.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2022/05/06/正则表达式学习/","link":"","permalink":"http://example.com/2022/05/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/","excerpt":"在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~ 另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~ 菜鸟工具在线正则表达式验证工具","text":"在刷LeetCode的时候发现很多恶心的字符串规则判断题目都可以转化成正则表达式来做，也正好通过这些题来熟悉下正则的用法，未来还是希望能自己在不查的情况下凭空写出来正则的~ 另外作为一个nlp的同学，正则不会还是差点意思啊哈哈哈，这个博客可能以后会不断扩充吧~ 菜鸟工具在线正则表达式验证工具 菜鸟工具在线正则表达式验证工具:https://c.runoob.com/front-end/854/ 正则总结匹配数字相关\\d 是匹配一个数字（0到9），在程序实现上一般需要再用 \\ 转义一下，即 \\\\d 如果要匹配多个数字的话，就使用 \\\\d+，这里 + 代表一个或者多个 如果要匹配小数，中间带着小数点 . 的话，就是 \\\\d+.\\\\d+，注意这里还没有加入正负号的匹配 加号 + 与乘号 ** 表示匹配前面的字符0个或多个 + 表示前面的字符1个或多个 问号 ?直接跟在表达式后面，表示匹配前面的一次或者零次，类似于{0, 1}的用法，[+-]&#123;0,1&#125;\\\\d+.\\\\d+ 和 [+-]?\\\\d+.\\\\d+ 应该是等价的意思，匹配前面有没有+-这些符号 指数符^ 和 dollar符 $^ 用来匹配起始位置，$ 用来匹配结束位置，配合使用一般用作检验，比如检验一段文本是否只包含数字 ^[0-9]*$ 如果 ^ 使用在中括号中，则有一种not的感觉 小括号 ()小括号起到了一种组的概念，首先可以按照顺序使用 \\\\1，\\\\2 进行访问匹配，例如在html/xml标签的匹配中，可以用 &lt;(div)&gt;[^&lt;]*&lt;/\\\\1&gt; 来进行匹配div标签，这样中间 [^&lt;]* 的意思就是匹配不是 &lt; 的任意字符，后边的 &lt;/\\\\1&gt; 能够自动对应到尾部标签去；注意这样的可能存在的嵌套关系匹配替换，可以每次循环迭代把内层的不断替换成一些特殊字符或者空，直到匹配不到为止； 12345text: &lt;div&gt;&lt;font color=&#x27;red&#x27;&gt;hello, world&lt;/font&gt;&lt;div&gt;tmp2&lt;/div&gt;&lt;/div&gt;re: &lt;(div)&gt;[^&lt;]*&lt;/\\1&gt;result: &lt;div&gt;tmp2&lt;/div&gt; 中括号 [] 与竖线 |中括号用来匹配单个字符，是否属于中括号中的一个字符 [0-9] [A-Z] 这样都也是可以的，注意如果待正则匹配的内容中已经具有中括号（其他括号也是同理），需要用 \\[ 把其他待匹配的做一个转义的感觉 竖线 | 就是一个或的意思，虽然不知道为什么要和中括号写在一个类别hhh，感觉使用场景上来说还是很灵活的 大括号 &#123;&#125;匹配出现几次那种感觉，例如 \\\\d&#123;1,3&#125; 就是匹配出现一段文本中1次到3次的数字，这里还可以补充一下问号 ? 的作用，有一种最小匹配的感觉 好了，1+1=2学会（废）了！开始搞题！ BJUTACM OJ 2017年12月蓝桥杯预选赛题目ip地址判断题目链接 题目大意于是由于各种各样的原因, 出现了一个叹号。 我们都已经看到了工具下载及比赛规则的地址是 http://172.21.17.211/ 下面你就来判断一下一个网址是否符合 http://a.b.c.d/ 的格式吧。 (a, b, c, d 均为长度在 [1, 5] 且由数字 0-9 构成的字符串) 输入一行字符串。 长度小于50。 输出如果输入符合要求。 输出 “Yes”。否则输出 “No” 。 (输出不含引号) 样例输入 1http://172.21.17.211/ 样例输出 1Yes 分析和解答这个题对自己影响是真的大，当年蓝桥预选赛靠着这个题在大一上从毫无基础的小白就到学校预选赛的前30名，用C语言一条规则一条规则的适配，AC的那一刻真是最难忘的会议之一~ 现在再来做这个题的话，过了这么多年了，发现用非常简单的正则就能写出来，也就把题总结在这里了~ 1234567891011import repattern = re.compile(r&#x27;http://[0-9]&#123;1,5&#125;\\.[0-9]&#123;1,5&#125;\\.[0-9]&#123;1,5&#125;\\.[0-9]&#123;1,5&#125;/&#x27;)if __name__ == &#x27;__main__&#x27;: input_str = str(input()) tmp_str = re.sub(pattern, &#x27;&#x27;, input_str) if len(tmp_str) == 0: print(&quot;Yes&quot;) else: print(&quot;No&quot;) 65.有效数字题目链接 题目大意有效数字（按顺序）可以分成以下几个部分： 一个 小数 或者 整数 （可选）一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;） 下述格式之一： 至少一位数字，后面跟着一个点 &#39;.&#39; 至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字 一个点 &#39;.&#39; ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;） 至少一位数字 部分有效数字列举如下：[&quot;2&quot;, &quot;0089&quot;, &quot;-0.1&quot;, &quot;+3.14&quot;, &quot;4.&quot;, &quot;-.9&quot;, &quot;2e10&quot;, &quot;-90E3&quot;, &quot;3e+7&quot;, &quot;+6e-1&quot;, &quot;53.5e93&quot;, &quot;-123.456e789&quot;] 部分无效数字列举如下：[&quot;abc&quot;, &quot;1a&quot;, &quot;1e&quot;, &quot;e3&quot;, &quot;99e2.5&quot;, &quot;--6&quot;, &quot;-+3&quot;, &quot;95a54e53&quot;] 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。 示例1： 12输入：s = &quot;0&quot;输出：true 示例2： 12输入：s = &quot;e&quot;输出：false 示例3： 12输入：s = &quot;.&quot;输出：false 提示： 1 &lt;= s.length &lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 &#39;+&#39; ，减号 &#39;-&#39; ，或者点 &#39;.&#39; 。 分析和解答这个题要分两部分考虑，首先考虑单独表示一个整数或者小数，然后再考虑科学计数法的内容，科学计数法就是 e-5 或者 e10 这样的 单独考虑整数： [+-]&#123;0,1&#125;\\\\d+解释：+- 号可以出现0次或者1次（也可以用 ? 替代）， &#123;0,1&#125;，\\\\d+ 匹配整数； 考虑小数，情况1： [+-]&#123;0,1&#125;\\\\d+\\\\.\\\\d+解释：+- 号可以出现0次或者1次（也可以用 ? 替代），后面是 x.x 形式的小数； 考虑小数，情况2： [+-]&#123;0,1&#125;\\\\d+\\\\.解释：后面是 x. 形式的小数； 考虑小数，情况3： [+-]&#123;0,1&#125;\\\\.\\\\d+解释：后面是 .x 形式的小数； 然后考虑科学计数法，即 从e开始后面的位置 ，情况有： [eE][+-]?× -&gt; 不能带小数点，因为不能是e2.5次方这样的，所以正则的写法为 ([eE][+-]?\\\\d+)? ，这里只能匹配一次，所以要把整体的带上括号 ※合并上述内容，前边的必须有，科学计数法不一定要有： (([+-]?\\\\d+)|([+-]?\\\\d+\\\\.\\\\d+)|([+-]?\\\\d+\\\\.)|([+-]?\\\\.\\\\d+))([eE][+-]?\\\\d+)? ※这里还有个坑的内容，例如对于 3. 这种case，如果把整数的匹配写在前面，那么只会优先匹配到 3 了，所以要把小数写在前面，整数写在后面 (([+-]?\\\\d+\\\\.\\\\d+)|([+-]?\\\\d+\\\\.)|([+-]?\\\\.\\\\d+)|([+-]?\\\\d+))([eE][+-]?\\\\d+)? ※补充还有个坑的地方，就是说 1+3 这种case，在后面的话小数部分应该写成 ([eE][+-]?\\\\d+)? ，而不能写成多一个问号 ([eE]?[+-]?\\\\d+)? 只有出现了e或者E，才能让+-出现0或1次 非转义的final写法： (([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+)|([+-]?\\d+))([eE][+-]?\\d+)? 代码如下所示，这里的注意点是 re.compile(ur&#39;&#39;) 就可以不用转义各个字符了，转义还是个考虑的重点问题； 替换成一个特殊字符 # ，最后可以用这个特殊字符做一些判断，避免单个 e 一类的问题； 123456789101112131415class Solution(object): def isNumber(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; import re pattern = re.compile(ur&#x27;(([+-]?\\d+\\.\\d+)|([+-]?\\d+\\.)|([+-]?\\.\\d+)|([+-]?\\d+))([eE][+-]?\\d+)?&#x27;) # 这里不用转义了 tmp_s = re.sub(pattern, &quot;#&quot;, s) if tmp_s != &#x27;#&#x27;: return False else: return True 591.标签验证器题目链接 题目大意给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则： 代码必须被 合法的闭合标签包围 。否则，代码是无效的。 闭合标签 （不一定合法）要严格符合格式：&lt;TAG_NAME&gt;TAG_CONTENT&lt;/TAG_NAME&gt; 。其中，&lt;TAG_NAME&gt; 是起始标签，&lt;/TAG_NAME&gt; 是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是 合法的 。 合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。 合法的 TAG_CONTENT 可以包含其他 合法的闭合标签 ，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的 &lt; 、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的 。 一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。 一个 &lt; ，如果你找不到一个后续的 &gt; 与之匹配，是不合法的。并且当你找到一个 &lt; 或 &lt;/ 时，所有直到下一个&gt;的前的字符，都应当被解析为 TAG_NAME（不一定合法）。 cdata 有如下格式：&lt;![CDATA[CDATA_CONTENT]]&gt;。CDATA_CONTENT 的范围被定义成 &lt;![CDATA[ 和后续的第一个 ]]&gt; 之间的字符。 CDATA_CONTENT 可以包含 任意字符 。cdata 的功能是阻止验证器解析 CDATA_CONTENT ，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为 常规字符 。 合法代码的例子： 1234567891011121314151617181920212223242526272829303132333435363738输入: &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt;]]&gt;&lt;/DIV&gt;&quot;输出: True解释: 代码被包含在了闭合的标签内： &lt;DIV&gt; 和 &lt;/DIV&gt; 。TAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。 即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。输入: &quot;&lt;DIV&gt;&gt;&gt; ![cdata[]] &lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&gt;]&lt;/DIV&gt;&quot;输出: True解释:我们首先将代码分割为： start_tag|tag_content|end_tag 。start_tag -&gt; &quot;&lt;DIV&gt;&quot;end_tag -&gt; &quot;&lt;/DIV&gt;&quot;tag_content 也可被分割为： text1|cdata|text2 。text1 -&gt; &quot;&gt;&gt; ![cdata[]] &quot;cdata -&gt; &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;&quot; ，其中 CDATA_CONTENT 为 &quot;&lt;div&gt;]&gt;&quot;text2 -&gt; &quot;]]&gt;&gt;]&quot;start_tag 不是 &quot;&lt;DIV&gt;&gt;&gt;&quot; 的原因参照规则 6 。cdata 不是 &quot;&lt;![CDATA[&lt;div&gt;]&gt;]]&gt;]]&gt;&quot; 的原因参照规则 7 。 不合法代码的例子： 123456789101112131415161718输入: &quot;&lt;A&gt; &lt;B&gt; &lt;/A&gt; &lt;/B&gt;&quot;输出: False解释: 不合法。如果 &quot;&lt;A&gt;&quot; 是闭合的，那么 &quot;&lt;B&gt;&quot; 一定是不匹配的，反之亦然。输入: &quot;&lt;DIV&gt; div tag is not closed &lt;DIV&gt;&quot;输出: False输入: &quot;&lt;DIV&gt; unmatched &lt; &lt;/DIV&gt;&quot;输出: False输入: &quot;&lt;DIV&gt; closed tags with invalid tag name &lt;b&gt;123&lt;/b&gt; &lt;/DIV&gt;&quot;输出: False输入: &quot;&lt;DIV&gt; unmatched tags with invalid tag name &lt;/1234567890&gt; and &lt;CDATA[[]]&gt; &lt;/DIV&gt;&quot;输出: False输入: &quot;&lt;DIV&gt; unmatched start tag &lt;B&gt; and unmatched end tag &lt;/C&gt; &lt;/DIV&gt;&quot;输出: False 注意: 为简明起见，你可以假设输入的代码（包括提到的 任意字符 ）只包含 数字, 字母, &#39;&lt;&#39;,&#39;&gt;&#39;,&#39;/&#39;,&#39;!&#39;,&#39;[&#39;,&#39;]&#39;和&#39; &#39;。 分析和解答这个题还是挺难的，也是一种正则表达式的练习吧，总之对正则表达式又熟了一分，想法和题解就写在代码的注释里了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution(object): def isValid(self, code): # 使用正则表达式偷鸡了，正好作为一个正则表达式题目的练习了 import re # 去掉CDATA字段变化为空，注意由于&#x27;[&#x27;括号字符在正则表达式中具有特殊的含义，所以要&#x27;\\&#x27;字符完成转义 # 【badcase4】CDATA必须被标签包含 # 【badcase5】.*?和.*的区别？ code_remove_cdata = re.sub(r&quot;&lt;!\\[CDATA\\[.*?\\]\\]&gt;&quot;, &quot;#&quot;, code) # 【badcase2】如果全是CDATA匹配到的就返回False if len(code_remove_cdata) == 1: return False # 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键 # 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面 prev = code_remove_cdata code_remove_cdata_tag = re.sub(r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\\1&gt;&quot;, &quot;#&quot;, code_remove_cdata) print(&quot;code_remove_cdata: &quot;, code_remove_cdata) print(&quot;code_remove_cdata_tag: &quot;, code_remove_cdata_tag) # 一直正则替换 while prev != code_remove_cdata_tag: prev = code_remove_cdata_tag # 【badcase1】这里要特别注意正则表达式括号的转义问题，另外[^&lt;]*也很关键 # 【badcase3】要替换成一个非法字符，这样最后保证所有代码段都被包含在里面 code_remove_cdata_tag = re.sub(r&quot;&lt;([A-Z]&#123;1,9&#125;)&gt;[^&lt;]*&lt;/\\1&gt;&quot;, &quot;#&quot;, code_remove_cdata_tag) print(&quot;code_remove_cdata_tag: &quot;, code_remove_cdata_tag) if code_remove_cdata_tag == &quot;#&quot;: return True else: return False# if __name__ == &#x27;__main__&#x27;:# s = Solution()# code = &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt; ]]&gt; &lt;DIV&gt; &lt;A&gt; &lt;![CDATA[&lt;b&gt;]]&gt; &lt;/A&gt; &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt; &lt;/DIV&gt;&quot;# # badcase1# # &quot;&lt;DIV&gt; unmatched &lt; &lt;/DIV&gt;&quot; -&gt; [^&lt;]*的问题，要求中甲不能匹配&lt;# # badcase2# # &quot;&lt;![CDATA[wahaha]]]&gt;&lt;![CDATA[]&gt; wahaha]]&gt;&quot; -&gt; 如果经过第一步处理后就空了，那就要返回False# # badcase3# # &quot;&lt;A&gt;&lt;/A&gt;&lt;B&gt;&lt;/B&gt;&quot; 要输出False# # badcase4# # &quot;&lt;![CDATA[ABC]]&gt;&lt;TAG&gt;sometext&lt;/TAG&gt;&quot; CDATA必须被标签包含# # badcase5，.*和.*?还是有区别的，# # &quot;&lt;DIV&gt;This is the first line &lt;![CDATA[&lt;div&gt; &lt;![cdata]&gt; [[]]&lt;/div&gt; ]]&gt; &lt;DIV&gt; &lt;A&gt; &lt;![CDATA[&lt;b&gt;]]&gt; &lt;/A&gt; &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt; &lt;/DIV&gt;&quot;# # 如果是.*匹配（贪婪匹配），会替换成：&lt;DIV&gt;This is the first line # &lt;/A&gt; &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt; &lt;/DIV&gt;# # 如果是.*?匹配（最小匹配），会替换成：&lt;DIV&gt;This is the first line # &lt;DIV&gt; &lt;A&gt; # &lt;/A&gt; &lt;A&gt; &lt;C&gt;&lt;/C&gt;&lt;/A&gt;&lt;/DIV&gt; &lt;/DIV&gt;# print(&quot;output res: &quot;, s.isValid(code))","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"273-283场LeetCode周赛总结","slug":"algorithms/leetcode-weekly-contest/273-283场LeetCode周赛总结","date":"2022-05-04T09:44:54.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2022/05/04/algorithms/leetcode-weekly-contest/273-283场LeetCode周赛总结/","link":"","permalink":"http://example.com/2022/05/04/algorithms/leetcode-weekly-contest/273-283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/","excerpt":"273-283场LeetCode周赛综述&amp;总结： LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢； 温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~ 另外这里相对整理一下需要数据结构/特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容； 总结来看主要有这些操作： 【前后缀和】【数学&amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;构造】【链表】【二分】【字符串】【水题】","text":"273-283场LeetCode周赛综述&amp;总结： LeetCode感觉周赛做多了有时候思维就容易僵化，像中间有几次感觉对第二题、第三题直接走到不同思路上去了就直接坐牢； 温故而知新，定期总结下周赛题目的套路，希望早日能成为周赛三题&amp;前1000名选手吧，现在感觉只有在手感特别好还有题目完全正好适配的时候才能前1000，剩下的情况能进前2000都是大胜利了，还是要不断刷题积累下了~ 另外这里相对整理一下需要数据结构/特殊技巧才能做出来的题，比较水的题可能就不放在这里了，可以参考各次博客内容； 总结来看主要有这些操作： 【前后缀和】【数学&amp;找规律】【哈希表mapping】【贪心】【Counter计数】【滑动窗口】【哨兵】【模拟】【动态规划】【设计&amp;构造】【链表】【二分】【字符串】【水题】 前后缀和 前后缀和大概是因为每次都要统计相同的位置，那么就是每次在基础上做累加的操作来避免每次对于相同位置的统计； ※273场周赛第3题 2121.相同元素的间隔之和，这个题同时被归入了 前后缀和 、 数学&amp;找规律 和 哈希表mapping 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125; 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路； ※280场周赛第3题 2171.拿出最少数目的魔法豆，这个题同时被归入了 前后缀和 和 贪心 的思路，排序后前缀拿过去就可以了； 数学&amp;找规律 数学和找规律的题一般都要现场推，自己动手模拟下看看，也没什么太多复盘的思路，每次遇到的感觉都不会太一样； ※273场周赛第3题 2121.相同元素的间隔之和，这个题同时被归入了 前后缀和 、 数学&amp;找规律 和 哈希表mapping 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125; 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路； 283场周赛第2题 2195.向数组中追加 K 个整数，暴力哈希的思路还是比较好像，但实际上不能这样，还要往后补的思路，总结数学题来说就是每次现场推就行了，复盘的时候不用想的太明白； 哈希表mapping 哈希表是个简化时间复杂度的好东西，万物皆可哈希hhhh； ※273场周赛第3题 2121.相同元素的间隔之和，这个题同时被归入了 前后缀和 、 数学&amp;找规律 和 哈希表mapping 三个类型，这个题算是遇到相对比较难的第三题了，制作一种类似于 &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125; 的mapping思路，然后可以在内部开始模拟，用数学的方法找一找规律，前后缀和在这个过程中可能就能发现前缀和相关的一些优化了，总结来说虽然可能是连续刷周赛的第一次周赛，但是这个题在各次来说也是比较难的第三题了，降时间复杂度就要想mapping，前后缀和这些思路； ※275场周赛第3题 2135.统计追加字母可以获得的单词数，这个题主要就是哈希表的思想，一方面来说 重排 这个事情可以在最开始的时候把大家都重排了这样一种预处理得到，另一方面来说set起到判重的作用，差一个字符上就是截断的拼接问题 word[:i] + word[i+1:] 这样可以把第i位的字符忽略掉，还是很难的这个题，这么看来说275场周赛的三个题都好难啊； 277场周赛第3题 2150.找出数组中的所有孤独数字，这个题哈希表也太明显了，甚至有些情况够不上平常周赛第一题，第二题的难度，包装的也比较简单，其实可以算在水题里了； 贪心 贪心的事情，不用想的那么明白哈哈哈哈； 274场周赛第3题 2126.摧毁小行星，这个题算是很简单的第三题啊，274场周赛没有实时做，不然来说的话应该是一个靠前三题能rank前1000内的比赛，就是直接暴力贪心就可以了，中间带一个简单的排序，名言之贪心的事情不用搞那么明白！； 276场周赛第2题 2139.得到目标值的最少行动次数，从大往小贪心就可以了，如果是偶数就除，如果是奇数就减就行了； 279场周赛第2题 2165.重排数字的最小值，这个题分正数负数贪心就可以了，前导0还是个约束条件； 280场周赛第2题 2170.使数组变成交替数组的最少操作数，第二题还是不能想太复杂了，奇数偶数位，选出分别两边出现最多的，但是 不能相等的，当时把自己坑惨了啊，还是要仔细读题，读歪了那可真是掉沟里了； ※280场周赛第3题 2171.拿出最少数目的魔法豆，这个题同时被归入了 前后缀和 和 贪心 的思路，排序后前缀拿过去就可以了； ※281场周赛第3题 2182.构造限制重复的字符串，这个题真的难，不是特殊情况下一定不要往原地交换的思路想，要想往新构造的思路想，剩下就是贪心和随缘的面向答案编程了； Counter计数 Counter是个很常用的数据结构，任何涉及到统计的的题目都可能会用到这个，不知道在其他语言Counter的对应是什么； ※275场周赛第1题 2133.检查是否每一行每一列都包含全部整数，是个比较难的第一题，甚至感觉很多情况下难度超过了第二题，一方面是对一行/一列取Counter计数的时候，应该是 第i行：Counter(matrix[i]) 和 第i列：Counter([matrix[x][i] for x in range(n)])，另一方面来说Counter是可以加减，还有相比较的，这个是个很方便的特性不知道在其他语言里怎么使用这个内容，这个题的特色点在于只要遍历一次主对角线做Counter，就可以涵盖所有情况了； ※275场周赛第2题 2134.最少交换次数来组合所有的 1 II，这个题同时被归入了 滑动窗口，哨兵 和 Counter计数 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！； 282场周赛第2题 2186.使两字符串互为字母异位词的最少步骤数，经典Counter加减，莽过去！； 滑动窗口 主要看题目是否本身暗含了一种窗口的思想在里面； ※275场周赛第2题 2134.最少交换次数来组合所有的 1 II，这个题同时被归入了 滑动窗口，哨兵 和 Counter计数 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！； 哨兵 主要是简化实现上的操作，比如把环变成数组，还有就是针对起始位置还有终点位置的特殊处理； ※275场周赛第2题 2134.最少交换次数来组合所有的 1 II，这个题同时被归入了 滑动窗口，哨兵 和 Counter计数 三种类型，算是相对比较难的第二题了，一方面在一个长度为有几个1的滑动的窗口中不断滑动过去，然后通过Counter看看把几个1聚在一起最少需要把几个0变成1，另一方面可以通过哨兵的机制，把环形的问题转成线型的问题，在这种需要计数类的问题的时候，Counter还是好用的！； 276场周赛第1题 2138.将字符串拆分为若干长度为 k 的组，也是水题但是可以通过哨兵补齐的思想，这样最后切分起来就很容易了，看了下当时的代码，不知道为什么当时能写那么复杂。。。； 模拟 一般按照题目来，跟着题目操作就可以； 273场周赛第2题 2120.执行所有后缀指令，使用 [1:] 不断截断，然后按照操作要求来模拟就行，这种题感觉也是不能着急，争取能在5分钟内完成第二题和第一题，要爆一下手速，第二题一般不会太难，不要太考虑时间复杂度的事情，想到方法基本就差不多了； 274场周赛第2题 2125.银行中的激光束数量，感觉是题目理解相对比较长的第二题，第二题可能存在题面复杂类的问题，但是通过这个题来看不能着急读题，读完题最好一遍能理解题意，尽快做出来； 280场周赛第1题 2169. 得到 0 的操作数，两边来回减，按照题目的要求模拟就可以了； 动态规划 还是要多刷，包括普通dp，区间dp等等，跟一波wls了； ※276场周赛第3题 2140.解决智力问题，这个题dp还是相对能看出来的？每个位置是选和不选两种状态，但是这个题只能让自己觉得自己智力有问题，dp第三题还是难，看来276和275场周赛是把自己给虐了，这个题要存 截止到当前位置的状态值！ 状态压缩（2^n那种类型的题目） 看数据范围有可能可以看出来是不是这类型的题目，特点就是每个状态下验证合理性的感觉吧； ※277场周赛第4题 2151.基于陈述统计最多好人数，还是比较难的，首先看数据范围如果是8，15这样比较小的数，那可能就要想能不能往2^n这种方向上做一做，这个题的关键思路还是当时室友给的，就是说：只需要判断假定所有说真话的人是否和条件有冲突就可以了，这种2^n很多情况都是判断每种情况是否合理的; 设计&amp;构造 设计构造题目比较思路型，可能也是面试常考的题目，包括LRU也是设计类题目； 279场周赛第3题 2166.设计位集，依照时间复杂度把一些能简化时间复杂度的操作转化为全局的，在 __init__ 的时候设计全局变量，然后后边依照这个全局变量简化时间复杂度即可，设计的时候来说边设计应该就是能想到的； ※283场周赛第3题 2196.根据描述创建二叉树，这种设计的题，要把每个节点做成一个哈希，然后用哈希再往里插入就可以了，构造的题目好像要用这种哈希是比较普遍的思路； 链表 链表题还没在周赛见过太多，这个题是比较水的链表题； 281场周赛第2题 2181.合并零之间的节点，链表模拟操作，操作过去就行了； 二分 二分边界情况判断，最后是left还是right是真的难，二分也可以做在每个情况下，O(n)的合理性验证吧； ※282场周赛第3题 2187.完成旅途的最少时间，自己想的时候没有看出来哪里可以二分，在大佬的提醒下二分验证每个时刻，O(n)判断judge是否合理，实际上有点像2^n那种题的验证思路了； 字符串 字符串题目还是很多的，一方面要会a-z A-Z这种ord chr的转化，另外一方面也要自己多练习一些正则的题目； ※283场周赛第1题 2194.Excel 表中某个范围内的单元格，本来是个简单的二维遍历问题，但是居然不知道python怎么遍历字符。。。查了下是 ord() 把字符转数字, chr() 把数字转字符，这个还是要记住的，特别是一些a-z，A-Z的遍历题目； 水题273场周赛第1题 2119.反转两次的数字，稍微操作一下就可以完成这个模拟操作了，第一题千万注意的就是不要急躁，耐下心来一遍把题读完，然后2分钟之内刷出来； 274场周赛第1题 2124.检查是否所有 A 都在 B 之前，标准水题，这种题感觉要半分钟读题，一分半内手速搞定暴力出来； 277场周赛第1题 2148.元素计数，能看出来是和最大最小比就很容易了，读题还是要细心呀； 277场周赛第2题 2149.按符号重排数组，甚至比很多第一题还简单，是相对比较简单的第二题了，直接拆成两个，不做原地操作就还是很简单的； 279场周赛第1题 2164.对奇偶下标分别排序，这个题虽然是水题，但是可以学习python奇数偶数 下标位置 取值方法，nums[::2]取偶数，nums[1:;2]取奇数； 281场周赛第1题 2180.统计各位数字之和为偶数的整数个数，水题，写个judge函数搞过去就可以了； 282场周赛第1题 2185.统计包含给定前缀的字符串，python有 str.startswith() 函数，用这个就可以了；","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"}]},{"title":"291场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/291场LeetCode周赛","date":"2022-05-02T01:07:10.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/05/02/algorithms/leetcode-weekly-contest/291场LeetCode周赛/","link":"","permalink":"http://example.com/2022/05/02/algorithms/leetcode-weekly-contest/291%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题； 感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙 第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了； 第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了； 第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了； 第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了；","text":"周赛综述&amp;总结： 久违的前1000名了，这次能排的稍微靠前点在于前三个题特别快的就做出来了，可惜第四个题没做出来，要不说不定能到前500呢hh~ 上周做了一回笔试题，今天再看周赛题还有点陌生了，也可能是这种陌生感让自己做快了一些吧，另外还是喜欢描述比较短的题； 感觉就是状态好+题目对着自己常做的思路吧，也可能和周中稍微做了几个题有些关系，前三个题描述还都不是很简单，但是做出来的都比自己预期的快一些，第四个题上来方向又走偏了，如果走到数学规律上面的话感觉可能还有戏，这个题是个“贡献”类的思路，比较巧妙 第一题：毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了； 第二题：做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了； 第三题：这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了； 第四题：一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，具体内容写在博客里了； 希望下次前1000名来得快一点，这次确实是题简单了 第一题：6047.移除指定数字得到的最大结果题目链接 题目大意给你一个表示某个正整数的字符串 number 和一个字符 digit 。 从 number 中 恰好 移除 一个 等于 digit 的字符后，找出并返回按 十进制 表示 最大 的结果字符串。生成的测试用例满足 digit 在 number 中出现至少一次。 示例1： 123输入：number = &quot;123&quot;, digit = &quot;3&quot;输出：&quot;12&quot;解释：&quot;123&quot; 中只有一个 &#x27;3&#x27; ，在移除 &#x27;3&#x27; 之后，结果为 &quot;12&quot; 。 示例2： 1234输入：number = &quot;1231&quot;, digit = &quot;1&quot;输出：&quot;231&quot;解释：可以移除第一个 &#x27;1&#x27; 得到 &quot;231&quot; 或者移除第二个 &#x27;1&#x27; 得到 &quot;123&quot; 。由于 231 &gt; 123 ，返回 &quot;231&quot; 。 示例3： 1234输入：number = &quot;551&quot;, digit = &quot;5&quot;输出：&quot;51&quot;解释：可以从 &quot;551&quot; 中移除第一个或者第二个 &#x27;5&#x27; 。两种方案的结果都是 &quot;51&quot; 。 提示： 2 &lt;= number.length &lt;= 100 number 由数字 &#39;1&#39; 到 &#39;9&#39; 组成 digit 是 &#39;1&#39; 到 &#39;9&#39; 中的一个数字 digit 在 number 中出现至少一次 分析和解答毕竟第一题，直接暴力每个位置比较+列表拼接join就可以了，注意最后的返回值是个字符串，室友大佬后来还提醒说这个题中间如果转int处理可能会爆，看来是用python正好就把这个坑给避开了； 1234567891011121314class Solution(object): def removeDigit(self, number, digit): &quot;&quot;&quot; :type number: str :type digit: str :rtype: str &quot;&quot;&quot; res = -1 for i in range(len(number)): if number[i] == digit: tmp_list = &#x27;&#x27;.join(number[:i] + number[i+1:]) res = max(res, int(tmp_list)) return str(res) 第二题：6048.必须拿起的最小连续卡牌数题目链接 题目大意给你一个整数数组 cards ，其中 cards[i] 表示第 i 张卡牌的 值 。如果两张卡牌的值相同，则认为这一对卡牌 匹配 。 返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 -1 。 示例1： 123输入：cards = [3,4,2,3,4,7]输出：4解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。 示例2： 123输入：cards = [1,0,5,3]输出：-1解释：无法找出含一对匹配卡牌的一组连续卡牌。 提示： 1 &lt;= cards.length &lt;= 10^5 0 &lt;= cards[i] &lt;= 10^6 分析和解答做一个哈希表，每个数字映射到他出现过位置的一个列表，然后遍历这个哈希表，看看区间长度比较下找个min的就可以了，还是比较好想到这个思路的 1234567891011121314151617181920212223class Solution(object): def minimumCardPickup(self, cards): &quot;&quot;&quot; :type cards: List[int] :rtype: int &quot;&quot;&quot; from collections import defaultdict tmp_dict = defaultdict(list) for i in range(len(cards)): tmp_dict[cards[i]].append(i) # print(tmp_dict) res = 1e9 for value in tmp_dict.values(): if len(value) &lt; 2: continue for j in range(len(value)-1): res = min(res, value[j+1]-value[j]) if res != 1e9: return res+ 1 else: return -1 第三题：6049.含最多 K 个可整除元素的子数组题目链接 题目大意给你一个整数数组 nums 和两个整数 k 和 p ，找出并返回满足要求的不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素。 如果满足下述条件之一，则认为数组 nums1 和 nums2 是 不同 数组： 两数组长度 不同 ，或者 存在 至少 一个下标 i 满足 nums1[i] != nums2[i] 。 子数组 定义为：数组中的连续元素组成的一个 非空 序列。 示例1： 12345678输入：nums = [2,3,3,2,2], k = 2, p = 2输出：11解释：位于下标 0、3 和 4 的元素都可以被 p = 2 整除。共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。 示例2： 123456输入：nums = [1,2,3,4], k = 4, p = 1输出：10解释：nums 中的所有元素都可以被 p = 1 整除。此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。 提示： 1 &lt;= nums.length &lt;= 200 1 &lt;= nums[i], p &lt;= 200 1 &lt;= k &lt;= nums.length 分析和解答这个题先判断每个位置是否可以被p整除，然后根据这个做一个新的列表，能被p整除的就是1，不能被p整除的就是0，之后按照他这个子数组的定义来遍历（就是j要从i开始遍历），去重的话可以用tuple的子数组作为key，然后就是对每个区间sum就可以了； 另外还想说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j=i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢 1234567891011121314151617181920212223242526272829303132333435class Solution(object): def countDistinct(self, nums, k, p): &quot;&quot;&quot; :type nums: List[int] :type k: int :type p: int :rtype: int &quot;&quot;&quot; # preprocess cnt_list = [] for i in range(len(nums)): if nums[i] % p == 0: cnt_list.append(1) else: cnt_list.append(0) # print(&quot;cnt_list: &quot;, cnt_list) res = 0 # from collections import defaultdict hash_set = &#123;&#125; for i in range(len(nums)): for j in range(i, len(nums)): tmp_list = nums[i:j+1] if hash_set.get(tuple(tmp_list)) is not None: continue hash_set[tuple(tmp_list)] = 1 tmp = sum(cnt_list[i:j+1]) if tmp &lt;= k: res += 1 # print(tmp_list) return res 第四题：6050.字符串的总引力题目链接 题目大意字符串的 引力 定义为：字符串中 不同 字符的数量。 例如，&quot;abbca&quot; 的引力为 3 ，因为其中有 3 个不同字符 &#39;a&#39;、&#39;b&#39; 和 &#39;c&#39; 。 给你一个字符串 s ，返回 其所有子字符串的总引力 。 子字符串 定义为：字符串中的一个连续字符序列。 分析和解答一道计算“贡献”的题目，自己一开始想的有点偏，贡献类的题目感觉不能从完全全局来说，要考虑每个字符在全局上的贡献，这个题也是第一次遇到，感觉算法还是很神奇的，自己举的例子是下边这个图这样，这样能按照每个字符，来统计每个字符的贡献度： 非重复情况： 重复情况： 另外还想再次说这个子字符串好有意思啊，他不是2^n那种遍历方法的，而是j=i那种双重for循环的，看了眼数据范围还在想要不要搞2^n做法呢 正确解答方法： 12345678910111213141516class Solution(object): def appealSum(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; # 一种每个字符贡献度的思想，还是很有特点的 res = 0 char_dict = &#123;&#125; for i in range(len(s)): if char_dict.get(s[i]) is None: res += (i + 1) * (len(s)-i) else: res += (i - char_dict[s[i]]) * (len(s) - i) char_dict[s[i]] = i return res 这里也额外把自己当时写的暴力方法附上，一位缩减了时间复杂度，实际上像个小丑哈哈哈哈哈哈哈哈，dp了但没完全dp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def appealSum(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; res = 0 d1 = &#123;&#125; for i in range(len(s)): d1[i] = &#123;s[i]: 1&#125; res += 1 print(&quot;init: &quot;, d1) res_d = &#123;&#125; # 这里感觉是一个base基础上的dp，每次要取几位，有点不像平常的遍历思路1 # 现在要开始每次取两位 for l in range(2, len(s)+1): for i in range(len(s)-l+1): # base base = s[i:i+l-1] # print(&quot;base: &quot;, base) # now（要不要给他加一个标识？） tmp_s = s[i:i+l] # print(&quot;tmp_s: &quot;, tmp_s) # 增量 upper = tmp_s[len(base):] # print(&quot;upper: &quot;, upper) # 查看upper在不在 if d1[i].get(upper) is None: # 不在，这样是一种累加的 d1[i][tmp_s] = d1[i][base] + 1 d1[i][upper] = 1 res += d1[i][tmp_s] else: d1[i][tmp_s] = d1[i][base] res += d1[i][tmp_s] # continue # res += d1[i][upper] # d1[i][upper] = d1[i][upper] + 1 # continue # print(d1) # print(res) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"哈希函数","slug":"哈希函数","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"},{"name":"滚动哈希","slug":"滚动哈希","permalink":"http://example.com/tags/%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C/"}]},{"title":"687.最长同值路径-python","slug":"algorithms/leetcode-python/687-最长同值路径-python","date":"2022-04-30T02:49:27.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2022/04/30/algorithms/leetcode-python/687-最长同值路径-python/","link":"","permalink":"http://example.com/2022/04/30/algorithms/leetcode-python/687-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84-python/","excerpt":"687.最长同值路径（中等） 题目大意： 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。","text":"687.最长同值路径（中等） 题目大意： 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 题目题目链接 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 示例1： 12输入：root = [5,4,5,1,1,5]输出：2 示例2： 12输入：root = [1,4,5,4,4,5]输出：2 提示： 树的节点数的范围是 [0, 10^4] -1000 &lt;= Node.val &lt;= 1000 树的深度将不超过 1000 分析和解答比较经典能看出来是 树中子结构dfs/dp的题目，关于该类型题目比较经典的感觉是124.二叉树中的最大路径和 hard 题目类型 的细节总结和 相似题目分析 可见leetcode124题的博客 对于这个题目来说，子结构下的返回值可能会有none的情况，另外也需要全局比较，总结来说和124题目比较像，如果再做到这题的话不知道能不能做出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): &quot;&quot;&quot; 典型树中子结构搜索的题目 &quot;&quot;&quot; def __init__(self): self.max_res = 0 def longestUnivaluePath(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; # 1. 先写dfs递归函数 def dfs(root): if root is None: return 0 # 3. 子结构搜索任务要用后序遍历，这里写递归两次 left = dfs(root.left) right = dfs(root.right) # 4. 写全局的那个逻辑，全局结构要把左右都考虑上 tmp_res = 0 # 路径长度，所以这里是0开始 if root.left is not None and root.val == root.left.val: tmp_res += left if root.right is not None and root.val == root.right.val: tmp_res += right self.max_res = max(self.max_res, tmp_res) # 2. 对于树中的子结构搜索任务，写返回值，看看不同种情况下子结构该怎么返回 if (root.left is not None and root.val == root.left.val) and (root.right is not None and root.val == root.right.val): return max(left, right) + 1 elif root.left is not None and root.val == root.left.val: return left + 1 elif root.right is not None and root.val == root.right.val: return right + 1 else: return 1 # 为什么是return1，只能暂时理解为每个的base都是1了 dfs(root) return self.max_res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"543.二叉树的直径-python","slug":"algorithms/leetcode-python/543-二叉树的直径-python","date":"2022-04-30T02:20:42.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/04/30/algorithms/leetcode-python/543-二叉树的直径-python/","link":"","permalink":"http://example.com/2022/04/30/algorithms/leetcode-python/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-python/","excerpt":"543.二叉树的直径（简单） 题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。","text":"543.二叉树的直径（简单） 题目大意：给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 题目题目链接 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例：给定二叉树 123456 1 / \\ 2 3 / \\ 4 5 返回 3，它的长度是路径 [4,2,1,3] 或者 [5,2,1,3] 注意：两结点之间的路径长度是以它们之间边的数目表示。 分析和解答题目中给出了一个提示，就是说 这条路径可能穿过也可能不穿过根节点，那么换句话说，每个节点都有可能是 路径的根节点，这样应该可以判断出是经典的 树形子结构dfs/dp题目，关于该类型题目比较经典的感觉是124.二叉树中的最大路径和 hard 题目类型 的细节总结和 相似题目分析 可见leetcode124题的博客 这个题目来说，坑点在于不是节点数目，而是边数目的表示，最后需要加减个1一般通过调试就可以完成了，然后路径上的话一般子结构返回值就是 1+xxx 这样的；另外想说的是这个题居然是简单题，和124本质上没有什么区别啊 12345678910111213141516171819202122232425262728# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def __init__(self): self.max_len = -1e9 # 这里要新定义一个？ def diameterOfBinaryTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; def dfs(root): if root is None: return 0 max_left_len = dfs(root.left) max_right_len = dfs(root.right) self.max_len = max(self.max_len, 1 + max_left_len + max_right_len) return 1 + max(max_left_len, max_right_len) # 子结构的加上根 dfs(root) return self.max_len - 1","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"124.二叉树中的最大路径和-python","slug":"algorithms/leetcode-python/124-二叉树中的最大路径和-python","date":"2022-04-30T01:38:40.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/04/30/algorithms/leetcode-python/124-二叉树中的最大路径和-python/","link":"","permalink":"http://example.com/2022/04/30/algorithms/leetcode-python/124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-python/","excerpt":"124.二叉树中的最大路径和（困难） 题目大意：路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。","text":"124.二叉树中的最大路径和（困难） 题目大意：路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 题目题目链接 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 示例1： 123输入：root = [1,2,3]输出：6解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6 示例2： 123输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42 提示： 树中节点数目范围是 [1, 3 * 10^4] -1000 &lt;= Node.val &lt;= 1000 分析和解答经典的树形子结构dp题目，这个题带了一个最大路径和，这块是要有一个全局的变量，每个子结构的值要和这个全局的值来比取最大值； 树里的子结构，一般思路就是后序遍历的思想，把每个节点当做根节点，然后求出这个点左右和这个点的值加起来，和全局的来比；而其中比较关键的是在此之前，每个地方的递归出口，也就是后序遍历的出口要把子结构的值给返回回去，而这种路径的话，子结构实际上只能往左边或者右边，也就是root.val + max(left_val, right_val)，其中两边的val需要通过递归来完成返回 总结来说，一般的套路是如下几个步骤： 写 from function tools import lru_cache ，在dfs函数前加上 @lru_cache(1000*1000) 的修饰，这样可以一定程度上减小时间占用（在笔试题目中可能会有奇效hh）； 写入口，入口一般有两种情况，像是笔试题目的话可能是 def dfs(left, right) 这样的，像是leetcode题目的话，可能就是 def dfs(root)； 写出口返回值，一般来说就是子结构的值，如果是像这个题一样树中路径的话，就是当前节点加上左边或者右边的； 写后续遍历的递归部分，将两边的子结构传入dfs函数中，来进一步往深度优先寻找； 写全局比较，这个步骤不一定存在，但是如果把每个节点像这个题一样当做“中转节点”的话，那就要和全局的值比较一下； 写递归出口条件，一般来说就是 root is None 或者 left &gt;= right这类的条件； 这个模式感觉还挺套路的，几乎子结构或者带着树中路径的题目都可以这么做，也算是积累到一种做法吧，相似题目包括： 124.二叉树中的最大路径和 hard543.二叉树直径 easy687.最长同值路径 medium001场笔试练习 第四题.最优二叉树 通过上边的总结来说，这个题目基本已经可以做出来了，需要注意的是这个题目中可能有负数存在，路径上带上负数还不如不带这条路径，子结构返回的时候需要注意一下 补充： 543.二叉树直径 easy: https://leetcode-cn.com/problems/diameter-of-binary-tree/ 124.二叉树中的最大路径和 hard: https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/ 这两个题感觉是很像的，但是不太像树形dp，就像是在树里的dfs一样，感觉最主要的思路就是子结构 在写dfs函数的时候，先写返回值，返回值是左右两个子结构中最大的一个加上当前节点的值；；这里说是子结构是因为他的父节点如果选了左边的就不能选右边的（题目特性决定）；；代表这个根作为子结构的条件下最大值 然后写结束条件，一般就是root is None的时候 然后写递归的两边，基本就是把root.left和root.right传进去 然后写全局的，全局的就是 当前+左子结构+右子结构，然后和现有比取最大的；；；代表按这个根作为真实根的情况下条件的最大值 最后return回全局的这个最大的 树里子结构的dfs 1234567891011121314151617181920212223242526272829303132333435# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def __init__(self): self.max_res = -1e9 def maxPathSum(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; def dfs(root): if root is None: return 0 left_max_val = dfs(root.left) # 往左子树走，以左子树为根的最大子结构 right_max_val = dfs(root.right) # 往右子树走，右子树的最大子结构 tmp_value = root.val + left_max_val + right_max_val # 以root为根的最大子结构 self.max_res = max(self.max_res, tmp_value) # 这个return是单一子结构的return，子结构下不能同时往左又往右走，只能选择一边，子结构的！！！ if root.val + max([0, left_max_val, right_max_val]) &gt; 0: return root.val + max([0, left_max_val, right_max_val]) else: return 0 dfs(root) return self.max_res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"}]},{"title":"001场笔试练习","slug":"001场笔试练习","date":"2022-04-26T13:32:06.000Z","updated":"2022-11-20T01:50:08.881Z","comments":true,"path":"2022/04/26/001场笔试练习/","link":"","permalink":"http://example.com/2022/04/26/001%E5%9C%BA%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0/","excerpt":"写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz； 笔试题目选择：美团2021校招笔试-编程题(通用编程试题,第10场) 笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题/面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6/10，还加上了一个@lru_cache(1000*1000)；","text":"写在第一次尝试时：笔试题目感觉和平常LeetCode题目不太一样，比较关键的是要自己构造输入并且有些场景下可能会遇到格式化输出的情况。中间的调试过程平台不同也会让人做起来不太熟练，现在感觉在刷周赛之外也要做一做笔试题，有些笔试题感觉出题思路和ACM那些比较像和周赛的考察点不太一样，这样也是为了未来做准备，并且多积累一些刷题经验吧~ 输入输出这块感觉还是挺大的坑的，整体结构上可以写成类似于LeetCode solution的形式，还有个突然想起来补充说的，笔试题感觉每次给的样例case都好简单啊，估计只能过最最简单case的那种，而且测试的时候貌似不能面向答案编程Orz； 笔试题目选择：美团2021校招笔试-编程题(通用编程试题,第10场) 笔试刷题总结：前两个题都有一种模拟的感觉，第一个题情况没考虑全但是case太弱了直接给偷过了，第二个的话就是排序简单模拟，第三个题的话一眼看过去因为有最左这种的条件在几乎一下就能看出是小根堆这个背景了，总结来看的话这次这套题前三个题甚至比周赛题还简单？第四个题是树形dp，看了看答案还是没学会，感觉像是一种树构造性的题目，感觉经验还是差太多了，还需要多做题吧，希望能在dp上更进一步，这样笔试题/面试题就都没有那么怕了，跟一波b站wls哈哈哈；补充：后来把第四题用暴力dfs的方法过了6/10，还加上了一个@lru_cache(1000*1000)； 第一题：淘汰分数题目大意某比赛已经进入了淘汰赛阶段,已知共有n名选手参与了此阶段比赛，他们的得分分别是a_1,a_2….a_n,小美作为比赛的裁判希望设定一个分数线m，使得所有分数大于m的选手晋级，其他人淘汰。 但是为了保护粉丝脆弱的心脏，小美希望晋级和淘汰的人数均在[x,y]之间。 显然这个m有可能是不存在的，也有可能存在多个m，如果不存在，请你输出-1，如果存在多个，请你输出符合条件的最低的分数线。 数据范围：1 ≤ n ≤ 50000，1 ≤ x ≤ y ≤ n进阶：时间复杂度O(nlogn)，空间复杂度O(n) 输入描述： 12输入第一行仅包含三个正整数n,x,y，分别表示参赛的人数和晋级淘汰人数区间。(1&lt;=n&lt;=50000,1&lt;=x,y&lt;=n)输入第二行包含n个整数，中间用空格隔开，表示从1号选手到n号选手的成绩。(1&lt;=|a_i|&lt;=1000) 输出描述： 1输出仅包含一个整数，如果不存在这样的m，则输出-1，否则输出符合条件的最小的值。 输入例子1： 126 2 31 2 3 4 5 6 输出例子1： 13 分析和解答这个题好像出的case比较弱，做的时候直接用前后缀偷鸡了，实际上可能需要考虑同分数的情况，所以自己的前后缀做法实际上是有问题的，不过既然偷过了，就先不管了哈哈哈，就当他是笔试题和leetcode的不同了； 笔试题模板就用类似这样的，写成leetcode的写法，也会相对比较熟练了 12345678910111213141516171819202122232425262728293031323334353637#encoding:utf-8class Solution(object): def func(self, n, x, y, scores): scores.sort() pre = 0 last = len(scores) m = -1 for i in range(len(scores)): # 二分优化 pre += 1 last -= 1 if pre &gt;= x and pre &lt;= y and last &gt;= x and last &lt;= y: m = scores[i] break return mif __name__ == &#x27;__main__&#x27;: # init solution s = Solution() # input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773 n, x, y = map(int, input().strip().split(&quot; &quot;)) scores = list(map(int, input().strip().split(&quot; &quot;))) # mock区域 # n = 6 # x = 2 # y = 3 # scores = [1, 2, 3, 4, 5, 6] res = s.func(n, x, y, scores) print(res) 第二题：正则序列题目大意我们称一个长度为n的序列为正则序列，当且仅当该序列是一个由1~n组成的排列，即该序列由n个正整数组成，取值在[1,n]范围，且不存在重复的数，同时正则序列不要求排序 有一天小团得到了一个长度为n的任意序列s，他需要在有限次操作内，将这个序列变成一个正则序列，每次操作他可以任选序列中的一个数字，并将该数字加一或者减一。 请问他最少用多少次操作可以把这个序列变成正则序列？ 数据范围： 1 ≤ n ≤ 20000，0 ≤ abs(s_i) ≤ 10000进阶：时间复杂度O(n)，空间复杂度O(n) 注：这里实际上是不是写错了，时间复杂度没法做到O(n)吧 输入例子1： 125-1 2 3 10 100 输出例子1： 1103 分析和解答这个题也太简单了，感觉甚至不如平常周赛第一题的包装后的难度，排个序然后对位相减就可以，O(nlogn)的解法如下 12345678910111213141516171819202122232425#encoding:utf-8class Solution(object): def func(self, n, nums): nums.sort() res = 0 for i in range(len(nums)): res += abs(nums[i] - (i+1)) return resif __name__ == &#x27;__main__&#x27;: # init solution s = Solution() # input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773 n = map(int, input().strip().split(&quot; &quot;)) nums = list(map(int, input().strip().split(&quot; &quot;))) # mock区域 # n = 5 # nums = [-1, 2, 3, 10, 100] res = s.func(n, nums) print(res) 第三题：公司食堂题目大意小美和小团所在公司的食堂有N张餐桌，从左到右摆成一排，每张餐桌有2张餐椅供至多2人用餐，公司职员排队进入食堂用餐。小美发现职员用餐的一个规律并告诉小团：当男职员进入食堂时，他会优先选择已经坐有1人的餐桌用餐，只有当每张餐桌要么空着要么坐满2人时，他才会考虑空着的餐桌； 当女职员进入食堂时，她会优先选择未坐人的餐桌用餐，只有当每张餐桌都坐有至少1人时，她才会考虑已经坐有1人的餐桌； 无论男女，当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐。现在食堂内已有若干人在用餐，另外M个人正排队进入食堂，小团会根据小美告诉他的规律预测排队的每个人分别会坐哪张餐桌。 进阶：时间复杂度O(nlogn)，空间复杂度O(n) 输入描述： 123456789第一行输入一个整数T（1&lt;=T&lt;=10），表示数据组数。每组数据占四行，第一行输入一个整数N（1&lt;=N&lt;=500000）；第二行输入一个长度为N且仅包含数字0、1、2的字符串，第i个数字表示左起第i张餐桌已坐有的用餐人数；第三行输入一个整数M（1&lt;=M&lt;=2N且保证排队的每个人进入食堂时都有可供选择的餐桌）；第四行输入一个长度为M且仅包含字母M、F的字符串，若第i个字母为M，则排在第i的人为男性，否则其为女性。 输出描述： 1每组数据输出占M行，第i行输出一个整数j（1&lt;=j&lt;=N），表示排在第i的人将选择左起第j张餐桌用餐。 输入示例1： 1234515011026MFMMFF 输入示例2： 123456211344 分析和解答感觉是个模拟题，本来以为笔试会经常出这种模拟题的，但是从今年来看好像不是这样啊。当有多张餐桌供职员选择时，他会选择最靠左的餐桌用餐 这感觉是一个提示，提示使用优先队列做模拟； 现在来看这个题好像一下想过去也不是能秒做的题目，但是感觉那天状态比较好吧？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#encoding:utf-8class Solution(object): def func(self, n, sitdown_peoples, m, gender): res_list = [] have_zero_count = 0 have_one_count = 0 have_two_count = 0 import heapq mapping = &#123;0: [], 1: [], 2: []&#125; # 每个list是priority queue（heapq） for i in range(len(sitdown_peoples)): mapping[sitdown_peoples[i]].append(i) # heapify一下，优先队列 for i in range(3): heapq.heapify(mapping[i]) # print(&quot;after mapping: &quot;, mapping) for i in range(len(gender)): if gender[i] == &#x27;M&#x27;: # 男员工会优先选择有一个人的地方坐，如果都有了就去坐两个空的 if len(mapping[1]) != 0: # 优先选择有一个人的地方坐 # 坐在这里 tmp_idx = heapq.heappop(mapping[1]) res_list.append(tmp_idx) # 修改状态 heapq.heappush(mapping[2], tmp_idx) else: # 去坐两个空的 tmp_idx = heapq.heappop(mapping[0]) res_list.append(tmp_idx) # 修改状态 heapq.heappush(mapping[1], tmp_idx) else: # 女员工会优先选择都空的地方坐，如果没有了才会和别人拼桌 if len(mapping[0]) != 0: # 优先选择没有人的地方 # 坐在这里 tmp_idx = heapq.heappop(mapping[0]) res_list.append(tmp_idx) # 修改状态 heapq.heappush(mapping[1], tmp_idx) else: # 去坐有人的 tmp_idx = heapq.heappop(mapping[1]) res_list.append(tmp_idx) # 修改状态 heapq.heappush(mapping[2], tmp_idx) return res_list if __name__ == &#x27;__main__&#x27;: # init solution s = Solution() # input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773 t = int(input().strip()) for _ in range(t): n = int(input().strip()) sitdown_peoples = list(map(str, input())) sitdown_peoples = [int(item) for item in sitdown_peoples] m = int(input().strip()) gender = list(map(str, input())) # print(&quot;n: &quot;, n) # print(&quot;sitdown_peoples: &quot;, sitdown_peoples) # print(&quot;m: &quot;, m) # print(&quot;gender: &quot;, gender) res_list = s.func(n, sitdown_peoples, m, gender) # print(&quot;res_list: &quot;, res_list) for i in range(len(res_list)): print(res_list[i]+1) 第四题：最优二叉树II题目大意小团有一个由N个节点组成的二叉树，每个节点有一个权值。定义二叉树每条边的开销为其两端节点权值的乘积，二叉树的总开销即每条边的开销之和。小团按照二叉树的中序遍历依次记录下每个节点的权值，即他记录下了N个数，第i个数表示位于中序遍历第i个位置的节点的权值。之后由于某种原因，小团遗忘了二叉树的具体结构。在所有可能的二叉树中，总开销最小的二叉树被称为最优二叉树。现在，小团请小美求出最优二叉树的总开销。 输入描述： 12第一行输入一个整数N（1&lt;=N&lt;=300），表示二叉树的节点数。第二行输入N个由空格隔开的整数，表示按中序遍历记录下的各个节点的权值，所有权值均为不超过1000的正整数。 输出描述： 1输出一个整数，表示最优二叉树的总开销。 输入例子1： 1257 6 5 1 3 输出例子1： 145 例子说明1： 1最优二叉树如图所示，总开销为7*1+6*5+5*1+1*3=45。 分析和解答这个题后来看了答案，好像是要区间dp的做法，但是区间dp感觉就是完全未知的领域了，树上的操作感觉实在是太多了，包括还有线段树一类的，说到这里也什么时候找个线段树的模板，以备之后套用吧 这个题也可以用树形dp直接暴力，而且这里学到一个lru_cache，对于笔试题感觉是一种偷鸡的操作，让本来只能过2/10的测试用例瞬间变到过6/10 ~ 7/10了，感觉就是dfs中的一个笔试偷鸡操作？应该所有dfs都可以用吧！ 12345from functiontools import lru_cache@lru_cache(1000*1000)def dfs(): # do sth 这个题暂时只学习了下dfs暴力的方法了，和子结构树形dp很像，但是和leetcode那边的区别是这里的输入是一个数组，所以dfs的区间是 (0, n) 这种感觉，然后dfs的含义感觉就是把 i 作为子结构的根节点，然后i这个位置乘父亲的，再加上左边和右边的，就完成了一次内部的递归，此外，在内部递归中要遍历每个 i 位置，即每次（包括dfs下去的子层）都要把这个地方当做根节点试一下，最后记录一个局部子结构的ret最优作为返回值，而 (0, n) 这个子结构实际上就是父结构了，另外每次要把 parent_value 往下传下去； 子结构dp，LeetCode相似题目： 687.最长同值路径 medium124.二叉树中的最大路径和 hard543.二叉树直径 easy 如下代码可以通过6/10 ~ 7/10组测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142434445#encoding:utf-8from functools import lru_cacheclass Solution(object): def func(self, n, values): # 输出的values是一个global的数组，这里lru_cache大幅优化效率 @lru_cache(1000*1000) def dfs(left, right, parent_val): # 3. 写出口，这里等于的话，就0 if left &gt;= right: return 0 # 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值 res = 1e9 # 2. 递归这个left,right区间下的最优子结构 for i in range(left, right): left_val = dfs(left, i, values[i]) right_val = dfs(i+1, right, values[i]) res = min(res, values[i] * parent_val + left_val + right_val) # 1. 先写返回值，这里是子结构返回值，每个子结构都初始化一个inf值 return res return dfs(0, n, 0)if __name__ == &#x27;__main__&#x27;: # init solution s = Solution() # input区域 https://blog.csdn.net/mmmmonkeyfei/article/details/118863773 n = int(input().strip()) global values values = list(map(int, input().strip().split(&quot; &quot;))) # print(&quot;n: &quot;, n) # print(&quot;values: &quot;, values) # 调用以及output res = s.func(n, values) print(res)","categories":[{"name":"笔试练习-python","slug":"笔试练习-python","permalink":"http://example.com/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0-python/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","permalink":"http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"}]},{"title":"LeetCode2022春季战队赛","slug":"algorithms/leetcode-weekly-contest/LeetCode2022春季战队赛","date":"2022-04-23T11:47:54.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022春季战队赛/","link":"","permalink":"http://example.com/2022/04/23/algorithms/leetcode-weekly-contest/LeetCode2022%E6%98%A5%E5%AD%A3%E6%88%98%E9%98%9F%E8%B5%9B/","excerpt":"比赛综述&amp;总结： 这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了， 另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的","text":"比赛综述&amp;总结： 这个春季战队赛还是挺难的，第一题上来就是读题困难；第二题只能想到很暴力的思路了，感觉第二题和笔试题还是挺像的，这种时间超出的没想到有一些dp操作优化感觉还是太久没做类似的题目了；第三题hard的dp，现在自己的实力差距还是有些大了，有时间还是想补一下这个题的；后面几个题貌似难度有点过大了， 另外赛制的话这个看起来就像函数版的ACM赛制一样，不能面向错误编程了，只告诉一个超出时间限制还是有难度的 第一题：LCP 55.采集果实题目链接 题目大意欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。 在新手村中，各位勇者需要采集一些果实来制作药剂。time[i] 表示勇者每次采集 1～limit 颗第 i 种类型的果实需要的时间（即每次最多可以采集 limit 颗果实）。 当前勇者需要完成「采集若干批果实」的任务， fruits[j] = [type, num] 表示第 j 批需要采集 num 颗 type 类型的果实。采集规则如下： 按 fruits 给定的顺序依次采集每一批次 采集完当前批次的果实才能开始采集下一批次 勇者完成当前批次的采集后将清空背包（即多余的果实将清空） 请计算并返回勇者完成采集任务最少需要的时间。 示例1： 12345678910输入：time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3输出：10解释：由于单次最多采集 3 颗第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2*1=2第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3*2=6第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2*1=2返回总耗时 2+6+2=10 示例2： 123456789输入：time = [1], fruits = [[0,3],[0,5]], limit = 2输出：5解释：由于单次最多采集 2 颗第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1*2=2第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1*3=3需按照顺序依次采集，返回 2+3=5 提示： 1 &lt;= time.length &lt;= 100 1 &lt;= time[i] &lt;= 100 1 &lt;= fruits.length &lt;= 10^3 0 &lt;= fruits[i][0] &lt; time.length 1 &lt;= fruits[i][1] &lt; 10^3 1 &lt;= limit &lt;= 100 分析和解答这个题一上来就让人读题困难了，简单概括来说就是一个套角标，然后看看是否能整除，除完了向上取整吧 123456789101112131415class Solution(object): def getMinimumTime(self, time, fruits, limit): &quot;&quot;&quot; :type time: List[int] :type fruits: List[List[int]] :type limit: int :rtype: int &quot;&quot;&quot; res = 0 for i in range(len(fruits)): if fruits[i][1] % limit != 0: res += ((fruits[i][1]//limit) + 1) * time[fruits[i][0]] else: res += (fruits[i][1]//limit) * time[fruits[i][0]] return res 第二题：LCP 56.信物传送题目链接 题目大意欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。 本次试炼场地设有若干传送带，matrix[i][j] 表示第 i 行 j 列的传送带运作方向，&quot;^&quot;,&quot;v&quot;,&quot;&lt;&quot;,&quot;&gt;&quot; 这四种符号分别表示 上、下、左、右 四个方向。信物会随传送带的方向移动。勇者每一次施法操作，可临时变更一处传送带的方向，在物品经过后传送带恢复原方向。 通关信物初始位于坐标 start 处，勇者需要将其移动到坐标 end 处，请返回勇者施法操作的最少次数。 注意： start 和 end 的格式均为 [i,j] 示例1： 123456789输入：matrix = [&quot;&gt;&gt;v&quot;,&quot;v^&lt;&quot;,&quot;&lt;&gt;&lt;&quot;], start = [0,1], end = [2,0]输出：1解释：如上图所示当信物移动到 [1,1] 时，勇者施法一次将 [1,1] 的传送方向 ^ 从变更为 &lt;从而信物移动到 [1,0]，后续到达 end 位置因此勇者最少需要施法操作 1 次 示例2： 12345输入：matrix = [&quot;&gt;&gt;v&quot;,&quot;&gt;&gt;v&quot;,&quot;^&lt;&lt;&quot;], start = [0,0], end = [1,1]输出：0解释：勇者无需施法，信物将自动传送至 end 位置 示例3： 123输入：matrix = [&quot;&gt;^^&gt;&quot;,&quot;&lt;^v&gt;&quot;,&quot;^v^&lt;&quot;], start = [0,0], end = [1,3]输出：3 提示： matrix 中仅包含 &#39;^&#39;、&#39;v&#39;、&#39;&lt;&#39;、&#39;&gt;&#39; 0 &lt; matrix.length &lt;= 100 0 &lt; matrix[i].length &lt;= 100 0 &lt;= start[0],end[0] &lt; matrix.length 0 &lt;= start[1],end[1] &lt; matrix[i].length 分析和解答这个题感觉有平常周赛里相对难一点第三题的感觉，比赛的时候没有想到太好的做法就直接超级暴力了，赛后看只过了2/32个测试用例，这也是这个比赛没法面向答案编程的难度吧hhhh 实际上要用bfs+dp的做法来做，当时能想到bfs，但是还是忽略和dp结合到一起了 这个题不需要记录vis了，就是说只把更小的入队，也好像不能纯优先队列，因为有些地方有好几个方向能走到，另外不用优先队列也可以做，但是用优先队列好像耗时会快一些 优先队列方法： 12345678910111213141516171819202122232425262728293031323334353637383940def conveyorBelt(self, matrix, start, end): &quot;&quot;&quot; :type matrix: List[str] :type start: List[int] :type end: List[int] :rtype: int &quot;&quot;&quot; dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] # 二维dp，代表从每个点到x y位置处的最小消耗 dp = [[1e9 for _ in range(len(matrix[0]))] for _ in range(len(matrix))] # 状态初始化 sx, sy = start import heapq pq = [] heapq.heappush(pq, (0, [sx, sy])) # 优先队列 dp[sx][sy] = 0 while len(pq) != 0: tmp = heapq.heappop(pq) x, y = tmp[1] for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx &gt;= 0 and nx &lt; len(matrix) and ny &gt;= 0 and ny &lt; len(matrix[0]): # 这里不用设置visited数组是关键 if (matrix[x][y] == &#x27;^&#x27; and i == 2) or (matrix[x][y] == &#x27;v&#x27; and i == 0) or (matrix[x][y] == &#x27;&lt;&#x27; and i == 3) or (matrix[x][y] == &#x27;&gt;&#x27; and i == 1): if dp[x][y] &lt; dp[nx][ny]: # 只有更小的才入队，貌似不是优先队列也行 dp[nx][ny] = dp[x][y] heapq.heappush(pq, (tmp[0], [nx, ny])) else: if dp[x][y] + 1 &lt; dp[nx][ny]: # 只有更小的才入队，貌似不是优先队列也行 dp[nx][ny] = dp[x][y] + 1 heapq.heappush(pq, (tmp[0]+1, [nx, ny])) return dp[end[0]][end[1]] 非优先队列方法： 1234567891011121314151617181920212223242526272829303132333435363738def conveyorBelt(self, matrix, start, end): &quot;&quot;&quot; :type matrix: List[str] :type start: List[int] :type end: List[int] :rtype: int &quot;&quot;&quot; dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] # 二维dp，代表从每个点到x y位置处的最小消耗 dp = [[1e9 for _ in range(len(matrix[0]))] for _ in range(len(matrix))] # 状态初始化 sx, sy = start queue = [[sx, sy]] dp[sx][sy] = 0 while len(queue) != 0: x, y = queue[0] queue = queue[1:] for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx &gt;= 0 and nx &lt; len(matrix) and ny &gt;= 0 and ny &lt; len(matrix[0]): # 这里不用设置visited数组是关键 if (matrix[x][y] == &#x27;^&#x27; and i == 2) or (matrix[x][y] == &#x27;v&#x27; and i == 0) or (matrix[x][y] == &#x27;&lt;&#x27; and i == 3) or (matrix[x][y] == &#x27;&gt;&#x27; and i == 1): if dp[x][y] &lt; dp[nx][ny]: # 只有更小的才入队，貌似不是优先队列也行 dp[nx][ny] = dp[x][y] queue.append([nx, ny]) else: if dp[x][y] + 1 &lt; dp[nx][ny]: # 只有更小的才入队，貌似不是优先队列也行 dp[nx][ny] = dp[x][y] + 1 queue.append([nx, ny]) return dp[end[0]][end[1]] 比赛时候的超时做法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107class Solution(object): def conveyorBelt(self, matrix, start, end): &quot;&quot;&quot; :type matrix: List[str] :type start: List[int] :type end: List[int] :rtype: int &quot;&quot;&quot; dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] record = [[[-1, 0] for _ in range(len(matrix[0]))] for _ in range(len(matrix))] visited = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))] total_vis = 0 target_vis = len(matrix[0]) * len(matrix) # 第一次从start开始走，把所有能走到的位置都标记上，如果走到了end则跳出并且输出0 # x纵向，y横向 sx, sy = start nx, ny = sx, sy while visited[nx][ny] == 0 and nx &gt;= 0 and nx &lt; len(matrix) and ny &gt;= 0 and ny &lt; len(matrix[0]): # 如果走到了end则跳出，并且输出0 if nx == end[0] and ny == end[1]: return 0 # 标记访问过的 visited[nx][ny] = 1 total_vis += 1 # 修改状态 record[nx][ny][0] = 0 record[nx][ny][1] = 1 # 按照当前的格子走 if matrix[nx][ny] == &#x27;&gt;&#x27;: ny = ny + 1 elif matrix[nx][ny] == &#x27;&lt;&#x27;: ny = ny - 1 elif matrix[nx][ny] == &#x27;^&#x27;: nx = nx - 1 elif matrix[nx][ny] == &#x27;v&#x27;: nx = nx + 1 # print(&quot;total_vis: &quot;, total_vis) # print(&quot;target_vis: &quot;, target_vis) # print(&quot;record: &quot;, record) # 暴力走 now_status = 0 jilu_i = 0 jilu_j = 0 while total_vis != target_vis: # 找到一个与now_status相邻的位置 break_flag = False for i in range(jilu_i, len(matrix)): for j in range(jilu_j, len(matrix[0])): can_flag = False if visited[i][j] == 0: # 如果还没有访问过 # 如果临近的可达状态有上一个now_status的 for k in range(4): nnx = i + dx[k] nny = j + dy[k] if nnx &gt;= 0 and nnx &lt; len(matrix) and nny &gt;= 0 and nny &lt; len(matrix[0]) and record[nnx][nny][0] == now_status: # can_flag = True break if can_flag: break_flag = True break if break_flag: break if break_flag: # 还能找到 jilu_i = i jilu_j = j nx, ny = i, j while nx &gt;= 0 and nx &lt; len(matrix) and ny &gt;= 0 and ny &lt; len(matrix[0]) and visited[nx][ny] == 0: # 修改状态 record[nx][ny][0] = now_status + 1 record[nx][ny][1] = 1 # 增加 visited[i][j] = 1 total_vis += 1 # 按照当前的格子走 if matrix[nx][ny] == &#x27;&gt;&#x27;: ny = ny + 1 elif matrix[nx][ny] == &#x27;&lt;&#x27;: ny = ny - 1 elif matrix[nx][ny] == &#x27;^&#x27;: nx = nx - 1 elif matrix[nx][ny] == &#x27;v&#x27;: nx = nx + 1 # print(record) # print(&quot;=============&quot;) else: now_status += 1 # 再多一跳才能跳到的 return record[end[0]][end[1]][0]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"}]},{"title":"289场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/289场LeetCode周赛","date":"2022-04-18T10:03:00.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/04/18/algorithms/leetcode-weekly-contest/289场LeetCode周赛/","link":"","permalink":"http://example.com/2022/04/18/algorithms/leetcode-weekly-contest/289%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了； 第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… 吃饭时的怪癖 好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh 第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了； 第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多； 第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 这次周赛之后补的没有按时间做了，总体来说的话用到的数据结构和方法都是周赛常见的，前缀还有Counter这些的。第四题根据大佬的说法是个树形DP，其实应该看一看的但是事情比较多只能把第四题鸽了； 第二题这种有点类似数学的题，还有最近的聊天来看又让自己想起本科刷题比赛期间里最后悔的一个题目了，关于素数的题那学期还正好在学信安数学，找了那么久规律已经对了，可惜最后只是错在边界上了，如果当时能和队友再多讨论下，或者再想想边界和精度的问题应该就能过了，也可能这就是ACM比赛的魅力吧… 吃饭时的怪癖 好像也是自己的第15场周赛，希望能继续坚持了，不知道目标是什么的时候就坚持刷题呗hhh 第一题：比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了； 第二题：很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多； 第三题：一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：6070.计算字符串的数字和题目链接 题目大意给你一个由若干数字（0 - 9）组成的字符串 s ，和一个整数。 如果 s 的长度大于 k ，则可以执行一轮操作。在一轮操作中，需要完成以下工作： 将 s 拆分 成长度为 k 的若干 连续数字组 ，使得前 k 个字符都分在第一组，接下来的 k 个字符都分在第二组，依此类推。注意，最后一个数字组的长度可以小于 k 。 用表示每个数字组中所有数字之和的字符串来 替换 对应的数字组。例如，&quot;346&quot; 会替换为 &quot;13&quot; ，因为 3 + 4 + 6 = 13 。 合并 所有组以形成一个新字符串。如果新字符串的长度大于 k 则重复第一步。 返回在完成所有轮操作后的 s 。 示例1： 12345678910输入：s = &quot;11111222223&quot;, k = 3输出：&quot;135&quot;解释：- 第一轮，将 s 分成：&quot;111&quot;、&quot;112&quot;、&quot;222&quot; 和 &quot;23&quot; 。 接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 这样，s 在第一轮之后变成 &quot;3&quot; + &quot;4&quot; + &quot;6&quot; + &quot;5&quot; = &quot;3465&quot; 。- 第二轮，将 s 分成：&quot;346&quot; 和 &quot;5&quot; 。 接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。 这样，s 在第二轮之后变成 &quot;13&quot; + &quot;5&quot; = &quot;135&quot; 。 现在，s.length &lt;= k ，所以返回 &quot;135&quot; 作为答案。 示例2： 123456输入：s = &quot;00000000&quot;, k = 3输出：&quot;000&quot;解释：将 &quot;000&quot;, &quot;000&quot;, and &quot;00&quot;.接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 s 变为 &quot;0&quot; + &quot;0&quot; + &quot;0&quot; = &quot;000&quot; ，其长度等于 k ，所以返回 &quot;000&quot; 。 提示： 1 &lt;= s.length &lt;= 100 2 &lt;= k &lt;= 100 s 仅由数字（0 - 9）组成。 分析和解答比较简单但是这种题总让人感觉要敲很多本来可以合并到一起的代码，自己的想法总需要锻炼手速，可能就是自己和大佬的区别了； 123456789101112131415161718192021222324252627class Solution(object): def digitSum(self, s, k): &quot;&quot;&quot; :type s: str :type k: int :rtype: str &quot;&quot;&quot; while len(s) &gt; k: tmp_list = [] ttmp_list = [] for i in range(len(s)): ttmp_list.append(s[i]) if (i+1) % k == 0: tmp_list.append(ttmp_list) ttmp_list = [] if len(ttmp_list): tmp_list.append(ttmp_list) # print(tmp_list) tttmp_list = [] for i in range(len(tmp_list)): tsum = 0 for j in range(len(tmp_list[i])): tsum += int(tmp_list[i][j]) tttmp_list.append(str(tsum)) s = &#x27;&#x27;.join(tttmp_list) return s 第二题：6071.完成所有任务需要的最少轮数题目链接 题目大意给你一个下标从 0 开始的整数数组 tasks ，其中 tasks[i] 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 相同难度级别 的任务。 返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 示例1： 12345678输入：tasks = [2,2,3,3,2,4,4,4,4,4]输出：4解释：要想完成所有任务，一个可能的计划是：- 第一轮，完成难度级别为 2 的 3 个任务。 - 第二轮，完成难度级别为 3 的 2 个任务。 - 第三轮，完成难度级别为 4 的 3 个任务。 - 第四轮，完成难度级别为 4 的 2 个任务。 可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。 示例2： 123输入：tasks = [2,3,3]输出：-1解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。 提示： 1 &lt;= tasks.length &lt;= 10^5 1 &lt;= tasks[i] &lt;= 10^9 分析和解答很像数学题，但仔细看起来就是个贪心，Counter+贪心很快就能搞定，然后拓展一下的话让自己想起中国剩余定理、扩展欧几里得算法、欧拉函数这些的了。另外补充说一下周赛的第二题感觉够不上medium的难度，笔试的题2/3也都是medium但是难很多； 12345678910111213141516171819202122232425262728class Solution(object): def minimumRounds(self, tasks): &quot;&quot;&quot; :type tasks: List[int] :rtype: int &quot;&quot;&quot; from collections import Counter cnt_tasks = Counter(tasks) print(cnt_tasks) # Counter(&#123;4: 5, 2: 3, 3: 2&#125;) res = 0 for key, value in cnt_tasks.items(): if value == 1: # 中间跳出 return -1 t_value = value cnt_nums = t_value // 3 t_value -= cnt_nums * 3 if t_value == 1: cnt_nums = cnt_nums - 1 + 2 # 去掉一次搞3，然后搞两次2 elif t_value == 2: cnt_nums += 1 t_value -= 2 # print(t_value) res += cnt_nums return res 第三题：6072.转角路径的乘积中最多能有几个尾随零题目链接 题目大意给你一个二维整数数组 grid ，大小为 m x n，其中每个单元格都含一个正整数。 转角路径 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 向水平方向 或者 向竖直方向 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 另一个 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。 一条路径的 乘积 定义为：路径上所有值的乘积。 请你从 grid 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。 注意： 水平 移动是指向左或右移动。 竖直 移动是指向上或下移动。 示例1： 12345678输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]输出：3解释：左侧的图展示了一条有效的转角路径。其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。可以证明在这条转角路径的乘积中尾随零数目最多。中间的图不是一条有效的转角路径，因为它有不止一个弯。右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。 示例2： 1234输入：grid = [[4,3,2],[7,6,1],[8,8,8]]输出：0解释：网格如上图所示。不存在乘积含尾随零的转角路径。 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 10^5 1 &lt;= m * n &lt;= 10^5 1 &lt;= grid[i][j] &lt;= 1000 分析和解答一方面要想到后缀为0实际上只能通过2*5得到，这样把每个格子的2 5先记录下来。然后能想到是前缀的思想，自己想到了从上到下，从左到右，从右到左的前缀和，但是漏掉了从下到上的前缀和，就是从下往上的一个L拐的情况，最开始还以为是dfs但是数据范围和只能拐一次不太像。求出四方向的前缀后，剩下就是角标算一算了，注意如果能往右拐一格，实际上就能拐到底了； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Solution(object): def maxTrailingZeros(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; def get_num_five(num): cnt = 0 while num%5 == 0: num /= 5 cnt += 1 return cnt def get_num_two(num): cnt = 0 while num%2 == 0: num /= 2 cnt += 1 return cnt # 从上到下的前缀矩阵，从下到上的前缀矩阵 grid_up_to_down_prefix = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] grid_down_to_up_prefix = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] for i in range(len(grid)): for j in range(len(grid[0])): if i == 0: # 第一行 grid_up_to_down_prefix[i][j][0] = get_num_two(grid[i][j]) grid_up_to_down_prefix[i][j][1] = get_num_five(grid[i][j]) grid_down_to_up_prefix[len(grid)-1][j][0] = get_num_two(grid[len(grid)-1][j]) grid_down_to_up_prefix[len(grid)-1][j][1] = get_num_five(grid[len(grid)-1][j]) else: grid_up_to_down_prefix[i][j][0] = grid_up_to_down_prefix[i-1][j][0] + get_num_two(grid[i][j]) grid_up_to_down_prefix[i][j][1] = grid_up_to_down_prefix[i-1][j][1] + get_num_five(grid[i][j]) grid_down_to_up_prefix[len(grid)-1-i][j][0] = grid_down_to_up_prefix[len(grid)-i][j][0] + get_num_two(grid[len(grid)-1-i][j]) grid_down_to_up_prefix[len(grid)-1-i][j][1] = grid_down_to_up_prefix[len(grid)-i][j][1] + get_num_five(grid[len(grid)-1-i][j]) # 从左到右的前缀矩阵，从右到左的前缀矩阵 grid_left_to_right_prefix = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] grid_right_to_left_prefix = [[[0, 0] for _ in range(len(grid[0]))] for _ in range(len(grid))] for i in range(len(grid)): for j in range(len(grid[0])): if j == 0: # 第一列 grid_left_to_right_prefix[i][j][0] = get_num_two(grid[i][j]) grid_left_to_right_prefix[i][j][1] = get_num_five(grid[i][j]) grid_right_to_left_prefix[i][len(grid[0])-1][0] = get_num_two(grid[i][len(grid[0])-1]) grid_right_to_left_prefix[i][len(grid[0])-1][1] = get_num_five(grid[i][len(grid[0])-1]) else: grid_left_to_right_prefix[i][j][0] = grid_left_to_right_prefix[i][j-1][0] + get_num_two(grid[i][j]) grid_left_to_right_prefix[i][j][1] = grid_left_to_right_prefix[i][j-1][1] + get_num_five(grid[i][j]) grid_right_to_left_prefix[i][len(grid[0])-1-j][0] = grid_right_to_left_prefix[i][len(grid[0])-j][0] + get_num_two(grid[i][len(grid[0])-1-j]) grid_right_to_left_prefix[i][len(grid[0])-1-j][1] = grid_right_to_left_prefix[i][len(grid[0])-j][1] + get_num_five(grid[i][len(grid[0])-1-j]) # for i in range(len(grid)): # for j in range(len(grid[0])): # print(grid_right_to_left_prefix[i][j]) # print(&quot;\\n&quot;) # 从上往下走，从下往上走同时 max_zero_last = 0 for i in range(len(grid)): for j in range(len(grid[0])): # 上往下，然后往右看 cnt_num_2 = grid_up_to_down_prefix[i][j][0] + grid_left_to_right_prefix[i][-1][0] - grid_left_to_right_prefix[i][j][0] cnt_num_5 = grid_up_to_down_prefix[i][j][1] + grid_left_to_right_prefix[i][-1][1] - grid_left_to_right_prefix[i][j][1] max_zero_last = max(max_zero_last, min(cnt_num_2, cnt_num_5)) # 下往上，然后往右看 cnt_num_2 = grid_down_to_up_prefix[len(grid)-1-i][j][0] + grid_left_to_right_prefix[len(grid)-1-i][-1][0] - grid_left_to_right_prefix[len(grid)-1-i][j][0] cnt_num_5 = grid_down_to_up_prefix[len(grid)-1-i][j][1] + grid_left_to_right_prefix[len(grid)-1-i][-1][1] - grid_left_to_right_prefix[len(grid)-1-i][j][1] max_zero_last = max(max_zero_last, min(cnt_num_2, cnt_num_5)) # 上往下，然后往左看 cnt_num_2 = grid_up_to_down_prefix[i][j][0] + grid_right_to_left_prefix[i][0][0] - grid_right_to_left_prefix[i][j][0] cnt_num_5 = grid_up_to_down_prefix[i][j][1] + grid_right_to_left_prefix[i][0][1] - grid_right_to_left_prefix[i][j][1] max_zero_last = max(max_zero_last, min(cnt_num_2, cnt_num_5)) # 下往上，然后往左看 cnt_num_2 = grid_down_to_up_prefix[len(grid)-1-i][j][0] + grid_right_to_left_prefix[len(grid)-1-i][0][0] - grid_right_to_left_prefix[len(grid)-1-i][j][0] cnt_num_5 = grid_down_to_up_prefix[len(grid)-1-i][j][1] + grid_right_to_left_prefix[len(grid)-1-i][0][1] - grid_right_to_left_prefix[len(grid)-1-i][j][1] max_zero_last = max(max_zero_last, min(cnt_num_2, cnt_num_5)) return max_zero_last","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"}]},{"title":"288场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/288场LeetCode周赛","date":"2022-04-11T14:15:10.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/04/11/algorithms/leetcode-weekly-contest/288场LeetCode周赛/","link":"","permalink":"http://example.com/2022/04/11/algorithms/leetcode-weekly-contest/288%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 上一周清明节扫墓鸽了一周，这周又回来了~ 周中尝试做了一个笔试题找了下思路的手感，然后发现leetcode说不定隔一阵做一次手感会更好哈哈哈。这次的前三个题感觉都是很快就有思路的，然后感觉自己做的顺手程度和代码的变量命名关系很大，如果变量命名的很顺利，那说明这次周赛可能就会很顺利了； 另外来说的话周赛确实要总结下数据结构，感觉前三题都是各种数据结构几乎差不多就能做出来了，而且要熟悉各个数据结构的时间复杂度，像这次的第三题实际上堆的想法是在脑子里一闪而过的，但是没有深思考下去就放弃了，有点可惜； 这次还积累到一个很坑的地方，就是除【1e9+7】和除【1000000007还有除10**9+7】可能是有精度问题的！！！最后比赛结束后才因为精度问题把这个题改过了做出来，实在是太坑了，或者说可能要用int把1e9+7转一下吧 第一题：比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的； 第二题：加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧； 第三题：根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 上一周清明节扫墓鸽了一周，这周又回来了~ 周中尝试做了一个笔试题找了下思路的手感，然后发现leetcode说不定隔一阵做一次手感会更好哈哈哈。这次的前三个题感觉都是很快就有思路的，然后感觉自己做的顺手程度和代码的变量命名关系很大，如果变量命名的很顺利，那说明这次周赛可能就会很顺利了； 另外来说的话周赛确实要总结下数据结构，感觉前三题都是各种数据结构几乎差不多就能做出来了，而且要熟悉各个数据结构的时间复杂度，像这次的第三题实际上堆的想法是在脑子里一闪而过的，但是没有深思考下去就放弃了，有点可惜； 这次还积累到一个很坑的地方，就是除【1e9+7】和除【1000000007还有除10**9+7】可能是有精度问题的！！！最后比赛结束后才因为精度问题把这个题改过了做出来，实在是太坑了，或者说可能要用int把1e9+7转一下吧 第一题：比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的； 第二题：加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧； 第三题：根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：2231.按奇偶性交换后的最大数字题目链接 题目大意给你一个正整数 num 。你可以交换 num 中 奇偶性 相同的任意两位数字（即，都是奇数或者偶数）。 返回交换 任意 次之后 num 的 最大 可能值。 示例1： 123456输入：num = 1234输出：3412解释：交换数字 3 和数字 1 ，结果得到 3214 。交换数字 2 和数字 4 ，结果得到 3412 。注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。 示例2： 12345输入：num = 65875输出：87655解释：交换数字 8 和数字 6 ，结果得到 85675 。交换数字 5 和数字 7 ，结果得到 87655 。注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。 提示： 1 &lt;= num &lt;= 10^9 分析和解答比较水，奇偶位置（交错位置）分开靠考虑的题遇到过好几次了，这种题就纯是锻炼手速和快速思路，应该写的再快一点的； 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def largestInteger(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; nums = list(str(num)) tmp = [0 for i in range(len(nums))] # 记录角标奇偶性 oushu = [] jishu = [] for i in range(len(nums)): if int(nums[i]) % 2 == 0: tmp[i] = 0 oushu.append(int(nums[i])) else: tmp[i] = 1 jishu.append(int(nums[i])) # 贪心 k = 0 jishu.sort(reverse=True) j = 0 oushu.sort(reverse=True) res = [] for i in range(len(nums)): if tmp[i] == 0: res.append(oushu[j]) j += 1 else: res.append(jishu[k]) k += 1 res = [str(item) for item in res] return int(&#x27;&#x27;.join(res)) 第二题：2232.向表达式添加括号后的最小结果题目链接 题目大意给你一个下标从 0 开始的字符串 expression ，格式为 &quot;&lt;num1&gt;+&lt;num2&gt;&quot; ，其中 &lt;num1&gt; 和 &lt;num2&gt; 表示正整数。 请你向 expression 中添加一对括号，使得在添加之后， expression 仍然是一个有效的数学表达式，并且计算后可以得到 最小 可能值。左括号 必须 添加在 &#39;+&#39; 的左侧，而右括号必须添加在 &#39;+&#39; 的右侧。 返回添加一对括号后形成的表达式 expression ，且满足 expression 计算得到 最小 可能值。如果存在多个答案都能产生相同结果，返回任意一个答案。 生成的输入满足：expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围。 示例1： 12345输入：expression = &quot;247+38&quot;输出：&quot;2(47+38)&quot;解释：表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。注意 &quot;2(4)7+38&quot; 不是有效的结果，因为右括号必须添加在 &#x27;+&#x27; 的右侧。可以证明 170 是最小可能值。 示例2： 123输入：expression = &quot;12+34&quot;输出：&quot;1(2+3)4&quot;解释：表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。 示例3： 123输入：expression = &quot;999+999&quot;输出：&quot;(999+999)&quot;解释：表达式计算得到 999 + 999 = 1998 。 提示： 3 &lt;= expression.length &lt;= 10 expression 仅由数字 &#39;1&#39; 到 &#39;9&#39; 和 &#39;+&#39; 组成 expression 由数字开始和结束 expression 恰好仅含有一个 &#39;+&#39;. expression 的原始值和添加满足要求的任一对括号之后 expression 的值，都符合 32-bit 带符号整数范围 分析和解答加括号一个比较恶心的题，这种题就是角标要算来算去调来调去，然后又要考虑边界情况的，这次还没看清楚输出结果，以为是要输出那个最小可能数字，没想到是输出表达式还坑了一下。这个题如果给初学者做估计对双重循环的理解能更进一步吧； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution(object): def minimizeResult(self, expression): &quot;&quot;&quot; :type expression: str :rtype: str &quot;&quot;&quot; # 遍历每个可添加位置，然后找一个最小的 expression_list = expression.split(&#x27;+&#x27;) left_list = list(expression_list[0]) right_list = list(expression_list[1]) # print(left_list) # print(right_list) tmp_res = -1 min_res = 1e9 # left # 哨兵 left_res = 0 right_res = len(right_list)-1 min_res = int(&#x27;&#x27;.join(left_list)) + int(&#x27;&#x27;.join(right_list)) # min_res = min(min_res, int(&#x27;&#x27;.join(left_list[:1])) * (int(&#x27;&#x27;.join(left_list[1:])) + int(&#x27;&#x27;.join(right_list)))) # min_res = min(min_res, (int(&#x27;&#x27;.join(left_list)) + int(&#x27;&#x27;.join(right_list[:len(right_list)-1]))) * int(&#x27;&#x27;.join(right_list[len(right_list)-1:]))) for i in range(len(left_list)): # i代表插在前边 for j in range(len(right_list)): # j代表插在后边 # if i != 0 and j != len(right_list) - 1: pre = int(&#x27;&#x27;.join(left_list[:i])) if len(&#x27;&#x27;.join(left_list[:i])) else 1 inter = (int(&#x27;&#x27;.join(left_list[i:])) + int(&#x27;&#x27;.join(right_list[:j+1]))) last = int(&#x27;&#x27;.join(right_list[j+1:])) if len(&#x27;&#x27;.join(right_list[j+1:])) else 1 tmp_res = pre * inter * last if tmp_res &lt; min_res: min_res = tmp_res left_res = i right_res = j # min_res = min(min_res, tmp_res) # print(left_list[:i]) # print(left_list[i:]) # print(right_list[:j+1]) # print(right_list[j+1:]) # assert False # print(left_res, right_res) left_list.insert(left_res, &#x27;(&#x27;) right_list.insert(right_res+1, &#x27;)&#x27;) res_list = left_list + [&#x27;+&#x27;] + right_list return &#x27;&#x27;.join(res_list) 第三题：2233.K 次增加后的最大乘积题目链接 题目大意给你一个非负整数数组 nums 和一个整数 k 。每次操作，你可以选择 nums 中 任一 元素并将它 增加 1 。 请你返回 至多 k 次操作后，能得到的 nums 的 最大乘积 。由于答案可能很大，请你将答案对 10^9 + 7 取余后返回。 示例1： 123456输入：nums = [0,4], k = 5输出：20解释：将第一个数增加 5 次。得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。可以证明 20 是能得到的最大乘积，所以我们返回 20 。存在其他增加 nums 的方法，也能得到最大乘积。 示例2： 123456输入：nums = [6,3,3,2], k = 2输出：216解释：将第二个数增加 1 次，将第四个数增加 1 次。得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。可以证明 216 是能得到的最大乘积，所以我们返回 216 。存在其他增加 nums 的方法，也能得到最大乘积。 提示： 1 &lt;= nums.length, k &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^6 分析和解答根据数学积累还是能想到把数字均匀散开的时候乘积最大的，就像评论区说的就和周长固定的时候，什么时候矩形的面积最大一样，自己的想法是把每个地方均匀散开（向下一个数字补齐），排序后使用一种类似于前缀的思想简化时间复杂度，然后算长度来做乘法；另外大佬的heap（优先队列）做法实在是太眼前一亮了，没想到根据k的数据范围可以直接这么暴力，这样一下就简化很多了；另外就是大数精度的问题了，发现这个bug是因为这么多数乘在一起，不能就和标准答案差几吧； 自己的算法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution(object): def maximumProduct(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; # test = [43, 57, 60, 70, 72, 84, 86, 92] # ttt_1 = 1 # for i in range(len(test)): # ttt_1 *= (test[i] % (1e9+7)) # print(&quot;ttt_1: &quot;, ttt_1%(1e9+7)) c = 1000000007 # 这里换成1e9 + 7就过不了 # 平均了乘积最大，好像有前缀和那感觉 nums.sort() # 从小到大排序 print(&quot;nums: &quot;, nums) tmp_idx = -1 for i in range(len(nums)-1): if nums[i] &lt; nums[i+1]: # 这里还是有问题？ # print(&quot;k: &quot;, k) # print(&quot;(nums[i+1] - nums[i]) * i: &quot;, (nums[i+1] - nums[i]) * (i+1)) if k &gt; (nums[i+1] - nums[i]) * (i+1): k -= (nums[i+1] - nums[i]) * (i+1) nums[i] = nums[i+1] else: tmp_idx = i break # print(&quot;first nums: &quot;, nums) # print(&quot;tmp_idx: &quot;, tmp_idx) # print(&quot;k:&quot;, k) if tmp_idx == -1: # 把剩余的k均匀展开到各个地方 bias = k // len(nums) # 每个能增加几 k -= bias * len(nums) # print((nums[0] + bias + 1)**k) # print((nums[0] + bias)**(len(nums) - k)) # res = ((nums[-1] + bias + 1)**k) * ((nums[-1] + bias)**(len(nums) - k)) # 下边两行替代 res = 1 a1 = (nums[-1] + bias + 1) a2 = (nums[-1] + bias) for kl in range(k): res = ((res % c) * (a1 % c)) % c for kl in range(len(nums) - k): res = ((res % c) * (a2 % c)) % c else: # print(&quot;nums: &quot;, nums) # print(&quot;nums[tmp_idx+1:]: &quot;, nums[tmp_idx+1:]) res = 1 for i in range(tmp_idx+1, len(nums)): res = ((res%c) * (nums[i]%c)) % c t_nums = copy.deepcopy(nums[:tmp_idx+1]) # print(&quot;t_nums: &quot;, t_nums) bias = k // len(t_nums) # 每个能增加几 k -= bias * len(t_nums) t_res = 1 a1 = (t_nums[-1] + bias + 1) a2 = (t_nums[-1] + bias) # t_res = ((t_nums[-1] + bias + 1)**k) * ((t_nums[-1] + bias)**(len(t_nums) - k)) for kl in range(k): t_res = ((t_res % c) * (a1 % c)) % c for kl in range(len(t_nums) - k): t_res = ((t_res % c) * (a2 % c)) % c res = ((res%c) * (t_res%c)) % c return int(res) 抄大佬的堆的思路： 12345678910111213141516171819202122class Solution(object): def maximumProduct(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; c = 1000000007 # 这里换成1e9 + 7就过不了 import heapq heapq.heapify(nums) # 直接暴力模拟，k &lt; 10^5 while k &gt; 0: tmp = heapq.heappop(nums) heapq.heappush(nums, tmp+1) k -= 1 res = 1 for i in range(len(nums)): res = ((res%c) * (nums[i]%c)) % c return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","permalink":"http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"286场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/286场LeetCode周赛","date":"2022-03-27T13:37:13.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/03/27/algorithms/leetcode-weekly-contest/286场LeetCode周赛/","link":"","permalink":"http://example.com/2022/03/27/algorithms/leetcode-weekly-contest/286%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这周周赛久违的在常规时间里做出三题了，感觉还是要先仔细读题然后多想一想常用的数据结构和思路吧，像这次的第二题就很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加；另外这次周赛感觉又在面向答案编程了，自己的思考总是不太全面就开始做题，中间各种边界情况和极端情况就会忽略，笔试比较好用但是面试就不好说了，还是要加强下自己的一次AC准确率！ 第一题：比较简单，但是又忘记了 set 是可以直接相减的了，还用了个 Counter 搞来搞去整了半天，有点过于耗费时间了； 第二题：看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！ 第三题：数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 10 11 12 13 ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 9*次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 这周周赛久违的在常规时间里做出三题了，感觉还是要先仔细读题然后多想一想常用的数据结构和思路吧，像这次的第二题就很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加；另外这次周赛感觉又在面向答案编程了，自己的思考总是不太全面就开始做题，中间各种边界情况和极端情况就会忽略，笔试比较好用但是面试就不好说了，还是要加强下自己的一次AC准确率！ 第一题：比较简单，但是又忘记了 set 是可以直接相减的了，还用了个 Counter 搞来搞去整了半天，有点过于耗费时间了； 第二题：看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！ 第三题：数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 10 11 12 13 ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 9*次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：5268.找出两数组的不同题目链接 题目大意给你两个下标从 0 开始的整数数组 nums1 和 nums2 ，请你返回一个长度为 2 的列表 answer ，其中： answer[0] 是 nums1 中所有 不 存在于 nums2 中的 不同 整数组成的列表。 answer[1] 是 nums2 中所有 不 存在于 nums1 中的 不同 整数组成的列表。 注意：列表中的整数可以按 任意 顺序返回。 示例1： 12345输入：nums1 = [1,2,3], nums2 = [2,4,6]输出：[[1,3],[4,6]]解释：对于 nums1 ，nums1[1] = 2 出现在 nums2 中下标 0 处，然而 nums1[0] = 1 和 nums1[2] = 3 没有出现在 nums2 中。因此，answer[0] = [1,3]。对于 nums2 ，nums2[0] = 2 出现在 nums1 中下标 1 处，然而 nums2[1] = 4 和 nums2[2] = 6 没有出现在 nums2 中。因此，answer[1] = [4,6]。 示例2： 12345输入：nums1 = [1,2,3,3], nums2 = [1,1,2,2]输出：[[3],[]]解释：对于 nums1 ，nums1[2] 和 nums1[3] 没有出现在 nums2 中。由于 nums1[2] == nums1[3] ，二者的值只需要在 answer[0] 中出现一次，故 answer[0] = [3]。nums2 中的每个整数都在 nums1 中出现，因此，answer[1] = [] 。 提示： 1 &lt;= nums1.length, nums2.length &lt;= 1000 -1000 &lt;= nums1[i], nums2[i] &lt;= 1000 分析和解答比较简单，但是又忘记了 set 是可以直接相减的了，还用了个 Counter 搞来搞去整了半天，有点过于耗费时间了； 方法1（比赛时方法，现在看起来有点蠢hhh）： 1234567891011121314151617181920212223242526272829class Solution(object): def findDifference(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[List[int]] &quot;&quot;&quot; nums1 = list(set(nums1)) nums2 = list(set(nums2)) cnt1 = Counter(nums1) - Counter(nums2) cnt2 = Counter(nums2) - Counter(nums1) print(cnt1) print(cnt2) res = [] tmp = [] for key, value in cnt1.items(): tmp.append(key) res.append(tmp) tmp = [] for key, value in cnt2.items(): tmp.append(key) res.append(tmp) return res 方法2（set方法，只需一行233333）： 12345678class Solution(object): def findDifference(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: List[List[int]] &quot;&quot;&quot; return [list(set(nums1) - set(nums2)), list(set(nums2) - set(nums1))] 第二题：5236.美化数组的最少删除数题目链接 题目大意给你一个下标从 0 开始的整数数组 nums ，如果满足下述条件，则认为数组 nums 是一个 美丽数组 ： nums.length 为偶数 对所有满足 i % 2 == 0 的下标 i ，nums[i] != nums[i + 1] 均成立 注意，空数组同样认为是美丽数组。 你可以从 nums 中删除任意数量的元素。当你删除一个元素时，被删除元素右侧的所有元素将会向左移动一个单位以填补空缺，而左侧的元素将会保持 不变 。 返回使 nums 变为美丽数组所需删除的 最少 元素数目。 示例1： 123输入：nums = [1,1,2,3,5]输出：1解释：可以删除 nums[0] 或 nums[1] ，这样得到的 nums = [1,2,3,5] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 1 个元素。 示例2： 123输入：nums = [1,1,2,2,3,3]输出：2解释：可以删除 nums[0] 和 nums[5] ，这样得到的 nums = [1,2,2,3] 是一个美丽数组。可以证明，要想使 nums 变为美丽数组，至少需要删除 2 个元素。 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i] &lt;= 10^5 分析和解答看过去感觉就是个贪心思路的题，没有太验证过就开始写了，在调试了一些case后最后还是过了，自己搞这种题目的话如果这样就会要么过，要么就推倒重来，其实还是应该稍微合理性验证下的！很像之前有一个“模板匹配”的题目，主要需要反向思维一下，把删除变成添加，然后贪心就可以！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def minDeletion(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 0: return 0 res = [-1 for _ in range(len(nums))] idx_res = 0 idx_nums = 0 i = 0 while i &lt; len(nums): if idx_res % 2 == 0: &quot;&quot;&quot; 如果是偶数位了，就直接贪心选 &quot;&quot;&quot; res[idx_res] = nums[i] idx_res += 1 i += 1 elif idx_res % 2 != 0: &quot;&quot;&quot; 如果是奇数位，选一个离得比较远的 &quot;&quot;&quot; while i &lt; len(nums): if nums[i] != res[idx_res-1]: break i += 1 # print(nums[i], res[idx_res-1]) try: res[idx_res] = nums[i] idx_res += 1 i += 1 except: break # print(&quot;out: &quot;, i) if idx_res % 2 != 0: idx_res -= 1 # print(res[:idx_res]) return len(nums) - idx_res 第三题：5253.找到指定长度的回文数题目链接 题目大意给你一个整数数组 queries 和一个 正 整数 intLength ，请你返回一个数组 answer ，其中 answer[i] 是长度为 intLength 的 正回文数 中第 queries[i] 小的数字，如果不存在这样的回文数，则为 -1。 回文数 指的是从前往后和从后往前读一模一样的数字。回文数不能有前导 0 。 示例1： 123456输入：queries = [1,2,3,4,5,90], intLength = 3输出：[101,111,121,131,141,999]解释：长度为 3 的最小回文数依次是：101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 201, ...第 90 个长度为 3 的回文数是 999 。 示例2： 12345输入：queries = [2,4,6], intLength = 4输出：[1111,1331,1551]解释：长度为 4 的前 6 个回文数是：1001, 1111, 1221, 1331, 1441 和 1551 。 提示： 1 &lt;= queries.length &lt;= 5 * 10^4 1 &lt;= queries[i] &lt;= 10^9 1 &lt;= intLength &lt;= 15 分析和解答数学算角标的题目，如果是多年前刚刚接触编程的时候估计找到规律后也算不太对，但现在只要手动推导出来规律后实现起来应该几乎差不多了。这次多少还是有点面向答案编程的感觉，出一个badcase调试一组出一个badcase调试一组，这个是个比较坏的习惯。整体来说的话，这个题的思路就是算一半！比如要是四位数（偶数）的话，就是前一半先写 10 11 12 13 ，这样二位数往上递增的，后一半直接把这个反向过来拼接就行，其实也是个隐含的贪心思路，就等于从小往大选。如果是奇数的话，还需要单独把中间那个数算出来，多一个 9*次数的感觉。另外总觉得这个题很像之前cjc老师教数字逻辑课的时候，某一种二进制的写法一样，每次也是要颠倒一下，具体记不太清了； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Solution(object): def kthPalindrome(self, queries, intLength): &quot;&quot;&quot; :type queries: List[int] :type intLength: int :rtype: List[int] &quot;&quot;&quot; res = [] if intLength == 1: for i in range(len(queries)): res.append(queries[i]) # print(res) # return res elif intLength == 2: for i in range(len(queries)): tmp = int(str(queries[i]) + str(queries[i])) res.append(tmp) # print(res) # return res # elif intLength == 3: # for i in range(len(queries)): # a = queries[i] // 10 + 1 # b = queries[i] % 10 - 1 # if b == -1: # b = 9 # if a == 10: # a = 9 # tmp = int(str(a) + str(b) + str(a)) # res.append(tmp) # # print(res) # # return res else: ttmp = intLength // 2 # 整除2 if intLength % 2 == 0: # 要求偶数位，那就是第i个ttmp位数 base_idx = 10 ** (ttmp - 1) - 1 for i in range(len(queries)): half = str(base_idx + queries[i]) res.append(int(half + half[::-1])) # return res else: # 奇数位的，先确定中间的 for i in range(len(queries)): mid = str((queries[i] - 1) % 10) # print(mid) base_idx = 10 ** (ttmp - 1) - 1 # 多少位数在前边 if queries[i] % 10 != 0: offset = (queries[i] // 10) + 1 else: offset = (queries[i] // 10) half = str(base_idx + offset) # print(half) res.append(int(half+mid+half[::-1])) # return res max_tmp = (10 ** intLength) - 1 for i in range(len(res)): if res[i] &gt; max_tmp: res[i] = -1 return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"记录服务器conda虚拟环境导出","slug":"记录服务器conda虚拟环境导出","date":"2022-03-23T07:29:16.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2022/03/23/记录服务器conda虚拟环境导出/","link":"","permalink":"http://example.com/2022/03/23/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8conda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AF%BC%E5%87%BA/","excerpt":"某些场景下需要进行虚拟环境迁移，或者使用其他人的虚拟环境，这种时候如果能够完整导出别人的虚拟环境，在自己的环境下直接下载同步就很方便。","text":"某些场景下需要进行虚拟环境迁移，或者使用其他人的虚拟环境，这种时候如果能够完整导出别人的虚拟环境，在自己的环境下直接下载同步就很方便。 Reference: https://blog.csdn.net/shunaoxi2313/article/details/92003710 原机器A的导出准备通过如下命令，可以查看当前conda的可用环境 1234(base) abc@h1:~$ conda info --envs# conda environments:#base * /home/abc/miniconda3 导出当前的conda环境（注意，这样导出貌似只会导出使用conda命令安装的内容，如果需要导出pip则还需要其他步骤），这里直接在base环境下（如果要导出别的，就conda activate venv1这类的之后再导出就可以）。导出后会在目录下生成一个py36.yaml文件 1conda env export &gt; py36.yaml 注意如果导出base环境的话，在目标机器上可能会提示已存在base环境（而且base环境无法删除）。所以如果导出base环境最好先复制一下，再导出base环境的复制品，如下所示 123456789101112131415161718192021(base) abc@h1:~$ conda create -n h1_abc_base --clone baseSource: /home/abc/miniconda3Destination: /home/abc/miniconda3/envs/h1_abc_baseThe following packages cannot be cloned out of the root environment: - defaults/linux-64::conda-4.9.2-py36h06a4308_0Packages: 84Files: 35464Preparing transaction: doneVerifying transaction: doneExecuting transaction: / Enabling nb_conda_kernels...Status: enableddone## To activate this environment, use## $ conda activate h1_abc_base## To deactivate an active environment, use## $ conda deactivate 12(base) abc@h1:~$ conda activate h1_abc_base(h1_abc_base) abc@h1:~$ conda env export &gt; h1_abc_base.yaml 完成上述步骤后，查看了一下h1_abc_base.yaml文件，其中已经包含了pip安装的一些内容，不过为了以防万一还是也把pip的内容导出一遍，如下所示，会生成requirements.txt 1(h1_abc_base) abc@h1:~$ pip freeze &gt; h1_abc_base_requirements.txt 目标机器B的迁移下载目标机器A最终生成的 h1_abc_base.yaml 与 h1_abc_base_requirements.txt，复制到目标机器的个人conda/miniconda目录下 /data/sdb1/lyx/ 首先执行如下操作，导入conda环境 1234567(base) lyx@h5:/data/sdb1/lyx$ conda env create -f h1_abc_base.yaml...Successfully built docopt jieba pyrouge sklearn termcolor textrank4zhInstalling collected packages: jmespath, numpy, cached-property, botocore, werkzeug, threadpoolctl, scipy, s3transfer, protobuf, markdown, joblib, h5py, grpcio, yarg, torch, termcolor, tensorboard, scikit-learn, regex, pytz, networkx, keras-preprocessing, keras-applications, jieba, gast, docopt, dill, boto3, astor, absl-py, textrank4zh, tensorflow, tensorboardx, sklearn, rouge, pytorch-pretrained-bert, pyrouge, pipreqs, pandas, multiprocess, emojiSuccessfully installed absl-py-0.11.0 astor-0.8.1 boto3-1.17.68 botocore-1.20.69 cached-property-1.5.2 dill-0.3.3 docopt-0.6.2 emoji-1.2.0 gast-0.4.0 grpcio-1.33.2 h5py-3.1.0 jieba-0.42.1 jmespath-0.10.0 joblib-0.17.0 keras-applications-1.0.8 keras-preprocessing-1.1.2 markdown-3.3.3 multiprocess-0.70.11.1 networkx-2.5.1 numpy-1.16.0 pandas-1.1.4 pipreqs-0.4.10 protobuf-3.14.0 pyrouge-0.1.3 pytorch-pretrained-bert-0.6.2 pytz-2020.4 regex-2021.4.4 rouge-1.0.0 s3transfer-0.4.2 scikit-learn-0.23.2 scipy-1.5.4 sklearn-0.0 tensorboard-1.12.2 tensorboardx-2.1 tensorflow-1.12.0 termcolor-1.1.0 textrank4zh-0.3 threadpoolctl-2.1.0 torch-1.1.0 werkzeug-1.0.1 yarg-0.1.9 其次执行如下操作，安装pip的包的版本（不一定要做）： 12(base) lyx@h5:/data/sdb1/lyx$ conda activate h1_abc_base(h1_abc_base) lyx@h5:/data/sdb1/lyx$ pip install -r h1_abc_base_requirements.txt 注意目前的安装操作还是需要在线环境才能安装的，离线安装的时候可能需要在导出环境配置文件的同时把下载环境的那些文件也都一起导出来，未来如果有需求的时候再进一步研究了！ 1234567(h1_abc_base) lyx@h5:/data/sdb1/lyx$ pythonPython 3.6.12 |Anaconda, Inc.| (default, Sep 8 2020, 23:10:56) [GCC 7.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import torch&gt;&gt;&gt; torch.cuda.is_available()True","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"python-ACM模式的输入输出","slug":"algorithms/python-ACM模式的输入输出","date":"2022-03-23T02:45:31.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/03/23/algorithms/python-ACM模式的输入输出/","link":"","permalink":"http://example.com/2022/03/23/algorithms/python-ACM%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","excerpt":"在笔试环节做题的时候，题目大多数情况会是以ACM模式的输入输出构造，","text":"在笔试环节做题的时候，题目大多数情况会是以ACM模式的输入输出构造， Reference: https://blog.csdn.net/mmmmonkeyfei/article/details/118863773 各种类型情况总结TODO PTA的平台可以用python交，POJ用python交不了example1: POJ2524：并查集题目题目链接 除了数据输入输出的提醒以外，也还提醒了以前很多在C语言算法题的时候，用的数组都可以用哈希表替代 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 这里是哈希表par = &#123;&#125;vis = &#123;&#125;def get_root(a): &quot;&quot;&quot; 找根（找部落） &quot;&quot;&quot; if par[a] != a: par[a] = get_root(par[a]) return par[a]def merge(a, b): &quot;&quot;&quot; 把p2往p1聚类 &quot;&quot;&quot; p1 = get_root(a) p2 = get_root(b) if p1 != p2: par[p2] = p1if __name__ == &#x27;__main__&#x27;: js = 0 while True: n, m = map(int, input().split(&quot; &quot;)) if n == 0 and m == 0: break # 这里重置了 vis = &#123;&#125; for i in range(1, n+1): par[i] = i for i in range(m): a, b = map(int, input().split(&quot; &quot;)) merge(a, b) count = 0 for i in range(1, n+1): if vis.get(get_root(i)) == 1: continue else: count += 1 vis[get_root(i)] = 1 js += 1 print(&quot;Case %d: %d\\n&quot; % (js, count), end=&#x27;&#x27;) example2-尝试输入输出字符串，GPLT轮着输出几次题目链接 123456789101112131415161718192021222324252627282930313233343536373839from collections import Counterclass Solution(object): def __init__(self): pass def output_gplt(self, s): cnt_dict = Counter(s) return_list = [] cnt_g = cnt_dict.get(&#x27;g&#x27;, 0) + cnt_dict.get(&#x27;G&#x27;, 0) cnt_p = cnt_dict.get(&#x27;p&#x27;, 0) + cnt_dict.get(&#x27;P&#x27;, 0) cnt_l = cnt_dict.get(&#x27;l&#x27;, 0) + cnt_dict.get(&#x27;L&#x27;, 0) cnt_t = cnt_dict.get(&#x27;t&#x27;, 0) + cnt_dict.get(&#x27;T&#x27;, 0) while cnt_g != 0 or cnt_p != 0 or cnt_l != 0 or cnt_t != 0: if cnt_g != 0: return_list.append(&#x27;G&#x27;) cnt_g -= 1 if cnt_p != 0: return_list.append(&#x27;P&#x27;) cnt_p -= 1 if cnt_l != 0: return_list.append(&#x27;L&#x27;) cnt_l -= 1 if cnt_t != 0: return_list.append(&#x27;T&#x27;) cnt_t -= 1 return &#x27;&#x27;.join(return_list)if __name__ == &#x27;__main__&#x27;: s = str(input()) res = Solution().output_gplt(s) print(res) example3-","categories":[],"tags":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/tags/LeetCode-python/"}]},{"title":"285场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/285场LeetCode周赛","date":"2022-03-20T14:25:56.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/03/20/algorithms/leetcode-weekly-contest/285场LeetCode周赛/","link":"","permalink":"http://example.com/2022/03/20/algorithms/leetcode-weekly-contest/285%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 被周末临时开会打断的一次周赛，有点烦hhh。总结来说这次周赛给的教训第一个应该就是好好读题？好好读题理解题意后再开始做，反而会比一上来突然来个想法就做顺利很多，在每个想法开始前要有个大概的实现难度预估和通过可能性预估，一般来说周赛前三个题仔细思考下，合理性分析下，感觉还都是可以做出来的，思路其实绕来绕去大部分还是那些，比较需要构思好再写吧！ 第一题：比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序； 第二题：这个题自己想到的是一种模拟的思想，但是模拟过去后 RRRRS 这种情况，自己的操作后会变成 RRRSS ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 LLLL ，后缀去掉 RRRR ，最后中间的不是 S 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法； 第三题：原来 2^n 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 20-32 以内，就可以暴力遍历 2^20~30 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 被周末临时开会打断的一次周赛，有点烦hhh。总结来说这次周赛给的教训第一个应该就是好好读题？好好读题理解题意后再开始做，反而会比一上来突然来个想法就做顺利很多，在每个想法开始前要有个大概的实现难度预估和通过可能性预估，一般来说周赛前三个题仔细思考下，合理性分析下，感觉还都是可以做出来的，思路其实绕来绕去大部分还是那些，比较需要构思好再写吧！ 第一题：比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序； 第二题：这个题自己想到的是一种模拟的思想，但是模拟过去后 RRRRS 这种情况，自己的操作后会变成 RRRSS ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 LLLL ，后缀去掉 RRRR ，最后中间的不是 S 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法； 第三题：原来 2^n 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 20-32 以内，就可以暴力遍历 2^20~30 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：6027.统计数组中峰和谷的数量题目链接 题目大意给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i 和 j ，如果 nums[i] == nums[j] ， 则认为这两下标属于 同一个 峰或谷。 注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。 返回 nums 中峰和谷的数量。 示例1： 12345678910输入：nums = [2,4,1,1,6,5]输出：3解释：在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 &gt; 2 且 4 &gt; 1 ，下标 1 是一个峰。在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 2 是一个谷。在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 &lt; 4 且 1 &lt; 6 ，下标 3 符合谷的定义，但需要注意它和下标 2 是同一个谷的一部分。在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 &gt; 1 且 6 &gt; 5 ，下标 4 是一个峰。在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。共有 3 个峰和谷，所以返回 3 。 示例2： 12345678910输入：nums = [6,6,5,5,4,1]输出：0解释：在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 2 既不是峰也不是谷。在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 &lt; 6 且 5 &gt; 4 ，下标 3 既不是峰也不是谷。在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 &lt; 5 且 4 &gt; 1 ，下标 4 既不是峰也不是谷。在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。共有 0 个峰和谷，所以返回 0 。 提示： 3 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 分析和解答比较简单，但是一开始读题的时候感觉又卡壳了，感觉读题还是不能读太急吧！做一个去重后就不用向左右判断不等于的了，去重后要保持顺序； 下边这个代码实际上冗余了很多； 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def countHillValley(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; tmp_nums = [] tmp = -1 for i in range(len(nums)): if tmp == -1: tmp = nums[i] tmp_nums.append(nums[i]) continue else: if nums[i] == tmp: continue else: tmp = nums[i] tmp_nums.append(nums[i]) print(tmp_nums) cnt = 0 for i in range(1, len(tmp_nums)-1): # 找到左边不相等的 t1 = -1 for j in range(i-1, -1, -1): if tmp_nums[j] != tmp_nums[i]: t1 = tmp_nums[j] break t2 = -1 for j in range(i+1, len(tmp_nums)): if tmp_nums[j] != tmp_nums[i]: t2 = tmp_nums[j] break print(tmp_nums[i], t1, t2) if (tmp_nums[i] &gt; t1 and tmp_nums[i] &gt; t2 and t1 != -1 and t2 != -1) or (tmp_nums[i] &lt; t1 and tmp_nums[i] &lt; t2 and t1 != -1 and t2 != -1): cnt +=1 return cnt 第二题：6028.统计道路上的碰撞次数题目链接 题目大意在一条无限长的公路上有 n 辆汽车正在行驶。汽车按从左到右的顺序按从 0 到 n - 1 编号，每辆车都在一个 独特的 位置。 给你一个下标从 0 开始的字符串 directions ，长度为 n 。directions[i] 可以是 &#39;L&#39; 、 &#39;R&#39; 或 &#39;S&#39; 分别表示第 i 辆车是向 左 、向 右 或者 停留 在当前位置。每辆车移动时 速度相同 。 碰撞次数可以按下述方式计算： 当两辆移动方向 相反 的车相撞时，碰撞次数加 2 。 当一辆移动的车和一辆静止的车相撞时，碰撞次数加 1 。 碰撞发生后，涉及的车辆将无法继续移动并停留在碰撞位置。除此之外，汽车不能改变它们的状态或移动方向。 返回在这条道路上发生的 碰撞总次数 。 示例1： 123456789输入：directions = &quot;RLRSLL&quot;输出：5解释：将会在道路上发生的碰撞列出如下：- 车 0 和车 1 会互相碰撞。由于它们按相反方向移动，碰撞数量变为 0 + 2 = 2 。- 车 2 和车 3 会互相碰撞。由于 3 是静止的，碰撞数量变为 2 + 1 = 3 。- 车 3 和车 4 会互相碰撞。由于 3 是静止的，碰撞数量变为 3 + 1 = 4 。- 车 4 和车 5 会互相碰撞。在车 4 和车 3 碰撞之后，车 4 会待在碰撞位置，接着和车 5 碰撞。碰撞数量变为 4 + 1 = 5 。因此，将会在道路上发生的碰撞总次数是 5 。 示例2： 1234输入：directions = &quot;LLRR&quot;输出：0解释：不存在会发生碰撞的车辆。因此，将会在道路上发生的碰撞总次数是 0 。 提示： 1 &lt;= directions.length &lt;= 10^5 directions[i] 的值为 &#39;L&#39; 、&#39;R&#39; 或 &#39;S&#39; 分析和解答这个题自己想到的是一种模拟的思想，但是模拟过去后 RRRRS 这种情况，自己的操作后会变成 RRRSS ，这种还要从右往左过一遍。赛后看题解有大佬的思路是，在前缀去掉 LLLL ，后缀去掉 RRRR ，最后中间的不是 S 的数目就是碰撞的数目了，感觉真的是一个很奇妙的思路+数学解法； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def countCollisions(self, directions): &quot;&quot;&quot; :type directions: str :rtype: int &quot;&quot;&quot; # directions += &#x27;R&#x27; # 哨兵 init_status = [[i, i, &#x27;S&#x27;] for i in range(len(directions))] # 第几个车，第几个车移动后，这个车的移动方向是 new_status = [] for i in range(len(init_status)): if directions[i] == &#x27;L&#x27;: new_status.append([init_status[i][0], init_status[i][0]-1, &#x27;L&#x27;]) elif directions[i] == &#x27;R&#x27;: new_status.append([init_status[i][0], init_status[i][0]+1, &#x27;R&#x27;]) elif directions[i] == &#x27;S&#x27;: new_status.append(init_status[i]) res = 0 for i in range(len(new_status)-1): if new_status[i][1] &gt;= new_status[i+1][1]: # 这两个会撞上，判断两个状态 if new_status[i][2] != &#x27;S&#x27; and new_status[i+1][2] != &#x27;S&#x27; and new_status[i+1][2] != new_status[i][2]: # print(&quot;2: &quot;, new_status[i], new_status[i+1]) res += 2 else: # print(&quot;1: &quot;, new_status[i], new_status[i+1]) res += 1 # 汇总成之前的，不应该是之前的 new_status[i] = init_status[i] new_status[i][2] = &#x27;S&#x27; new_status[i+1] = init_status[i+1] new_status[i+1][2] = &#x27;S&#x27; # print(&quot;i, new_status: &quot;, i, new_status) # # 还需要再过一遍# # 正着过 for i in range(1, len(new_status)): if new_status[i][2] == &#x27;L&#x27; and new_status[i-1][2] == &#x27;S&#x27;: res += 1 new_status[i][2] == &#x27;S&#x27; for i in range(len(new_status)-1, 0, -1): if new_status[i-1][2] == &#x27;R&#x27; and new_status[i][2] == &#x27;S&#x27;: res += 1 new_status[i-1][2] = &#x27;S&#x27; return res 第三题：6029.射箭比赛中的最大得分题目链接 题目大意Alice 和 Bob 是一场射箭比赛中的对手。比赛规则如下： Alice 先射 numArrows 支箭，然后 Bob 也射 numArrows 支箭。 分数按下述规则计算： 箭靶有若干整数计分区域，范围从 0 到 11 （含 0 和 11）。 箭靶上每个区域都对应一个得分 k（范围是 0 到 11），Alice 和 Bob 分别在得分 k 区域射中 ak 和 bk 支箭。如果 ak &gt;= bk ，那么 Alice 得 k 分。如果 ak &lt; bk ，则 Bob 得 k 分 如果 ak == bk == 0 ，那么无人得到 k 分。 例如，Alice 和 Bob 都向计分为 11 的区域射 2 支箭，那么 Alice 得 11 分。如果 Alice 向计分为 11 的区域射 0 支箭，但 Bob 向同一个区域射 2 支箭，那么 Bob 得 11 分。 给你整数 numArrows 和一个长度为 12 的整数数组 aliceArrows ，该数组表示 Alice 射中 0 到 11 每个计分区域的箭数量。现在，Bob 想要尽可能 最大化 他所能获得的总分。 返回数组 bobArrows ，该数组表示 Bob 射中 0 到 11 每个 计分区域的箭数量。且 bobArrows 的总和应当等于 numArrows 。 如果存在多种方法都可以使 Bob 获得最大总分，返回其中 任意一种 即可。 示例1： 12345输入：numArrows = 9, aliceArrows = [1,1,0,1,0,0,2,1,0,1,2,0]输出：[0,0,0,0,1,1,0,0,1,2,3,1]解释：上表显示了比赛得分情况。Bob 获得总分 4 + 5 + 8 + 9 + 10 + 11 = 47 。可以证明 Bob 无法获得比 47 更高的分数。 示例2： 12345输入：numArrows = 3, aliceArrows = [0,0,1,0,0,0,0,0,0,0,0,2]输出：[0,0,0,0,0,0,0,0,1,1,1,0]解释：上表显示了比赛得分情况。Bob 获得总分 8 + 9 + 10 = 27 。可以证明 Bob 无法获得比 27 更高的分数。 提示： 1 &lt;= numArrows &lt;= 10^5 aliceArrows.length == bobArrows.length == 12 0 &lt;= aliceArrows[i], bobArrows[i] &lt;= numArrows sum(aliceArrows[i]) == numArrows 分析和解答原来 2^n 的这种做法被称作状态压缩，这个题能想到这种做法还是不容易的，感觉一方面是数据范围如果是 20-32 以内，就可以暴力遍历 2^20~30 这么多种情况，也算是一种数据上的提示吧。题目中的返回任意情况可能也说明了这一点； 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def maximumBobPoints(self, numArrows, aliceArrows): &quot;&quot;&quot; :type numArrows: int :type aliceArrows: List[int] :rtype: List[int] &quot;&quot;&quot; max_score = 0 # 直接暴力枚举，11种二进制转状态，判断在哪些状态能得分（是合理的） for i in range(2**len(aliceArrows)): tmp_bin = [] tmp = i while tmp &gt; 0: tmp_bin.append(tmp&amp;1) tmp &gt;&gt;= 1 tmp_bin += [0 for _ in range(len(aliceArrows)-len(tmp_bin))] # 1代表要在这些位置上击败alice，然后做合理性判断就行了 flag = True cnt = 0 tmp_score = 0 tmp_list = [] for j in range(len(aliceArrows)): if tmp_bin[j] == 1: cnt += aliceArrows[j] + 1 tmp_score += j tmp_list.append(aliceArrows[j] + 1) else: tmp_list.append(0) # 这里判断合理性 if cnt &lt;= numArrows: if tmp_score &gt; max_score: max_score= tmp_score res = tmp_list res[0] = numArrows - sum(res) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"递归","slug":"递归","permalink":"http://example.com/tags/%E9%80%92%E5%BD%92/"}]},{"title":"2044.统计按位或能得到最大值的子集数目-python","slug":"algorithms/leetcode-python/2044-统计按位或能得到最大值的子集数目-python","date":"2022-03-15T06:53:56.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2022/03/15/algorithms/leetcode-python/2044-统计按位或能得到最大值的子集数目-python/","link":"","permalink":"http://example.com/2022/03/15/algorithms/leetcode-python/2044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE-python/","excerpt":"2044.统计按位或能得到最大值的子集数目（中等） 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。","text":"2044.统计按位或能得到最大值的子集数目（中等） 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。 题目题目链接 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。 示例1： 12345输入：nums = [3,1]输出：2解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：- [3]- [3,1] 示例2： 123输入：nums = [2,2,2]输出：7解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。 示例3： 123456789输入：nums = [3,2,1,5]输出：6解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：- [3,5]- [3,1,5]- [3,2,5]- [3,2,1,5]- [2,5]- [2,1,5] 提示： 1 &lt;= nums.length &lt;= 16 1 &lt;= nums[i] &lt;= 10^5 分析和解答典型的 2^n 暴力遍历题目，题目里给的提示 16 也代表了这个意思， 2^16 = 65536； 如果是每日一题的话就先不用回溯搞了，回溯好像是dfs分为取和不取的两个分支往下dfs，写起来稍微有点麻烦； 大佬的提醒下不用做什么哈希表了，在迭代判断的过程中直接记录 max ，然后出现新的更大的 refresh 掉那个 cnt 、没出现新的然后等于 max 的直接 cnt+=1 这样就可以了。 12345678910111213141516171819202122232425262728class Solution(object): def countMaxOrSubsets(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; max_or = 0 max_or_count = 0 for i in range(2**len(nums)): tmp = i tmp_list = [] while tmp &gt; 0: tmp_list.append(tmp&amp;1) tmp &gt;&gt;= 1 tmp_list += [0 for _ in range(len(nums)-len(tmp_list))] # print(tmp_list) # 1是选择，0是不选择 tmp_or = 0 for j in range(len(tmp_list)): if tmp_list[j] == 1: tmp_or |= nums[j] # 按位或简单写法 if tmp_or &gt; max_or: max_or = tmp_or max_or_count = 1 elif tmp_or == max_or: max_or_count += 1 return max_or_count","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode每日一题","slug":"LeetCode-python/LeetCode每日一题","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"589.N叉树的前序遍历-python","slug":"algorithms/leetcode-python/589-N叉树的前序遍历-python","date":"2022-03-14T12:56:17.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/03/14/algorithms/leetcode-python/589-N叉树的前序遍历-python/","link":"","permalink":"http://example.com/2022/03/14/algorithms/leetcode-python/589-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-python/","excerpt":"589.N叉树的前序遍历（简单） 题目大意： 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。","text":"589.N叉树的前序遍历（简单） 题目大意： 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 题目题目链接 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[1,3,5,6,2,4] 示例2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10] 提示： 节点总数在范围 [0, 10^4] 内 0 &lt;= Node.val &lt;= 10^4 n 叉树的高度小于或等于 1000 分析和解答解法1：递归这个题要是用递归的话那是绝对的简单题，N叉树就感觉把所有children走一遍就行了，和二叉树的前序遍历递归完全是一个模板 123456789101112131415161718192021222324&quot;&quot;&quot;# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution(object): def preorder(self, root): &quot;&quot;&quot; :type root: Node :rtype: List[int] &quot;&quot;&quot; # 递归 res = [] def dfs_preorder(root): if root is None: return res.append(root.val) for ch in root.children: dfs_preorder(ch) dfs_preorder(root) return res 解法2：迭代N叉树的前序遍历和后序遍历的迭代法本质就是栈的应用，前序遍历是每次弹出来就加，而后序遍历要在每次加的基础上最后reverse一下 在自己设定好栈顶和栈底的基础上，按照操作来就可以了，手写模拟下很快就能找到规律 123456789101112131415161718192021222324252627282930&quot;&quot;&quot;# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution(object): def preorder(self, root): &quot;&quot;&quot; :type root: Node :rtype: List[int] &quot;&quot;&quot; # 前序遍历用栈实现非递归 res = [] stack = [] if root is not None: stack.append(root) while len(stack): tmp = stack[0] # 左边是栈顶，右边是栈底 stack = stack[1:] res.append(tmp.val) # tmp.children是一个list，倒序入栈，这个还是相对好像的吧 for i in range(len(tmp.children)-1, -1, -1): if tmp.children[i] is not None: stack.insert(0, tmp.children[i]) # 在位置0insert # print([a.val for a in stack]) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode每日一题","slug":"LeetCode-python/LeetCode每日一题","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}]},{"title":"590.N叉树的后序遍历-python","slug":"algorithms/leetcode-python/590-N叉树的后序遍历-python","date":"2022-03-14T12:55:53.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/03/14/algorithms/leetcode-python/590-N叉树的后序遍历-python/","link":"","permalink":"http://example.com/2022/03/14/algorithms/leetcode-python/590-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-python/","excerpt":"590.N叉树的后序遍历（简单） 题目大意： 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。","text":"590.N叉树的后序遍历（简单） 题目大意： 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 题目题目链接 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。 n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。 示例1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[5,6,3,2,4,1] 示例2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1] 提示： 节点总数在范围 [0, 10^4] 内 0 &lt;= Node.val &lt;= 10^4 n 叉树的高度小于或等于 1000 分析和解答解法1：递归这个题写完内部的dfs函数居然忘了调用了哈哈哈，很简单和二叉树的一样就行 123456789101112131415161718192021222324&quot;&quot;&quot;# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution(object): def postorder(self, root): &quot;&quot;&quot; :type root: Node :rtype: List[int] &quot;&quot;&quot; # 递归 res = [] def dfs_postorder(root): if root is None: return for ch in root.children: dfs_postorder(ch) res.append(root.val) dfs_postorder(root) # 居然是因为忘写了这句话 return res 解法2：迭代使用了前序遍历迭代的思想，自己写一写模拟就好，最后需要reverse过来，也就是 t_list = t_list[::-1] 123456789101112131415161718192021222324252627&quot;&quot;&quot;# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution(object): def postorder(self, root): &quot;&quot;&quot; :type root: Node :rtype: List[int] &quot;&quot;&quot; # 迭代，这里可以借助前序遍历 res = [] stack = [] if root is not None: stack.append(root) while len(stack): tmp = stack[0] # 左边栈顶，右边栈底 stack = stack[1:] res.append(tmp.val) for ch in tmp.children: if ch is not None: stack.insert(0, ch) return res[::-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode每日一题","slug":"LeetCode-python/LeetCode每日一题","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}]},{"title":"429.N叉树的层序遍历-python","slug":"algorithms/leetcode-python/429-N叉树的层序遍历-python","date":"2022-03-14T12:55:27.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/03/14/algorithms/leetcode-python/429-N叉树的层序遍历-python/","link":"","permalink":"http://example.com/2022/03/14/algorithms/leetcode-python/429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-python/","excerpt":"429.N叉树的层序遍历（中等） 题目大意： 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。","text":"429.N叉树的层序遍历（中等） 题目大意： 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 题目题目链接 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 示例1： 12输入：root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]] 示例2： 12输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 提示： 树的高度不会超过 1000 树的节点总数在 [0, 10^4] 之间 分析和解答层序遍历本质上是广度优先，广度优先本质上就是bfs（？好像在说废话hhh） 这个题需要特别注意下把层序遍历 append 成这个嵌套的样子 [[], [], []] ，这里的思路是每次记录下当前层的数目，然后在 pop-appendtail 的时候只把当前层这么多个的给 pop 出来，使用一个中间的 tmp_ans 来存储每层，然后一层一层的 append 123456789101112131415161718192021222324252627282930313233&quot;&quot;&quot;# Definition for a Node.class Node(object): def __init__(self, val=None, children=None): self.val = val self.children = children&quot;&quot;&quot;class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: Node :rtype: List[List[int]] &quot;&quot;&quot; res = [] queue = [] # 左出，右进 if root is not None: queue.append(root) # 层序遍历代码写成一体化的，因为层序遍历还要兼顾层级的输出 while len(queue): # 每次都把当前这一层走完，然后append tmp_ans = [] now_level_len = len(queue) for i in range(now_level_len): # 只是为了执行这么多次 tmp_q = queue[0] queue = queue[1:] tmp_ans.append(tmp_q.val) for ch in tmp_q.children: queue.append(ch) res.append(tmp_ans) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}]},{"title":"23.合并K个升序链表-python","slug":"algorithms/leetcode-python/23-合并K个升序链表-python","date":"2022-03-14T11:36:09.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2022/03/14/algorithms/leetcode-python/23-合并K个升序链表-python/","link":"","permalink":"http://example.com/2022/03/14/algorithms/leetcode-python/23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-python/","excerpt":"23.合并K个升序链表（困难） 题目大意： 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。","text":"23.合并K个升序链表（困难） 题目大意： 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 题目题目链接 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例1： 12345678910输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 示例2： 12输入：lists = []输出：[] 示例3： 12输入：lists = [[]]输出：[] 提示： k == lists.length 0 &lt;= k &lt;= 10^4 0 &lt;= lists[i].length &lt;= 500 10^4 &lt;= lists[i][j] &lt;= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 分析和解答这个题感觉实际真的明白了什么是优先队列，什么是堆的思想。python这个 heapq 是真的神，如果用正数就是小根堆，如果是用负数就可以转化为大根堆了！ 只要先用 heapq 存储成一个堆，然后不断 heappop()就可以了，这里推荐堆的命名可以直接用 heap； 另注，这个题实际上有很多做法，但这个做法是最为简单的了，其他还需要进一步探究； 123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def mergeKLists(self, lists): &quot;&quot;&quot; :type lists: List[ListNode] :rtype: ListNode &quot;&quot;&quot; import heapq # 优先队列 heap = [] for i, t_list in enumerate(lists): head = t_list while head is not None: heapq.heappush(heap, head.val) head = head.next # 尾插法 return_head = ListNode(val=0, next=None) p = return_head while len(heap) != 0: tmp = heapq.heappop(heap) p.next = ListNode(val=tmp) p = p.next return return_head.next","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","permalink":"http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"分治","slug":"分治","permalink":"http://example.com/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"}]},{"title":"284场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/284场LeetCode周赛","date":"2022-03-13T13:43:04.000Z","updated":"2022-11-20T01:50:08.887Z","comments":true,"path":"2022/03/13/algorithms/leetcode-weekly-contest/284场LeetCode周赛/","link":"","permalink":"http://example.com/2022/03/13/algorithms/leetcode-weekly-contest/284%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这周三个题还是相对友善一点点的：第一题读题有些困难hhh读好了一些角标标记的操作就可以了；第二题感觉一下想过去就是个哈希表记录，感觉也是状态好才能现场写出来吧；第三题需要考虑很多种case是个比较细节的题，感觉还是模拟为主。总结来说这周还都属于是一下想过去有思路的题，希望未来能进一步保持啊啊啊啊啊； 第一题：角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 abs 就可以了； 第二题：一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）； 第三题：这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 nums 的长度是 10^5 的时候就感觉可以模拟了，然后 k 比这个大就说明可能会有一部分相对特殊的case； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 这周三个题还是相对友善一点点的：第一题读题有些困难hhh读好了一些角标标记的操作就可以了；第二题感觉一下想过去就是个哈希表记录，感觉也是状态好才能现场写出来吧；第三题需要考虑很多种case是个比较细节的题，感觉还是模拟为主。总结来说这周还都属于是一下想过去有思路的题，希望未来能进一步保持啊啊啊啊啊； 第一题：角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 abs 就可以了； 第二题：一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple）； 第三题：这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 nums 的长度是 10^5 的时候就感觉可以模拟了，然后 k 比这个大就说明可能会有一部分相对特殊的case； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：6031.找出数组中的所有 K 近邻下标题目链接 题目大意给你一个下标从 0 开始的整数数组 nums 和两个整数 key 和 k 。K 近邻下标 是 nums 中的一个下标 i ，并满足至少存在一个下标 j 使得 |i - j| &lt;= k 且 nums[j] == key 。 以列表形式返回按 递增顺序 排序的所有 K 近邻下标。 示例1： 1234567891011输入：nums = [3,4,9,1,3,9,5], key = 9, k = 1输出：[1,2,3,4,5,6]解释：因此，nums[2] == key 且 nums[5] == key 。- 对下标 0 ，|0 - 2| &gt; k 且 |0 - 5| &gt; k ，所以不存在 j 使得 |0 - j| &lt;= k 且 nums[j] == key 。所以 0 不是一个 K 近邻下标。- 对下标 1 ，|1 - 2| &lt;= k 且 nums[2] == key ，所以 1 是一个 K 近邻下标。- 对下标 2 ，|2 - 2| &lt;= k 且 nums[2] == key ，所以 2 是一个 K 近邻下标。- 对下标 3 ，|3 - 2| &lt;= k 且 nums[2] == key ，所以 3 是一个 K 近邻下标。- 对下标 4 ，|4 - 5| &lt;= k 且 nums[5] == key ，所以 4 是一个 K 近邻下标。- 对下标 5 ，|5 - 5| &lt;= k 且 nums[5] == key ，所以 5 是一个 K 近邻下标。- 对下标 6 ，|6 - 5| &lt;= k 且 nums[5] == key ，所以 6 是一个 K 近邻下标。因此，按递增顺序返回 [1,2,3,4,5,6] 。 示例2： 1234输入：nums = [2,2,2,2,2], key = 2, k = 2输出：[0,1,2,3,4]解释：对 nums 的所有下标 i ，总存在某个下标 j 使得 |i - j| &lt;= k 且 nums[j] == key ，所以每个下标都是一个 K 近邻下标。 因此，返回 [0,1,2,3,4] 。 提示： 1 &lt;= nums.length &lt;= 1000 1 &lt;= nums[i] &lt;= 1000 key 是数组 nums 中的一个整数 1 &lt;= k &lt;= nums.length 分析和解答角标的基础题，感觉读明白题后很快就做出来了，注意需要一个绝对值 abs 就可以了 123456789101112131415161718192021222324class Solution(object): def findKDistantIndices(self, nums, key, k): &quot;&quot;&quot; :type nums: List[int] :type key: int :type k: int :rtype: List[int] &quot;&quot;&quot; tmp = [] for i in range(len(nums)): if nums[i] == key: tmp.append(i) print(tmp) res = [] for i in range(len(nums)): for j in range(len(tmp)): if abs(i - tmp[j]) &lt;= k: print(&quot;i, j: &quot;, i,j) res.append(i) break # print(res) return res 第二题：5203.统计可以提取的工件题目链接 题目大意存在一个 n x n 大小、下标从 0 开始的网格，网格中埋着一些工件。给你一个整数 n 和一个下标从 0 开始的二维整数数组 artifacts ，artifacts 描述了矩形工件的位置，其中 artifacts[i] = [r1i, c1i, r2i, c2i] 表示第 i 个工件在子网格中的填埋情况： (r1i, c1i) 是第 i 个工件 左上 单元格的坐标，且 (r2i, c2i) 是第 i 个工件 右下 单元格的坐标。 你将会挖掘网格中的一些单元格，并清除其中的填埋物。如果单元格中埋着工件的一部分，那么该工件这一部分将会裸露出来。如果一个工件的所有部分都都裸露出来，你就可以提取该工件。 给你一个下标从 0 开始的二维整数数组 dig ，其中 dig[i] = [ri, ci] 表示你将会挖掘单元格 (ri, ci) ，返回你可以提取的工件数目。 生成的测试用例满足： 不存在重叠的两个工件。 每个工件最多只覆盖 4 个单元格。 dig 中的元素互不相同。 示例1： 1234567输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1]]输出：1解释： 不同颜色表示不同的工件。挖掘的单元格用 &#x27;D&#x27; 在网格中进行标记。有 1 个工件可以提取，即红色工件。蓝色工件在单元格 (1,1) 的部分尚未裸露出来，所以无法提取该工件。因此，返回 1 。 示例2： 123输入：n = 2, artifacts = [[0,0,0,0],[0,1,1,1]], dig = [[0,0],[0,1],[1,1]]输出：2解释：红色工件和蓝色工件的所有部分都裸露出来（用 &#x27;D&#x27; 标记），都可以提取。因此，返回 2 。 提示： 1 &lt;= n &lt;= 1000 1 &lt;= artifacts.length, dig.length &lt;= min(n^2, 10^5) artifacts[i].length == 4 dig[i].length == 2 0 &lt;= r1i, c1i, r2i, c2i, ri, ci &lt;= n - 1 r1i &lt;= r2i c1i &lt;= c2i 不存在重叠的两个工件 每个工件 最多 只覆盖 4 个单元格 dig 中的元素互不相同 分析和解答一眼看过去大概就能识别到是一个需要记录的题，主要是一些反向哈希的策略，实际上只要在写的时候不断完善程序逻辑基本就能做出来了，注意字典的key可以是元组（tuple） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution(object): def digArtifacts(self, n, artifacts, dig): &quot;&quot;&quot; :type n: int :type artifacts: List[List[int]] :type dig: List[List[int]] :rtype: int &quot;&quot;&quot; # 哈希表记录每个地方的状态 # 要用mark吗，还是说看起来直接暴力就行了 reverse_mapping = &#123;&#125; d = [0 for i in range(len(artifacts))] m = [[-1 for i in range(n)] for j in range(n)] for i in range(len(artifacts)): r1, c1, r2 ,c2 = artifacts[i] d[i] = 0 # mapping for j in range(r1, r2+1): for k in range(c1, c2+1): m[j][k] = 1 # 反向mapping，这个工件属于第几个 reverse_mapping[(j, k)] = i # jk角标的地方属于第i个工件 d[i] += 1 #print(&quot;d: &quot;, d) #print(&quot;m: &quot;, m) #print(&quot;reverse_mapping: &quot;, reverse_mapping) for i in range(len(dig)): r, c = dig[i] # 先判断这个地方是不是有 if m[r][c] == 1: # 再判断是第几个零件 index = reverse_mapping[(r, c)] # 减去第几个零件 d[index] -= 1 m[r][c] = 0 # 挖掉 else: continue res = 0 #print(d) for i in range(len(d)): if d[i] == 0: res += 1 return res 第三题：5227.K 次操作后最大化顶端元素题目链接 题目大意给你一个下标从 0 开始的整数数组 nums ，它表示一个 栈 ，其中 nums[0] 是栈顶的元素。 每一次操作中，你可以执行以下操作 之一 ： 如果栈非空，那么 删除 栈顶端的元素。 如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回栈顶，这个元素成为新的栈顶元素。 同时给你一个整数 k ，它表示你总共需要执行操作的次数。 请你返回 恰好 执行 k 次操作以后，栈顶元素的 最大值 。如果执行完 k 次操作以后，栈一定为空，请你返回 -1 。 示例1： 123456789输入：nums = [5,2,2,4,0,6], k = 4输出：5解释：4 次操作后，栈顶元素为 5 的方法之一为：- 第 1 次操作：删除栈顶元素 5 ，栈变为 [2,2,4,0,6] 。- 第 2 次操作：删除栈顶元素 2 ，栈变为 [2,4,0,6] 。- 第 3 次操作：删除栈顶元素 2 ，栈变为 [4,0,6] 。- 第 4 次操作：将 5 添加回栈顶，栈变为 [5,4,0,6] 。注意，这不是最后栈顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大栈顶元素。 示例2： 12345输入：nums = [2], k = 1输出：-1解释：第 1 次操作中，我们唯一的选择是将栈顶元素弹出栈。由于 1 次操作后无法得到一个非空的栈，所以我们返回 -1 。 提示： 1 &lt;= nums.length &lt;= 10^5 0 &lt;= nums[i], k &lt;= 10^9 分析和解答这个题感觉还是case比较多，感觉自己还是一种模拟的思路吧，感觉通过这个题积累的一些周赛思路是有些边界条件或者极端case完全是可以单独处理的（比如这个题数组长度为1的时候），尝试融合到通用case里反而会增加难度，另外看这个题的做题思路可能和其他人不太一样，好像有更加数学的解法。另外实际上是看到 nums 的长度是 10^5 的时候就感觉可以模拟了，然后 k 比这个大就说明可能会有一部分相对特殊的case； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution(object): def maximumTop(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; if k == 0: return nums[0] jilu_remove = [] now_max = -1 cnt_op = 0 index = 0 res = -1 for i in range(len(nums)): # if cnt_op == k - 1: # 判断是再拿一个的高，还是把加回去的高 try: nayige = nums[index+1] except: nayige = -1 cnt_op += 1 res = max(now_max, nayige) elif cnt_op &lt; k: # 代表还能操作 jilu_remove.append(nums[index]) if nums[index] &gt; now_max: now_max = nums[index] index += 1 cnt_op += 1 else: break # 最后还有可能出现还剩很多的情况，因为len(nums)比k小，到时候要判断情况的 left_times = k - cnt_op jilu_remove.sort(reverse=True) print(&quot;left_times: &quot;, left_times) print(&quot;jilu_remove: &quot;, jilu_remove) print(&quot;res: &quot;, res) # 当剩余操作次数为left_times时 left_times %= (2 * len(nums)) print(&quot;left_times: &quot;, left_times) if left_times &lt;= len(nums) and left_times != 0: res = now_max if left_times &gt; len(nums): if len(nums) == 1: if left_times % 2 != 0: # 奇数 res = now_max else: # 偶数 try: res = jilu_remove[1] except: res = -1 else: res = now_max return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"2055.蜡烛之间的盘子-python","slug":"algorithms/leetcode-python/2055-蜡烛之间的盘子-python","date":"2022-03-08T12:22:04.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2022/03/08/algorithms/leetcode-python/2055-蜡烛之间的盘子-python/","link":"","permalink":"http://example.com/2022/03/08/algorithms/leetcode-python/2055-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90-python/","excerpt":"2055.蜡烛之间的盘子（中等） 每日一题的话就不在这里完整粘贴题目的题面了，换用自己的想法写法说一说 这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题","text":"2055.蜡烛之间的盘子（中等） 每日一题的话就不在这里完整粘贴题目的题面了，换用自己的想法写法说一说 这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题 题目题目链接 题目大意： 给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 &#39;*&#39; 和 &#39;|&#39; ，其中 &#39;*&#39; 表示一个 盘子 ，&#39;|&#39; 表示一支 蜡烛 。 同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。 比方说，s = &quot;||**||**|*&quot; ，查询 [3, 8] ，表示的是子字符串 &quot;*||**|&quot; 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。 示例1： 12345输入：s = &quot;**|**|***|&quot;, queries = [[2,5],[5,9]]输出：[2,3]解释：- queries[0] 有两个盘子在蜡烛之间。- queries[1] 有三个盘子在蜡烛之间。 示例2： 12345输入：s = &quot;***|**|*****|**||**|*&quot;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]输出：[9,0,0,0,0]解释：- queries[0] 有 9 个盘子在蜡烛之间。- 另一个查询没有盘子在蜡烛之间。 提示： 3 &lt;= s.length &lt;= 10^5 s 只包含字符 &#39;*&#39; 和 &#39;|&#39; 。 1 &lt;= queries.length &lt;= 10^5 queries[i].length == 2 0 &lt;= left_i &lt;= right_i &lt; s.length 分析和解答这个题感觉和周赛第三题非常接近？是一个感觉可以积累的很经典的前缀和题目，每个盘子位置先存到左右蜡烛的索引，然后再存前缀，实际上两个位置之间的差，就是【左边那个位置的右边蜡烛位置】，和【右边那个位置的左边蜡烛位置】之间的差了，感觉是一种角标索引（哈希表）背景下的前缀和问题，这种区间多次查询感觉确实不少前缀和问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution(object): def platesBetweenCandles(self, s, queries): &quot;&quot;&quot; :type s: str :type queries: List[List[int]] :rtype: List[int] &quot;&quot;&quot; # 经典前缀题目思路 # 先遍历两边，找到每个位置的左边和右边第一次碰到蜡烛的位置 # 然后再看前缀和，截止到当前位置处，出现过几个*了 left_candle_idx = [-1 for _ in range(len(s))] right_candle_idx = [-1 for _ in range(len(s))] plate_prefix_sum = [-1 for _ in range(len(s))] # 先正着走一遍，找到每个index位置处左边的那个candle的角标 left = -1 for i in range(len(s)): if s[i] == &#x27;|&#x27;: left = i left_candle_idx[i] = i elif s[i] == &#x27;*&#x27;: left_candle_idx[i] = left print(&quot;left_candle_idx: &quot;, left_candle_idx) # 倒着走一遍，找到每个index位置处右边的那个candle的角标 right = -1 for i in range(len(s)-1, -1, -1): if s[i] == &#x27;|&#x27;: right = i right_candle_idx[i] = i else: right_candle_idx[i] = right print(&quot;right_candle_idx: &quot;, right_candle_idx) # 正着走找prefix prefix = 0 for i in range(len(s)): if s[i] == &#x27;*&#x27;: prefix += 1 plate_prefix_sum[i] = prefix print(&quot;plate_prefix_sum: &quot;, plate_prefix_sum) res = [] for i in range(len(queries)): l, r = queries[i][0], queries[i][1] # 特殊处理 if l == r: res.append(0) continue tmp = plate_prefix_sum[left_candle_idx[r]]-plate_prefix_sum[right_candle_idx[l]] # 这里可能还会有异常，一下不好想感觉只能通过case看一下 res.append(tmp) if tmp &gt;= 0 else res.append(0) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode每日一题","slug":"LeetCode-python/LeetCode每日一题","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"98.验证二叉搜索树-python","slug":"algorithms/leetcode-python/98-验证二叉搜索树-python","date":"2022-03-07T14:11:18.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2022/03/07/algorithms/leetcode-python/98-验证二叉搜索树-python/","link":"","permalink":"http://example.com/2022/03/07/algorithms/leetcode-python/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-python/","excerpt":"98.验证二叉搜索树（中等） 题目大意： 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。","text":"98.验证二叉搜索树（中等） 题目大意： 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 题目给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例1： 12输入：root = [2,1,3]输出：true 示例2： 123输入：root = [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在 [1, 10^4] 内 -2^31 &lt;= Node.val &lt;= 2^31 - 1 分析和解答解法一：自己称为上界下界法该种方法不需要用到额外的变量那种感觉， 开始从一个最小和一个最大开始作为入口，然后递归的判断每个节点是不是在是不是在这个范围内即可 （二叉搜索树的性质：各个节点的val都不能相同） 对于根节点，其肯定包含在最开始的上界/下界内，然后就开始递归，根的左子树必须在(最小, 根的val)开区间内，右子树必须在(根的val, 最大)开区间内 另外注意，因为是判断的题，最后要返回一个bool的值，所以自递归的时候每个地方也要返回一个True/False 123456789101112131415161718192021222324252627282930313233343536# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def isValidBST(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; # 上界-下界法 def dfs(root, lower, upper): # 出口条件 if root is None: return True # False的条件 if root.val &lt;= lower or root.val &gt;= upper: return False # 左子树的值应该在lower，root.val开区间之间 if dfs(root.left, lower, root.val) is False: return False # 右子树的值应该在root.val，upper开区间之间 if dfs(root.right, root.val, upper) is False: return False return True return dfs(root, -1e15, 1e15) 解法二：全局变量法二叉搜索树本质上就是中序遍历要是递增的，所以使用中序遍历的思想搞一个自递归的函数就差不多了 同样是注意，因为自递归的，每个地方要有个bool类的返回值 123456789101112131415161718192021222324252627282930# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def __init__(self): self.pre_val = -1e15 # 写在这里的当做全局变量了 def isValidBST(self, root): &quot;&quot;&quot; # 这里使用二叉树中序遍历的思想，把这个函数制作为一个自递归的 :type root: TreeNode :rtype: bool &quot;&quot;&quot; # 出口 if root is None: return True if self.isValidBST(root.left) is True: # 中序的基础上要有返回值 if root.val &gt; self.pre_val: self.pre_val = root.val else: return False return self.isValidBST(root.right) return False","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"39.组合总和-python","slug":"algorithms/leetcode-python/39-组合总和-python","date":"2022-03-07T12:16:26.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/03/07/algorithms/leetcode-python/39-组合总和-python/","link":"","permalink":"http://example.com/2022/03/07/algorithms/leetcode-python/39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-python/","excerpt":"","text":"39.组合总和（中等） 题目大意： 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。1234567891011121314对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。&lt;!--more--&gt;# 题目给你一个 **无重复元素** 的整数数组 ```candidates``` 和一个目标整数 ```target``` ，找出 ```candidates``` 中可以使数字和为目标数 ```target``` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。```candidates``` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 ```target``` 的不同组合数少于 ```150``` 个。示例1： 输入：candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。 12示例2： 输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]] 12示例3： 输入: candidates = [2], target = 1输出: [] 123456789101112131415161718192021222324252627282930313233提示：- ```1 &lt;= candidates.length &lt;= 30```- ```1 &lt;= candidates[i] &lt;= 200```- ```candidate``` 中的每个元素都 **互不相同**- ```1 &lt;= target &lt;= 500```# 分析和解答这个题是个经典的回溯题，首先想一个dfs的构造：- 每次要把现在的now_sum传进去，代表dfs到每一层的时候现在加到多少了，用来进行出口条件的判断；- 每次要判断一个位置选还是不选，这样的话假设一个数组长度是n，每次要把现在到第几个n传递下去，而因为是dfs，每次不需要传递i+1，还是可以传递i的；- 每次要把list给加上，代表dfs的时候，现在选了哪些了，然后在第一个条件如果到出口的话，就要把list append进去；```dfs```的开始状态，按照这个思路就是```0，0，[]```，然后出口条件如果等于则append列表，如果大于则```return```，之后走新的```dfs```条件，每次i从当前的```now_idx```取到```n```，每个状态都生成一个分支，这里可以进行一个剪枝，如果超过了就```break```掉，然后这样的话就可以开展第一轮```dfs```了，先把选这个```i```位置处的```append```进去，然后用```copy.deepcopy()```传一下到下一层，然后再```list = list[:-1]```把这个去除掉**另外特别注意，这个题的数组需要先排序一下，否则循环剪枝那里可能后边还有更小的就break了不会被放进来了**```pythonres = []def dfs(now_sum, now_idx, now_list): if now_sum == target: res.append(now_list) if now_sum &gt; target: return for i in range(now_idx, len(candidates)): if now_sum + candidates[i] &gt; target: break now_list.append(candidates[i]) dfs(now_sum + candidates[i], i, copy.deepcopy(now_list)) # 注意这里要deepcopy now_list = now_list[:-1] # 截断下 当时写的代码如下： 12345678910111213141516171819202122232425262728class Solution(object): def combinationSum(self, candidates, target): &quot;&quot;&quot; :type candidates: List[int] :type target: int :rtype: List[List[int]] &quot;&quot;&quot; candidates.sort() # 先排个序 res = [] # 递归要找出口，一个条件一个条件的加入到参数中 def dfs(now_sum, tmp_list, now_idx): if now_sum == target: # 需要解决一个去重问题，多加一个位标记，代表只能从后边的开始选了，比如说开始选择了3之后，就不能再开始选前边的2了 res.append(tmp_list) return elif now_sum &gt; target: # 加爆了，不满足return return else: for i in range(now_idx, len(candidates)): if now_sum + candidates[i] &lt;= target: tmp_list.append(candidates[i]) dfs(now_sum + candidates[i], copy.deepcopy(tmp_list), i) # 下一次这个now_idx只能从当前的i之后开始了，这样解决重复问题 tmp_list = tmp_list[:-1] # 回溯 else: break dfs(0, [], 0) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"283场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/283场LeetCode周赛","date":"2022-03-07T10:35:08.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/03/07/algorithms/leetcode-weekly-contest/283场LeetCode周赛/","link":"","permalink":"http://example.com/2022/03/07/algorithms/leetcode-weekly-contest/283%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这次感觉就是从头卡到尾哈哈哈，每个题或多或少都卡了一下，感觉近几次做题真的思想越来越僵化了，也可能和太久没写代码了有关吧，2月轻松了一个月，3月开始真的忙碌了hhh，等哪天闲下来要完整总结下做题用到的一些常用结构了； 看了下有写笔记的是273到283，算上新年鸽了一次正好十次，感觉可以十次总结下，之后找时间先写个新的博客~ 第一题：上来就不顺了下，要考虑python怎么做这种字符串的操作，查了一下才知道ord()可以把字母转化为ASCII表，然后再用chr()把ASCII字符转换回串，然后实际上是一个简单的二重循环遍历； 第二题：这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了，之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了，中间写起来细节感觉很多，还是被坑了不少的。另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？； 第三题：好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping），开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个，但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了； 第四题：鸽了鸽了；","text":"周赛综述&amp;总结： 这次感觉就是从头卡到尾哈哈哈，每个题或多或少都卡了一下，感觉近几次做题真的思想越来越僵化了，也可能和太久没写代码了有关吧，2月轻松了一个月，3月开始真的忙碌了hhh，等哪天闲下来要完整总结下做题用到的一些常用结构了； 看了下有写笔记的是273到283，算上新年鸽了一次正好十次，感觉可以十次总结下，之后找时间先写个新的博客~ 第一题：上来就不顺了下，要考虑python怎么做这种字符串的操作，查了一下才知道ord()可以把字母转化为ASCII表，然后再用chr()把ASCII字符转换回串，然后实际上是一个简单的二重循环遍历； 第二题：这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了，之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了，中间写起来细节感觉很多，还是被坑了不少的。另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？； 第三题：好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping），开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个，但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了； 第四题：鸽了鸽了； 第一题：2194.Excel表中某个范围内的单元格题目链接 题目大意Excel 表中的一个单元格 (r, c) 会以字符串 &quot;&lt;col&gt;&lt;row&gt;&quot; 的形式进行表示，其中： &lt;col&gt; 即单元格的列号 c 。用英文字母表中的 字母 标识。 例如，第 1 列用 &#39;A&#39; 表示，第 2 列用 &#39;B&#39; 表示，第 3 列用 &#39;C&#39; 表示，以此类推。 &lt;row&gt; 即单元格的行号 r 。第 r 行就用 整数 r 标识。 给你一个格式为 &quot;&lt;col1&gt;&lt;row1&gt;:&lt;col2&gt;&lt;row2&gt;&quot; 的字符串 s ，其中 &lt;col1&gt; 表示 c1 列，&lt;row1&gt; 表示 r1 行，&lt;col2&gt; 表示 c2 列，&lt;row2&gt; 表示 r2 行，并满足 r1 &lt;= r2 且 c1 &lt;= c2 。 找出所有满足 r1 &lt;= x &lt;= r2 且 c1 &lt;= y &lt;= c2 的单元格，并以列表形式返回。单元格应该按前面描述的格式用 字符串 表示，并以 非递减 顺序排列（先按列排，再按行排）。 示例1： 12345输入：s = &quot;K1:L2&quot;输出：[&quot;K1&quot;,&quot;K2&quot;,&quot;L1&quot;,&quot;L2&quot;]解释：上图显示了列表中应该出现的单元格。红色箭头指示单元格的出现顺序。 示例2： 12345输入：s = &quot;A1:F1&quot;输出：[&quot;A1&quot;,&quot;B1&quot;,&quot;C1&quot;,&quot;D1&quot;,&quot;E1&quot;,&quot;F1&quot;]解释：上图显示了列表中应该出现的单元格。 红色箭头指示单元格的出现顺序。 提示： s.length == 5 &#39;A&#39; &lt;= s[0] &lt;= s[3] &lt;= &#39;Z&#39; &#39;1&#39; &lt;= s[1] &lt;= s[4] &lt;= &#39;9&#39; s 由大写英文字母、数字、和 &#39;:&#39; 组成 分析和解答ord(&quot;a&quot;)是把一个字符转化为ASCII码表示，例如该句会输出97 chr(97)是把一个ASCII码（或者也不一定，就是数字）转化为字符表示，例如该句会输出a 知道上边两个操作后怎么遍历就不是难事了，代码如下所示 12345678910111213141516171819class Solution(object): def cellsInRange(self, s): &quot;&quot;&quot; :type s: str :rtype: List[str] &quot;&quot;&quot; s_1 = s[0] n_1 = s[1] s_2 = s[3] n_2 = s[4] res = [] for i in range(ord(s_1), ord(s_2)+1): for j in range(int(n_1), int(n_2)+1): # print(chr(i)) # print(str(j)) res.append(&quot;&quot;.join([chr(i), str(j)])) return res 第二题：6017.向数组中追加K个整数题目链接 题目大意给你一个整数数组 nums 和一个整数 k 。请你向 nums 中追加 k 个 未 出现在 nums 中的、互不相同 的 正 整数，并使结果数组的元素和 最小 。 返回追加到 nums 中的 k 个整数之和。 示例1： 12345输入：nums = [1,4,25,10,25], k = 2输出：5解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 2 和 3 。nums 最终元素和为 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70 ，这是所有情况中的最小值。所以追加到数组中的两个整数之和是 2 + 3 = 5 ，所以返回 5 。 示例2： 12345输入：nums = [5,6], k = 6输出：25解释：在该解法中，向数组中追加的两个互不相同且未出现的正整数是 1 、2 、3 、4 、7 和 8 。nums 最终元素和为 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36 ，这是所有情况中的最小值。所以追加到数组中的两个整数之和是 1 + 2 + 3 + 4 + 7 + 8 = 25 ，所以返回 25 。 提示： 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i], k &lt;= 10^9 分析和解答这个题就感受到上难度了hhh，一上来必然很容易想到暴力遍历法，然后看了下数据范围估计超时间复杂度了 之后就是一个想优化的过程，大佬提了下排序后倒是能想到思路，就是直接用求和公式统计下差，然后最后看看全都补完了还剩多少个剩余的，剩余的其实就是现有max+1在往后求和k个就行了 中间写起来细节感觉很多，还是被坑了不少的。 另外还有一个哨兵机制，能简化下第一个位置的计算的感觉？； 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def minimalKSum(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; orig_k = k # res = sum(nums) res = 0 nums.append(0) nums.sort() # print(nums) for i in range(1, len(nums)): tmp = nums[i] - nums[i-1] - 1 # 差 # print(tmp) if k &gt; tmp: # 求和tmp个 if (nums[i] - 1) &gt;= nums[i-1] + 1: res += (((nums[i-1] + 1) + (nums[i] - 1)) * tmp) // 2 # print(&#x27;a&#x27;, nums[i-1] + 1, nums[i] - 1) k -= tmp else: # 求和k个 res += (((nums[i-1] + 1) + (nums[i-1] + k)) * k) // 2 # print(&#x27;b&#x27;, nums[i-1] + 1,nums[i-1] + k) k -= tmp break # print(res) # print(k) if k &gt; 0: # 某些问题？ # 如果全部中间不够了 res += (max(nums) + 1 + max(nums) + k) * k // 2 return res 第三题：2196.根据描述创建二叉树题目链接 题目大意给你一个二维整数数组 descriptions ，其中 descriptions[i] = [parenti, childi, isLefti] 表示 parenti 是 childi 在 二叉树 中的 父节点，二叉树中各节点的值 互不相同 。此外： 如果 isLefti == 1 ，那么 childi 就是 parenti 的左子节点。 如果 isLefti == 0 ，那么 childi 就是 parenti 的右子节点。 请你根据 descriptions 的描述来构造二叉树并返回其 根节点 。 测试用例会保证可以构造出 有效 的二叉树。 示例1： 1234输入：descriptions = [[20,15,1],[20,17,0],[50,20,1],[50,80,0],[80,19,1]]输出：[50,20,80,15,17,19]解释：根节点是值为 50 的节点，因为它没有父节点。结果二叉树如上图所示。 示例2： 1234输入：descriptions = [[1,2,1],[2,3,0],[3,4,1]]输出：[1,2,null,null,3,4]解释：根节点是值为 1 的节点，因为它没有父节点。 结果二叉树如上图所示。 提示： 1 &lt;= descriptions.length &lt;= 10^4 descriptions[i].length == 3 1 &lt;= parenti, childi &lt;= 10^5 0 &lt;= isLefti &lt;= 1 descriptions 所描述的二叉树是一棵有效二叉树 分析和解答好像还是在周赛里第一次见到这种构建的题，这次想到的比较慢，以后应该想构建题就直接搞哈希表（mapping） 开始是一种超级暴力的思路，每次找一个节点，都去dfs一遍看看能不能插入，能插入就插入，不能插入就下一个 但实际上mapping后每个value都能找到对应的节点，这样插入的时候实际上就是把“地址”拼接在一起了； 两轮，第一轮存节点+直接建树，然后第二轮找root作为返回； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def createBinaryTree(self, descriptions): &quot;&quot;&quot; :type descriptions: List[List[int]] :rtype: Optional[TreeNode] &quot;&quot;&quot; def pre_insert(root, item): if root is None: return False if root.val == item[0]: # pre_insert(root, ) if item[2] == 1: root.left = TreeNode(val=item[1]) else: root.right = TreeNode(val=item[1]) return True return pre_insert(root.left, item) or pre_insert(root.right, item) mapping = &#123;&#125; have_father = &#123;&#125; root = None for i, des in enumerate(descriptions): if mapping.get(des[0]) is None: mapping[des[0]] = TreeNode(val=des[0]) if mapping.get(des[1]) is None: mapping[des[1]] = TreeNode(val=des[1]) # 边记录边建树 if des[2] == 1: mapping[des[0]].left = mapping[des[1]] else: mapping[des[0]].right = mapping[des[1]] have_father[des[1]] = True # print(have_father) for i, des in enumerate(descriptions): if have_father.get(des[0]) is None: return mapping[des[0]]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"macOS及Linux-触控板左右滑动失效问题","slug":"macOS及Linux-触控板左右滑动失效问题","date":"2022-02-28T02:58:39.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2022/02/28/macOS及Linux-触控板左右滑动失效问题/","link":"","permalink":"http://example.com/2022/02/28/macOS%E5%8F%8ALinux-%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%B7%A6%E5%8F%B3%E6%BB%91%E5%8A%A8%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","excerpt":"需求：某些场景下（其实感觉是插拔HDMI线外接显示器的时候），可能出现触控板手势左右滑动失效的问题；","text":"需求：某些场景下（其实感觉是插拔HDMI线外接显示器的时候），可能出现触控板手势左右滑动失效的问题； 解决办法 killall Dock在网上查到的解决办法，可在终端执行如下命令，即可通过类似一种自动重启的方法解决这个问题 1killall Dock","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"282场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/282场LeetCode周赛","date":"2022-02-27T15:17:19.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/02/27/algorithms/leetcode-weekly-contest/282场LeetCode周赛/","link":"","permalink":"http://example.com/2022/02/27/algorithms/leetcode-weekly-contest/282%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 又是光速做完前两个题，然后盯着第三题发呆的一周周赛，第三题这次用到的思路是二分，感觉还是要多刷题多积累，可能需要找个时间复盘一下做题常用到的思路了吧哈哈哈，现在感觉思路有点打不开了，可能要阶段性总结梳理下吧，这样避免下有些想法太极端了~ 第一题：这个题python有str.startswtih()函数，用这个返回值的True和False直接加就行了； 第二题：一眼看过去都有点没看懂这个题，后来感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了； 第三题：这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了； 第四题：鸽了鸽了；","text":"周赛综述&amp;总结： 又是光速做完前两个题，然后盯着第三题发呆的一周周赛，第三题这次用到的思路是二分，感觉还是要多刷题多积累，可能需要找个时间复盘一下做题常用到的思路了吧哈哈哈，现在感觉思路有点打不开了，可能要阶段性总结梳理下吧，这样避免下有些想法太极端了~ 第一题：这个题python有str.startswtih()函数，用这个返回值的True和False直接加就行了； 第二题：一眼看过去都有点没看懂这个题，后来感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了； 第三题：这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了； 第四题：鸽了鸽了； 第一题：6008.统计包含给定前缀的字符串题目链接 题目大意给你一个字符串数组 words 和一个字符串 pref 。 返回 words 中以 pref 作为 前缀 的字符串的数目。 字符串 s 的 前缀 就是 s 的任一前导连续字符串。 示例1： 123输入：words = [&quot;pay&quot;,&quot;attention&quot;,&quot;practice&quot;,&quot;attend&quot;], pref = &quot;at&quot;输出：2解释：以 &quot;at&quot; 作为前缀的字符串有两个，分别是：&quot;attention&quot; 和 &quot;attend&quot; 。 示例2： 123输入：words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], pref = &quot;code&quot;输出：0解释：不存在以 &quot;code&quot; 作为前缀的字符串。 提示： 1 &lt;= words.length &lt;= 100 1 &lt;= words[i].length, pref.length &lt;= 100 words[i] 和 pref 由小写英文字母组成 分析和解答直接调用python的str.startswith(pref)函数就可以，这里或许可以借机复习下Trie树的数据结构，每个节点由一个mapping的词典和is_last标记组成，第一次插入一个单词的时候就是不断创造mapping里边嵌套的mapping，中间的节点is_last都是False，最后的一个节点is_last设置成True；之后插入第二个单词的时候就有一种寻迹的感觉了，如果已经有了就不用重复插入； p.s.没想到这题和某top10排名大佬代码一模一样哈哈哈，奇怪的开心点增加了 12345678910111213class Solution(object): def prefixCount(self, words, pref): &quot;&quot;&quot; :type words: List[str] :type pref: str :rtype: int &quot;&quot;&quot; res = 0 for word in words: if word.startswith(pref): res += 1 return res 第二题：2186.使两字符串互为字母异位词的最少步骤数题目链接 题目大意给你两个字符串 s 和 t 。在一步操作中，你可以给 s 或者 t 追加 任一字符 。 返回使 s 和 t 互为 字母异位词 所需的最少步骤数。 字母异位词 指字母相同但是顺序不同（或者相同）的字符串。 示例1： 12345678输入：s = &quot;leetcode&quot;, t = &quot;coats&quot;输出：7解释：- 执行 2 步操作，将 &quot;as&quot; 追加到 s = &quot;leetcode&quot; 中，得到 s = &quot;leetcodeas&quot; 。- 执行 5 步操作，将 &quot;leede&quot; 追加到 t = &quot;coats&quot; 中，得到 t = &quot;coatsleede&quot; 。&quot;leetcodeas&quot; 和 &quot;coatsleede&quot; 互为字母异位词。总共用去 2 + 5 = 7 步。可以证明，无法用少于 7 步操作使这两个字符串互为字母异位词。 示例2： 123输入：s = &quot;night&quot;, t = &quot;thing&quot;输出：0解释：给出的字符串已经互为字母异位词。因此，不需要任何进一步操作。 提示： 1 &lt;= s.length, t.length &lt;= 2 * 10^5 s 和 t 由小写英文字符组成 分析和解答看到这个题就想着要拟合测试样例，感觉能拟合测试样例可能就差不多能做出来了，然后看到第二个样例感觉就是比较明显的Counter了，感觉就是一个计数两个字符串的题目，计数一下然后互相用Counter相减的性质，互相相减后统计字符个数就行了； 1234567891011121314151617181920212223class Solution(object): def minSteps(self, s, t): &quot;&quot;&quot; :type s: str :type t: str :rtype: int &quot;&quot;&quot; s_counter = Counter(s) t_counter = Counter(t) # print(s_counter) # print(t_counter) s_t_counter = s_counter - t_counter t_s_counter = t_counter - s_counter # print(&quot;s_t_counter:&quot;, s_t_counter) # print(&quot;t_s_counter:&quot;, t_s_counter) res = 0 for key, value in s_t_counter.items(): res += value for key, value in t_s_counter.items(): res += value return res 第三题：2187.完成旅途的最少时间题目链接 题目大意给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。 每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。 给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。 示例1： 12345678910输入：time = [1,2,3], totalTrips = 5输出：3解释：- 时刻 t = 1 ，每辆公交车完成的旅途数分别为 [1,0,0] 。 已完成的总旅途数为 1 + 0 + 0 = 1 。- 时刻 t = 2 ，每辆公交车完成的旅途数分别为 [2,1,0] 。 已完成的总旅途数为 2 + 1 + 0 = 3 。- 时刻 t = 3 ，每辆公交车完成的旅途数分别为 [3,1,1] 。 已完成的总旅途数为 3 + 1 + 1 = 5 。所以总共完成至少 5 趟旅途的最少时间为 3 。 示例2： 12345输入：time = [2], totalTrips = 1输出：2解释：只有一辆公交车，它将在时刻 t = 2 完成第一趟旅途。所以完成 1 趟旅途的最少时间为 2 。 提示： 1 &lt;= time.length &lt;= 10^5 1 &lt;= time[i], totalTrips &lt;= 10^7 分析和解答这个题一眼看过去就感觉有很暴力的思路，遍历每个时刻，在每个时刻下再进一步遍历数组，判断是不是可以超过需要的趟数，后来在大佬的提醒下是在遍历每个时刻这里可以二分，这很符合二分的性质，也是好久没在具体的题里用到过二分了； 二分的过程细节需要把握下，就是 right left = mid 还是 mid + 1 还是 mid - 1 这类的问题。 1234567891011121314151617181920212223242526272829class Solution(object): def minimumTime(self, time, totalTrips): &quot;&quot;&quot; :type time: List[int] :type totalTrips: int :rtype: int &quot;&quot;&quot; def judge(mid, time, totalTrips): tmp = 0 for t in time: tmp += mid // t if tmp &gt;= totalTrips: return True else: return False left = 1 right = min(time) * totalTrips while left &lt; right: mid = (left + right) &gt;&gt; 1 # 中间那个时间 # 判断中间那个时间是否可以完成 if judge(mid, time, totalTrips): right = mid else: left = mid + 1 return left","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"}]},{"title":"281场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/281场LeetCode周赛","date":"2022-02-27T11:12:42.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/02/27/algorithms/leetcode-weekly-contest/281场LeetCode周赛/","link":"","permalink":"http://example.com/2022/02/27/algorithms/leetcode-weekly-contest/281%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 依旧是前两个题很简单，然后第三题直接卡到死的节奏，感觉近几次周赛第三题感觉都不是很好，可能需要阶段性的复习一下？ 总结下来的话算法似乎都是在可以知道范围内的，比如这次题印象比较深的就是要正确理解题意或者说不要走到和题意错误的路上，有些题可能需要灵光一现用一些广泛用的Coutner、二分、前缀和、有限队列单调栈类的，有些题可能写着写着会有思路吧。 总之感觉刷题这个事还是要持续进行，总有瓶颈也总需要突破，冲！ 第一题：看到n &lt; 1000感觉就直接暴力模拟就行了，模拟起来还是相对简单的，python对字符的操作太方便了； 第二题：一个链表的操作题，很简单就能搞定了，纯链表题现在感觉没有太难的； 第三题：这个题这次又卡的时间太长了，开始想的是排序后原地交换的思路，然后感觉就思维掉到一个坑里边了，一直在排序后原地交换一些细节条件里考虑来考虑去。后来大佬提醒说可以用Counter后排序贪心的思路，感觉这个思路一下就简单并且明确了； 第四题：鸽了鸽了。","text":"周赛综述&amp;总结： 依旧是前两个题很简单，然后第三题直接卡到死的节奏，感觉近几次周赛第三题感觉都不是很好，可能需要阶段性的复习一下？ 总结下来的话算法似乎都是在可以知道范围内的，比如这次题印象比较深的就是要正确理解题意或者说不要走到和题意错误的路上，有些题可能需要灵光一现用一些广泛用的Coutner、二分、前缀和、有限队列单调栈类的，有些题可能写着写着会有思路吧。 总之感觉刷题这个事还是要持续进行，总有瓶颈也总需要突破，冲！ 第一题：看到n &lt; 1000感觉就直接暴力模拟就行了，模拟起来还是相对简单的，python对字符的操作太方便了； 第二题：一个链表的操作题，很简单就能搞定了，纯链表题现在感觉没有太难的； 第三题：这个题这次又卡的时间太长了，开始想的是排序后原地交换的思路，然后感觉就思维掉到一个坑里边了，一直在排序后原地交换一些细节条件里考虑来考虑去。后来大佬提醒说可以用Counter后排序贪心的思路，感觉这个思路一下就简单并且明确了； 第四题：鸽了鸽了。 第一题：2180.统计各位数字之和为偶数的整数个数题目链接 题目大意给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。 正整数的 各位数字之和 是其所有位上的对应数字相加的结果。 示例1： 1234输入：num = 4输出：2解释：只有 2 和 4 满足小于等于 4 且各位数字之和为偶数。 示例2： 12345输入：num = 30输出：14解释：只有 14 个整数满足小于等于 30 且各位数字之和为偶数，分别是： 2、4、6、8、11、13、15、17、19、20、22、24、26 和 28 。 提示： 1 &lt;= num &lt;= 1000 分析和解答考虑到数据范围的1000，直接暴力就可以了 1234567891011121314151617181920class Solution(object): def countEven(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; def judge(n): res = 0 str_n = str(n) for i in range(len(str_n)): res += int(str_n[i]) return res % 2 == 0 res = 0 for i in range(1, num+1): if judge(i): res += 1 return res 第二题：2181.合并零之间的节点题目链接 题目大意给你一个链表的头节点 head ，该链表包含由 0 分隔开的一连串整数。链表的 开端 和 末尾 的节点都满足 Node.val == 0 。 对于每两个相邻的 ```0`` ，请你将它们之间的所有节点合并成一个节点，其值是所有已合并节点的值之和。然后将所有 0 移除，修改后的链表不应该含有任何 0 。 返回修改后链表的头节点 head 。 示例1： 123456输入：head = [0,3,1,0,4,5,2,0]输出：[4,11]解释：上图表示输入的链表。修改后的链表包含：- 标记为绿色的节点之和：3 + 1 = 4- 标记为红色的节点之和：4 + 5 + 2 = 11 示例2： 1234567输入：head = [0,1,0,3,0,2,2,0]输出：[1,3,4]解释：上图表示输入的链表。修改后的链表包含：- 标记为绿色的节点之和：1 = 1- 标记为红色的节点之和：3 = 3- 标记为黄色的节点之和：2 + 2 = 4 提示： 列表中的节点数目在范围 [3, 2 * 10^5] 内 0 &lt;= Node.val &lt;= 1000 不 存在连续两个 Node.val == 0 的节点 链表的 开端 和 末尾 节点都满足 Node.val == 0 分析和解答看起来提示里很多条件都是避免特殊情况用的，链表题比较复杂的地方在于经常有一些很极端的case只能靠测试样例来debug，很难一次想到，这个题没有这个问题不过也需要注意下 12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def mergeNodes(self, head): &quot;&quot;&quot; :type head: Optional[ListNode] :rtype: Optional[ListNode] &quot;&quot;&quot; new_head = ListNode(val=0, next=None) q = new_head tmp = 0 head = head.next while head is not None: if head.val == 0: tmp_node = ListNode(val=tmp) q.next = tmp_node q = q.next tmp = 0 else: tmp += head.val head = head.next return new_head.next 第三题：2182.构造限制重复的字符串题目链接 题目大意给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。 返回 字典序最大的 repeatLimitedString 。 如果在字符串 a 和 b 不同的第一个位置，字符串 a 中的字母在字母表中出现时间比字符串 b 对应的字母晚，则认为字符串 a 比字符串 b 字典序更大 。如果字符串中前 min(a.length, b.length) 个字符都相同，那么较长的字符串字典序更大。 示例1： 123456789输入：s = &quot;cczazcc&quot;, repeatLimit = 3输出：&quot;zzcccac&quot;解释：使用 s 中的所有字符来构造 repeatLimitedString &quot;zzcccac&quot;。字母 &#x27;a&#x27; 连续出现至多 1 次。字母 &#x27;c&#x27; 连续出现至多 3 次。字母 &#x27;z&#x27; 连续出现至多 2 次。因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。该字符串是字典序最大的 repeatLimitedString ，所以返回 &quot;zzcccac&quot; 。注意，尽管 &quot;zzcccca&quot; 字典序更大，但字母 &#x27;c&#x27; 连续出现超过 3 次，所以它不是一个有效的 repeatLimitedString 。 示例2： 123456789输入：s = &quot;aababab&quot;, repeatLimit = 2输出：&quot;bbabaa&quot;解释：使用 s 中的一些字符来构造 repeatLimitedString &quot;bbabaa&quot;。 字母 &#x27;a&#x27; 连续出现至多 2 次。 字母 &#x27;b&#x27; 连续出现至多 2 次。 因此，没有字母连续出现超过 repeatLimit 次，字符串是一个有效的 repeatLimitedString 。 该字符串是字典序最大的 repeatLimitedString ，所以返回 &quot;bbabaa&quot; 。 注意，尽管 &quot;bbabaaa&quot; 字典序更大，但字母 &#x27;a&#x27; 连续出现超过 2 次，所以它不是一个有效的 repeatLimitedString 。 提示： 1 &lt;= repeatLimit &lt;= s.length &lt;= 10^5 s由小写英文字母组成 分析和解答这个题现场做的时候又做了好久好久，最后还是gg了，当时主要考虑的是一种排序后交换的思路，但是交换的思路最后就越换越乱，比如换完了后在那个位置的“指针”是否要++这样的； 后来大佬给了一种Counter计数排序后贪心的思路感觉能想到的话代码实现就比较简单了，每次取最头的元素，然后取够个数了后就交替取一个下一个，如果没有下一个就代表已经取不了了，这样实际上有一种类似于队列的小思想在里边 另外删除列表中的一个元素可以用del tmp[i]这样的操作来做 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def repeatLimitedString(self, s, repeatLimit): &quot;&quot;&quot; :type s: str :type repeatLimit: int :rtype: str &quot;&quot;&quot; # 还是要多锻炼多总结思路hhh # 一种贪心算法的思想，Counter后排序，然后相对贪心一点的拿就行了 # 开始的思路想的是排序后有一种原地交换的感觉，但后来还是换着换着就乱了 counter_s = Counter(s) # print(counter_s) counter_s_list = sorted([list(x) for x in counter_s.items()], key=lambda x: x[0]) counter_s_list.reverse() # print(counter_s_list) result = [] while len(counter_s_list): # 循环直到为空为止，这里不用循环变量i，直接用0就行了 if counter_s_list[0][1] &lt;= repeatLimit: result.append(counter_s_list[0][0] * counter_s_list[0][1]) counter_s_list = counter_s_list[1:] else: result.append(counter_s_list[0][0] * repeatLimit) counter_s_list[0][1] -= repeatLimit if counter_s_list[0][1] &gt; 0: # 如果还有的话，如果此时列表就1个了，就结束，否则和下一个交换 if len(counter_s_list) &gt; 1: result.append(counter_s_list[1][0]) counter_s_list[1][1] -= 1 if counter_s_list[1][1] == 0: # counter_s_list = counter_s_list[:1] + counter_s_list[2:] # 去掉，这里写的其实不够简化 del counter_s_list[1] else: break # print(result) return &#x27;&#x27;.join(result)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","permalink":"http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"78.子集-python","slug":"algorithms/leetcode-python/78-子集-python","date":"2022-02-21T10:51:36.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2022/02/21/algorithms/leetcode-python/78-子集-python/","link":"","permalink":"http://example.com/2022/02/21/algorithms/leetcode-python/78-%E5%AD%90%E9%9B%86-python/","excerpt":"78.子集（中等） 题目大意： 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。","text":"78.子集（中等） 题目大意： 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 题目题目链接 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例1： 12输入：nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例2： 12输入：nums = [0]输出：[[],[0]] 提示： 1 &lt;= nums.length &lt;= 10 -10 &lt;= nums[i] &lt;= 10 nums 中的所有元素 互不相同 分析和解答解法一：2^n遍历法在某次周赛的时候积累到了这个思路，可以通过位运算的方法把0到n的二进制每个位的表示都提取出来，这样就可以实现每个位置选择/不选择的2^n遍历法。 123456789101112131415161718192021222324class Solution(object): def subsets(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; # 某次周赛积累到的2^n这种的遍历思路，可以实现暴力非递归 def get_bits(num): l = [] while num &gt; 0: l.append(num&amp;1) num &gt;&gt;= 1 return l ans = [] for i in range(2**len(nums)): l = get_bits(i) tmp = [] for j in range(len(l)): if l[j] == 1: tmp.append(nums[j]) ans.append(tmp) return ans 解法二：dfs回溯法dfs的方法在本质上也是针对每个位置的选择，不选择。所以每次carry到递归下一个轮次状态就是位置i，针对位置i的选择和不选择两条dfs分支。 另外在这个题里发现dfs的时候需要deepcopy复制一份，列表在dfs过程中不能指向相同的地址，否则一个改动了就全部改动了。 12345678910111213141516171819202122232425class Solution(object): def subsets(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; # 递归思路，这个题涉及到了python的深浅拷贝问题，在dfs向下一层的时候本质上是复制了状态，所以要拷贝 res = [] def dfs(i, tmp_list): &quot;&quot;&quot; :type i: int，代表当前到了dfs的第几层了 : type tmp_list: List[int]，代表当前带着哪些下到下一层了！！！！ &quot;&quot;&quot; if i == len(nums): # 这类的递归一般用长度作为出口 res.append(tmp_list) return # 不取的dfs分支 dfs(i+1, copy.deepcopy(tmp_list)) # 这里要传拷贝，否则会搞到一个分支上！！！ # 取的dfs分支 tmp_list.append(nums[i]) dfs(i+1, copy.deepcopy(tmp_list)) # 这里要传拷贝 dfs(0, []) return res","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"}]},{"title":"19.删除链表的倒数第N个结点-python","slug":"algorithms/leetcode-python/19-删除链表的倒数第N个结点-python","date":"2022-02-21T10:11:44.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/02/21/algorithms/leetcode-python/19-删除链表的倒数第N个结点-python/","link":"","permalink":"http://example.com/2022/02/21/algorithms/leetcode-python/19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-python/","excerpt":"19.删除链表的倒数第 N 个结点（中等） 题目大意： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","text":"19.删除链表的倒数第 N 个结点（中等） 题目大意： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 题目题目链接 题目大意：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例1： 12输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 示例2： 12输入：head = [1], n = 1输出：[] 示例3： 12输入：head = [1,2], n = 1输出：[1] 提示： 链表中结点的数目为 sz 1 &lt;= sz &lt;= 30 0 &lt;= Node.val &lt;= 100 1 &lt;= n &lt;= sz 分析和解答这是一个经典的双指针题目了，保持pq指针之间的距离差是n，然后当p先到结尾后，把q.next那个地方删除了就可以。 这个题比较麻烦的地方在于很难一次性做对，需要自己构造一些相对极端的的case来测试下，例如只有一个节点的链表这样的。 12345678910111213141516171819202122232425262728293031# Definition for singly-linked list.# class ListNode(object):# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution(object): def removeNthFromEnd(self, head, n): &quot;&quot;&quot; :type head: ListNode :type n: int :rtype: ListNode &quot;&quot;&quot; # 注意自己构造一些badcase的例子，来把所有特殊情况覆盖掉 # 双指针法，双指针之间的差距是n p = head q = head i = 0 while i &lt; n: q = q.next i += 1 # 让q指向最后一个不为None的，有一个异常情况是q已经是None了，应该删除头结点 if q is None: return head.next while q.next is not None: p = p.next q = q.next # 删除p p.next = p.next.next return head","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"101.对称二叉树-python","slug":"algorithms/leetcode-python/101-对称二叉树-python","date":"2022-02-14T06:52:02.000Z","updated":"2022-11-20T01:50:08.881Z","comments":true,"path":"2022/02/14/algorithms/leetcode-python/101-对称二叉树-python/","link":"","permalink":"http://example.com/2022/02/14/algorithms/leetcode-python/101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-python/","excerpt":"101.对称二叉树（简单） 题目大意： 给你一个二叉树的根节点 root ， 检查它是否轴对称。","text":"101.对称二叉树（简单） 题目大意： 给你一个二叉树的根节点 root ， 检查它是否轴对称。 题目题目链接 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例1： 12输入：root = [1,2,2,3,4,4,3]输出：true 示例2： 12输入：root = [1,2,2,null,3,null,3]输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 &lt;= Node.val &lt;= 100 题目分析和解答这种题又和完全的自递归题目有些区别，需要再构造一个dfscheck的函数，来套一下递归。 这个dfs_check()函数的输入是两个root这样的感觉，先判断当前节点的左右是否相等，然后往下嵌套递归，判断当前节点的左的左和当前节点右的右，还有当前节点左的右和当前节点右的左是不是一样就行了，在前边要加入一些None的出口递归条件 1234567891011121314151617181920212223242526# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; def dfs_check(root1, root2): &quot;&quot;&quot; 用于判断一个点的左右子树是否轴对称，首次输入两个都是这个树的根 &quot;&quot;&quot; if root1 is None and root2 is None: return True if root1 is None or root2 is None: return False # 当前节点的左右，然后递归下一层的左右！ return root1.val == root2.val and dfs_check(root1.left, root2.right) and dfs_check(root1.right, root2.left) return dfs_check(root, root)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"617.合并二叉树-python","slug":"algorithms/leetcode-python/617-合并二叉树-python","date":"2022-02-14T06:49:48.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/02/14/algorithms/leetcode-python/617-合并二叉树-python/","link":"","permalink":"http://example.com/2022/02/14/algorithms/leetcode-python/617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-python/","excerpt":"617.合并二叉树（简单） 题目大意： 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。","text":"617.合并二叉树（简单） 题目大意： 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 题目题目链接 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例1： 12输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7] 示例2： 12输入：root1 = [1], root2 = [1,2]输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -10^4 &lt;= Node.val &lt;= 10^4 题目分析和解答这个题有一种自递归的感觉，题目的初始Solution类如下： 1234567class Solution(object): def mergeTrees(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: TreeNode &quot;&quot;&quot; rtype是一个TreeNode类型的，所以能有一种自递归的感觉，先建立TreeNode，然后 这种自递归的题还是可以先把主干写好了，再决定递归出口那样的感觉。 123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightclass Solution(object): def mergeTrees(self, root1, root2): &quot;&quot;&quot; :type root1: TreeNode :type root2: TreeNode :rtype: TreeNode &quot;&quot;&quot; # 整个题目有一种自递归的感觉 if root1 is None: return root2 if root2 is None: return root1 merged_node = TreeNode(val=root1.val + root2.val) merged_node.left = self.mergeTrees(root1.left, root2.left) merged_node.right = self.mergeTrees(root1.right, root2.right) return merged_node","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"280场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/280场LeetCode周赛","date":"2022-02-13T17:58:59.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/02/14/algorithms/leetcode-weekly-contest/280场LeetCode周赛/","link":"","permalink":"http://example.com/2022/02/14/algorithms/leetcode-weekly-contest/280%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这周做的状态和水平感觉都不是很好，第一个题做下去的时候就感觉不是很顺，第二个题直接就卡住了，感觉还是把第二题想的太简单或者说样例分析不太够？第三题直接没来得及看，最后复盘的时候感觉比赛有规定的时间内也不一定好想，和之前某一周ABCDE的前后缀和有点像，但是简单了一些； 第一题：一种模拟操作的感觉就行了？开始还以为要一些数学的操作，这种题如果告诉难度的话可能比较简单，但是如果不知道难度比较怕想到数学题上边去； 第二题：这个题当时做的时候直接就卡死了，卡了可以说一个多小时，还是样例可能误导了一种的感觉，最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了； 第三题：一种前缀和，或者说反向思路的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的； 第四题：鸽！","text":"周赛综述&amp;总结： 这周做的状态和水平感觉都不是很好，第一个题做下去的时候就感觉不是很顺，第二个题直接就卡住了，感觉还是把第二题想的太简单或者说样例分析不太够？第三题直接没来得及看，最后复盘的时候感觉比赛有规定的时间内也不一定好想，和之前某一周ABCDE的前后缀和有点像，但是简单了一些； 第一题：一种模拟操作的感觉就行了？开始还以为要一些数学的操作，这种题如果告诉难度的话可能比较简单，但是如果不知道难度比较怕想到数学题上边去； 第二题：这个题当时做的时候直接就卡死了，卡了可以说一个多小时，还是样例可能误导了一种的感觉，最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了； 第三题：一种前缀和，或者说反向思路的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的； 第四题：鸽！ 第一题：2169.得到0的操作数题目链接 题目大意给你两个 非负 整数 num1 和 num2 。 每一步 操作 中，如果 num1 &gt;= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。 例如， num1 = 5 且 num2 = 4 ，应该用 num1 减 num2 ，因此，得到 num1 = 1 和 num2 = 4 。然而，如果 num1 = 4 且 num2 = 5 ，一步操作后，得到 num1 = 4 和 num2 = 1 。 返回使 num1 = 0 或 num2 = 0 的 操作数 。 示例1： 12345678输入：num1 = 2, num2 = 3输出：3解释：- 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 &lt; num2 ，num2 减 num1 得到 num1 = 2 ，num2 = 3 - 2 = 1 。- 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 &gt; num2 ，num1 减 num2 。- 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。所以总操作数是 3 。 示例2： 123456输入：num1 = 10, num2 = 10输出：1解释：- 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10 = 0 。此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。所以总操作数是 1 。 提示： 0 &lt;= num1, num2 &lt;= 105 分析和解答这个题开始还以为需要一些数学的操作，没想到直接循环模拟就行了，注意python的两个数值交换可以使用如下代码直接交换 1a, b = b, a 看了一些题解说是可以用辗转相除法，不禁想到信安数学里学过为数不多的数论知识都还给老师了哈哈哈 123456789101112131415161718class Solution(object): def countOperations(self, num1, num2): &quot;&quot;&quot; :type num1: int :type num2: int :rtype: int &quot;&quot;&quot; cnt = 0 while True: if num1 == 0 or num2 == 0: break if num1 &lt; num2: num1, num2 = num2, num1 if num1 &gt;= num2: num1 = num1 - num2 cnt += 1 # print(num1, num2) return cnt 第二题：2170.使数组变成交替数组的最少操作数题目链接 题目大意给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。 如果满足下述条件，则数组 nums 是一个 交替数组 ： nums[i - 2] == nums[i] ，其中 2 &lt;= i &lt;= n - 。 nums[i - 1] != nums[i] ，其中 1 &lt;= i &lt;= n - 1 。 在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。 返回使数组变成交替数组的 最少操作数 。 示例1： 123456输入：nums = [3,1,3,2,4,3]输出：3解释：使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。在这种情况下，操作数为 3 。可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。 示例2： 123456输入：nums = [1,2,2,2,2]输出：2解释：使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].在这种情况下，操作数为 2 。注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。 提示： 1 &lt;= nums.length &lt;= 105 1 &lt;= nums[i] &lt;= 105 分析和解答这个题感觉还是个很考思路的题，一旦有一些理解错或者路走歪了就容易做不出来了。 最少的修改数目也就是奇偶位要拆开，在奇数位偶数位各选一个最大的数字作为统一就可以了！注意这两个数字在角标上不一定是连续的，被这个地方坑了好久，不用连续只要几乎选一个最大的，然后稍微做一些分类讨论就可以了 12345678910111213141516171819202122232425262728293031323334class Solution(object): def minimumOperations(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 1: return 0 oushu = [nums[i] for i in range(0, len(nums), 2)] jishu = [nums[i] for i in range(1, len(nums), 2)] oushu_counter = Counter(oushu) jishu_counter = Counter(jishu) oushu_counter_value = sorted(oushu_counter.items(), key=lambda x: -x[1]) jishu_counter_value = sorted(jishu_counter.items(), key=lambda x: -x[1]) # 三种情况 if oushu_counter_value[0][0] != jishu_counter_value[0][0]: max_num = oushu_counter_value[0][1] + jishu_counter_value[0][1] else: if len(oushu_counter_value) &lt; 2: oushu_counter_value.append((0, 0)) if len(jishu_counter_value) &lt; 2: jishu_counter_value.append((0, 0)) max_num = max(oushu_counter_value[1][1] + jishu_counter_value[0][1], oushu_counter_value[0][1] + jishu_counter_value[1][1]) return len(nums) - max_num 第三题：2171.拿出最少数目的魔法豆题目链接 题目大意给你一个 正 整数数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。 请你从每个袋子中 拿出 一些豆子（也可以 不拿出 ），使得剩下的 非空 袋子中（即 至少 还有 一颗 魔法豆的袋子）魔法豆的数目 相等 。一旦魔法豆从袋子中取出，你不能将它放到任何其他的袋子中。 请你返回你需要拿出魔法豆的 最少数目。 示例1： 1234567891011输入：beans = [4,1,6,5]输出：4解释：- 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5]- 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5]- 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4]总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。没有比取出 4 个魔法豆更少的方案。 示例2： 1234567891011输入：beans = [2,10,3,2]输出：7解释：- 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2]- 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0]- 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0]总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。没有比取出 7 个魔法豆更少的方案。 提示： 1 &lt;= beans.length &lt;= 105 1 &lt;= beans[i] &lt;= 105 分析和解答一眼看过去这种题目肯定是要排序的，后边发现只要排序+枚举就可以了，有一种反向思路的感觉 一种前缀和，或者说反向思路的感觉，算出来最多能留多少个，也就是最少能拿出来多少个了，还是很牛的 123456789101112131415161718class Solution(object): def minimumRemoval(self, beans): &quot;&quot;&quot; :type beans: List[int] :rtype: int &quot;&quot;&quot; # 第i个地方最多保留(n-i) * beans[i]个 beans.sort() total = 0 max_save = 0 for i in range(len(beans)): total += beans[i] max_save = max(max_save, (len(beans)-i) * beans[i]) return total - max_save","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"279场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/279场LeetCode周赛","date":"2022-02-07T08:41:48.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/02/07/algorithms/leetcode-weekly-contest/279场LeetCode周赛/","link":"","permalink":"http://example.com/2022/02/07/algorithms/leetcode-weekly-contest/279%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 这次手感还可以，在比赛时间做出了三个题，回看复盘的时候感觉当时状态可能确实好hhh，思路一路做下来没有中断的感觉。一些常见的操作包括filp一类的，还有就是下边这段代码可以直接取出来奇偶下标的！（实际是在280周赛复盘发现的） 12nums[::2] # 取出偶数下标的valuenums[1::2] # 取出奇数下标的value 还有个是index截断的重拼接可以使用下边这种方式 1s[index] + &#x27;&#x27;.join(s[:index]) + &#x27;&#x27;.join(s[index+1:]) 第一题：印象比较深的是要把奇数偶数下标的分开拍，注意审题的感觉； 第二题：也是一个排序的思路，可以分大于0小于0两种情况分类讨论，还是很容易区分状态的； 第三题：一种设计题的思路，第一次很简单的做很快就超时了，超时后复盘发现可以用一些标识为来进行一些标志，有一个filp操作，标志出filp_status后，其他的操作都可以通过cnt直接O(1)的返回了，做题的时候状态比较好，感觉这个题还是没那么好想，也可能是做的时候根据badcase发现了优化思路吧； 第四题：鸽！","text":"周赛综述&amp;总结： 这次手感还可以，在比赛时间做出了三个题，回看复盘的时候感觉当时状态可能确实好hhh，思路一路做下来没有中断的感觉。一些常见的操作包括filp一类的，还有就是下边这段代码可以直接取出来奇偶下标的！（实际是在280周赛复盘发现的） 12nums[::2] # 取出偶数下标的valuenums[1::2] # 取出奇数下标的value 还有个是index截断的重拼接可以使用下边这种方式 1s[index] + &#x27;&#x27;.join(s[:index]) + &#x27;&#x27;.join(s[index+1:]) 第一题：印象比较深的是要把奇数偶数下标的分开拍，注意审题的感觉； 第二题：也是一个排序的思路，可以分大于0小于0两种情况分类讨论，还是很容易区分状态的； 第三题：一种设计题的思路，第一次很简单的做很快就超时了，超时后复盘发现可以用一些标识为来进行一些标志，有一个filp操作，标志出filp_status后，其他的操作都可以通过cnt直接O(1)的返回了，做题的时候状态比较好，感觉这个题还是没那么好想，也可能是做的时候根据badcase发现了优化思路吧； 第四题：鸽！ 第一题：2164.对奇偶下标分别排序题目链接 题目大意给你一个下标从 0 开始的整数数组 nums 。根据下述规则重排 nums 中的值： 按 非递增 顺序排列 nums 奇数下标 上的所有值。 举个例子，如果排序前 nums = [4,1,2,3] ，对奇数下标的值排序后变为 [4,3,2,1] 。奇数下标 1 和 3 的值按照非递增顺序重排。 按 非递减 顺序排列 nums 偶数下标 上的所有值。 举个例子，如果排序前 nums = [4,1,2,3] ，对偶数下标的值排序后变为 [2,1,4,3] 。偶数下标 0 和 2 的值按照非递减顺序重排。 返回重排 nums 的值之后形成的数组。 示例1： 12345678输入：nums = [4,1,2,3]输出：[2,3,4,1]解释：首先，按非递增顺序重排奇数下标（1 和 3）的值。所以，nums 从 [4,1,2,3] 变为 [4,3,2,1] 。然后，按非递减顺序重排偶数下标（0 和 2）的值。所以，nums 从 [4,1,2,3] 变为 [2,3,4,1] 。因此，重排之后形成的数组是 [2,3,4,1] 。 示例2： 12345输入：nums = [2,1]输出：[2,1]解释：由于只有一个奇数下标和一个偶数下标，所以不会发生重排。形成的结果数组是 [2,1] ，和初始数组一样。 提示： 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 分析和解答这个题主要是审题，开始审题错了还被坑了一回，注意是奇偶数下标这样的。 然后就是280场周赛get到的一个技巧，用下边这个代码操作可以把奇数偶数间隔的取出来 12nums[::2] # 取出偶数下标的valuenums[1::2] # 取出奇数下标的value 1234567891011121314151617181920212223class Solution(object): def sortEvenOdd(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; o_index = nums[::2] j_index = nums[1::2] o_index.sort() j_index.sort(key=lambda x: -x) result = [] j = 0 k = 0 for i in range(len(nums)): if i % 2 == 0: result.append(o_index[j]) j += 1 else: result.append(j_index[k]) k += 1 return result 第二题：2165.重排数字的最小值题目链接 题目大意给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。 返回不含前导零且值最小的重排数字。 注意，重排各位数字后，num 的符号不会改变。 示例1： 1234输入：num = 310输出：103解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。不含任何前导零且值最小的重排数字是 103 。 示例2： 1234输入：num = -7605输出：-7650解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。不含任何前导零且值最小的重排数字是 -7650 。 提示： -10^15 &lt;= num &lt;= 10^15 分析和解答要分开处理正数和负数的情况，然后贪心思路的感觉。在str和int类型之间来回转化。 如果是正数的处理要稍微复杂一点点，就是第一位不能以0起头，要选择一个不是0的index作为起头。 注意列表的拼接，可以使用如下的操作方式： 1s[index] + &#x27;&#x27;.join(s[:index]) + &#x27;&#x27;.join(s[index+1:] 题目解答如下 1234567891011121314151617181920212223242526272829class Solution(object): def smallestNumber(self, num): &quot;&quot;&quot; :type num: int :rtype: int &quot;&quot;&quot; r_list = [] if num &lt; 0: s = list(str(-num)) s.sort(key=lambda x: -int(x)) # 选一个最大的（第一个就是），进行重组 return_int = -int(&#x27;&#x27;.join(s)) # print(return_int) else: # num &gt;= 0 s = list(str(num)) s.sort() index = -1 for i in range(len(s)): if int(s[i]) != 0: index = i break print(index) return_int = int(s[index] + &#x27;&#x27;.join(s[:index]) + &#x27;&#x27;.join(s[index+1:])) # print(return_int) return return_int 第三题：2166.设计位集题目链接 题目大意位集 Bitset 是一种能以紧凑形式存储位的数据结构。 请你实现 Bitset 类。 Bitset(int size) 用 size 个位初始化 Bitset ，所有位都是 0 。 void fix(int idx) 将下标为 idx 的位上的值更新为 1 。如果值已经是 1 ，则不会发生任何改变。 void unfix(int idx) 将下标为 idx 的位上的值更新为 0 。如果值已经是 0 ，则不会发生任何改变。 void flip() 翻转 Bitset 中每一位上的值。换句话说，所有值为 0 的位将会变成 1 ，反之亦然。 boolean all() 检查 Bitset 中 每一位 的值是否都是 1 。如果满足此条件，返回 true ；否则，返回 false 。 boolean one() 检查 Bitset 中 是否 至少一位 的值是 1 。如果满足此条件，返回 true ；否则，返回 false 。 int count() 返回 Bitset 中值为 1 的位的 总数 。 String toString() 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 i 个下标处的字符应该与 Bitset 中的第 i 位一致。 示例： 123456789101112131415161718输入[&quot;Bitset&quot;, &quot;fix&quot;, &quot;fix&quot;, &quot;flip&quot;, &quot;all&quot;, &quot;unfix&quot;, &quot;flip&quot;, &quot;one&quot;, &quot;unfix&quot;, &quot;count&quot;, &quot;toString&quot;][[5], [3], [1], [], [], [0], [], [], [0], [], []]输出[null, null, null, null, false, null, null, true, null, 2, &quot;01010&quot;]解释Bitset bs = new Bitset(5); // bitset = &quot;00000&quot;.bs.fix(3); // 将 idx = 3 处的值更新为 1 ，此时 bitset = &quot;00010&quot; 。bs.fix(1); // 将 idx = 1 处的值更新为 1 ，此时 bitset = &quot;01010&quot; 。bs.flip(); // 翻转每一位上的值，此时 bitset = &quot;10101&quot; 。bs.all(); // 返回 False ，bitset 中的值不全为 1 。bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = &quot;00101&quot; 。bs.flip(); // 翻转每一位上的值，此时 bitset = &quot;11010&quot; 。bs.one(); // 返回 True ，至少存在一位的值为 1 。bs.unfix(0); // 将 idx = 0 处的值更新为 0 ，此时 bitset = &quot;01010&quot; 。bs.count(); // 返回 2 ，当前有 2 位的值为 1 。bs.toString(); // 返回 &quot;01010&quot; ，即 bitset 的当前组成情况。 提示： 1 &lt;= size &lt;= 10^5 0 &lt;= idx &lt;= size - 1 至多调用 fix、unfix、flip、all、one、count 和 toString 方法 总共 10^5 次 至少调用 all、one、count 或 toString 方法一次 至多调用 toString 方法 5 次 分析和解答要通过一个filp的操作把很多操作都变成O(1)的， fix和unfix的操作因为是数组角标的操作，所以是O(1)的，但是注意这个操作要根据filp的状态来决定 filp直接把self.filp_status修改了就行O(1) all、one、count根据cnt值和filp_status共同确定也可以O(1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Bitset(object): def __init__(self, size): &quot;&quot;&quot; :type size: int &quot;&quot;&quot; # 都放在初始化里？ self.bs = [0 for _ in range(size)] self.cnt = 0 self.filp_status = 0 def fix(self, idx): # 这个没的改了 &quot;&quot;&quot; :type idx: int :rtype: None &quot;&quot;&quot; if self.bs[idx] != 1 and self.filp_status == 0: self.bs[idx] = 1 self.cnt += 1 elif self.filp_status == 1 and self.bs[idx] != 0: self.bs[idx] = 0 self.cnt += 1 def unfix(self, idx): # 这个没的改了 &quot;&quot;&quot; :type idx: int :rtype: None &quot;&quot;&quot; if self.bs[idx] == 1 and self.filp_status == 0: self.bs[idx] = 0 self.cnt -= 1 elif self.filp_status == 1 and self.bs[idx] != 1: self.bs[idx] = 1 self.cnt -= 1 def flip(self): &quot;&quot;&quot; :rtype: None &quot;&quot;&quot; # 翻转了 if self.filp_status == 0: self.filp_status = 1 else: self.filp_status = 0 self.cnt = len(self.bs) - self.cnt def all(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; if self.cnt == len(self.bs): return True else: return False def one(self): &quot;&quot;&quot; :rtype: bool &quot;&quot;&quot; if self.cnt &gt;= 1: return True else: return False def count(self): &quot;&quot;&quot; :rtype: int &quot;&quot;&quot; return self.cnt def toString(self): &quot;&quot;&quot; :rtype: str &quot;&quot;&quot; if self.filp_status == 0: return &#x27;&#x27;.join([str(x) for x in self.bs]) else: return &#x27;&#x27;.join([str(abs(1-x)) for x in self.bs])# Your Bitset object will be instantiated and called as such:# obj = Bitset(size)# obj.fix(idx)# obj.unfix(idx)# obj.flip()# param_4 = obj.all()# param_5 = obj.one()# param_6 = obj.count()# param_7 = obj.toString()","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"277场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/277场LeetCode周赛","date":"2022-01-23T07:51:15.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/01/23/algorithms/leetcode-weekly-contest/277场LeetCode周赛/","link":"","permalink":"http://example.com/2022/01/23/algorithms/leetcode-weekly-contest/277%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 在大佬们的帮助下第一次周赛ak并进了前1000名还是很开心的hhh，前三个题是有史以来见过最水的周赛题，感觉全是easy难度的，最后一个题学习到了位运算的暴力遍历思路，而且还有一个题目特有的思想是只需要考虑说真话的人就行了，因为假的说话怎么都是有可能的，于是在假定所有说真话的人判断是否和条件有冲突就可以了。 另外突然感觉这次题目的前三题描述都好简单啊，喜欢这样的题，搞直接点行不行hhh 第一题：排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了； 第二题：自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了； 第三题：mapping就能解决，这种题还是很好想到mapping（哈希表）的； 第四题：感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了；","text":"周赛综述&amp;总结： 在大佬们的帮助下第一次周赛ak并进了前1000名还是很开心的hhh，前三个题是有史以来见过最水的周赛题，感觉全是easy难度的，最后一个题学习到了位运算的暴力遍历思路，而且还有一个题目特有的思想是只需要考虑说真话的人就行了，因为假的说话怎么都是有可能的，于是在假定所有说真话的人判断是否和条件有冲突就可以了。 另外突然感觉这次题目的前三题描述都好简单啊，喜欢这样的题，搞直接点行不行hhh 第一题：排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了； 第二题：自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了； 第三题：mapping就能解决，这种题还是很好想到mapping（哈希表）的； 第四题：感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了； 第一题：5989.元素计数题目链接 题目大意给你一个整数数组 nums ，统计并返回在 nums 中同时具有一个严格较小元素和一个严格较大元素的元素数目。 示例1： 12345输入：nums = [11,7,2,15]输出：2解释：元素 7 ：严格较小元素是元素 2 ，严格较大元素是元素 11 。元素 11 ：严格较小元素是元素 7 ，严格较大元素是元素 15 。总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。 示例2： 1234输入：nums = [-3,3,3,90]输出：2解释：元素 3 ：严格较小元素是元素 -3 ，严格较大元素是元素 90 。由于有两个元素的值为 3 ，总计有 2 个元素都满足在 nums 中同时存在一个严格较小元素和一个严格较大元素。 提示： 1 &lt;= nums.length &lt;= 100 -105 &lt;= nums[i] &lt;= 105 分析和解答排个序后和最大最小比就行了，这个内容还是挺隐含的，如果能看出来是和最大最小比就很简单了 12345678910111213class Solution(object): def countElements(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; cnt = 0 nums.sort() for i in range(1, len(nums)-1): if nums[i] &gt; nums[0] and nums[-1] &gt; nums[i]: cnt += 1 return cnt 第二题：5991.按符号重排数组题目链接 题目大意给你一个下标从 0 开始的整数数组 nums ，数组长度为 偶数 ，由数目相等的正整数和负整数组成。 你需要 重排 nums 中的元素，使修改后的数组满足下述条件： 任意 连续 的两个整数 符号相反 对于符号相同的所有整数，保留 它们在 nums 中的 顺序 。 重排后数组以正整数开头。 重排元素满足上述条件后，返回修改后的数组。 示例1： 123456输入：nums = [3,1,-2,-5,2,-4]输出：[3,-2,1,-5,2,-4]解释：nums 中的正整数是 [3,1,2] ，负整数是 [-2,-5,-4] 。重排的唯一可行方案是 [3,-2,1,-5,2,-4]，能满足所有条件。像 [1,-2,2,-5,3,-4]、[3,1,2,-2,-5,-4]、[-2,3,-5,1,-4,2] 这样的其他方案是不正确的，因为不满足一个或者多个条件。 示例2： 12345输入：nums = [-1,1]输出：[1,-1]解释：1 是 nums 中唯一一个正整数，-1 是 nums 中唯一一个负整数。所以 nums 重排为 [1,-1] 。 提示： 2 &lt;= nums.length &lt;= 2 * 105 nums.length 是 偶数 1 &lt;= |nums[i]| &lt;= 105 nums 由 相等 数量的正整数和负整数组成 分析和解答自己使用的是比较简单的解法，因为是周赛就不在继续想更加复杂的解法了，拆成两个数组就行了 12345678910111213141516171819class Solution(object): def rearrangeArray(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; result = [] nums_positive = [] nums_negative = [] for i in range(len(nums)): if nums[i] &gt; 0: nums_positive.append(nums[i]) else: nums_negative.append(nums[i]) for i in range(len(nums_positive)): result.append(nums_positive[i]) result.append(nums_negative[i]) return result 第三题：5990.找出数组中的所有孤独数字题目链接 题目大意给你一个整数数组 nums 。如果数字 x 在数组中仅出现 一次 ，且没有 相邻 数字（即，x + 1 和 x - 1）出现在数组中，则认为数字 x 是 孤独数字 。 返回 nums 中的 所有 孤独数字。你可以按 任何顺序 返回答案。 示例1： 12345678输入：nums = [10,6,5,8]输出：[10,8]解释：- 10 是一个孤独数字，因为它只出现一次，并且 9 和 11 没有在 nums 中出现。- 8 是一个孤独数字，因为它只出现一次，并且 7 和 9 没有在 nums 中出现。- 5 不是一个孤独数字，因为 6 出现在 nums 中，反之亦然。因此，nums 中的孤独数字是 [10, 8] 。注意，也可以返回 [8, 10] 。 示例2： 12345678输入：nums = [1,3,5,3]输出：[1,5]解释：- 1 是一个孤独数字，因为它只出现一次，并且 0 和 2 没有在 nums 中出现。- 5 是一个孤独数字，因为它只出现一次，并且 4 和 6 没有在 nums 中出现。- 3 不是一个孤独数字，因为它出现两次。因此，nums 中的孤独数字是 [1, 5] 。注意，也可以返回 [5, 1] 。 提示： 1 &lt;= nums.length &lt;= 105 0 &lt;= nums[i] &lt;= 106 分析和解答mapping就能解决，这种题还是很好想到mapping（哈希表）的；也或许题目中的任何顺序暗示了可以排序和mapping做吧 1234567891011121314151617181920class Solution(object): def findLonely(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[int] &quot;&quot;&quot; result = [] mappings = &#123;&#125; for i in range(len(nums)): if mappings.get(nums[i]) is None: mappings[nums[i]] = 1 else: mappings[nums[i]] += 1 for key, value in mappings.items(): # 把孤独的加进来，用key if value &lt; 2 and mappings.get(key-1) is None and mappings.get(key+1) is None: result.append(key) return result 第四题：5992.基于陈述统计最多好人数题目链接 题目大意戏中存在两种角色： 好人：该角色只说真话。 坏人：该角色可能说真话，也可能说假话。 给你一个下标从 0 开始的二维整数数组 statements ，大小为 n x n ，表示 n 个玩家对彼此角色的陈述。具体来说，statements[i][j] 可以是下述值之一： 0 表示 i 的陈述认为 j 是 坏人 。 1 表示 i 的陈述认为 j 是 好人 。 2 表示 i 没有对 j 作出陈述。 另外，玩家不会对自己进行陈述。形式上，对所有 0 &lt;= i &lt; n ，都有 statements[i][i] = 2 。 根据这 n 个玩家的陈述，返回可以认为是 好人 的 最大 数目。 示例1： 1234567891011121314151617181920212223输入：statements = [[2,1,2],[1,2,2],[2,0,2]]输出：2解释：每个人都做一条陈述。- 0 认为 1 是好人。- 1 认为 0 是好人。- 2 认为 1 是坏人。以 2 为突破点。- 假设 2 是一个好人： - 基于 2 的陈述，1 是坏人。 - 那么可以确认 1 是坏人，2 是好人。 - 基于 1 的陈述，由于 1 是坏人，那么他在陈述时可能： - 说真话。在这种情况下会出现矛盾，所以假设无效。 - 说假话。在这种情况下，0 也是坏人并且在陈述时说假话。 - 在认为 2 是好人的情况下，这组玩家中只有一个好人。- 假设 2 是一个坏人： - 基于 2 的陈述，由于 2 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 2 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 由于 1 是好人，0 也是好人。 - 在认为 2 是坏人且说假话的情况下，这组玩家中有两个好人。在最佳情况下，至多有两个好人，所以返回 2 。注意，能得到此结论的方法不止一种。 示例2： 1234567891011121314151617输入：statements = [[2,0],[0,2]]输出：1解释：每个人都做一条陈述。- 0 认为 1 是坏人。- 1 认为 0 是坏人。以 0 为突破点。- 假设 0 是一个好人： - 基于与 0 的陈述，1 是坏人并说假话。 - 在认为 0 是好人的情况下，这组玩家中只有一个好人。- 假设 0 是一个坏人： - 基于 0 的陈述，由于 0 是坏人，那么他在陈述时可能： - 说真话。在这种情况下，0 和 1 都是坏人。 - 在认为 0 是坏人但说真话的情况下，这组玩家中没有一个好人。 - 说假话。在这种情况下，1 是好人。 - 在认为 0 是坏人且说假话的情况下，这组玩家中只有一个好人。在最佳情况下，至多有一个好人，所以返回 1 。 注意，能得到此结论的方法不止一种。 提示： n == statements.length == statements[i].length 2 &lt;= n &lt;= 15 statements[i][j] 的值为 0、1 或 2 statements[i][i] == 2 分析和解答感谢大佬们的帮助hh，看到题目条件的数据范围只有15，所以可以2^15次方这个数量级的二进制暴力来做，需要注意的附加条件是只需要判断假定所有说真话的人是否和条件有冲突就可以了 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def maximumGood(self, statements): &quot;&quot;&quot; :type statements: List[List[int]] :rtype: int &quot;&quot;&quot; max_good_people = 0 n = len(statements) def judge(state, statements): for i in range(len(state)): if state[i] == 1: # 只判断是好人的情况 for j in range(n): if i == j: continue if statements[i][j] == 2: continue if statements[i][j] != state[j]: return False return True # 学到了，2^n种状态，用位运算遍历 for i in range((2 ** n) - 1, -1, -1): now_good = 0 tmp = i state = [0 for i in range(n)] cnt = 0 while tmp &gt; 0: state[cnt] = tmp &amp; 1 if state[cnt] == 1: now_good += 1 tmp &gt;&gt;= 1 cnt += 1 flag = judge(state, statements) if flag: max_good_people = max(max_good_people, now_good) return max_good_people","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"}]},{"title":"70场LeetCode双周赛","slug":"algorithms/leetcode-weekly-contest/70场LeetCode双周赛","date":"2022-01-22T16:33:04.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/01/23/algorithms/leetcode-weekly-contest/70场LeetCode双周赛/","link":"","permalink":"http://example.com/2022/01/23/algorithms/leetcode-weekly-contest/70%E5%9C%BALeetCode%E5%8F%8C%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 不常做双周赛的题目hhh，这次的bfs走迷宫一类的题目还是让人印象很深的，简单的dfs bfs模板还是要熟练些，这种题还是比全排列的那种深度优先更让人好理解一些； 第一题：贪心就可以，排个序后每买两个不买一个； 第二题：这个隐藏数组题目在时间复杂度上还是被坑了一下的，如果不看示例自己在TLE后能不能想到还是个问题，对于首位序列lower upper的问题，从示例总结出来的“对齐”思路很关键； 第三题：一个标准的bfs题目模板，题目给的排序约束条件既可以按照自己的方法先都走完后再拿出来排，也可能可以作为优先队列的约束条件，还要注意题目的step其实暗示了bfs而不是dfs； 第四题：咕咕咕","text":"周赛综述&amp;总结： 不常做双周赛的题目hhh，这次的bfs走迷宫一类的题目还是让人印象很深的，简单的dfs bfs模板还是要熟练些，这种题还是比全排列的那种深度优先更让人好理解一些； 第一题：贪心就可以，排个序后每买两个不买一个； 第二题：这个隐藏数组题目在时间复杂度上还是被坑了一下的，如果不看示例自己在TLE后能不能想到还是个问题，对于首位序列lower upper的问题，从示例总结出来的“对齐”思路很关键； 第三题：一个标准的bfs题目模板，题目给的排序约束条件既可以按照自己的方法先都走完后再拿出来排，也可能可以作为优先队列的约束条件，还要注意题目的step其实暗示了bfs而不是dfs； 第四题：咕咕咕 第一题：5971.打折购买糖果的最小开销题目链接 题目大意一家商店正在打折销售糖果。每购买 两个 糖果，商店会 免费 送一个糖果。 免费送的糖果唯一的限制是：它的价格需要小于等于购买的两个糖果价格的 较小值 。 比方说，总共有4个糖果，价格分别为1，2，3和4，一位顾客买了价格为2和3的糖果，那么他可以免费获得价格为1的糖果，但不能获得价格为4的糖果。 给你一个下标从 0 开始的整数数组cost，其中cost[i]表示第i个糖果的价格，请你返回获得 所有 糖果的 最小 总开销。 示例1： 123456输入：cost = [1,2,3]输出：5解释：我们购买价格为 2 和 3 的糖果，然后免费获得价格为 1 的糖果。总开销为 2 + 3 = 5 。这是开销最小的 唯一 方案。注意，我们不能购买价格为 1 和 3 的糖果，并免费获得价格为 2 的糖果。这是因为免费糖果的价格必须小于等于购买的 2 个糖果价格的较小值。 示例2： 12345678输入：cost = [6,5,7,9,2,2]输出：23解释：最小总开销购买糖果方案为：- 购买价格为 9 和 7 的糖果- 免费获得价格为 6 的糖果- 购买价格为 5 和 2 的糖果- 免费获得价格为 2 的最后一个糖果因此，最小总开销为 9 + 7 + 5 + 2 = 23 。 示例3： 1234输入：cost = [5,5]输出：10解释：由于只有 2 个糖果，我们需要将它们都购买，而且没有免费糖果。所以总最小开销为 5 + 5 = 10 。 提示： 1 &lt;= cost.length &lt;= 100 1 &lt;= cost[i] &lt;= 100 分析和解答贪！ 排序后贪心就可以了，记得写的时候对于这个continue的位置还纠结了下，不过复盘来说应该会有不少种写法的 12345678910111213141516class Solution(object): def minimumCost(self, cost): &quot;&quot;&quot; :type cost: List[int] :rtype: int &quot;&quot;&quot; cost = sorted(cost, key=lambda x: -x) cnt = 0 result = 0 for i in range(len(cost)): if cnt != 0 and cnt % 2 == 0: cnt = 0 continue result += cost[i] cnt += 1 return result 第二题：5972.统计隐藏数组数目题目链接 题目大意给你一个下标从 0 开始且长度为 n 的整数数组 differences ，它表示一个长度为 n + 1 的 隐藏 数组 相邻 元素之间的 差值 。更正式的表述为：我们将隐藏数组记作 hidden ，那么 differences[i] = hidden[i + 1] - hidden[i] 。 同时给你两个整数 lower 和 upper ，它们表示隐藏数组中所有数字的值都在 闭 区间 [lower, upper] 之间。 比方说，differences = [1, -3, 4] ，lower = 1 ，upper = 6 ，那么隐藏数组是一个长度为 4 且所有值都在 1 和 6 （包含两者）之间的数组。 [3, 4, 1, 5] 和 [4, 5, 2, 6] 都是符合要求的隐藏数组。 [5, 6, 3, 7] 不符合要求，因为它包含大于 6 的元素。 [1, 2, 3, 4] 不符合要求，因为相邻元素的差值不符合给定数据。 请你返回 符合 要求的隐藏数组的数目。如果没有符合要求的隐藏数组，请返回 0 。 示例1： 123456输入：differences = [1,-3,4], lower = 1, upper = 6输出：2解释：符合要求的隐藏数组为：- [3, 4, 1, 5]- [4, 5, 2, 6]所以返回 2 。 示例2： 12345678输入：differences = [3,-4,5,1,-2], lower = -4, upper = 5输出：4解释：符合要求的隐藏数组为：- [-3, 0, -4, 1, 2, 0]- [-2, 1, -3, 2, 3, 1]- [-1, 2, -2, 3, 4, 2]- [0, 3, -1, 4, 5, 3]所以返回 4 。 示例3： 123输入：differences = [4,-7,2], lower = 3, upper = 6输出：0解释：没有符合要求的隐藏数组，所以返回 0 。 提示： n == differences.length 1 &lt;= n &lt;= 105 -105 &lt;= differences[i] &lt;= 105 -105 &lt;= lower &lt;= upper &lt;= 105 分析和解答这个题开始想到的是一种从lower开始全部遍历的策略，但是很容易的就超时了，后来从示例2发现可以使用一种“数学”方法，复盘认为最关键的内容就是要使用一种“对齐”的思想，这样就避免了把两边的情况都考虑上，只考虑一边就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def numberOfArrays(self, differences, lower, upper): &quot;&quot;&quot; :type differences: List[int] :type lower: int :type upper: int :rtype: int &quot;&quot;&quot; &quot;&quot;&quot; # 看了一个示例后，感觉只算一遍，然后算一个max low就可以了吧 result = 0 for start_idx in range(lower, upper+1): tmp_start_idx = start_idx flag = True for i in range(len(differences)): tmp_start_idx += differences[i] if not (tmp_start_idx &lt;= upper and tmp_start_idx &gt;= lower): flag = False break if flag: result += 1 return result &quot;&quot;&quot; result = 0 tmp_start_idx = lower seq_max = lower seq_min = lower for i in range(len(differences)): tmp_start_idx += differences[i] seq_max = max(seq_max, tmp_start_idx) seq_min = min(seq_min, tmp_start_idx)# print(&quot;seq_max: &quot;, seq_max)# print(&quot;seq_min: &quot;, seq_min) d1 = upper - seq_max d2 = seq_min - lower # 3种情况 seq_max = seq_max + (lower - seq_min) seq_min = lower # print(&quot;seq_max: &quot;, seq_max) # print(&quot;seq_min: &quot;, seq_min) return max(0, upper - seq_max + 1) 第三题：5973.价格范围内最高排名的 K 样物品题目链接 题目大意给你一个下标从 0 开始的二维整数数组 grid ，它的大小为 m x n ，表示一个商店中物品的分布图。数组中的整数含义为： 0 表示无法穿越的一堵墙。 1 表示可以自由通过的一个空格子。 所有其他正整数表示该格子内的一样物品的价格。你可以自由经过这些格子。 从一个格子走到上下左右相邻格子花费 1 步。 同时给你一个整数数组 pricing 和 start ，其中 pricing = [low, high] 且 start = [row, col] ，表示你开始位置为 (row, col) ，同时你只对物品价格在 闭区间 [low, high] 之内的物品感兴趣。同时给你一个整数 k 。 你想知道给定范围 内 且 排名最高 的 k 件物品的 位置 。排名按照优先级从高到低的以下规则制定： 距离：定义为从 start 到一件物品的最短路径需要的步数（较近 距离的排名更高）。 价格：较低 价格的物品有更高优先级，但只考虑在给定范围之内的价格。 行坐标：较小 行坐标的有更高优先级。 列坐标：较小 列坐标的有更高优先级。 请你返回给定价格内排名最高的 k 件物品的坐标，将它们按照排名排序后返回。如果给定价格内少于 k 件物品，那么请将它们的坐标 全部 返回。 分析和解答bfs的一个基础模板题，在写的时候先用了dfs结果超时了。复盘分析为什么使用bfs的原因，bfs可以保证每个地方step是一定递增1的，而不像dfs可能一个位置有多种走法。 后来看题解来说这个题实际上背后可能隐藏的是优先队列的思路，但是这块的内容确实还不太熟悉，什么时候先复习下大根堆小根堆的内容吧，滑动窗口那道hard题 bfs正确题解代码49/491234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def highestRankedKItems(self, grid, pricing, start, k): &quot;&quot;&quot; :type grid: List[List[int]] :type pricing: List[int] :type start: List[int] :type k: int :rtype: List[List[int]] &quot;&quot;&quot; # 过一个异常处理 if len(grid) == 0: return [] # 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了 m = len(grid) n = len(grid[0]) vis = [[0 for _ in range(n)] for _ in range(m)] dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] x = start[0] y = start[1] vis[x][y] = 1 bfs_queue = [] bfs_queue.append([x, y, 0, grid[x][y]]) result = [] # 使用bfs的思路 while len(bfs_queue) != 0: # 取队头并pop now_x, now_y, now_step, now_value = bfs_queue[0][0], bfs_queue[0][1], bfs_queue[0][2], bfs_queue[0][3] if now_value &gt;= pricing[0] and now_value &lt;= pricing[1]: result.append(bfs_queue[0]) bfs_queue = bfs_queue[1:] # 把四个方向满足条件的加入到队列中 for i in range(4): nx = now_x + dx[i] ny = now_y + dy[i] if nx &gt;= 0 and nx &lt; m and ny &gt;= 0 and ny &lt; n and grid[nx][ny] != 0 and vis[nx][ny] == 0: vis[nx][ny] = 1 bfs_queue.append([nx, ny, now_step+1, grid[nx][ny]]) # dfs(x, y, 0) result.sort(key=lambda x: (x[2], x[3], x[0], x[1])) if len(result) &gt; k: return [[result[x][0], result[x][1]] for x in range(k)] else: return [[x[0], x[1]] for x in result] dfs超时版本题解代码15/4912345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution(object): def highestRankedKItems(self, grid, pricing, start, k): &quot;&quot;&quot; :type grid: List[List[int]] :type pricing: List[int] :type start: List[int] :type k: int :rtype: List[List[int]] &quot;&quot;&quot; # 过一个异常处理 if len(grid) == 0: return [] # 一眼看过去很像dfs啊，d就完事了，会不会超时之后再说了 m = len(grid) n = len(grid[0]) vis = [[0 for _ in range(n)] for _ in range(m)] dx = [0, 1, 0, -1] dy = [1, 0, -1, 0] x = start[0] y = start[1] vis[x][y] = 1 result = [] mappings = &#123;&#125; def dfs(x, y, step): if grid[x][y] &lt;= pricing[1] and grid[x][y] &gt;= pricing[0]: if mappings.get((x, y)) is None: mappings[(x, y)] = [step, grid[x][y]] else: tmp_list = mappings[(x, y)] if step &lt; tmp_list[0]: mappings[(x, y)] = [step, grid[x][y]] for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx &gt;= 0 and nx &lt; m and ny &gt;=0 and ny &lt; n and grid[nx][ny] != 0 and vis[nx][ny] == 0: vis[nx][ny] = 1 dfs(nx, ny, step+1) vis[nx][ny] = 0 dfs(x, y, 0) for key, value in mappings.items(): result.append([key[0], key[1], value[0], value[1]]) result.sort(key=lambda x: (x[2], x[3], x[0], x[1])) # print(result) if len(result) &gt; k: return [[result[x][0], result[x][1]] for x in range(k)] else: return [[x[0], x[1]] for x in result]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"}]},{"title":"219.存在重复元素II-python","slug":"algorithms/leetcode-python/219-存在重复元素II-python","date":"2022-01-19T16:20:28.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2022/01/20/algorithms/leetcode-python/219-存在重复元素II-python/","link":"","permalink":"http://example.com/2022/01/20/algorithms/leetcode-python/219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II-python/","excerpt":"219.存在重复元素II（简单） 题目大意： 给你一个整数数组nums和一个整数k，判断数组中是否存在两个不同的索引i和j，满足nums[i] == nums[j]且abs(i - j) &lt;= k。如果存在，返回true；否则，返回false。","text":"219.存在重复元素II（简单） 题目大意： 给你一个整数数组nums和一个整数k，判断数组中是否存在两个不同的索引i和j，满足nums[i] == nums[j]且abs(i - j) &lt;= k。如果存在，返回true；否则，返回false。 题目题目链接 题目大意： 给你一个整数数组nums和一个整数k，判断数组中是否存在两个不同的索引i和j，满足nums[i] == nums[j]且abs(i - j) &lt;= k。如果存在，返回true；否则，返回false。 示例1： 12输入：nums = [1,2,3,1], k = 3输出：true 示例2： 12输入：nums = [1,0,1,1], k = 1输出：true 示例3： 12输入：nums = [1,2,3,1,2,3], k = 2输出：false 提示： 1 &lt;= nums.length &lt;= 105 -109 &lt;= nums[i] &lt;= 109 0 &lt;= k &lt;= 105 分析和解答用一个字典判断就行，这样每次更新最后出现的状态，O(n)时间复杂度 123456789101112131415class Solution(object): def containsNearbyDuplicate(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: bool &quot;&quot;&quot; temp_dict = &#123;&#125; for i in range(len(nums)): if temp_dict.get(nums[i]) is not None: if i - temp_dict.get(nums[i]) &lt;= k: return True temp_dict[nums[i]] = i # 每次强制更新为最后的，这样方便找最近的 return False","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"160.相交链表-python","slug":"algorithms/leetcode-python/160-相交链表-python","date":"2022-01-17T07:57:26.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/01/17/algorithms/leetcode-python/160-相交链表-python/","link":"","permalink":"http://example.com/2022/01/17/algorithms/leetcode-python/160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-python/","excerpt":"160.相交链表（简单） 题目大意： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？","text":"160.相交链表（简单） 题目大意： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？ 题目题目链接 给你两个单链表的头节点headA和headB，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回null。 图示两个链表在节点c1开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 自定义评测： 评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为0 listA - 第一个链表 listB - 第二个链表 skipA - 在listA中（从头节点开始）跳到交叉节点的节点数 skipB - 在listB中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。 示例1： 12345输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at &#x27;8&#x27;解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例2： 12345输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at &#x27;2&#x27;解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例3： 12345输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 提示： listA中节点数目为m listB中节点数目为n 1 &lt;= m, n &lt;= 3 * 104 1 &lt;= Node.val &lt;= 105 0 &lt;= skipA &lt;= m 0 &lt;= skipB &lt;= n 如果listA和listB没有交点，intersectVal为0 如果listA和listB有交点，intersectVal == listA[skipA] == listB[skipB] 分析和解答这个题在面试的时候曾经被问过，判断两个链表是否有交有很多种方法，如果只是判断是否有交的话，最简单的方法就是两个链表都分别走到结尾处，如果结尾处是一样的，那么就判断两个链表在之前一定有交了； 这个题要求判断并找到两个链表相交的位置，一种非常简单的思路是把每个地方都存到一个字典里，这样找一下就行了，但是题目的附加要求是O(1)的时间复杂度，所以说不能这么做； 下边这个图也是看了题解后才明白的，这样最多走a+b这个长度的次数，两个走的长度是一样的，如果有交集则必定能相交！ 123456789101112131415161718192021222324class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; if headA is None or headB is None: return None # 循环结束的两种条件，一种是pq交到一个位置了，另外一种就是pq都是null，所以都是 # 只走一遍就可以了，a+b的长度 p = headA q = headB while p != q: if p is None: p = headB else: p = p.next if q is None: q = headA else: q = q.next return p 复习单链表的一个写法 1234class ListNode(object): def __init__(self, val=0, next=None): self.val = val self.next = next","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"}]},{"title":"136.只出现一次的数字-python","slug":"algorithms/leetcode-python/136-只出现一次的数字-python","date":"2022-01-17T03:26:58.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/01/17/algorithms/leetcode-python/136-只出现一次的数字-python/","link":"","permalink":"http://example.com/2022/01/17/algorithms/leetcode-python/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-python/","excerpt":"136.只出现一次的数字（简单） 题目大意： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？","text":"136.只出现一次的数字（简单） 题目大意： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 题目题目链接 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例1： 12输入: [2,2,1]输出: 1 示例2： 12输入: [4,1,2,1,2]输出: 4 题目分析和解答简单的位运算题目，因为题目说了其余每个元素都出现了两次，所以用xor就行了，真值表上异是1，同是0 1234567891011class Solution(object): def singleNumber(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; return_num = nums[0] for i in range(1, len(nums)): return_num ^= nums[i] # 异或 return return_num","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"104.二叉树的最大深度-python","slug":"algorithms/leetcode-python/104-二叉树的最大深度-python","date":"2022-01-16T15:43:31.000Z","updated":"2022-11-20T01:50:08.881Z","comments":true,"path":"2022/01/16/algorithms/leetcode-python/104-二叉树的最大深度-python/","link":"","permalink":"http://example.com/2022/01/16/algorithms/leetcode-python/104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-python/","excerpt":"104.二叉树的最大深度（简单） 题目大意： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。","text":"104.二叉树的最大深度（简单） 题目大意： 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 题目题目链接 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树[3,9,20,null,null,15,7]， 12345 3 / \\9 20 / \\ 15 7 返回它的最大深度3。 题目分析和解答这个题是一个典型的”自递归“系列的题目，首先复习一下树节点的写法（建议每个二叉树的题目都复习一下） 12345class TreeNode(object): def __init__(self, val=-1, left=None, right=None): self.val = val self.left = left self.right = right 复习Solution的写法和题解，注意这个maxDepth函数，他的返回值是一个int，代表直接调用这个函数就要得到最终答案的depth返回值，所以感觉是一个自递归的题目了，这种的递归dfs还是很好写的 12345678910class Solution(object): def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if root is None: return 0 else: return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"275场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/275场LeetCode周赛","date":"2022-01-16T13:20:42.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/01/16/algorithms/leetcode-weekly-contest/275场LeetCode周赛/","link":"","permalink":"http://example.com/2022/01/16/algorithms/leetcode-weekly-contest/275%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 前两个题实际上说感觉还没有那么容易想，第三个题的话感觉简化的思路是需要复盘梳理的，另外只能说Counter永远的神哈哈哈哈 第一题：这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用matrix[i]，而取矩阵的某一列没有什么很好的思路，可以用[matrix[x][j] for x in range(n)]，这里的j代表第j列； 第二题：比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可； 第三题：只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set/dict/Counter中，这样可以O(1)的判断是否存在； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 前两个题实际上说感觉还没有那么容易想，第三个题的话感觉简化的思路是需要复盘梳理的，另外只能说Counter永远的神哈哈哈哈 第一题：这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用matrix[i]，而取矩阵的某一列没有什么很好的思路，可以用[matrix[x][j] for x in range(n)]，这里的j代表第j列； 第二题：比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可； 第三题：只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set/dict/Counter中，这样可以O(1)的判断是否存在； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：2133.检查是否每一行每一列都包含全部整数题目链接 题目大意对一个大小为n x n的矩阵而言，如果其每一行和每一列都包含从1到n的全部整数（含1和n），则认为该矩阵是一个有效矩阵。 给你一个大小为n x n的整数矩阵matrix，请你判断矩阵是否为一个有效矩阵：如果是，返回true；否则，返回false。 示例1： 1234输入：matrix = [[1,2,3],[3,1,2],[2,3,1]]输出：true解释：在此例中，n = 3 ，每一行和每一列都包含数字 1、2、3 。因此，返回 true 。 示例2： 1234输入：matrix = [[1,1,1],[1,2,3],[1,2,3]]输出：false解释：在此例中，n = 3 ，但第一行和第一列不包含数字 2 和 3 。因此，返回 false 。 提示： n == matrix.length == matrix[i].length 1 &lt;= n &lt;= 100 1 &lt;= matrix[i][j] &lt;= n 分析和解答这个题开始想法是把每个位置都遍历判断一下，但这样搞就超时了，后来发现只判断对角线就可以了，这里还有个思路是取矩阵的某一行可以用matrix[i]，而取矩阵的某一列没有什么很好的思路，可以用[matrix[x][j] for x in range(n)]，这里的j代表第j列； 12345678910111213141516171819202122232425262728293031class Solution(object): def checkValid(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: bool &quot;&quot;&quot; &quot;&quot;&quot; # tle n = len(matrix) target = [i+1 for i in range(n)] target_count = Counter(target) for i in range(n): for j in range(n): tmp_counter1 = Counter(matrix[i]) tmp_counter2 = Counter([matrix[x][j] for x in range(n)]) if not (tmp_counter1 == target_count and tmp_counter2 == target_count): return False return True &quot;&quot;&quot; # 只判断对角线就够了？ n = len(matrix) target = [i+1 for i in range(n)] target_count = Counter(target) for i in range(n): tmp_counter1 = Counter(matrix[i]) tmp_counter2 = Counter([matrix[x][i] for x in range(n)]) if not (tmp_counter1 == target_count and tmp_counter2 == target_count): return False return True 第二题：2134.最少交换次数来组合所有的1 II题目链接 题目大意交换定义为选中一个数组中的两个互不相同的位置并交换二者的值。 环形数组是一个数组，可以认为第一个元素和最后一个元素相邻。 给你一个二进制环形数组nums，返回在任意位置将数组中的所有1聚集在一起需要的最少交换次数。 示例1： 12345678输入：nums = [0,1,0,1,1,0,0]输出：1解释：这里列出一些能够将所有 1 聚集在一起的方案：[0,0,1,1,1,0,0] 交换 1 次。[0,1,1,1,0,0,0] 交换 1 次。[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。因此，需要的最少交换次数为 1 。 示例2： 1234567输入：nums = [0,1,1,1,0,0,1,1,0]输出：2解释：这里列出一些能够将所有 1 聚集在一起的方案：[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。[1,1,1,1,1,0,0,0,0] 交换 2 次。无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。因此，需要的最少交换次数为 2 。 示例3： 1234输入：nums = [1,1,0,0,1]输出：0解释：得益于数组的环形特性，所有的 1 已经聚集在一起。因此，需要的最少交换次数为 0 。 提示： 1 &lt;= nums.length &lt;= 105 nums[i]为0或者1 分析和解答比较思路题的感觉，用一个滑动窗口存储最终状态，当前状态和最终状态的差距就是move的次数，另外有个需要注意的是，滑动窗口的尾部角标是i+k（或者i+k-1一类的），这个题也是能体现出Counter的好用，但是Counter在使用的时候时间复杂度貌似比较高，注意每次不要都生成新的Counter，只要根据首尾位置修改即可； 另外注意，这种环形的可以通过补充在最后边来进行简易的实现，取模的思路有点麻烦了，python语言还有其专门使用的extend函数； 1234567891011121314151617181920212223242526272829class Solution(object): def minSwaps(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; # 处理出一个初始化的目标状态 target_counter = Counter(nums) del target_counter[0] cnt = 0 for i in range(target_counter[1]): nums.append(nums[cnt]) cnt += 1 min_swaps = target_counter[1] init_counter = Counter(nums[0: (target_counter[1])]) min_swaps = min(min_swaps, (init_counter-target_counter)[0]) # print(init_counter) for i in range(1, len(nums)-target_counter[1]+1): init_counter -= Counter([nums[i-1]]) init_counter += Counter([nums[i+target_counter[1]-1]]) # print(init_counter) min_swaps = min(min_swaps, (init_counter-target_counter)[0]) return min_swaps 第三题：2135.统计追加字母可以获得的单词数题目链接 题目大意给你两个下标从0开始的字符串数组startWords和targetWords。每个字符串都仅由小写英文字母组成。 对于targetWords中的每个字符串，检查是否能够从 startWords 中选出一个字符串，执行一次转换操作，得到的结果与当前targetWords字符串相等。 转换操作如下面两步所述： 追加任何 不存在 于当前字符串的任一小写字母到当前字符串的末尾。 例如，如果字符串为&quot;abc&quot;，那么字母&#39;d&#39;、&#39;e&#39;或&#39;y&#39;都可以加到该字符串末尾，但&#39;a&#39;就不行。如果追加的是&#39;d&#39;，那么结果字符串为&quot;abcd&quot;。 重排新字符串中的字母，可以按任意顺序重新排布字母。 例如，&quot;abcd&quot;可以重排为&quot;acbd&quot;、&quot;bacd&quot;、&quot;cbda&quot;，以此类推。注意，它也可以重排为&quot;abcd&quot;自身。 找出targetWords中有多少字符串能够由startWords中的任一字符串执行上述转换操作获得。返回targetWords中这类字符串的数目。 注意：你仅能验证targetWords中的字符串是否可以由startWords中的某个字符串经执行操作获得。startWords中的字符串在这一过程中 不 发生实际变更。 分析和解答只能说是非常妙的一个题，普通搞的话很容易超时，于是可以将每个单词的字母排序后放入到一个set/dict/Counter中，这样可以O(1)的判断是否存在； 其中感觉也有用到一种反向的思维，目标单词是startWord加上一个字母，所以startWord是目标单词减去一个字母，这样的话可能更容易想到是用一个set/dict/Counter来进行查找了； 还是很值得复盘的一个题目，感觉字母排序也是一个需要复盘的点； TLE超时版本代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution(object): def wordCount(self, startWords, targetWords): &quot;&quot;&quot; :type startWords: List[str] :type targetWords: List[str] :rtype: int &quot;&quot;&quot; &quot;&quot;&quot; # TLE result_cnt = 0 none_counter = Counter(&quot;&quot;) counter_start_words = [Counter(x) for x in startWords] counter_target_words = [Counter(x) for x in targetWords] for i in range(len(counter_target_words)): flag = 0 for j in range(len(counter_start_words)): # 剪枝 if len(targetWords[i]) - len(counter_start_words[j]) != 1: continue if len([key for key in (counter_start_words[j] - counter_target_words[i]).keys()]) != 0: continue tmp_counter = counter_target_words[i] - counter_start_words[j] # 必须只有一个键，且这个键值为1，且这个不出现在原来的counter_target_words[i]中 key_list = [key for key in tmp_counter.keys()] if len(key_list) == 1 and tmp_counter[key_list[0]] == 1 and counter_start_words[j].get(key_list[0]) is None: flag = 1 break if flag == 1: result_cnt += 1 return result_cnt &quot;&quot;&quot; set_start_words = [set(x) for x in startWords] set_target_words = [set(x) for x in targetWords] result_cnt = 0 for i in range(len(targetWords)): for j in range(len(startWords)): if len(targetWords[i]) - len(startWords[j]) != 1: continue if len(list(set_target_words[i].symmetric_difference(set_start_words[j]))) == 1: print(set_target_words[i], set_start_words[j]) result_cnt += 1 break return result_cnt 修改后的不超时代码： 12345678910111213141516171819class Solution(object): def wordCount(self, startWords, targetWords): &quot;&quot;&quot; :type startWords: List[str] :type targetWords: List[str] :rtype: int &quot;&quot;&quot; set_start_words = set([&quot;&quot;.join(sorted(list(startWord))) for startWord in startWords]) sorted_target_words = [&quot;&quot;.join(sorted(list(targetWord))) for targetWord in targetWords] counter_sorted_target_words = Counter(sorted_target_words) cnt = 0 for targetWord, value in counter_sorted_target_words.items(): for i in range(len(targetWord)): tmp_s = targetWord[:i] + targetWord[i+1:] if tmp_s in set_start_words: cnt += value break return cnt","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"276场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/276场LeetCode周赛","date":"2022-01-16T09:27:04.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/01/16/algorithms/leetcode-weekly-contest/276场LeetCode周赛/","link":"","permalink":"http://example.com/2022/01/16/algorithms/leetcode-weekly-contest/276%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 前两题难度还是比较低的，第三题的话感觉dp这个思路还值得复盘研究一下，常见的一维dp数组感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值； 第一题：简单字符串模拟，有一些mod的使用，熟练度的题目； 第二题：从大到小贪心就行了，最后一次直接 += target - 1； 第三题：一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用max()而TLE，所以在优化方向上应该也找到后边一种思路的优化方向； 第四题：未来有机会再试了TAT（周常鸽第四题）；","text":"周赛综述&amp;总结： 前两题难度还是比较低的，第三题的话感觉dp这个思路还值得复盘研究一下，常见的一维dp数组感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值； 第一题：简单字符串模拟，有一些mod的使用，熟练度的题目； 第二题：从大到小贪心就行了，最后一次直接 += target - 1； 第三题：一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用max()而TLE，所以在优化方向上应该也找到后边一种思路的优化方向； 第四题：未来有机会再试了TAT（周常鸽第四题）； 第一题：5980.将字符串拆分为若干长度为k的组题目链接 题目大意字符串s可以按下述步骤划分为若干长度为k的组： 第一组由字符串中的前k个字符组成，第二组由接下来的k个字符串组成，依此类推。每个字符都能够成为某一个组的一部分。 对于最后一组，如果字符串剩下的字符不足k个，需使用字符fill来补全这一组字符。 注意，在去除最后一个组的填充字符fill（如果存在的话）并按顺序连接所有的组后，所得到的字符串应该是s。 给你一个字符串s，以及每组的长度k和一个用于填充的字符fill，按上述步骤处理之后，返回一个字符串数组，该数组表示s分组后每个组的组成情况。 示例1： 12345678输入：s = &quot;abcdefghi&quot;, k = 3, fill = &quot;x&quot;输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;]解释：前 3 个字符是 &quot;abc&quot; ，形成第一组。接下来 3 个字符是 &quot;def&quot; ，形成第二组。最后 3 个字符是 &quot;ghi&quot; ，形成第三组。由于所有组都可以由字符串中的字符完全填充，所以不需要使用填充字符。因此，形成 3 组，分别是 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。 示例2： 123456输入：s = &quot;abcdefghij&quot;, k = 3, fill = &quot;x&quot;输出：[&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jxx&quot;]解释：与前一个例子类似，形成前三组 &quot;abc&quot;、&quot;def&quot; 和 &quot;ghi&quot; 。对于最后一组，字符串中仅剩下字符 &#x27;j&#x27; 可以用。为了补全这一组，使用填充字符 &#x27;x&#x27; 两次。因此，形成 4 组，分别是 &quot;abc&quot;、&quot;def&quot;、&quot;ghi&quot; 和 &quot;jxx&quot; 。 提示： 1 &lt;= s.length &lt;= 100 s 仅由小写英文字母组成 1 &lt;= k &lt;= 100 fill 是一个小写英文字母 分析和解答简单的字符串模拟，需要比较熟练地使用mod 1234567891011121314151617181920class Solution(object): def divideString(self, s, k, fill): &quot;&quot;&quot; :type s: str :type k: int :type fill: str :rtype: List[str] &quot;&quot;&quot; return_list = [] s_list = list(s) if len(s_list) % k != 0: s_list += [fill for _ in range(k - len(s_list) % k)] print(s_list) i = 0 while i &lt; len(s_list): return_list.append(&quot;&quot;.join(s_list[i: i+k])) i += k return return_list 第二题：5194.得到目标值的最少行动次数题目链接 题目大意你正在玩一个整数游戏。从整数1开始，期望得到整数target。 在一次行动中，你可以做下述两种操作之一： 递增，将当前整数的值加 1（即，x = x + 1）。 加倍，使当前整数的值翻倍（即，x = 2 * x）。 在整个游戏过程中，你可以使用递增操作任意次数。但是只能使用加倍操作 至多maxDoubles次。 给你两个整数target和maxDoubles，返回从 1 开始得到target需要的最少行动次数。 示例1： 123输入：target = 5, maxDoubles = 0输出：4解释：一直递增 1 直到得到 target 。 示例2： 12345678输入：target = 19, maxDoubles = 2输出：7解释：最初，x = 1 。递增 3 次，x = 4 。加倍 1 次，x = 8 。递增 1 次，x = 9 。加倍 1 次，x = 18 。递增 1 次，x = 19 。 示例3： 12345678输入：target = 10, maxDoubles = 4输出：4解释：最初，x = 1 。 递增 1 次，x = 2 。 加倍 1 次，x = 4 。 递增 1 次，x = 5 。 加倍 1 次，x = 10 。 提示： 1 &lt;= target &lt;= 109 0 &lt;= maxDoubles &lt;= 100 分析和解答贪心，还是比较容易看出来的 123456789101112131415161718192021class Solution(object): def minMoves(self, target, maxDoubles): &quot;&quot;&quot; :type target: int :type maxDoubles: int :rtype: int &quot;&quot;&quot; cnt = 0 while maxDoubles != 0 and target != 1: if target % 2 != 0: target -= 1 cnt += 1 else: target //= 2 cnt += 1 maxDoubles -= 1 cnt += target - 1 return cnt 第三题：5982.解决智力问题题目链接 题目大意给你一个下标从0开始的二维整数数组questions，其中questions[i] = [pointsi, brainpoweri]。 这个数组表示一场考试里的一系列题目，你需要按顺序（也就是从问题0开始依次解决），针对每个问题选择解决或者跳过操作。解决问题i将让你获得pointsi的分数，但是你将无法解决接下来的brainpoweri个问题（即只能跳过接下来的brainpoweri个问题）。如果你跳过问题i，你可以对下一个问题决定使用哪种操作。 比方说，给你questions = [[3, 2], [4, 3], [4, 4], [2, 5]]： 如果问题0被解决了， 那么你可以获得3分，但你不能解决问题1和2。 如果你跳过问题0，且解决问题1，你将获得4分但是不能解决问题2和3。 请你返回这场考试里你能获得的最高分数。 示例1： 1234567输入：questions = [[3,2],[4,3],[4,4],[2,5]]输出：5解释：解决问题 0 和 3 得到最高分。- 解决问题 0 ：获得 3 分，但接下来 2 个问题都不能解决。- 不能解决问题 1 和 2- 解决问题 3 ：获得 2 分总得分为：3 + 2 = 5 。没有别的办法获得 5 分或者多于 5 分。 示例2： 12345678输入：questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]输出：7解释：解决问题 1 和 4 得到最高分。- 跳过问题 0- 解决问题 1 ：获得 2 分，但接下来 2 个问题都不能解决。- 不能解决问题 2 和 3- 解决问题 4 ：获得 5 分总得分为：2 + 5 = 7 。没有别的办法获得 7 分或者多于 7 分。 提示： 1 &lt;= questions.length &lt;= 105 questions[i].length == 2 1 &lt;= pointsi, brainpoweri &lt;= 105 分析和解答题目的名字好有意思哈哈哈哈，这是按时解决一下我的智力问题吗23333 一眼看上去很像背包，这种题多半就是dp了，就像总结里说的，常见的一维dp感觉是有两种思路，一种是存储当前位置的一些状态值，另外一种是存储截止到这个位置下的状态值，这个题就是后边一种思路，如果使用第一种思路实现的话会因为多次使用max()而TLE，所以在优化方向上应该也找到后边一种思路的优化方向； TLE的写法，这里dp数组存储的是每个状态的： 123456789101112131415161718192021222324class Solution(object): def mostPoints(self, questions): &quot;&quot;&quot; :type questions: List[List[int]] :rtype: int &quot;&quot;&quot; questions.reverse() dp = [x[0] for x in questions] # 每个位置上先初始化 for i in range(len(questions)): # 每个位置有选得到和选不到两种状态的dp if i - questions[i][1] - 1 &lt; 0: pass else: # 选和不选两种状态 # 选的话 tmp_choose = questions[i][0] + max(dp[0:i-questions[i][1]]) # 不选的话 tmp_not_choose = max(dp[i-questions[i][1]: i]) dp[i] = max(tmp_choose, tmp_not_choose) # print(dp) return max(dp) 优化后的写法， 这里dp数组存储的是截止到这个状态的，下图是思路： 12345678910111213141516171819class Solution(object): def mostPoints(self, questions): &quot;&quot;&quot; :type questions: List[List[int]] :rtype: int &quot;&quot;&quot; dp = [0 for x in questions] questions.reverse() for i in range(len(questions)): if i - questions[i][1] - 1 &lt; 0: # 越界了的状态，维护不断增加的dp dp[i] = max(dp[i-1], questions[i][0]) else: # 没有越界的话，因为不断增加 dp[i] = max(dp[i-1], questions[i][0] + dp[i - questions[i][1] - 1]) # print(max(dp)) return dp[len(questions) - 1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"Docker学习笔记3-Docker常用命令-狂神视频","slug":"develop/docker/Docker学习笔记3-Docker常用命令-狂神视频","date":"2022-01-07T16:14:06.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/01/08/develop/docker/Docker学习笔记3-Docker常用命令-狂神视频/","link":"","permalink":"http://example.com/2022/01/08/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/","excerpt":"Docker的常用命令，主要分为镜像和容器两个部分，也是Docker学习的基础 这里的命令如果对基础linux有了解，或者对screen系列命令有了解感觉还是很熟悉的，就是感觉要多用或者结合项目才能真正的记住","text":"Docker的常用命令，主要分为镜像和容器两个部分，也是Docker学习的基础 这里的命令如果对基础linux有了解，或者对screen系列命令有了解感觉还是很熟悉的，就是感觉要多用或者结合项目才能真正的记住 Docker的常用命令帮助命令1234docker version # 显示docker的版本信息docker info # 显示docker更加详细的信息，sys级别系统信息，包括镜像和容器的数量等docker 命令 --help # 万能命令，帮助命令docker --help 帮助文档的地址：docs.docker.com里有一个Reference docs.docker.com/engine/reference/commandline 镜像命令docker images 查看所有本地主机上的镜像 123456789101112131415[bupt_114@AIServer ~]$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest feb5d9fea6a5 3 months ago 13.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像的创建时间SIZE 镜像的大小# 可选项，可以docker image -aqOptions: -a, --all Show all images (default hides intermediate images) 列出所有镜像 -q, --quiet Only show image IDs 只显示镜像的id docker search 搜索镜像 1234567891011121314151617[bupt_114@AIServer ~]$ docker search mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 11912 [OK] mariadb MariaDB Server is a high performing open sou… 4558 [OK] mysql/mysql-server Optimized MySQL Server Docker images. Create… 895 [OK]phpmyadmin phpMyAdmin - A web interface for MySQL and M… 415 [OK]......# 可选项，通过收藏来过滤Options:--filter=STARS=3000 # 搜索出来的镜像就是STARS大于3000的[bupt_114@AIServer ~]$ docker search mysql --filter=STARS=3000NAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 11912 [OK] mariadb MariaDB Server is a high performing open sou… 4558 [OK] docker pull 下载镜像 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 下载镜像 docker pull 镜像名[:tag][bupt_114@AIServer ~]$ docker pull mysqlUsing default tag: latest # 如果不写tag，默认就是latestlatest: Pulling from library/mysql # 72a69066d2fe: Pull complete # 分层下载，docker image的核心 联合文件系统93619dbc5b36: Pull complete 99da31dd6142: Pull complete 626033c43d70: Pull complete 37d5d7efb64e: Pull complete ac563158d721: Pull complete d2ba16033dad: Pull complete 688ba7d5c01a: Pull complete 00e060b6d11d: Pull complete 1c04857f594f: Pull complete 4d7cfa90e6ea: Pull complete e0431212d27d: Pull complete Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 # 签名，防伪标志Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实地址# 等价docker pull mysql 和 docker pull docker.io/library/mysql:latest是等价的# 指定版本下载[bupt_114@AIServer ~]$ docker pull mysql:5.7 # 注意版本一定要在官方文档里有【docker笔记3图2】[bupt_114@AIServer ~]$ docker pull mysql:5.75.7: Pulling from library/mysql72a69066d2fe: Already exists 93619dbc5b36: Already exists 99da31dd6142: Already exists 626033c43d70: Already exists 37d5d7efb64e: Already exists ac563158d721: Already exists d2ba16033dad: Already exists 0ceb82207cd7: Pull complete 37f2405cae96: Pull complete e2482e017e53: Pull complete 70deed891d42: Pull complete Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7 docker rmi 删除镜像（既可以通过镜像的ID来删除，也可以通过镜像的名称来删除，涉及到删除的指令都非常危险啊） 123456789101112[bupt_114@AIServer ~]$ docker rmi -f c20987f18b13Untagged: mysql:5.7Untagged: mysql@sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94Deleted: sha256:c20987f18b130f9d144c9828df630417e2a9523148930dc3963e9d0dab302a76Deleted: sha256:6567396b065ee734fb2dbb80c8923324a778426dfd01969f091f1ab2d52c7989Deleted: sha256:0910f12649d514b471f1583a16f672ab67e3d29d9833a15dc2df50dd5536e40fDeleted: sha256:6682af2fb40555c448b84711c7302d0f86fc716bbe9c7dc7dbd739ef9d757150Deleted: sha256:5c062c3ac20f576d24454e74781511a5f96739f289edaadf2de934d06e910b92# 批量删除所有的[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq) # 删除全部的容器 123[bupt_114@AIServer ~]$ docker rmi -f 容器id # 删除指定的容器[bupt_114@AIServer ~]$ docker rmi -f 容器id 容器id 容器id # 删除多个容器[bupt_114@AIServer ~]$ docker rmi -f $(docker images -aq) # 删除全部的容器 容器命令说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习 在docker里面再装一个虚拟机！？ 1docker pull centos 新建容器并启动 123456789101112131415161718192021222324docker run [可选参数] image# 参数说明--name=&quot;Name&quot; # 容器名字，跑起来要知道叫什么，tomcat01, tomcat02，用来区分容器-d # 后台方式运行-it # 使用交互方式运行，进入容器查看内容-p # 指定容器的端口 -p 8080:8080，可以和主机映射起来也 -p ip:主机端口:容器端口 -p 主机端口:容器端口（常用） -p 容器端口 容器端口-P # 大P，随机指定端口# 测试，启动并进入容器[bupt_114@AIServer ~]$ docker run -it centos /bin/bash[root@364710ff50c7 /]# [root@364710ff50c7 /]# ls # 查看容器内部的centos，基础版本，很多命令都是不完善的bin dev etc home lib lib64 lost+found media mnt opt proc root run sbin srv sys tmp usr var# 从容器中退回主机[root@364710ff50c7 /]# exit[bupt_114@AIServer ~]$ 列出所有运行中的容器 1234567891011121314151617# docker ps 命令 # 列出当前正在运行的容器-a # 列出当前正在运行的容器 + 带出历史运行过的容器-n=? # 显示最近创建的容器，即个数-q # 只显示容器的编号[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[bupt_114@AIServer ~]$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES364710ff50c7 centos &quot;/bin/bash&quot; 5 minutes ago Exited (0) About a minute ago elated_lichterman93427549984f feb5d9fea6a5 &quot;/hello&quot; 29 hours ago Exited (0) 29 hours ago exciting_villani[bupt_114@AIServer ~]$ docker ps -a -n=1CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES364710ff50c7 centos &quot;/bin/bash&quot; 7 minutes ago Exited (0) 3 minutes ago elated_lichterman[bupt_114@AIServer ~]$ 退出容器 12exit # 直接停止容器并退出ctrl + P + Q # 容器不停止并退出 删除容器 1234567docker rm 容器id # 删除指定的容器，不能删除正在运行的容器，如果要强制删除，rm -fdocker rm -f $(docker ps -aq) # 删除所有的容器docker ps -a -q | xargs docker rm # 删除所有的容器（docker玩的不错跑路就玩得不错哈哈哈哈）# 运行中的不能直接删除，要加-f代表force[bupt_114@AIServer ~]$ docker rm f406a8591325Error response from daemon: You cannot remove a running container f406a8591325995950d4defb6d7eefbe45bd5ec11e895f7238ce53de4546c297. Stop the container before attempting removal or force remove 启动和停止容器的操作 1234567891011121314151617181920docker start 容器id # 启动容器docker attach 容器id # 进入容器docker restart 容器id # 重启容器docker stop 容器id # 停止当前正在运行的容器docker kill 容器id # 强制定制当前正在运行的容器[bupt_114@AIServer ~]$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES87ac7567be74 centos &quot;/bin/bash&quot; 9 seconds ago Exited (0) 6 seconds ago determined_cohen[bupt_114@AIServer ~]$ docker start 87ac7567be7487ac7567be74[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES87ac7567be74 centos &quot;/bin/bash&quot; 24 seconds ago Up 4 seconds determined_cohen[bupt_114@AIServer ~]$ docker stop 87ac7567be7487ac7567be74[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[bupt_114@AIServer ~]$ 常用的其他命令后台启动容器 123456789101112131415# 命令，docker run -d 镜像名！[bupt_114@AIServer ~]$ docker run -d centos0aab13a3c396931520159092a755ccc7eb1a2fc56895ab2e2cc43267e86be432# 问题，docker ps，发现centos停止了[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES[bupt_114@AIServer ~]$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0aab13a3c396 centos &quot;/bin/bash&quot; 12 seconds ago Exited (0) 11 seconds ago exciting_bose# 常见的坑：docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，没有程序了# 这块有点没理解，往后学习再看了[bupt_114@AIServer ~]$ 查看日志 1234567891011docker logs[bupt_114@AIServer ~]$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0aab13a3c396 centos &quot;/bin/bash&quot; 15 minutes ago Exited (0) 15 minutes ago exciting_bose[bupt_114@AIServer ~]$ docker logs -tf --tail 10 0aab13a3c396# 显示日志-tf # 显示日志，f是实时追踪，滚动查看--tail number # 要显示的日志条数 查看容器中的进程信息 ps用来查linux的进程信息 1234567891011# 注意，要容器正在运行才能查的出来docker top [容器id][bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8d05d658639d centos &quot;/bin/bash&quot; 15 seconds ago Up 14 seconds pensive_dirac[bupt_114@AIServer ~]$ docker top 8d05d658639dUID PID PPID C STIME TTY TIME CMDroot 11758 11735 0 21:37 pts/0 00:00:00 /bin/bash[bupt_114@AIServer ~]$ 查看镜像的元数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8d05d658639d centos &quot;/bin/bash&quot; About a minute ago Up About a minute pensive_dirac[bupt_114@AIServer ~]$ docker inspect 8d05d658639d[ &#123; &quot;Id&quot;: &quot;8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732&quot;, &quot;Created&quot;: &quot;2022-01-07T13:37:12.953676774Z&quot;, &quot;Path&quot;: &quot;/bin/bash&quot;, &quot;Args&quot;: [], &quot;State&quot;: &#123; &quot;Status&quot;: &quot;running&quot;, &quot;Running&quot;: true, &quot;Paused&quot;: false, &quot;Restarting&quot;: false, &quot;OOMKilled&quot;: false, &quot;Dead&quot;: false, &quot;Pid&quot;: 11758, &quot;ExitCode&quot;: 0, &quot;Error&quot;: &quot;&quot;, &quot;StartedAt&quot;: &quot;2022-01-07T13:37:13.28978368Z&quot;, &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot; &#125;, &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;, &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/resolv.conf&quot;, &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hostname&quot;, &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/hosts&quot;, &quot;LogPath&quot;: &quot;/var/lib/docker/containers/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732/8d05d658639d9dbc015cfef44b7390bc4cab2b658d646f0933defaa4ee2a8732-json.log&quot;, &quot;Name&quot;: &quot;/pensive_dirac&quot;, &quot;RestartCount&quot;: 0, &quot;Driver&quot;: &quot;overlay2&quot;, &quot;Platform&quot;: &quot;linux&quot;, &quot;MountLabel&quot;: &quot;&quot;, &quot;ProcessLabel&quot;: &quot;&quot;, &quot;AppArmorProfile&quot;: &quot;&quot;, &quot;ExecIDs&quot;: null, &quot;HostConfig&quot;: &#123; &quot;Binds&quot;: null, &quot;ContainerIDFile&quot;: &quot;&quot;, &quot;LogConfig&quot;: &#123; &quot;Type&quot;: &quot;json-file&quot;, &quot;Config&quot;: &#123;&#125; &#125;, &quot;NetworkMode&quot;: &quot;default&quot;, &quot;PortBindings&quot;: &#123;&#125;, &quot;RestartPolicy&quot;: &#123; &quot;Name&quot;: &quot;no&quot;, &quot;MaximumRetryCount&quot;: 0 &#125;, &quot;AutoRemove&quot;: false, &quot;VolumeDriver&quot;: &quot;&quot;, &quot;VolumesFrom&quot;: null, &quot;CapAdd&quot;: null, &quot;CapDrop&quot;: null, &quot;CgroupnsMode&quot;: &quot;host&quot;, &quot;Dns&quot;: [], &quot;DnsOptions&quot;: [], &quot;DnsSearch&quot;: [], &quot;ExtraHosts&quot;: null, &quot;GroupAdd&quot;: null, &quot;IpcMode&quot;: &quot;private&quot;, &quot;Cgroup&quot;: &quot;&quot;, &quot;Links&quot;: null, &quot;OomScoreAdj&quot;: 0, &quot;PidMode&quot;: &quot;&quot;, &quot;Privileged&quot;: false, &quot;PublishAllPorts&quot;: false, &quot;ReadonlyRootfs&quot;: false, &quot;SecurityOpt&quot;: null, &quot;UTSMode&quot;: &quot;&quot;, &quot;UsernsMode&quot;: &quot;&quot;, &quot;ShmSize&quot;: 67108864, &quot;Runtime&quot;: &quot;runc&quot;, &quot;ConsoleSize&quot;: [ 0, 0 ], &quot;Isolation&quot;: &quot;&quot;, &quot;CpuShares&quot;: 0, &quot;Memory&quot;: 0, &quot;NanoCpus&quot;: 0, &quot;CgroupParent&quot;: &quot;&quot;, &quot;BlkioWeight&quot;: 0, &quot;BlkioWeightDevice&quot;: [], &quot;BlkioDeviceReadBps&quot;: null, &quot;BlkioDeviceWriteBps&quot;: null, &quot;BlkioDeviceReadIOps&quot;: null, &quot;BlkioDeviceWriteIOps&quot;: null, &quot;CpuPeriod&quot;: 0, &quot;CpuQuota&quot;: 0, &quot;CpuRealtimePeriod&quot;: 0, &quot;CpuRealtimeRuntime&quot;: 0, &quot;CpusetCpus&quot;: &quot;&quot;, &quot;CpusetMems&quot;: &quot;&quot;, &quot;Devices&quot;: [], &quot;DeviceCgroupRules&quot;: null, &quot;DeviceRequests&quot;: null, &quot;KernelMemory&quot;: 0, &quot;KernelMemoryTCP&quot;: 0, &quot;MemoryReservation&quot;: 0, &quot;MemorySwap&quot;: 0, &quot;MemorySwappiness&quot;: null, &quot;OomKillDisable&quot;: false, &quot;PidsLimit&quot;: null, &quot;Ulimits&quot;: null, &quot;CpuCount&quot;: 0, &quot;CpuPercent&quot;: 0, &quot;IOMaximumIOps&quot;: 0, &quot;IOMaximumBandwidth&quot;: 0, &quot;MaskedPaths&quot;: [ &quot;/proc/asound&quot;, &quot;/proc/acpi&quot;, &quot;/proc/kcore&quot;, &quot;/proc/keys&quot;, &quot;/proc/latency_stats&quot;, &quot;/proc/timer_list&quot;, &quot;/proc/timer_stats&quot;, &quot;/proc/sched_debug&quot;, &quot;/proc/scsi&quot;, &quot;/sys/firmware&quot; ], &quot;ReadonlyPaths&quot;: [ &quot;/proc/bus&quot;, &quot;/proc/fs&quot;, &quot;/proc/irq&quot;, &quot;/proc/sys&quot;, &quot;/proc/sysrq-trigger&quot; ] &#125;, &quot;GraphDriver&quot;: &#123; &quot;Data&quot;: &#123; &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74-init/diff:/var/lib/docker/overlay2/70a302960300b9000282549b5adf25e9a4bd66f8e9c50f12844d5d156ea2c712/diff&quot;, &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/merged&quot;, &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/diff&quot;, &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/58cabfbd05b381fae72981c01524435bc9231561f1a492c32b9a4e402522db74/work&quot; &#125;, &quot;Name&quot;: &quot;overlay2&quot; &#125;, &quot;Mounts&quot;: [], &quot;Config&quot;: &#123; &quot;Hostname&quot;: &quot;8d05d658639d&quot;, &quot;Domainname&quot;: &quot;&quot;, &quot;User&quot;: &quot;&quot;, &quot;AttachStdin&quot;: true, &quot;AttachStdout&quot;: true, &quot;AttachStderr&quot;: true, &quot;Tty&quot;: true, &quot;OpenStdin&quot;: true, &quot;StdinOnce&quot;: true, &quot;Env&quot;: [ &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot; ], &quot;Cmd&quot;: [ &quot;/bin/bash&quot; ], &quot;Image&quot;: &quot;centos&quot;, &quot;Volumes&quot;: null, &quot;WorkingDir&quot;: &quot;&quot;, &quot;Entrypoint&quot;: null, &quot;OnBuild&quot;: null, &quot;Labels&quot;: &#123; &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;, &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;, &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;, &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;, &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot; &#125; &#125;, &quot;NetworkSettings&quot;: &#123; &quot;Bridge&quot;: &quot;&quot;, &quot;SandboxID&quot;: &quot;e1251439f6970af7a132751b9c2f1bc9bcd997589ed16c1824047626a5c34153&quot;, &quot;HairpinMode&quot;: false, &quot;LinkLocalIPv6Address&quot;: &quot;&quot;, &quot;LinkLocalIPv6PrefixLen&quot;: 0, &quot;Ports&quot;: &#123;&#125;, &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/e1251439f697&quot;, &quot;SecondaryIPAddresses&quot;: null, &quot;SecondaryIPv6Addresses&quot;: null, &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;Networks&quot;: &#123; &quot;bridge&quot;: &#123; &quot;IPAMConfig&quot;: null, &quot;Links&quot;: null, &quot;Aliases&quot;: null, &quot;NetworkID&quot;: &quot;46238680691e2ebb3e190ccf96fb7814787a55c663b4585dae38cd8e3abc4070&quot;, &quot;EndpointID&quot;: &quot;f95da790cb9492af2410a35ee110943d1af0f393ab5ec266071cb40f4621525a&quot;, &quot;Gateway&quot;: &quot;172.17.0.1&quot;, &quot;IPAddress&quot;: &quot;172.17.0.2&quot;, &quot;IPPrefixLen&quot;: 16, &quot;IPv6Gateway&quot;: &quot;&quot;, &quot;GlobalIPv6Address&quot;: &quot;&quot;, &quot;GlobalIPv6PrefixLen&quot;: 0, &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;, &quot;DriverOpts&quot;: null &#125; &#125; &#125; &#125;][bupt_114@AIServer ~]$ 进入当前正在运行的容器 1234567891011121314151617181920212223242526# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置# 命令1docker exec -it 容器id bashShell[bupt_114@AIServer ~]$ docker exec -it 8d05d658639d /bin/bash[root@8d05d658639d /]# # 命令2，注意进入的是一个正在进行的命令行！！！！而不是开启一个新的窗口docker attach 容器id[bupt_114@AIServer ~]$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES8d05d658639d centos &quot;/bin/bash&quot; 8 minutes ago Up 8 minutes pensive_dirac[bupt_114@AIServer ~]$ docker attach 8d05d658639d[root@8d05d658639d /]# ps -ef UID PID PPID C STIME TTY TIME CMDroot 1 0 0 13:37 pts/0 00:00:00 /bin/bashroot 30 1 0 13:45 pts/0 00:00:00 ps -ef[root@8d05d658639d /]# # docker exec # 进入容器后开启一个新的终端，可以在里面操作# dockerattach # 进入容器正在执行的终端，不会启动新的进程！ 从容器内拷贝文件到主机 注：从主机内拷到容器内一般用挂载来做！ 容器内外是隔离的 123docker cp 容器id:容器内路径 目的的主机路径# 拷贝使用一个手动过程，未来我们使用 -v 卷的技术，可以实现 学习方式：命令全部跟着敲一遍，自己记录笔记 docker命令小结 docker的命令是十分多的，上边是常见的容器和镜像命令","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[]},{"title":"Docker学习笔记2-安装环境-狂神视频","slug":"develop/docker/Docker学习笔记2-安装环境-狂神视频","date":"2022-01-07T14:30:41.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/01/07/develop/docker/Docker学习笔记2-安装环境-狂神视频/","link":"","permalink":"http://example.com/2022/01/07/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/","excerpt":"本篇博客记录根据狂神视频学习的Docker安装过程和一些安装后的基本配置 TODO 未来将在此博客补充Docker的离线部署过程，在真实的使用场景下还是有很多离线部署的场景需求的","text":"本篇博客记录根据狂神视频学习的Docker安装过程和一些安装后的基本配置 TODO 未来将在此博客补充Docker的离线部署过程，在真实的使用场景下还是有很多离线部署的场景需求的 Docker安装环境和一些基础配置Docker的安装注，下述安装过程是联网配置的过程，如果是离线部署的话还需要未来进一步学习 环境准备 1、需要会一点点Linux的基础；2、CentOS7；3、使用finalshell连接远程服务器进行操作； 个人在学习过程中在拥有root权限的zfx223服务器上操作，这样比较方便安装各种依赖环境等。环境查看如下所示： 1234# 系统内核是3.10以上的[root@AIServer ~]# uname -r3.10.0-957.el7.x86_64[root@AIServer ~]# 1234567891011121314151617# 查看系统版本[root@AIServer ~]# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;ANSI_COLOR=&quot;0;31&quot;CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;HOME_URL=&quot;https://www.centos.org/&quot;BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot; 安装 参考帮助文档，docs.docker.com 12345678910111213141516171819# 1、 卸载旧的版本[root@AIServer ~]# yum remove docker \\&gt; docker-client \\&gt; docker-client-latest \\&gt; docker-common \\&gt; docker-latest \\&gt; docker-latest-logrotate \\&gt; docker-logrotate \\&gt; docker-engine已加载插件：fastestmirror, langpacks参数 docker 没有匹配参数 docker-client 没有匹配参数 docker-client-latest 没有匹配参数 docker-common 没有匹配参数 docker-latest 没有匹配参数 docker-latest-logrotate 没有匹配参数 docker-logrotate 没有匹配参数 docker-engine 没有匹配不删除任何软件包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 2、 需要的安装包[root@AIServer ~]# yum install -y yum-utils已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * centos-gluster7: mirrors.aliyun.com * centos-ovirt42: mirrors.aliyun.com * centos-ovirt43: mirrors.aliyun.com * centos-qemu-ev: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.huaweicloud.combase | 3.6 kB 00:00:00 centos-gluster7 | 3.0 kB 00:00:00 centos-ovirt42 | 2.9 kB 00:00:00 centos-ovirt43 | 2.9 kB 00:00:00 centos-qemu-ev | 3.0 kB 00:00:00 centos-release-opstools | 2.9 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 yum-utils.noarch.0.1.1.31-50.el7 将被 升级---&gt; 软件包 yum-utils.noarch.0.1.1.31-54.el7_8 将被 更新--&gt; 解决依赖关系完成依赖关系解决================================================================================================================================================================================ Package 架构 版本 源 大小================================================================================================================================================================================正在更新: yum-utils noarch 1.1.31-54.el7_8 base 122 k事务概要================================================================================================================================================================================升级 1 软件包总计：122 kDownloading packages:Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在更新 : yum-utils-1.1.31-54.el7_8.noarch 1/2 清理 : yum-utils-1.1.31-50.el7.noarch 2/2 验证中 : yum-utils-1.1.31-54.el7_8.noarch 1/2 验证中 : yum-utils-1.1.31-50.el7.noarch 2/2 更新完毕: yum-utils.noarch 0:1.1.31-54.el7_8 完毕！ 1234567891011121314151617181920213、 设置镜像的仓库（通过仓库的方法进行安装）sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是从国外下载的，十分慢# 通过如下方式找到国内的https://blog.csdn.net/lvdingding/article/details/112862396yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo[root@AIServer ~]# yum-config-manager \\&gt; --add-repo \\&gt; http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo已加载插件：fastestmirror, langpacksadding repo from: http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repograbbing file http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo to /etc/yum.repos.d/docker-ce.reporepo saved to /etc/yum.repos.d/docker-ce.repo 1234567891011121314151617181920212223# 更新yum软件包索引，下述步骤中的fastestmirror还需要进一步学习yum makecache [root@AIServer ~]# yum makecache fast已加载插件：fastestmirror, langpacksLoading mirror speeds from cached hostfile * base: mirrors.aliyun.com * centos-gluster7: mirrors.aliyun.com * centos-ovirt42: mirrors.aliyun.com * centos-ovirt43: mirrors.aliyun.com * centos-qemu-ev: mirrors.aliyun.com * extras: mirrors.aliyun.com * updates: mirrors.huaweicloud.combase | 3.6 kB 00:00:00 centos-gluster7 | 3.0 kB 00:00:00 centos-ovirt42 | 2.9 kB 00:00:00 centos-ovirt43 | 2.9 kB 00:00:00 centos-qemu-ev | 3.0 kB 00:00:00 centos-release-opstools | 2.9 kB 00:00:00 docker-ce-stable | 3.5 kB 00:00:00 extras | 2.9 kB 00:00:00 updates | 2.9 kB 00:00:00 元数据缓存已建立 12# 4、安装docker相关的 docker-ce社区版， ee企业版 安装的过程一路yes过去~yum install docker-ce docker-ce-cli containerd.io 125、 启动dockersystemctl start docker 123456789101112136、 使用docker version查看是否安装成功[bupt_114@AIServer ~]$ docker version # 查看是否安装成功Client: Docker Engine - Community Version: 20.10.12 API version: 1.41 Go version: go1.16.12 Git commit: e91ed57 Built: Mon Dec 13 11:45:41 2021 OS/Arch: linux/amd64 Context: default Experimental: true...... 1237、 hello-worlddocker run hello-world 123458、 查看一下下载的这个hello-world镜像[root@AIServer ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest feb5d9fea6a5 3 months ago 13.3kB[root@AIServer ~]# 12345678了解，卸载docker# 卸载依赖sudo yum remove docker-ce docker-ce-cli containerd.io# 删除资源sudo rm -rf /var/lib/dockersudo rm -rf /var/lib/containerd Docker各个用户权限的设置，用户组Reference: https://www.cnblogs.com/franson-2016/p/6412971.html 阿里云镜像加速这是针对在阿里云上购买而言的，而且好像要收费？ 1、登录阿里云，找到容器服务2、找到镜像加速地址3、配置使用 回顾HelloWorld流程 底层原理Docker是怎么工作的 Docker是一个Clinet-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问 DockerServer接收到Docker-Client的指令，就会执行这个命令！ Docker为什么比VM快？ 1、Docker有着比虚拟机更少的抽象层。2、Docker利用的是宿主机的内核，vm需要是Guest OS。 所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS，分钟级别的，而Docker是利用宿主机的操作系统，省略了这个复杂的过程，秒级！","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[]},{"title":"1614.括号的最大嵌套深度-python","slug":"algorithms/leetcode-python/1614-括号的最大嵌套深度-python","date":"2022-01-06T17:07:44.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/01/07/algorithms/leetcode-python/1614-括号的最大嵌套深度-python/","link":"","permalink":"http://example.com/2022/01/07/algorithms/leetcode-python/1614-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6-python/","excerpt":"1614.括号的最大嵌套深度（简单） 题目大意： 如果字符串满足以下条件之一，则可以称之为有效括号字符串（valid parentheses string，可以简写为VPS）： 字符串是一个空字符串&quot;&quot;，或者是一个不为&quot;(&quot;或&quot;)&quot;的单字符。 字符串可以写为AB（A与B字符串连接），其中A和B都是 有效括号字符串 。 字符串可以写为(A)，其中A是一个 有效括号字符串 。 类似地，可以定义任何有效括号字符串S的 嵌套深度depth(S)： depth(&quot;&quot;) = 0 depth(C) = 0，其中C是单个字符的字符串，且该字符不是&quot;(&quot;或者&quot;)&quot; depth(A + B) = max(depth(A), depth(B))，其中A和B都是 有效括号字符串 epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中A是一个 有效括号字符串 例如：&quot;&quot;、&quot;()()&quot;、&quot;()(()())&quot;都是 有效括号字符串（嵌套深度分别为 0、1、2），而&quot;)(&quot;、&quot;(()&quot;都不是 有效括号字符串 。 给你一个有效括号字符串s，返回该字符串的s嵌套深度。","text":"1614.括号的最大嵌套深度（简单） 题目大意： 如果字符串满足以下条件之一，则可以称之为有效括号字符串（valid parentheses string，可以简写为VPS）： 字符串是一个空字符串&quot;&quot;，或者是一个不为&quot;(&quot;或&quot;)&quot;的单字符。 字符串可以写为AB（A与B字符串连接），其中A和B都是 有效括号字符串 。 字符串可以写为(A)，其中A是一个 有效括号字符串 。 类似地，可以定义任何有效括号字符串S的 嵌套深度depth(S)： depth(&quot;&quot;) = 0 depth(C) = 0，其中C是单个字符的字符串，且该字符不是&quot;(&quot;或者&quot;)&quot; depth(A + B) = max(depth(A), depth(B))，其中A和B都是 有效括号字符串 epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中A是一个 有效括号字符串 例如：&quot;&quot;、&quot;()()&quot;、&quot;()(()())&quot;都是 有效括号字符串（嵌套深度分别为 0、1、2），而&quot;)(&quot;、&quot;(()&quot;都不是 有效括号字符串 。 给你一个有效括号字符串s，返回该字符串的s嵌套深度。 题目题目链接 题目大意： 如果字符串满足以下条件之一，则可以称之为有效括号字符串（valid parentheses string，可以简写为VPS）： 字符串是一个空字符串&quot;&quot;，或者是一个不为&quot;(&quot;或&quot;)&quot;的单字符。 字符串可以写为AB（A与B字符串连接），其中A和B都是 有效括号字符串 。 字符串可以写为(A)，其中A是一个 有效括号字符串 。 类似地，可以定义任何有效括号字符串S的 嵌套深度depth(S)： depth(&quot;&quot;) = 0 depth(C) = 0，其中C是单个字符的字符串，且该字符不是&quot;(&quot;或者&quot;)&quot; depth(A + B) = max(depth(A), depth(B))，其中A和B都是 有效括号字符串 epth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中A是一个 有效括号字符串 例如：&quot;&quot;、&quot;()()&quot;、&quot;()(()())&quot;都是 有效括号字符串（嵌套深度分别为 0、1、2），而&quot;)(&quot;、&quot;(()&quot;都不是 有效括号字符串 。 给你一个有效括号字符串s，返回该字符串的s嵌套深度。 示例1： 123输入：s = &quot;(1+(2*3)+((8)/4))+1&quot;输出：3解释：数字 8 在嵌套的 3 层括号中。 示例2： 12输入：s = &quot;(1)+((2))+(((3)))&quot;输出：3 示例3： 12输入：s = &quot;1+(2*3)/(2-1)&quot;输出：1 示例4： 12输入：s = &quot;1&quot;输出：0 提示： 1 &lt;= s.length &lt;= 100 s 由数字 0-9 和字符 ‘+’、’-‘、’*’、’/‘、’(‘、’)’ 组成 题目数据保证括号表达式 s 是 有效的括号表达式 分析和解答这个题如果是python的话只要搞个list模拟栈就可以了，每次操作的时候判断当前list的长度，来更新max_depth还是很简单的 12345678910111213141516class Solution(object): def maxDepth(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; stack = [] max_depth = -1 for i, c in enumerate(s): if c == &#x27;(&#x27;: stack.append(c) elif c == &#x27;)&#x27;: stack = stack[:-1] # 截断到最后一个 max_depth = max(max_depth, len(stack)) return max_depth","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"}]},{"title":"64.最小路径和-python","slug":"algorithms/leetcode-python/64-最小路径和-python","date":"2022-01-06T06:25:29.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/01/06/algorithms/leetcode-python/64-最小路径和-python/","link":"","permalink":"http://example.com/2022/01/06/algorithms/leetcode-python/64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-python/","excerpt":"64.最小路径和（中等） 题目大意： 给定一个包含非负整数的m x n网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。","text":"64.最小路径和（中等） 题目大意： 给定一个包含非负整数的m x n网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 题目题目链接 题目大意： 给定一个包含非负整数的m x n网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例1： 123输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。 示例2： 12输入：grid = [[1,2,3],[4,5,6]]输出：12 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 200 0 &lt;= grid[i][j] &lt;= 100 分析和解答也是一眼就能看出来是二维dp的题目，往下走和往右都是只有一种不断累加的走法 之后的状态转移方程dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] 12345678910111213141516171819202122232425262728293031class Solution(object): def minPathSum(self, grid): &quot;&quot;&quot; :type grid: List[List[int]] :rtype: int &quot;&quot;&quot; # 一眼dp，然后想想dp的思路应该也挺简单的，做一个min应该就行吧 m = len(grid) n = len(grid[0]) dp = [[0 for i in range(n)] for j in range(m)] # 初始化dp数组的第一行，第一列 ## 初始化dp数组的第一行 now = 0 for i in range(n): now += grid[0][i] dp[0][i] = now ## 初始化dp数组的第一列 now = 0 for i in range(m): now += grid[i][0] dp[i][0] = now # print(dp) ## for i in range(1, m): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[m-1][n-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"62.不同路径-python","slug":"algorithms/leetcode-python/62-不同路径-python","date":"2022-01-06T06:05:54.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/01/06/algorithms/leetcode-python/62-不同路径-python/","link":"","permalink":"http://example.com/2022/01/06/algorithms/leetcode-python/62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-python/","excerpt":"62.不同路径（中等） 题目大意： 一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？","text":"62.不同路径（中等） 题目大意： 一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 题目题目链接 题目大意： 一个机器人位于一个m x n网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例1： 12输入：m = 3, n = 7输出：28 示例2： 1234567输入：m = 3, n = 2输出：3解释：从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向下 示例3： 12输入：m = 7, n = 3输出：28 示例4： 12输入：m = 3, n = 3输出：6 提示： 1 &lt;= m, n &lt;= 100 题目数据保证答案小于等于2 * 109 分析和解答很明显的二维dp，向下走的所有格子和向右走的所有格子都只有一种走法，所以初始化为1 之后的状态转移方程很好想dp[i][j] = dp[i-1][j] + dp[i][j-1] 123456789101112131415161718192021222324class Solution(object): def uniquePaths(self, m, n): &quot;&quot;&quot; :type m: int :type n: int :rtype: int &quot;&quot;&quot; dp = [[0 for i in range(n)] for i in range(m)] # 把第一行第一列进行初始化，第一行第一列都只有一种走法 ## 第一行 for i in range(n): dp[0][i] = 1 ## 第一列 for i in range(m): dp[i][0] = 1 # 开启新的dp状态转移 for i in range(1, m): for j in range(1, n): # 新的mn位置处有几种到达走法 dp[i][j] = dp[i][j-1] + dp[i-1][j] return dp[m-1][n-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"组合数学","slug":"组合数学","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]},{"title":"141.环形链表-python","slug":"algorithms/leetcode-python/141-环形链表-python","date":"2022-01-05T15:16:03.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/01/05/algorithms/leetcode-python/141-环形链表-python/","link":"","permalink":"http://example.com/2022/01/05/algorithms/leetcode-python/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-python/","excerpt":"141.环形链表（简单） 题目大意： 给你一个链表的头节点head，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回true。 否则，返回false。","text":"141.环形链表（简单） 题目大意： 给你一个链表的头节点head，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回true。 否则，返回false。 题目题目链接 题目大意： 给你一个链表的头节点head，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数pos来表示链表尾连接到链表中的位置（索引从 0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。 如果链表中存在环，则返回true。 否则，返回false。 示例1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 &lt;= Node.val &lt;= 105 pos 为 -1 或者链表中的一个 有效索引 。 进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 分析和解答12345# Definition for singly-linked list.class ListNode(object): def __init__(self, x): self.val = x self.next = None 方法1，普通的字典法这个node对象是可哈希化的，可以用来当做键，所以设置一个字典就知道了 1234567891011121314class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; save_dict = &#123;&#125; while head != None: if save_dict.get(head) is not None: return True save_dict[head] = 1 head = head.next return False 方法2，巧妙的修改值法妙！ 12345678910111213class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; while head != None: if head.val == &quot;啊哈哈哈哈&quot;: return True else: head.val = &quot;啊哈哈哈哈&quot; head = head.next return False 方法3，快慢指针一个慢的乌龟和一个快的兔子，兔子跑得快，如果有环那兔子是总能追上乌龟的 快慢指针需要注意不能条件的判断，要把例如head和head.next这种的一起来判断！ 1234567891011121314151617181920212223class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; # 先要把异常判断做好了 if head is None or head.next is None: return False slow_turtle = head fast_rabbit = head.next while slow_turtle != fast_rabbit: if fast_rabbit is None or fast_rabbit.next is None: return False else: slow_turtle = slow_turtle.next fast_rabbit = fast_rabbit.next.next return True","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"49.字母异位词分组-python","slug":"algorithms/leetcode-python/49-字母异位词分组-python","date":"2022-01-05T13:51:58.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/01/05/algorithms/leetcode-python/49-字母异位词分组-python/","link":"","permalink":"http://example.com/2022/01/05/algorithms/leetcode-python/49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-python/","excerpt":"","text":"49.字母异位词分组（中等） 题目大意： 给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。 字母异位词是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 题目题目链接 给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。 字母异位词是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例1： 12输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]] 示例2： 12输入: strs = [&quot;&quot;]输出: [[&quot;&quot;]] 示例3： 12输入: strs = [&quot;a&quot;]输出: [[&quot;a&quot;]] 提示： 1 &lt;= strs.length &lt;= 104 0 &lt;= strs[i].length &lt;= 100 strs[i]仅包含小写字母 分析和解答这个题想想自己做法也挺奇葩的，只能说Counter永远的神了 先重整理数组，在原有的字符串基础上变成[字符串, Counter对象, 标记位（标记是否已经加入了）] 一个两重for循环，在外层for循环中，如果没有加入则加入，如果已经加入了则continue。在内层循环中，a-b, b-a判断Counter是否相等（这里比如a是外层的i，b是内层的j），如果相等并且没加入，就加入到外层循环初始化的list中，然后内层循环结束后append Counter永远的神！（除了效率hhh） 12345678910111213141516171819202122232425262728class Solution(object): def groupAnagrams(self, strs): &quot;&quot;&quot; :type strs: List[str] :rtype: List[List[str]] &quot;&quot;&quot; from collections import Counter # 一旦用上Coutner耗时就会很高？ 不过Counter真的是个好东西 temp_list = [] for i, item in enumerate(strs): temp_list.append([item, Counter(item), 0]) # 0是一个标记位，标记是否被加进去了 return_list = [] for i in range(len(temp_list)): if temp_list[i][2] == 1: continue add_list = [temp_list[i][0]] temp_list[i][2] = 1 for j in range(i+1, len(temp_list)): if temp_list[j][1] == temp_list[i][1] and temp_list[j][2] == 0: add_list.append(temp_list[j][0]) temp_list[j][2] = 1 return_list.append(add_list) add_list = [] return return_list","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"48.旋转图像-python","slug":"algorithms/leetcode-python/48-旋转图像-python","date":"2022-01-05T13:41:05.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2022/01/05/algorithms/leetcode-python/48-旋转图像-python/","link":"","permalink":"http://example.com/2022/01/05/algorithms/leetcode-python/48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-python/","excerpt":"48.旋转图像（中等） 题目大意： 给定一个n × n的二维矩阵matrix表示一个图像。请你将图像顺时针旋转90度。 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。","text":"48.旋转图像（中等） 题目大意： 给定一个n × n的二维矩阵matrix表示一个图像。请你将图像顺时针旋转90度。 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 题目题目链接 题目大意： 给定一个n × n的二维矩阵matrix表示一个图像。请你将图像顺时针旋转90度。 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[[7,4,1],[8,5,2],[9,6,3]] 示例2： 12输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] 示例3： 12输入：matrix = [[1]]输出：[[1]] 示例4： 12输入：matrix = [[1,2],[3,4]]输出：[[3,1],[4,2]] 提示： matrix.length == n matrix[i].length == n 1 &lt;= n &lt;= 20 -1000 &lt;= matrix[i][j] &lt;= 1000 分析和解答直接硬转实在是太考验人了，所以现在是两种方法，这样算起来就变简单非常多了 先水平翻转，再沿副对角线翻转 先上下翻转，再沿主对角线翻转 12345678910111213141516171819202122232425262728class Solution(object): def rotate(self, matrix): &quot;&quot;&quot; :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. &quot;&quot;&quot; # 首先进行左右翻转，然后按照副对角线进行翻转，在torch里是triu相关的操作，哈哈 n = len(matrix) # 一个 nxn 的矩阵 ## 执行左右翻转 for i in range(n): for j in range(n//2): # 执行翻转 temp = matrix[i][j] matrix[i][j] = matrix[i][n-1-j] matrix[i][n-1-j] = temp # print(matrix) ## 按照副对角线进行翻转，事后复盘来看的话，按照副对角线翻转有些复杂了 for i in range(n): for j in range(n-1-i): # 执行翻转 temp = matrix[i][j] matrix[i][j] = matrix[n-1-j][n-1-i] matrix[n-1-j][n-1-i] = temp # print(i, j) # print(matrix)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"1576.替换所有的问号-python","slug":"algorithms/leetcode-python/1576-替换所有的问号-python","date":"2022-01-05T13:28:05.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2022/01/05/algorithms/leetcode-python/1576-替换所有的问号-python/","link":"","permalink":"http://example.com/2022/01/05/algorithms/leetcode-python/1576-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7-python/","excerpt":"1576.替换所有的问号（简单） 题目大意： 给你一个仅包含小写英文字母和&#39;?&#39;字符的字符串s，请你将所有的&#39;?&#39;转换为若干小写字母，使最终的字符串不包含任何连续重复的字符。 注意：你不能修改非&#39;?&#39;字符。 题目测试用例保证除&#39;?&#39;字符之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。","text":"1576.替换所有的问号（简单） 题目大意： 给你一个仅包含小写英文字母和&#39;?&#39;字符的字符串s，请你将所有的&#39;?&#39;转换为若干小写字母，使最终的字符串不包含任何连续重复的字符。 注意：你不能修改非&#39;?&#39;字符。 题目测试用例保证除&#39;?&#39;字符之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 题目题目链接 题目大意： 给你一个仅包含小写英文字母和&#39;?&#39;字符的字符串s，请你将所有的&#39;?&#39;转换为若干小写字母，使最终的字符串不包含任何连续重复的字符。 注意：你不能修改非&#39;?&#39;字符。 题目测试用例保证除&#39;?&#39;字符之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例1： 123输入：s = &quot;?zs&quot;输出：&quot;azs&quot;解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#x27;z&#x27; 。 示例2： 123输入：s = &quot;ubv?w&quot;输出：&quot;ubvaw&quot;解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。 示例3： 12输入：s = &quot;j?qg??b&quot;输出：&quot;jaqgacb&quot; 示例4： 12输入：s = &quot;??yw?ipkj?&quot;输出：&quot;acywaipkja&quot; 提示： 1 &lt;= s.length &lt;= 100 s 仅包含小写英文字母和 ‘?’ 字符 分析和解答每日一题还是挺简单的，这题主要注意的情况是一个字符最多相邻两个，也就是说只要准备三个需要被换的字符，比如[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]就可以了 另外是还需要判断问号连续出现的情况就行了 另：python的字符串处理最好先用列表，然后再join到一起，耗时问题 12345678910111213141516171819202122232425262728293031323334353637class Solution(object): def modifyString(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; # 注意可能连续出现两个问号！！！！ if len(s) == 1 and s[0] == &#x27;?&#x27;: return &quot;a&quot; letters = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] # 必将在三个字母中找到答案！ 这个地方还是挺关键的 return_list = [] # python字符串，先用list，然后join回去 for i in range(len(s)): if s[i] != &#x27;?&#x27;: return_list.append(s[i]) else: if i == 0: for letter in letters: if letter != s[i+1]: return_list.append(letter) break elif i == len(s) - 1: for letter in letters: if letter != return_list[i-1]: return_list.append(letter) break else: for letter in letters: if letter != s[i+1] and letter != return_list[i-1]: return_list.append(letter) break return &#x27;&#x27;.join(return_list)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Docker学习笔记1-背景-狂神视频","slug":"develop/docker/Docker学习笔记1-背景-狂神视频","date":"2022-01-05T01:25:45.000Z","updated":"2022-11-20T01:50:08.888Z","comments":true,"path":"2022/01/05/develop/docker/Docker学习笔记1-背景-狂神视频/","link":"","permalink":"http://example.com/2022/01/05/develop/docker/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01-%E8%83%8C%E6%99%AF-%E7%8B%82%E7%A5%9E%E8%A7%86%E9%A2%91/","excerpt":"在未来的项目部署中一定还会用到Docker，k8s等，该篇博客主要记录学习Docker的过程 之后还会整理一篇离线普通方式部署的博客，现在离线普通方式部署自己操作过几次弄的比较明白了，但是问题是对接方很难完全弄明白，所以也是学习Docker的原因之一吧","text":"在未来的项目部署中一定还会用到Docker，k8s等，该篇博客主要记录学习Docker的过程 之后还会整理一篇离线普通方式部署的博客，现在离线普通方式部署自己操作过几次弄的比较明白了，但是问题是对接方很难完全弄明白，所以也是学习Docker的原因之一吧 Docker学习 Docker概述 Docker安装 Docker命令 镜像命令 容器命令 操作命令 … Docker镜像 容器数据卷 DockerFile Docker网络原理 IDEA整合Docker Docker Compose（集群编排） Docker Swarm（集群管理，简化版k8s） CI/CD Jenkins Docker概述Docker为什么出现一款产品：开发-上线，两套环境！环境部署一次是非常麻烦的，应用环境，应用配置等 开发 —- 运维。问题：我在我的电脑上可以运行！版本更新，导致服务不可用（例如最近的log4j漏洞更新）！对于运维来说比较麻烦 开发即运维！环境配置是十分的麻烦，每一个机器都要部署环境（集群Redis，ES，Hadoop……）！费时费力。 发布一个项目，（jar + （Redis，MySQL，ES，jdk））一整套的环境，项目能不能都带上环境安装打包！ 之前在服务器配置一个应用的环境Redis，MySQL，ES，jdk，Hadoop，配置超麻烦了，不能够跨平台。 Windows，最后发布到Linux，环境上的区别很大 传统：开发给一个jar包，其他交给运维来做 现在：开发打包部署上线，一套流程做完 &nbsp; java – apk – 发布（应用商店） – 张三使用apk – 安装即可用！ java – jar（环境） – 打包项目带上环境（镜像） – （Docker仓库：商店） – 下载我们发布的镜像 – 直接运行即可！ &nbsp; Docker给以上问题提出了解决方案，思想就来自于集装箱！ JRE – 多个应用（端口冲突） – 原来都是交叉的！ 隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的 水果 生化武器 Docker通过隔离机制，可以将服务器利用到极致！ 本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！（Error analyze） &nbsp; Docker的历史API小子哈哈哈哈，我爬了，还是做API小子吧 2013年docker开源，2014.4.9 docker1.0开源，相较于虚拟机非常轻量化。docker是一种容器技术。 虚拟机也是属于虚拟化技术，Docker容器技术也是一种虚拟化技术！ vm：centos等等，隔离，需要开启多个虚拟机！几G docker：隔离，镜像（最核心的环境4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 聊聊docker Docker是基于Go语言开发的！是一个开源项目 www.docker.com docs.docker.com，Docker的文档是非常详细的 仓库地址：hub.docker.com git push, pull等等 虚拟化，容器沙箱机制 Docker能干嘛 之前的虚拟机技术 虚拟机技术缺点： 1、资源占用非常多2、冗余步骤多3、启动很慢 容器化技术 container 容器化技术不是模拟的一个完整的操作系统 比较Docker和虚拟机技术的不同 传统虚拟机，虚拟出一套硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件； 容器内的应用直接运行在宿主机的内核中，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了 每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响 DevOps(开发、运维) 应用更快速的交付和部署 传统：一堆帮助文档，安装程序 Docker：打包镜像发布测试，一键运行 更便捷的升级和扩缩容 使用了docker之后，我们部署应用就像搭积木一样 Redis5，tomcat 分别升级 (redis, tomcat) 打包升级 水平扩展负载均衡 更简单的系统运维 在容器化之后，我们的开发，测试环境都是一致的，不会出现在我的电脑上能用，在别人的电脑上用不了这种情况 更高效的计算资源利用 一个服务器运行几十个redis等等，集群 Docker是内核级别的虚拟化，一个物理机上运行很多个容器实例 Docker的基本组成 分成了三个部分，客户端、服务器、仓库 docker run运行一个哦让你去 docker pull拉取 docker build ….. 镜像运行起来就变成容器了！ tomcat镜像，tomcat1容器，tomcat2容器，等等 镜像（image）： docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 ===&gt; run ===&gt; tomcat01容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的） 容器（container）： Docker利用容器技术，独立运行一个或者一个组应用，通过镜像来创建的 启动，停止，删除，基本命令！ 目前就可以把这个容器理解为就是一个简易的linux系统， 仓库（repository）： 仓库就是存放镜像的地方！ 公有仓库 私有仓库 Docker Hub（默认是国外的） 阿里云，都有容器服务（配置镜像加速）","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[]},{"title":"274场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/274场LeetCode周赛","date":"2022-01-02T14:13:43.000Z","updated":"2022-11-20T01:50:08.886Z","comments":true,"path":"2022/01/02/algorithms/leetcode-weekly-contest/274场LeetCode周赛/","link":"","permalink":"http://example.com/2022/01/02/algorithms/leetcode-weekly-contest/274%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 前三个感觉都是水题，自己做的话感觉难得的10-20分钟就搞定了，因为是后来做的看了眼大佬们最快都做了20多分钟，前三个题这么简单的话第四题估计自己现在的水平很难做出来了； 第一题：一个由ab组成的字符串，如果b出现过了后边就不能出现a了，用一个flag判断就可以了； 第二题：用Counter统计每行1的个数，然后把0的行排除掉，result += count[i] * count[i+1]就可以了； 第三题：还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了； 第四题：未来有机会再试了","text":"周赛综述&amp;总结： 前三个感觉都是水题，自己做的话感觉难得的10-20分钟就搞定了，因为是后来做的看了眼大佬们最快都做了20多分钟，前三个题这么简单的话第四题估计自己现在的水平很难做出来了； 第一题：一个由ab组成的字符串，如果b出现过了后边就不能出现a了，用一个flag判断就可以了； 第二题：用Counter统计每行1的个数，然后把0的行排除掉，result += count[i] * count[i+1]就可以了； 第三题：还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了； 第四题：未来有机会再试了 第一题：2124.检查是否所有A都在B之前题目链接 题目大意给你一个仅由字符&#39;a&#39;和&#39;b&#39;组成的字符串s。如果字符串中 每个&#39;a&#39;都出现在 每个&#39;b&#39;之前，返回true；否则，返回false。 示例1： 12345输入：s = &quot;aaabbb&quot;输出：true解释：&#x27;a&#x27; 位于下标 0、1 和 2 ；而 &#x27;b&#x27; 位于下标 3、4 和 5 。因此，每个 &#x27;a&#x27; 都出现在每个 &#x27;b&#x27; 之前，所以返回 true 。 示例2： 12345输入：s = &quot;abab&quot;输出：false解释：存在一个 &#x27;a&#x27; 位于下标 2 ，而一个 &#x27;b&#x27; 位于下标 1 。因此，不能满足每个 &#x27;a&#x27; 都出现在每个 &#x27;b&#x27; 之前，所以返回 false 。 示例3： 1234输入：s = &quot;bbb&quot;输出：true解释：不存在 &#x27;a&#x27; ，因此可以视作每个 &#x27;a&#x27; 都出现在每个 &#x27;b&#x27; 之前，所以返回 true 。 提示： 1 &lt;= s.length &lt;= 100 s[i] 为 ‘a’ 或 ‘b’ 分析和解答easy题，读懂题意就好 1234567891011121314class Solution(object): def checkString(self, s): &quot;&quot;&quot; :type s: str :rtype: bool &quot;&quot;&quot; flag = False for i, c in enumerate(s): if flag == True and c == &#x27;a&#x27;: return False if c == &#x27;b&#x27;: flag = True return True 第二题：2125.银行中的激光束数量题目链接 题目大意银行内部的防盗安全装置已经激活。给你一个下标从0开始的二进制字符串数组bank，表示银行的平面图，这是一个大小为m x n的二维矩阵。bank[i]表示第i行的设备分布，由若干&#39;0&#39;和若干&#39;1&#39;组成。&#39;0&#39;表示单元格是空的，而&#39;1&#39;表示单元格有一个安全设备。 对任意两个安全设备而言，如果同时满足下面两个条件，则二者之间存在 一个 激光束： 两个设备位于两个 不同行 ：r1和r2，其中r1 &lt; r2。满足r1 &lt; i &lt; r2的所有行i，都没有安全设备。激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。 返回银行中激光束的总数量。 示例1： 12345678910111213输入：bank = [&quot;011001&quot;,&quot;000000&quot;,&quot;010100&quot;,&quot;001000&quot;]输出：8解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束： * bank[0][1] -- bank[2][1] * bank[0][1] -- bank[2][3] * bank[0][2] -- bank[2][1] * bank[0][2] -- bank[2][3] * bank[0][5] -- bank[2][1] * bank[0][5] -- bank[2][3] * bank[2][1] -- bank[3][2] * bank[2][3] -- bank[3][2]注意，第 0 行和第 3 行上的设备之间不存在激光束。这是因为第 2 行存在安全设备，这不满足第 2 个条件。 示例2： 123输入：bank = [&quot;000&quot;,&quot;111&quot;,&quot;000&quot;]输出：0解释：不存在两个位于不同行的设备 提示： m == bank.length n == bank[i].length 1 &lt;= m, n &lt;= 500 bank[i][j] 为 ‘0’ 或 ‘1’ 分析和解答理解题意就比较好做了 123456789101112131415161718class Solution(object): def numberOfBeams(self, bank): &quot;&quot;&quot; :type bank: List[str] :rtype: int &quot;&quot;&quot; result = 0 num_list = [] for item in bank: count = Counter(list(item))[&#x27;1&#x27;] if count != 0: num_list.append(count) # print(num_list) for i in range(len(num_list) - 1): result += num_list[i] * num_list[i+1] return result 第三题：2126.摧毁小行星题目链接 题目大意给你一个整数mass，它表示一颗行星的初始质量。再给你一个整数数组asteroids，其中asteroids[i]是第i颗小行星的质量。 你可以按任意顺序重新安排小行星的顺序，然后让行星跟它们发生碰撞。如果行星碰撞时的质量大于等于小行星的质量，那么小行星被摧毁，并且行星会获得这颗小行星的质量。否则，行星将被摧毁。 如果所有小行星都能被摧毁，请返回true，否则返回false。 示例1： 123456789输入：mass = 10, asteroids = [3,9,19,5,21]输出：true解释：一种安排小行星的方式为 [9,19,5,3,21] ：- 行星与质量为 9 的小行星碰撞。新的行星质量为：10 + 9 = 19- 行星与质量为 19 的小行星碰撞。新的行星质量为：19 + 19 = 38- 行星与质量为 5 的小行星碰撞。新的行星质量为：38 + 5 = 43- 行星与质量为 3 的小行星碰撞。新的行星质量为：43 + 3 = 46- 行星与质量为 21 的小行星碰撞。新的行星质量为：46 + 21 = 67所有小行星都被摧毁。 示例2： 123456输入：mass = 5, asteroids = [4,9,23,4]输出：false解释：行星无论如何没法获得足够质量去摧毁质量为 23 的小行星。行星把别的小行星摧毁后，质量为 5 + 4 + 9 + 4 = 22 。它比 23 小，所以无法摧毁最后一颗小行星。 提示： 1 &lt;= mass &lt;= 105 1 &lt;= asteroids.length &lt;= 105 1 &lt;= asteroids[i] &lt;= 105 分析和解答还是用到了排序，第一次遍历过去的时候可以先不断贪心，然后排序，再一个个加入来判断就行了； 1234567891011121314151617181920212223class Solution(object): def asteroidsDestroyed(self, mass, asteroids): &quot;&quot;&quot; :type mass: int :type asteroids: List[int] :rtype: bool &quot;&quot;&quot; tmp_list = [] for i, item in enumerate(asteroids): if item &lt;= mass: mass += item else: tmp_list.append(item) tmp_list = sorted(tmp_list, reverse=False) for item in tmp_list: if item &lt;= mass: mass += item else: return False return True","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"273场LeetCode周赛","slug":"algorithms/leetcode-weekly-contest/273场LeetCode周赛","date":"2021-12-26T08:16:43.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2021/12/26/algorithms/leetcode-weekly-contest/273场LeetCode周赛/","link":"","permalink":"http://example.com/2021/12/26/algorithms/leetcode-weekly-contest/273%E5%9C%BALeetCode%E5%91%A8%E8%B5%9B/","excerpt":"周赛综述&amp;总结： 第一题：感觉比较水，123400倒过来是004321，再倒回去是1234和原来的数字不一样了，这样其实可以直接判断末尾是不是0，还有是不是单独一个0就可以了； 第二题：矩阵内简单的模拟，up down left right，经过这四个操作后，不能越过矩阵的边界就行了，后缀在python里[i:]好像比较简单； 第三题：在当时做的时候何老板就在想是不是和数学有关的，后来听了卿哥的解答后感觉最关键的是abcde这个思路，这样比较容易可能能想到前缀和后缀的问题了，对于一个数字2，比如其角标在[a, b, c, d, e]五个位置，那么根据题意可以模拟下每个位置下的和，这样能看出来之间的关系，详见下文解答； 第四题：未来有机会再试了；","text":"周赛综述&amp;总结： 第一题：感觉比较水，123400倒过来是004321，再倒回去是1234和原来的数字不一样了，这样其实可以直接判断末尾是不是0，还有是不是单独一个0就可以了； 第二题：矩阵内简单的模拟，up down left right，经过这四个操作后，不能越过矩阵的边界就行了，后缀在python里[i:]好像比较简单； 第三题：在当时做的时候何老板就在想是不是和数学有关的，后来听了卿哥的解答后感觉最关键的是abcde这个思路，这样比较容易可能能想到前缀和后缀的问题了，对于一个数字2，比如其角标在[a, b, c, d, e]五个位置，那么根据题意可以模拟下每个位置下的和，这样能看出来之间的关系，详见下文解答； 第四题：未来有机会再试了； 第一题：2119.反转两次的数字题目链接 题目大意反转一个整数意味着倒置它的所有位。 例如，反转2021得到1202。反转12300得到321，不保留前导零。给你一个整数num，反转num得到reversed1，接着反转reversed1得到reversed2。如果reversed2等于num，返回true；否则，返回false。 示例1： 123输入：num = 526输出：true解释：反转 num 得到 625 ，接着反转 625 得到 526 ，等于 num 。 示例2： 123输入：num = 1800输出：false解释：反转 num 得到 81 ，接着反转 81 得到 18 ，不等于 num 。 示例3： 123输入：num = 0输出：true解释：反转 num 得到 0 ，接着反转 0 得到 0 ，等于 num 。 提示： 0 &lt;= num &lt;= 106 分析和解答这个题感觉不能被题面唬住了，还是判断后边有没有0就可以了，然后单独0的单独处理下； 12345678910111213class Solution(object): def isSameAfterReversals(self, num): &quot;&quot;&quot; :type num: int :rtype: bool &quot;&quot;&quot; if len(str(num)) == 1: return True if str(num)[-1] == &quot;0&quot;: return False else: return True 第二题：2120.执行所有后缀指令题目链接 题目大意现有一个n x n大小的网格，左上角单元格坐标(0, 0)，右下角单元格坐标(n - 1, n - 1)。给你整数n和一个整数数组startPos，其中startPos = [startrow, startcol]表示机器人最开始在坐标为(startrow, startcol)的单元格上。 另给你一个长度为m、下标从0开始的字符串s，其中s[i]是对机器人的第i条指令：&#39;L&#39;（向左移动），&#39;R&#39;（向右移动），&#39;U&#39;（向上移动）和 &#39;D&#39;（向下移动）。 机器人可以从s中的任一第i条指令开始执行。它将会逐条执行指令直到s的末尾，但在满足下述条件之一时，机器人将会停止： 下一条指令将会导致机器人移动到网格外。没有指令可以执行。返回一个长度为m的数组answer，其中answer[i]是机器人从第i条指令 开始 ，可以执行的 指令数目 。 示例1： 123456789输入：n = 3, startPos = [0,1], s = &quot;RRDDLU&quot;输出：[1,5,4,3,1,0]解释：机器人从 startPos 出发，并从第 i 条指令开始执行：- 0: &quot;RRDDLU&quot; 在移动到网格外之前，只能执行一条 &quot;R&quot; 指令。- 1: &quot;RDDLU&quot; 可以执行全部五条指令，机器人仍在网格内，最终到达 (0, 0) 。- 2: &quot;DDLU&quot; 可以执行全部四条指令，机器人仍在网格内，最终到达 (0, 0) 。- 3: &quot;DLU&quot; 可以执行全部三条指令，机器人仍在网格内，最终到达 (0, 0) 。- 4: &quot;LU&quot; 在移动到网格外之前，只能执行一条 &quot;L&quot; 指令。- 5: &quot;U&quot; 如果向上移动，将会移动到网格外。 示例2： 1234567输入：n = 2, startPos = [1,1], s = &quot;LURD&quot;输出：[4,1,0,0]解释：- 0: &quot;LURD&quot;- 1: &quot;URD&quot;- 2: &quot;RD&quot;- 3: &quot;D&quot; 示例3： 123输入：n = 1, startPos = [0,0], s = &quot;LRUD&quot;输出：[0,0,0,0]解释：无论机器人从哪条指令开始执行，都会移动到网格外。 提示： m == s.length 1 &lt;= n, m &lt;= 500 startPos.length == 2 0 &lt;= startrow, startcol &lt; n s 由 ‘L’、’R’、’U’ 和 ‘D’ 组成 分析和解答比较水，实际上是简单题，执行就可以了，后缀执行用s[:i]截断就可以了，边界的判断就像dfs couting lakes的判断一样 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def executeInstructions(self, n, startPos, s): &quot;&quot;&quot; :type n: int :type startPos: List[int] :type s: str :rtype: List[int] &quot;&quot;&quot; matrix = [[0 for i in range(n)] for j in range(n)] cnt = [0 for i in range(len(s))] for i in range(len(s)): startX = startPos[0] startY = startPos[1] tmp_seq = s[i:] # print(cnt) for j, c in enumerate(tmp_seq): if c == &#x27;L&#x27;: if startY - 1 &gt;= 0: startY = startY - 1 cnt[i] += 1 else: break elif c == &#x27;R&#x27;: if startY + 1 &lt; n: startY = startY + 1 cnt[i] += 1 else: break elif c == &#x27;U&#x27;: if startX - 1 &gt;= 0: startX = startX - 1 cnt[i] += 1 else: break elif c == &#x27;D&#x27;: if startX + 1 &lt; n: startX = startX + 1 cnt[i] += 1 else: break return cnt 第三题：2121.相同元素的间隔之和题目链接 题目大意给你一个下标从0开始、由n个整数组成的数组arr。 arr 中两个元素的 间隔 定义为它们下标之间的绝对差。更正式地，arr[i]和arr[j]之间的间隔是|i - j|。 返回一个长度为n的数组intervals，其中intervals[i]是arr[i]和arr中每个相同元素（与arr[i]的值相同）的间隔之和。 注意：|x|是x的绝对值。 示例1： 12345678910输入：arr = [2,1,3,1,2,3,3]输出：[4,2,7,2,4,4,5]解释：- 下标 0 ：另一个 2 在下标 4 ，|0 - 4| = 4- 下标 1 ：另一个 1 在下标 3 ，|1 - 3| = 2- 下标 2 ：另两个 3 在下标 5 和 6 ，|2 - 5| + |2 - 6| = 7- 下标 3 ：另一个 1 在下标 1 ，|3 - 1| = 2- 下标 4 ：另一个 2 在下标 0 ，|4 - 0| = 4- 下标 5 ：另两个 3 在下标 2 和 6 ，|5 - 2| + |5 - 6| = 4- 下标 6 ：另两个 3 在下标 2 和 5 ，|6 - 2| + |6 - 5| = 5 示例2： 1234567输入：arr = [10,5,10,10]输出：[5,0,3,4]解释：- 下标 0 ：另两个 10 在下标 2 和 3 ，|0 - 2| + |0 - 3| = 5- 下标 1 ：只有这一个 5 在数组中，所以到相同元素的间隔之和是 0- 下标 2 ：另两个 10 在下标 0 和 3 ，|2 - 0| + |2 - 3| = 3- 下标 3 ：另两个 10 在下标 0 和 2 ，|3 - 0| + |3 - 2| = 4 提示： n == arr.length 1 &lt;= n &lt;= 105 1 &lt;= arr[i] &lt;= 105 分析和解答思路还是很巧妙的，假设一个[a, b, c, d, e]角标数组，现在要统计c这个位置下的角标绝对差，那么这个位置上就是(c-a) + (c-b) + (d-c) + (e-c)，如果要统计 + (d-b) + (d-c) + (e-d)```，这样：1234567891011121314151617181920212223242526272829303132333435363738394041424344- 在```c```的位置下看规律，前缀（left_sum）是```a+b```，后缀（right_sum）是```d+e```，求和是：```(c-a) + (c-b) + (d-c) + (e-c)```- 在```d```的位置下看规律，前缀（left_sum）是```a+b+c```，后缀（right_sum）是```e```，求和是：```(d-a) + (d-b) + (d-c) + (e-d)```这样感觉可以总结出来规律了，在哪个角标x位置，就是：``` ((x * 前缀个数) - 前缀) + (后缀 - (x * 后缀个数))```，这样前缀后缀可以通过一种类似于滑动窗口的方法更新，大大减少了时间复杂度。```pythonclass Solution(object): def getDistances(self, arr): &quot;&quot;&quot; :type arr: List[int] :rtype: List[int] &quot;&quot;&quot; return_list = [0 for i in range(len(arr))] # 把arr转化为一个map，类似于3: [2, 5, 6]这样的，前边是数值，后边是数值的角标 tmp_dict = &#123;&#125; # &#123;1: [1, 3], 2: [0, 4], 3: [2, 5, 6]&#125; for i, item in enumerate(arr): if tmp_dict.get(arr[i]) is None: tmp_dict[arr[i]] = [i] else: tmp_dict[arr[i]].append(i) for key, value in tmp_dict.items(): # 在每个value中，使用 a b c d e的思想 left_sum = 0 left_cnt = 0 right_sum = 0 right_cnt = 0 for i in range(0, len(value)): right_sum += value[i] right_cnt += 1 for i in range(len(value)): # 滑动窗口的感觉 right_sum -= value[i] right_cnt -= 1 return_list[value[i]] = (right_sum - (right_cnt * value[i])) + (left_cnt * value[i] - left_sum) left_sum += value[i] left_cnt += 1 return return_list","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"709.转换成小写字母-python","slug":"algorithms/leetcode-python/709-转换成小写字母-python","date":"2021-12-19T09:42:38.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2021/12/19/algorithms/leetcode-python/709-转换成小写字母-python/","link":"","permalink":"http://example.com/2021/12/19/algorithms/leetcode-python/709-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D-python/","excerpt":"709.转换成小写字母（简单） 题目大意： 给你一个字符串s，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。","text":"709.转换成小写字母（简单） 题目大意： 给你一个字符串s，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。 题目题目链接 给你一个字符串s，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。 示例1： 12输入：s = &quot;Hello&quot;输出：&quot;hello&quot; 示例2： 12输入：s = &quot;here&quot;输出：&quot;here&quot; 示例3： 12输入：s = &quot;LOVELY&quot;输出：&quot;lovely&quot; 分析和解答主要是python语言的转小写，str.lower() 1234567class Solution(object): def toLowerCase(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; return s.lower()","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"200.岛屿数量-python","slug":"algorithms/leetcode-python/200-岛屿数量-python","date":"2021-12-17T01:51:06.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/17/algorithms/leetcode-python/200-岛屿数量-python/","link":"","permalink":"http://example.com/2021/12/17/algorithms/leetcode-python/200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-python/","excerpt":"200.岛屿数量（中等） 题目大意： 给你一个由&#39;1&#39;（陆地）和&#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。","text":"200.岛屿数量（中等） 题目大意： 给你一个由&#39;1&#39;（陆地）和&#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 题目题目链接 给你一个由&#39;1&#39;（陆地）和&#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例1： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]]输出：1 示例2： 1234567输入：grid = [ [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;], [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]]输出：3 提示： m == grid.length n == grid[i].length 1 &lt;= m, n &lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39; 分析和解答poj2386 Couting Lake的模板题目链接 走到每个位置上dfs，dfs不需要回溯所以很简单，就是把grid的所有状态修改了，这个题做过比较多次了比较熟悉了 12345678910111213141516171819202122class Solution(object): def numIslands(self, grid): &quot;&quot;&quot; :type grid: List[List[str]] :rtype: int &quot;&quot;&quot; def dfs(x, y): grid[x][y] = &quot;0&quot; dx = [1, 0, -1, 0] dy = [0, 1, 0, -1] for i in range(4): nx = x + dx[i] ny = y + dy[i] if 0 &lt;= nx &lt; len(grid) and 0 &lt;= ny &lt; len(grid[0]) and grid[nx][ny] == &quot;1&quot;: dfs(nx, ny) cnt = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == &quot;1&quot;: cnt += 1 dfs(i, j) return cnt","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"并查集","slug":"并查集","permalink":"http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"312.戳气球-python","slug":"algorithms/leetcode-python/312-戳气球-python","date":"2021-12-16T15:42:30.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/16/algorithms/leetcode-python/312-戳气球-python/","link":"","permalink":"http://example.com/2021/12/16/algorithms/leetcode-python/312-%E6%88%B3%E6%B0%94%E7%90%83-python/","excerpt":"312.戳气球（困难） 题目大意： 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。","text":"312.戳气球（困难） 题目大意： 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 题目题目链接 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 示例1： 12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 示例2： 12输入：nums = [1,5]输出：10 提示： n == nums.length 1 &lt;= n &lt;= 500 0 &lt;= nums[i] &lt;= 100 分析和解答这个题在没有见过之前几乎很难想到这个dp的思路，二维dp[i][j]数组代表的含义是，在开区间(i, j)之间所能获得的最大金币数。 注意dp数组的初始化，避免深浅拷贝问题！ 1dp = [[0 for i in range(len(nums))] for j in range(len(nums))] # 避免深浅拷贝问题 想到状态转移的递推关系，戳爆最后一个气球的时候，最后一个气球必然两边都是空的，也就是题目中说如果「如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球」，这个时候的状态，也就是dp[0][len(nums)-1]（注意这里的nums已经经过扩充，nums.insert(0, 1)，nums.insert(len(nums), 1)。 想在最后一个状态的状态转移方程，dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]，这里想法是要遍历k在整个区间上，找到一个最大的赋值给dp[0][len(nums)-1]。经过这个状态转移方程后，感觉可以慢慢想到是一种自底向上的动态规划策略，由于是开区间(i, j)，所以最小的窗口要从3开始，到len(nums)这个长度为止。然后用每个长度的窗口3、4 … len(nums)在上边滑动。循环整体结构如下所示 1234# 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间for window_size in range(2, len(nums)): # 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值 for i in range(0, len(nums)-window_size): 在每次的循环内部，需要计算dp[i][i+window_size]的值，这个就是上文中分析的开区间(i, j)之间能获得的最大金币数，遍历for k in range(i+1, j)，使用状态转移方程dp[0][len(nums)-1] = dp[0][k] + dp[0]*dp[k]*dp[len(nums)-1] + dp[k][len(nums)-1]，在不断的循环中窗口会扩大，也会自底向上。 完整解答如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution(object): def maxCoins(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; &quot;&quot;&quot; 自底向上动态规划感觉可以算非常经典的题目了？ 如果能想到dp数组的含义感觉还是可以理解的，但是感觉这个dp数组的含义实在不太好想 假设 dp[i][j] 表示【【【开区间】】】 (i,j) 内你能拿到的最多金币 想到这个递推的关系，删除【【【最后】】】一个气球k的时候，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j] 再加上这个题说如果i-1，i+1超出了数组的时候，就当他是一个数字为1的气球 所以如果在开始和最后补充上两个1的话，在新的数组上开区间(0, len(nums)-1)所能拿到的最大值，就是最终的状态了 这个状态在递推下，就等于最后一个删除的气球k，dp[i][k] + num[i]*num[j]*num[k] + dp[k][j]，有一种分而治之的思想 由于是开区间，所以最小的长度为3才可以，也或许是先想出上边的递推公式后，再来看dp的思路，dp数组的含义是什么了，感觉还是得想状态转移 最后来看的话，这个题是一个自底向上的动态规划问题，要首先找到小区间的，例如对于一个长度为3的开区间，永远就是当前窗口中间的那个数字 解法的话按照答案的思路写了一遍，答案还是有很多内容需要注意到的 - 包括区间不要让角标超出限制 - 还有range_best中的ij参数是代表开区间，所以在遍历的时候for k in range(i+1, j)就可以这样的 &quot;&quot;&quot; def get_range_best(i, j): max_value = 0 for k in range(i+1, j): tmp_value = dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j] max_value = max(max_value, tmp_value) dp[i][j] = max_value nums.insert(0, 1) nums.insert(len(nums), 1) dp = [[0 for i in range(len(nums))] for j in range(len(nums))] # 由于是自底向上的思想，要让这个开区间不断扩大，[2, len(nums))，注意是左闭右开区间 for window_size in range(2, len(nums)): # 在当前的窗口大小下，把整个数组过一遍，自底向上来不断修改dp中的值 for i in range(0, len(nums)-window_size): get_range_best(i, i+window_size) # 这个函数的作用是，找到在i, i+window_size这个开区间中，最大的那一个值，窗口大小是3（window_size=2时，就是那个值） # print(dp) # assert False return dp[0][len(nums)-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"}]},{"title":"72.编辑距离-python","slug":"algorithms/leetcode-python/72-编辑距离-python","date":"2021-12-16T14:52:36.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2021/12/16/algorithms/leetcode-python/72-编辑距离-python/","link":"","permalink":"http://example.com/2021/12/16/algorithms/leetcode-python/72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-python/","excerpt":"72.编辑距离（困难） 题目大意： 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符","text":"72.编辑距离（困难） 题目大意： 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 题目题目链接 给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例1： 123456输入：word1 = &quot;horse&quot;, word2 = &quot;ros&quot;输出：3解释：horse -&gt; rorse (将 &#x27;h&#x27; 替换为 &#x27;r&#x27;)rorse -&gt; rose (删除 &#x27;r&#x27;)rose -&gt; ros (删除 &#x27;e&#x27;) 示例2： 12345678输入：word1 = &quot;intention&quot;, word2 = &quot;execution&quot;输出：5解释：intention -&gt; inention (删除 &#x27;t&#x27;)inention -&gt; enention (将 &#x27;i&#x27; 替换为 &#x27;e&#x27;)enention -&gt; exention (将 &#x27;n&#x27; 替换为 &#x27;x&#x27;)exention -&gt; exection (将 &#x27;n&#x27; 替换为 &#x27;c&#x27;)exection -&gt; execution (插入 &#x27;u&#x27;) 提示： 0 &lt;= word1.length, word2.length &lt;= 500 word1 和 word2 由小写英文字母组成 题目分析和解答二维dp的题目，想象两个单词word1和word2，二维dp的每个位置上，代表word1的i位置处，和word2的j位置处情况下，多少次变换能达到是一样的情况； 个人习惯上把word1作为行来放置，把word2作为列来放置； 由于word1和word2都可能为空，所以在初始化二维dp数组的时候，行和列要分别是len(word1)+1和len(word2)+1，初始化dp数组的第一行第一列，想象i到j的这个顺序，第一列dp[i][0]代表word1在当前的情况下经过多少次操作能变成空，所以这个数值就等于i；第一行dp[0][i]就是代表空字符串经过多少次能变到word2的当前这个位置上。 现在初始化好了dp数组的第一行第一列，下边就来想状态转移这个方程，也是这个题目每次复习的时候需要想到的部分，dp[i][j]可以由dp[i-1][j-1]，dp[i-1][j]，dp[i][j-1]得到： dp[i-1][j-1]到dp[i][j]的操作是修改，注意修改这个操作需要判断word1 i位置处的值和word2 j位置处的值是不是相等的，如果相等的话则不需要修改，如果是不相等的话则需要修改，也就是dp[i-1][j-1]+1； dp[i][j-1]到dp[i][j]的操作是删除，想象最左上角的三个块，ij代表word1变到word2的这一种感觉。执行删除的情况下，状态转移后必然是dp[i][j]=dp[i][j-1]+1； dp[i-1][j]到dp[i][j]的操作是新增，同样是想象最左上角的三个块。执行新增的情况下，状态转移后必然是dp[i][j]=dp[i-1][j]+1 经过如上分析后，在每次判断时先判断是不是相等，如果相等的话，可以走dp[i][j]=dp[i-1][j-1]，代表不需要修改。如果是不相等的话就需要对三种情况进行min判断，dp[i][j]=min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1 经过上述循环后，因为在最开始前边补充的字符串为空的长度情况，所以dp[len(word1)][len(word2)]就可以了。 123456789101112131415161718192021222324252627282930313233class Solution(object): def minDistance(self, word1, word2): &quot;&quot;&quot; :type word1: str :type word2: str :rtype: int &quot;&quot;&quot; &quot;&quot;&quot; 二维dp的题目，dp数组代表，word1的前i个字符，和word2的前j个字符，需要几次修改可以变成一样的 回想题解里给出的那张图，要分别想到word1，word2为空字符串的情况 空串情况下的初始化状态比较容易想，一个字符串变成空串，就是这个字符串的长度的次数 &quot;&quot;&quot; # 初始化dp数组状态，word1在行维度上，word2在列维度上 dp = [[0 for i in range(len(word2)+1)] for j in range(len(word1)+1)] # 注意深浅拷贝的问题，这个还挺坑的，只能这么初始化数组 for i in range(len(word1)+1): dp[i][0] = i for i in range(len(word2) + 1): dp[0][i] = i # 假设每个地方想象的是从竖着的word1变到横着的word2的状态，那么[i-1][j-1]代表替换，[i-1][j]代表插入，[i][j-1]代表删除（想初始状态即可） # 如果当前两个字符相等的情况下，保持不变（即不做修改[i-1][j-1]的状态）一定是最优的，因为无论增加或减少，则一定还需要1次操作 # 而如果当前两个字符不等的情况，则由删除，增加，修改三种之最小的+1次操作得到 for i in range(1, len(word1)+1): for j in range(1, len(word2)+1): if word1[i-1] == word2[j-1]: dp[i][j] = dp[i-1][j-1] else: dp[i][j] = min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) +1 return dp[len(word1)][len(word2)]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"}]},{"title":"11.盛最多水的容器-python","slug":"algorithms/leetcode-python/11-盛最多水的容器-python","date":"2021-12-15T10:48:09.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/15/algorithms/leetcode-python/11-盛最多水的容器-python/","link":"","permalink":"http://example.com/2021/12/15/algorithms/leetcode-python/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-python/","excerpt":"11.盛最多水的容器（中等） 题目大意： 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。","text":"11.盛最多水的容器（中等） 题目大意： 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 题目题目链接 给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器。 示例1： 123输入：[1,8,6,2,5,4,8,3,7]输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例2： 12输入：height = [1,1]输出：1 示例3： 12输入：height = [4,3,2,1,4]输出：16 示例4： 12输入：height = [1,2,1]输出：2 提示： n == height.length 2 &lt;= n &lt;= 105 0 &lt;= height[i] &lt;= 104 分析与解答O(n^2)的方法很会超时 对上述方法采用双指针进行优化，整体性的思路如下： 在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i) min(a[i], a[j]) * (j-i) 由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小 所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板（贪心的思想应该隐含在这里了） 123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def maxArea(self, height): &quot;&quot;&quot; :type height: List[int] :rtype: int &quot;&quot;&quot; # O(n^2) time limit了 &quot;&quot;&quot; max_water = 0 for i in range(len(height)): for j in range(i, len(height)): max_water = max(max_water, (j-i)*min(height[i], height[j])) return max_water &quot;&quot;&quot; &quot;&quot;&quot; 对上述方法采用双指针进行优化，整体性的思路如下： 在整体上一定存在一个长板和一个短板，初始化下的面积为 短板高度 * (j-i) 由于水桶的容量是收到短板影响的，所以怎么“往内”移动长板都是没用的，要么是还受到现在的短板作用，要么是只会找到一个比现在短板更短的短板，由于是往内移动的，所以只会进一步缩小 所以要把短板往内移动，每次移动的时候记录当前的值并进行比较，注意在移动的过程中要更新短板 &quot;&quot;&quot; if len(height) &lt; 2: return 0 i = 0 j = len(height) - 1 max_water = (j-i) * min(height[i], height[j]) while i &lt; j: if height[i] &lt;= height[j]: # 等号随便给一边就可以了 while i &lt; j and height[i] &lt;= height[j]: max_water = max(max_water, (j-i) * min(height[i], height[j])) i += 1 else: while j &gt; i and height[j] &lt;= height[i]: max_water = max(max_water, (j-i) * min(height[i], height[j])) j -= 1 return max_water","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"15.三数之和-python","slug":"algorithms/leetcode-python/15-三数之和-python","date":"2021-12-15T09:46:36.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/15/algorithms/leetcode-python/15-三数之和-python/","link":"","permalink":"http://example.com/2021/12/15/algorithms/leetcode-python/15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-python/","excerpt":"15.三数之和（中等） 题目大意： 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。","text":"15.三数之和（中等） 题目大意： 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 题目题目链接 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例1： 12输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]] 示例2： 12输入：nums = []输出：[] 示例3： 12输入：nums = [0]输出：[] 提示： 0 &lt;= nums.length &lt;= 3000 -105 &lt;= nums[i] &lt;= 105 分析和解答O(n^3)是一种最容易想到的解法，但是会超时。 外层i，内层双指针+移动位置，移动位置主要是为去重的，每次ijk都要移动到下一个不一样的，指针的移动这里要模拟do-while循环，这个非常关键 既然是要求和为0，可以想到进行排序O(nlogn)，从小到大。之后的思路感觉是一种O(n^2)的思路，设立ijk i代表：一个基准的数字，可以看做jk位置处的数字加起来要等于-i位置处的数字 j，k代表：在i后边的数字序列中，j从头开始，k从尾开始，这样根据加了后的关系可以判断是j该往后移动还是k该往前移动 由于题目中要求答案中不可以包含重复的三元组，这里就是题目里代码实现起来很容易出错的部分了，i，j，k在每次遍历的时候都要走到下一个不一样的地方去，这里感觉有一种do-while循环的感觉 1234# 在如下的操作下，j最终会停在不相等的位置上j += 1while j &lt; k and nums[j] == nums[j-1]: j += 1 要分加起来等于0，小于0，大于0三个讨论，其中等于0的情况jk一起移动 有剪枝操作，在排序了后如果i位置处都大于0了，那么就可以结束了 解答如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution(object): def threeSum(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: List[List[int]] &quot;&quot;&quot; &quot;&quot;&quot; # O(n^3)，其中tuple这个操作用来去重用，tuple是可哈希化的，这种方法超时了 rlist = [] for i in range(len(nums)): for j in range(i+1, len(nums)): for k in range(j+1, len(nums)): if nums[i] + nums[j] + nums[k] == 0: tmplist = sorted([nums[i], nums[j], nums[k]]) rlist.append(tuple(tmplist)) temp = list(set(rlist)) return [[x[0], x[1], x[2]] for x in temp] &quot;&quot;&quot; # 优化方法 # O(nlogn)排序+ O(n^2)双指针，一前一后，跳过后 rlist = [] nums = sorted(nums) for i in range(len(nums)-2): # 学习题解中的剪枝操作 if nums[i] &gt; 0: break if i &gt; 0 and nums[i] == nums[i-1]: # 三元组不能重复，注意python的-1问题 continue j = i + 1 k = len(nums) - 1 while j &lt; k: if nums[i] + nums[j] + nums[k] == 0: rlist.append([nums[i], nums[j], nums[k]]) # print(rlist) # j移动到下一个不一样的 j += 1 while j &lt; k and nums[j] == nums[j-1]: j += 1 k -= 1 while k &gt; j and nums[k] == nums[k+1]: k -= 1 elif nums[i] + nums[j] + nums[k] &gt; 0: # 太大了，k往左移动到一个不一样的 k -= 1 while k &gt; j and nums[k] == nums[k+1]: k -= 1 else: # 模拟do-while循环 j += 1 while j &lt; k and nums[j] == nums[j-1]: j += 1 return rlist","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"146.LRU缓存机制-python","slug":"algorithms/leetcode-python/146-LRU缓存机制-python","date":"2021-12-15T03:43:06.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/15/algorithms/leetcode-python/146-LRU缓存机制-python/","link":"","permalink":"http://example.com/2021/12/15/algorithms/leetcode-python/146-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-python/","excerpt":"146.LRU缓存机制（中等） 题目大意： 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？","text":"146.LRU缓存机制（中等） 题目大意： 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ 题目题目链接 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例： 1234567891011121314151617输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示： 1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 最多调用 2 * 105 次 get 和 put 解答与分析这个题实在是太经典了，而且是自己面试过程中真正被问到而没有做出来的题目，首先第一步要根据题目所给出的内容自定义LRUCache类，也借此进一步熟悉语法。 自定义LRUCache类1234567891011121314class LRUCache(object): def __init__(self, capacity): self.capacity = capacity def get(self, key): &quot;&quot;&quot; rtype: int &quot;&quot;&quot; pass def put(self, key, value): &quot;&quot;&quot; rtype: None &quot;&quot;&quot; 使用双向链表来完成题目要求的操作时间复杂度要求题目中要求的O(1)时间复杂度下完成各个操作，主要靠的是cache词典和双向链表中的一些操作，缓存（cache）在这个题中十分关键 首先搞起来双向链表的基本模板 123456class BiLinkedList(object): def __init__(self, key=-1, val=-1, prev=None, next=None): self.key = key self.val = val self.prev = prev self.next = next LRUCache __init__中需要初始化的内容按照题目一步步的来分析，首先分析需要哪些内容放在LRUcatch的init中，首先是题目中给了的capacity代表这个LRU cache的最大容量，之后是一个为0的current_size代表当前LRU cache的容量，之后可以根据做一些特殊的判断。还有就是一个词典的cache，代表有哪些已经在LRUcache中了，这里最关键的是记住这个cache中存储的是key-node的mapping。还有就是初始化一个双向链表，注意这个双向链表的头和尾虽然直接初始化了，但是这两个节点并没有什么含义，所以head.next和tail.prev中间这些的才感觉是有用的。 12345678910class LRUCache(object): def __init__(self, capacity): self.capacity = capacity self.current_size = 0 self.cache = &#123;&#125; self.head = BiLinkedList() self.tail = BiLinkedList() self.head.next = self.tail self.tail.prev = self.head 分析LRUCache中的插入（put）操作和查找（get）操作插入（put）插入给了一个key和一个value。 首先判断key是不是已经在cache中了 如果已经在cache中了 在cache中删除这个key对应的node，然后把这个节点的更新值头插法搞到链表的最前边去。这里体现了双向链表的作用还有cache中key-node mapping的作用，，mapping找到一个node后，基于双向链表可完成O(1)的删除 如果不在的话 首先判断目前的self.current_size和self.capacity的关系， 如果相等了，则删除目前双向链表尾部的，之后用头插法在前边插入上。 如果self.current_size小于self.capacity，直接在头部插入后，self.capacity++就可以了 查找（get）查找只给了一个key，返回这个key对应的value，如果找不到就返回-1 这个直接从cache中找就可以了，但是注意查找到的同样要删除，并且头插法到最前边来 双向链表操作函数的编写综上所述，在该题中需要双向链表的三种操作：（注意这里只管链表的操作，是否能执行这些操作的判断在其他地方试） ①头插法 ②尾部删除：特别注意这里的尾部删除，在超出capacity的时候会执行尾部删除，这个时候要拿到尾部删除后的node，以便从cache中将其移除！！！！！！！！ ③中间删除 下边这些实现还要经常复习，主要是涉及顺序 123456789101112131415161718192021222324252627282930def add_to_head(self, node): &quot;&quot;&quot; 双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入 注意这里，是插入到虚拟head之后的一个 &quot;&quot;&quot; node.next = self.head.next node.prev = self.head self.head.next.prev = node self.head.next = node def remove_tail(self): &quot;&quot;&quot; 双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除 注意这里，是删除虚拟尾结点前边的一个！ &quot;&quot;&quot; temp = self.tail.prev self.tail.prev = self.tail.prev.prev self.tail.prev.next = self.tail temp.next = None temp.prev = None return tempdef remove_inter(self, node): &quot;&quot;&quot; 双向链表的中间节点删除 &quot;&quot;&quot; node.prev.next = node.next node.next.prev = node.prev 工具都造好了，最终整体上的代码实现如下，还要经常复习啊123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108&quot;&quot;&quot;使用双向链表的原因是因为双向链表的删除可以做到O(1)？也或许还有其他特性！注意题目中的关键字key存在于缓存中，要拿到关键字的值，也就是一个key-value的关系，一定要注意这个&quot;&quot;&quot;class BiLinkedList(object): def __init__(self, key=-1, value=-1, prev=None, next=None): self.key = key self.value = value self.prev = prev self.prev = nextclass LRUCache(object): def __init__(self, capacity): &quot;&quot;&quot; :type capacity: int &quot;&quot;&quot; self.capacity = capacity self.current_size = 0 self.cache = &#123;&#125; # 这个mapping是key -&gt; node！！ # 创建一个初始的头和一个初始的尾 self.head = BiLinkedList() self.tail = BiLinkedList() self.head.next = self.tail self.tail.prev = self.head def add_to_head(self, node): &quot;&quot;&quot; 双向链表的头插法，current_size 和 cache的变化不在这里做，这里只管插入 注意这里，是插入到虚拟head之后的一个 &quot;&quot;&quot; node.next = self.head.next node.prev = self.head self.head.next.prev = node self.head.next = node def remove_tail(self): &quot;&quot;&quot; 双向链表的删除尾，current_size 和 cache的变化不在这里做，这里只管删除 注意这里，是删除虚拟尾结点前边的一个！ &quot;&quot;&quot; temp = self.tail.prev self.tail.prev = self.tail.prev.prev self.tail.prev.next = self.tail temp.next = None temp.prev = None return temp def remove_inter(self, node): &quot;&quot;&quot; 双向链表的中间节点删除 &quot;&quot;&quot; node.prev.next = node.next node.next.prev = node.prev def get(self, key): &quot;&quot;&quot; :type key: int :rtype: int # 注意get的时候，要把这个地方挪到最前边，因为LRU访问的时候要挪到前边来 &quot;&quot;&quot; if self.cache.get(key) is None: return -1 else: node = self.cache.get(key) self.remove_inter(node) self.add_to_head(node) return node.value def put(self, key, value): &quot;&quot;&quot; :type key: int :type value: int :rtype: None &quot;&quot;&quot; if self.cache.get(key) is None: &quot;&quot;&quot; 需要头插入，如果插入后长度超过了capacity，就要进行尾部删除 cache需要变动 &quot;&quot;&quot; node = BiLinkedList(key=key, value=value) self.add_to_head(node) self.current_size += 1 self.cache[key] = node if self.current_size &gt; self.capacity: # 超出容量了，要删除，同时cache也要删除 temp = self.remove_tail() del self.cache[temp.key] else: &quot;&quot;&quot; 已经有了，拿到一个node，需要先删除，然后挪到最前边 cache不需要变动 &quot;&quot;&quot; node = self.cache.get(key) self.remove_inter(node) node = BiLinkedList(key=key, value=value) # 更新val值 self.cache[key] = node self.add_to_head(node)# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"双向链表","slug":"双向链表","permalink":"http://example.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"}]},{"title":"383.赎金信-python","slug":"algorithms/leetcode-python/383-赎金信-python","date":"2021-12-14T06:06:29.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/14/algorithms/leetcode-python/383-赎金信-python/","link":"","permalink":"http://example.com/2021/12/14/algorithms/leetcode-python/383-%E8%B5%8E%E9%87%91%E4%BF%A1-python/","excerpt":"383.赎金信（简单） 题目大意： 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。","text":"383.赎金信（简单） 题目大意： 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 题目题目链接 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例1： 12输入：ransomNote = &quot;a&quot;, magazine = &quot;b&quot;输出：false 示例2： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;输出：false 示例3： 12输入：ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;输出：true 提示： 1 &lt;= ransomNote.length, magazine.length &lt;= 105 ransomNote 和 magazine 由小写英文字母组成 分析和解答python中Counter的妙用，Counter是可以相减的！ 所以说如果在ransomNote中，减掉magazine后是空的，就代表可以组成的 12345678910class Solution(object): def canConstruct(self, ransomNote, magazine): &quot;&quot;&quot; :type ransomNote: str :type magazine: str :rtype: bool &quot;&quot;&quot; c1 = Counter(ransomNote) c2 = Counter(magazine) return c1 - c2 == Counter(&quot;&quot;)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"}]},{"title":"139.单词拆分-python","slug":"algorithms/leetcode-python/139-单词拆分-python","date":"2021-12-13T16:12:45.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/14/algorithms/leetcode-python/139-单词拆分-python/","link":"","permalink":"http://example.com/2021/12/14/algorithms/leetcode-python/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-python/","excerpt":"139.单词拆分（中等） 题目大意：给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。","text":"139.单词拆分（中等） 题目大意：给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。 题目题目链接 给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。 说明：拆分时可以重复使用字典中的单词。 示例1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 提示： 1 &lt;= s.length &lt;= 300 1 &lt;= wordDict.length &lt;= 1000 1 &lt;= wordDict[i].length &lt;= 20 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中的所有字符串 互不相同 分析和解答这个题在没见过之前想到dp还是挺难的，这里使用的是一维dp数组，其数组的含义是，当前这个位置下，能否被拆分成多个字典中的词 dp的状态转移方程想法是，从这个位置之前逐个遍历 要么是0到这个位置能构成一个单词 要么是之前一个能构成字典中单词的位置，到现在这个位置之间的词也在字典中 重点也是要特殊处理如下j==0的情况，另外列表截取的左闭右开 这个题要用dp的思路，这个感觉是最难想的，dp的每个位置代表当前位置，是否所有单词都能包含在词典中；；；对于一个位置，如果之前出现过能包含在词典中的（dp[j]==True），并且j到i（[j+1: i+1]）也在词典里，那么这个位置就是在的；；；注意按照这种思路，可能需要处理一些0的特殊情况 123456789101112131415161718192021222324252627282930313233class Solution(object): def wordBreak(self, s, wordDict): &quot;&quot;&quot; :type s: str :type wordDict: List[str] :rtype: bool &quot;&quot;&quot; # 这个题很难看出是dp的思路了，一眼看过去还以为是Trie树，KMP这样的 # dp数组代表的含义是，当前这个位置下，[能否](bool)被拆分成多个字典词 if len(s) == 0: return False dp = [False for i in range(len(s))] # 当前这个位置下，能否全部在词典中出现 for i in range(len(s)): # 如果i为0的情况 if i == 0: if s[i] in wordDict: dp[i] = True else: # 对于一个位置判断是否能全部在词典中出现，等于前一个能出现的位置 and 那个位置到这个位置之间能不能出现 for j in range(i): if j == 0 and s[: i+1] in wordDict: dp[i] = True break # j == 0没法走到这个情况 if dp[j] is True and s[j+1: i+1] in wordDict: dp[i] = True break # print(dp) return dp[len(s)-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"198.打家劫舍-python","slug":"algorithms/leetcode-python/198-打家劫舍-python","date":"2021-12-13T15:15:28.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/13/algorithms/leetcode-python/198-打家劫舍-python/","link":"","permalink":"http://example.com/2021/12/13/algorithms/leetcode-python/198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-python/","excerpt":"198.打家劫舍（中等） 题目大意：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。","text":"198.打家劫舍（中等） 题目大意：你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 题目题目链接 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。 示例1： 1234输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例2： 1234输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 400 解答与分析这个题dp的还是比较明显的，感觉可以算简单题了dp[i] = max(dp[i-1], s[i] + dp[i-2]) 1234567891011121314class Solution(object): def rob(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if len(nums) == 1: return nums[0] dp = [0 for i in range(len(nums))] dp[0] = nums[0] dp[1] = max(nums[0], nums[1]) for i in range(2, len(nums)): dp[i] = max(dp[i-1], dp[i-2] + nums[i]) return dp[len(nums)-1]","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"1446.连续字符-python","slug":"algorithms/leetcode-python/1446-连续字符-python","date":"2021-12-13T14:35:08.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/13/algorithms/leetcode-python/1446-连续字符-python/","link":"","permalink":"http://example.com/2021/12/13/algorithms/leetcode-python/1446-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6-python/","excerpt":"1446.连续字符（简单） 题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。","text":"1446.连续字符（简单） 题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。 题目题目链接 题目大意：给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。请你返回字符串的能量。 示例1： 123输入：s = &quot;leetcode&quot;输出：2解释：子字符串 &quot;ee&quot; 长度为 2 ，只包含字符 &#x27;e&#x27; 。 示例2： 123输入：s = &quot;abbcccddddeeeeedcba&quot;输出：5解释：子字符串 &quot;eeeee&quot; 长度为 5 ，只包含字符 &#x27;e&#x27; 。 示例3： 12输入：s = &quot;triplepillooooow&quot;输出：5 示例4： 12输入：s = &quot;hooraaaaaaaaaaay&quot;输出：11 示例5： 12输入：s = &quot;tourist&quot;输出：1 提示： 1 &lt;= s.length &lt;= 500 s 只包含小写英文字母。 分析和解答比较简单，O(n)遍历一次，如果不等清空重新计数就可以了，另外感觉有很多种实现方法。 12345678910111213141516171819class Solution(object): def maxPower(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; if len(s) == 0: return 0 max_cnt = 1 cnt = 1 for i in range(1, len(s)): if s[i] == s[i-1]: cnt += 1 else: cnt = 1 max_cnt = max(max_cnt, cnt) return max_cnt","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"208.实现Trie前缀树-python","slug":"algorithms/leetcode-python/208-实现Trie前缀树-python","date":"2021-12-13T03:37:15.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/13/algorithms/leetcode-python/208-实现Trie前缀树-python/","link":"","permalink":"http://example.com/2021/12/13/algorithms/leetcode-python/208-%E5%AE%9E%E7%8E%B0Trie%E5%89%8D%E7%BC%80%E6%A0%91-python/","excerpt":"208.最长递增子序列（中等） 题目大意：Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false","text":"208.最长递增子序列（中等） 题目大意：Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 题目题目链接 Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 示例： 1234567891011121314输入[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出[null, null, true, false, true, null, true]解释Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // 返回 Truetrie.search(&quot;app&quot;); // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;); // 返回 True 提示： 1 &lt;= word.length, prefix.length &lt;= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 分析和解答Trie树还是很经典的，同样是一个妙脆妙妙角一样妙的结构。这个题主要需要记住的是首先构建一个TrieNode，代表Trie树中的每个节点： 1234class TrieNode(object): def __init__(self): self.mapping = &#123;&#125; self.is_end = False 在之后想想每次插入过程，每次都从root开始进行插入，第一次插入一个单词如“apple”的时候，首先是“a“，令node=root，因为现在node肯定是空的，所以使得node.mapping[&#39;a&#39;]为一个新的TrieNode，之后走到这个TrieNode上，node=node.mapping.get(c)。特别注意，这里的mapping key是每个char，value是TrieNode类型的，在插入的最后，要使得node.is_end=True，标志出这个单词的结尾 在这样的插入条件下，第一次插入就是构建了一个超长的串。第二次插入的时候由于第一次插入过程中，有些节点已经可以共用了，所以就有“前缀”的感觉了，这样的感觉就是顺着串走，直到遇到新的后，就建立走到新的分支上，要想到Trie树并不是只插入一个字符串就结束了 找prefix和word都很简单，找word要多加一个判断is_end 题目解答： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class TrieNode(object): &quot;&quot;&quot; 实现一个TrieNode进行封装 &quot;&quot;&quot; def __init__(self): self.mapping = &#123;&#125; self.is_end = Falseclass Trie(object): def __init__(self): self.root = TrieNode() def insert(self, word): &quot;&quot;&quot; :type word: str :rtype: None 注意这个insert函数会多次执行， &quot;&quot;&quot; node = self.root for i, c in enumerate(word): if node.mapping.get(c) is None: node.mapping[c] = TrieNode() # 这里每次放入的是TreeNode node = node.mapping[c] node.is_end = True def search(self, word): &quot;&quot;&quot; :type word: str :rtype: bool &quot;&quot;&quot; node = self.root for i, c in enumerate(word): if node.mapping.get(c) is None: return False node = node.mapping[c] if node.is_end == True: return True else: return False· def startsWith(self, prefix): &quot;&quot;&quot; :type prefix: str :rtype: bool &quot;&quot;&quot; node = self.root for i, c in enumerate(prefix): if node.mapping.get(c) is None: return False node = node.mapping[c] return True# Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"438.找到字符串中所有字母异位词-python","slug":"algorithms/leetcode-python/438-找到字符串中所有字母异位词-python","date":"2021-12-12T03:18:10.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2021/12/12/algorithms/leetcode-python/438-找到字符串中所有字母异位词-python/","link":"","permalink":"http://example.com/2021/12/12/algorithms/leetcode-python/438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-python/","excerpt":"438.找到字符串中所有字母异位词（中等） 题目大意：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。","text":"438.找到字符串中所有字母异位词（中等） 题目大意：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 题目题目链接 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 示例一： 12345输入: s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出: [0,6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。 示例二： 123456输入: s = &quot;abab&quot;, p = &quot;ab&quot;输出: [0,1,2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。 提示： 1 &lt;= s.length, p.length &lt;= 3 * 104 s 和 p 仅包含小写字母 分析和解答这个题要构建一个“滑动窗口”来减少操作次数的感觉，就是说如果每i+=1向后移动一位的时候，如果都重新计数，那么将会时间复杂度非常高。所以在每次移动的时候，只需要把i-1位置的删除，再加入i+window_size-1位置处最新的字符即可，这样的话每次移动只用操作两下； 一开始设置一个和p长度相等的s之后开始滑动窗口，删除头并新增尾只需要操作两次了（注意做字典判断相等时候，要把字典值为0的删除掉），另外注意print语句也会占用时间； 另外这个题也可以使用colletions.Counter，Counter可以进行一个计数操作，而且最关键的是Counter居然可以执行加减操作， 12345678910111213141516&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; text1 = &quot;aaabbbccc&quot;&gt;&gt;&gt; text1_count = Counter(text1)&gt;&gt;&gt; text1_countCounter(&#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 3, &#x27;c&#x27;: 3&#125;)&gt;&gt;&gt; text1_count.get(&#x27;b&#x27;)3&gt;&gt;&gt; type(text1_count)&lt;class &#x27;collections.Counter&#x27;&gt;&gt;&gt;&gt; text2 = &quot;abcd&quot;&gt;&gt;&gt; text2_count = Counter(text2)&gt;&gt;&gt; text2_countCounter(&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 1, &#x27;c&#x27;: 1, &#x27;d&#x27;: 1&#125;)&gt;&gt;&gt; tmp = text1_count - text2_count&gt;&gt;&gt; tmpCounter(&#123;&#x27;a&#x27;: 2, &#x27;b&#x27;: 2, &#x27;c&#x27;: 2&#125;) 在上述思路分析后，主要记住新加入的位置是i+window_size-1就好了，代码编写思路还是比较简单，这里使用了Counter的方法，实际上用字典的方法也可以，而且说不定可以增加效率： 123456789101112131415161718192021222324252627class Solution(object): def findAnagrams(self, s, p): &quot;&quot;&quot; :type s: str :type p: str :rtype: List[int] &quot;&quot;&quot; rList = [] window_size = len(p) compare_dict = collections.Counter(p) record_s_dict = None for i in range(len(s)-window_size+1): if record_s_dict is None: record_s_dict = collections.Counter(s[i: window_size]) else: remove_head = collections.Counter(s[i-1]) # print(&quot;remove_head: &quot;, i, remove_head) add_tail = collections.Counter(s[i+window_size-1]) # 调试还是比较容易看出来这个错误的 # print(&quot;add tail: &quot;, i, add_tail) record_s_dict -= remove_head record_s_dict += add_tail # print(&quot;record_s_dict: &quot;, i, record_s_dict) if record_s_dict == compare_dict: rList.append(i) return rList","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"macOS及Linux-screen命令整理","slug":"macOS及Linux-screen命令整理","date":"2021-12-08T06:48:35.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/12/08/macOS及Linux-screen命令整理/","link":"","permalink":"http://example.com/2021/12/08/macOS%E5%8F%8ALinux-screen%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/","excerpt":"需求：例如在跑深度学习等程序的时候，需要让程序挂载在后台执行，这时候就可以使用screen命令进行后台的挂载","text":"需求：例如在跑深度学习等程序的时候，需要让程序挂载在后台执行，这时候就可以使用screen命令进行后台的挂载 screen -ls查看：screen -ls可以查看当前有哪些Attached/Detached的screen界面 1234(base) lyx@h5:~$ screen -lsThere is a screen on: 12442.xxxxxxx (12/08/2021 02:12:53 PM) (Detached)1 Socket in /var/run/screen/S-lyx.= screen -S [name]新建：screen -S [name]可以打开一个新的名称为[name]的screen界面 screen -r [name]返回：screen -r [name]可以返回名称为[name]的screen界面（例如之前暂时退出了，可通过此命令返回），名称可通过screen -ls查看 screen -X -S [id] quit删除：screen -X -S [id] quit可以关闭挂载的一些screen，这里只用输入id号即可 screen -D [name]有些情况下，如果finalshell等ssh窗口已经关闭，但是还显示在Attached的状态，就需要先D掉再进去 ```screen -D [name]``","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"iterm2+ohmyzsh安装及插件配置","slug":"iterm2+ohmyzsh安装及插件配置","date":"2021-12-06T04:04:41.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/12/06/iterm2+ohmyzsh安装及插件配置/","link":"","permalink":"http://example.com/2021/12/06/iterm2+ohmyzsh%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%85%8D%E7%BD%AE/","excerpt":"背景：iterm2可以替代macOS自带的terminal，而ohmyzsh是基于zsh命令行的一个扩展工具集，在其上可以安装插件来丰富命令行的功能（何老板推荐的syntax highlighting和auto suggestion）","text":"背景：iterm2可以替代macOS自带的terminal，而ohmyzsh是基于zsh命令行的一个扩展工具集，在其上可以安装插件来丰富命令行的功能（何老板推荐的syntax highlighting和auto suggestion） 安装item2直接官网安装即可，安装后把其保留在程序坞中，手工替代terminal https://iterm2.com/ 安装ohmyzsh直接执行官网的一句话命令安装： 1sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; https://ohmyz.sh/#install 安装ohmyzsh的插件syntax highlighting和auto suggestionReference: https://www.jianshu.com/p/2f2c09ebfb7fhttps://blog.csdn.net/qq_38839744/article/details/90247628 zsh-syntax-highlighting安装官网： https://github.com/zsh-users/zsh-syntax-highlighting 安装： 12git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrc 生效： 1source ~/.zshrc Auto suggestion的安装auto suggestion是ohmyzsh的一个插件，作用基本上是根据历史输入指令记录即使的提示，能够提高效率 git clone项目，并与ZSH建立关联 1git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 其中通过echo查看$ZSH_CUSTOM 12➜ ~ echo $ZSH_CUSTOM/Users/curious/.oh-my-zsh/custom 编辑~/.zshrc文件 1vim ~/.zshrc 按i 进入–INSERT–编辑模式，使用上下左右键找找到plugins=(git)这一行添加 1plugins=(git zsh-autosuggestions)","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"docker-Learning","slug":"develop/docker/docker-Learning","date":"2021-12-06T03:51:51.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/12/06/develop/docker/docker-Learning/","link":"","permalink":"http://example.com/2021/12/06/develop/docker/docker-Learning/","excerpt":"背景：docker有一种更加轻量级虚拟机的感觉，正好在一个课程中需要使用HBase、Hadoop等，又不方便在本地安装，所以可以使用docker的方式，也借此机会学习docker","text":"背景：docker有一种更加轻量级虚拟机的感觉，正好在一个课程中需要使用HBase、Hadoop等，又不方便在本地安装，所以可以使用docker的方式，也借此机会学习docker docker的安装macOS上可以安装docker destop，是个可视化的工具 https://www.docker.com/get-started Getting Started 第一步，clone a repository Getting Started项目是一个简单的Github repository，包含了一切建立镜像（image）和运行为容器（container）的过程 通过在容器中运行git克隆存储库 1CuriousdeMacBook-Pro:~ curious$ docker run --name repo alpine git clone https://github.com/docker/getting-started.git 之后，构建image Docker映像是仅用于容器的私有文件系统。它提供容器所需的所有文件和代码。 12CuriousdeMacBook-Pro:~ curious$ cd getting-started CuriousdeMacBook-Pro:getting-started curious$ docker build -t docker101tutorial . 运行第一个container 基于上一步中生成的映像启动容器。运行容器会启动具有私有资源的应用程序，这些资源与计算机的其余部分安全隔离。 1CuriousdeMacBook-Pro:getting-started curious$ docker run -d - p 80:80 --name docker-tutorial docker101tutorial cfd8702ce730feb351565711d7a44d147476d8faa18b03ae2d4815cc137d121b 保存并分享镜像 在Docker Hub上保存和共享您的映像，以便其他用户可以轻松地在任何目标计算机上下载和运行映像。","categories":[{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"}],"tags":[]},{"title":"github443问题的解决办法","slug":"mixed/git/github443问题的解决办法","date":"2021-12-05T16:56:27.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/12/06/mixed/git/github443问题的解决办法/","link":"","permalink":"http://example.com/2021/12/06/mixed/git/github443%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"背景：github经常遇到443问题，例如Failed to connect to github.com port 443: Operation timed out，这种情况下需要一些解决办法； Reference： https://www.jianshu.com/p/471aeba64724","text":"背景：github经常遇到443问题，例如Failed to connect to github.com port 443: Operation timed out，这种情况下需要一些解决办法； Reference： https://www.jianshu.com/p/471aeba64724 解决方法一（暂未尝试，但是从原理上来说应该是可以解决的） 查询可以用的IP，在 https://www.ipaddress.com/ 上分别搜索github.com、github.global-ssl.fastly.net 修改host文件 操作：sudo vi /etc/hosts 替换成以下ip即可 12151.101.185.194 github.global-ssl.fastly.net192.30.253.112 github.com 之后就可以进行一些尝试了 解决方法二（尝试了可以，需要梯子资源） 设置代理的方法，首先查找梯子代理的端口： 通过git config命令来设置 1git config --global http.proxy &quot;localhost:port&quot; 在使用完毕后可以改回来 1git config --global --unset http.proxy","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"记录一次hexo博客迁移过程","slug":"mixed/hexo/记录一次hexo博客迁移过程","date":"2021-12-05T15:53:36.000Z","updated":"2022-11-20T01:50:08.892Z","comments":true,"path":"2021/12/05/mixed/hexo/记录一次hexo博客迁移过程/","link":"","permalink":"http://example.com/2021/12/05/mixed/hexo/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%BF%87%E7%A8%8B/","excerpt":"背景：换了一个新电脑，需要把原来在github上配置的yixuan004.github.io博客环境重新在本地部署，中间涉及到一些软件的安装等","text":"背景：换了一个新电脑，需要把原来在github上配置的yixuan004.github.io博客环境重新在本地部署，中间涉及到一些软件的安装等 记录一次hexo博客迁移过程换了一个电脑后要重新部署自己的yixuan004.github.io博客，因为之前设置的已经比较完备了，把master分支和coding-pages分支（实际上的主分支）在github上分隔开了，所以首先拉取远程的coding-pages（实际上的主分支） 1git clone https://github.com/yixuan004/yixuan004.github.io.git 在之后需要在本地补充npm安装hexo环境，注意hexo环境必须安装在文件夹下 如果本地没node/npm环境的话，可到官网下载 http://nodejs.cn/download/ 12sudo npm install hexosudo npm install npm install hexo-deployer-git --save 在这之后理论上就可以进行操作和push了，和之前的博客一样即可： https://yixuan004.github.io/2021/09/13/我的首篇github博客/","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"28.实现strStr-python","slug":"algorithms/leetcode-python/28-实现strStr-python","date":"2021-12-03T03:14:37.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/03/algorithms/leetcode-python/28-实现strStr-python/","link":"","permalink":"http://example.com/2021/12/03/algorithms/leetcode-python/28-%E5%AE%9E%E7%8E%B0strStr-python/","excerpt":"28.实现strStr()（中等） 题目大意：实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。","text":"28.实现strStr()（中等） 题目大意：实现 strStr() 函数。给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 题目题目链接 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 12当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例1： 12输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出：2 示例2： 12输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出：-1 示例3： 12输入：haystack = &quot;&quot;, needle = &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 分析和解答这个题就是KMP算法的完全模板，虽然题目标注的难度是简单但感觉那是调用函数直接的做法。。。例如在python中可以直接用str1.find(str2)来解决，而题目要考察的就是这个函数的实现 KMP算法非常巧妙，这里学习的是Youtube+b站转载翻译的一个思路： https://www.bilibili.com/video/BV18k4y1m7Ar?p=1 思路是首先在needle（又称pattern）上构建pre数组，或者有人称为next数组。next数组的含义很有可能在面试中被问到，自己写几个的话，感觉强行理解这个next数组就是当前这个位置下，pattern的首尾最长公共子串的数目，例如abc ... abc是一个首尾重复的，这样的话，j在回退的时候，不必每次都回退到头部，而是回退到next[j]的位置，复习一下这个构建next数组的操作，这个kmp算法感觉还是要做到经常操作的（暂时不太考虑很特殊的情况）： 12345678910111213141516def construct_pre_arr(pattern): j = 0 i = 1 pre = [0] * len(pattern) while i &lt; len(pattern): if pattern[i] == pattern[j]: pre[i] = j + 1 j += 1 i += 1 elif pattern[i] != pattern[j]: if j == 0: pre[i] = 0 i += 1 else: j = next[j] return pre 在构建好pre数组后，之后就是两个串来操作了，使用pre数组，让在串str1中寻找pattern的时候，不用每次都回退到pattern的头部，自己手工复习一下这个写法，整个写法上来看是先判断有没有（j是否遍历到了最后一位），再找是哪一段。这里基本只是运用pre数组了，比之前修改还简单些 1234567891011121314151617\bi = 0 # str1的indexj = 0 # pattern的indexwhile i &lt; len(str1) and j &lt; len(pattern): if str1[i] == pattern[j]: i += 1 j += 1 else: if j == 0: i += 1 else: j = pre[j]if j == len(pattern): return i - jelse: return -1 整体题目的解答： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def strStr(self, haystack, needle): &quot;&quot;&quot; :type haystack: str :type needle: str :rtype: int &quot;&quot;&quot; m, n = len(haystack), len(needle) def compute_pre_array(needle): # 这个是计算pattern串的pre数组 pre = [0 for i in range(len(needle))] j = 0 i = 1 while i &lt; len(needle): if needle[i] == needle[j]: pre[i] = j + 1 # 注意这里的等于j + 1，实际上就是一个长度的感觉 j += 1 i += 1 else: if j == 0: pre[i] = 0 i += 1 elif j != 0: j = pre[j-1] # 精髓 return pre # pre数组的含义是，单个串在这个位置上，前缀长度等于后缀长度的个数，但是为什么要这么做还不是很理解 pre = compute_pre_array(needle) # step2 使用pre数组 i = 0 # 串1的index j = 0 # 串2的index while i &lt; m and j &lt; n: if haystack[i] == needle[j]: i += 1 j += 1 else: if j == 0: i += 1 elif j != 0: j = pre[j-1] if j == len(needle): return i - j # i停下的位置找回去 else: return -1","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"519.随机翻转矩阵-python","slug":"algorithms/leetcode-python/519-随机翻转矩阵-python","date":"2021-12-03T02:45:23.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2021/12/03/algorithms/leetcode-python/519-随机翻转矩阵-python/","link":"","permalink":"http://example.com/2021/12/03/algorithms/leetcode-python/519-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5-python/","excerpt":"519.随机翻转矩阵（中等） 题目大意：给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0","text":"519.随机翻转矩阵（中等） 题目大意：给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0 题目题目链接 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。 尽量最少调用内置的随机函数，并且优化时间和空间复杂度。 实现 Solution 类： Solution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0 示例： 12345678910111213输入[&quot;Solution&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;flip&quot;, &quot;reset&quot;, &quot;flip&quot;][[3, 1], [], [], [], [], []]输出[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]解释Solution solution = new Solution(3, 1);solution.flip(); // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同solution.flip(); // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同solution.flip(); // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]solution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回solution.flip(); // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同 提示： 1 &lt;= m, n &lt;= 104 每次调用flip 时，矩阵中至少存在一个值为 0 的格子。 最多调用 1000 次 flip 和 reset 方法。 分析和解答这个题如果未来会被问到的话，首先需要自己熟悉一下手写基础框架 12345678910111213class Solution(object): def __init__(self, m, n): self.m = m self.n = n # do something def filp(self): # do something pass def reset(self): # do something pass 目前使用一种非常简单的方法就解决了，每次随机一个[0, m-1]，随机一个[0, n-1]（使用random.randint(a, b)，注意这里a，b都是闭区间的），用一个dict判断d[(rand_m, rand_n)]是否有，如果有就一直重新随机，直到不存在，不存在的情况下加入dict。清空则就是清空词典。但这个运气最差得情况下会调用很多次随机函数，所以实际上不符合题意的，只是比较简单实现，暂时不属于hot100题就未来补充了。 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def __init__(self, m, n): &quot;&quot;&quot; :type m: int :type n: int &quot;&quot;&quot; self.m = m self.n = n self.temp_dict = &#123;&#125; def flip(self): &quot;&quot;&quot; :rtype: List[int] &quot;&quot;&quot; # 把self的值取过来 m = self.m n = self.n m_temp = random.randint(0, m-1) n_temp = random.randint(0, n-1) while self.temp_dict.get((m_temp, n_temp)) is not None: m_temp = random.randint(0, m-1) n_temp = random.randint(0, n-1) self.temp_dict[(m_temp, n_temp)] = 1 return [m_temp, n_temp] def reset(self): &quot;&quot;&quot; :rtype: None &quot;&quot;&quot; self.temp_dict = &#123;&#125;# Your Solution object will be instantiated and called as such:# obj = Solution(m, n)# param_1 = obj.flip()# obj.reset() 优化解法（减少随机函数的调用次数）待补充","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"TODO优化","slug":"TODO优化","permalink":"http://example.com/tags/TODO%E4%BC%98%E5%8C%96/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"水塘抽样","slug":"水塘抽样","permalink":"http://example.com/tags/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/"},{"name":"随机化","slug":"随机化","permalink":"http://example.com/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"}]},{"title":"121.买卖股票的最佳时机-python","slug":"algorithms/leetcode-python/121-买卖股票的最佳时机-python","date":"2021-12-03T02:32:40.000Z","updated":"2022-11-20T01:50:08.882Z","comments":true,"path":"2021/12/03/algorithms/leetcode-python/121-买卖股票的最佳时机-python/","link":"","permalink":"http://example.com/2021/12/03/algorithms/leetcode-python/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-python/","excerpt":"121.买卖股票的最佳时机（简单） 题目大意：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。","text":"121.买卖股票的最佳时机（简单） 题目大意：给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 题目题目链接 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。 设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 1234输入：[7,1,5,3,6,4]输出：5解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 123输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 &lt;= prices.length &lt;= 105 0 &lt;= prices[i] &lt;= 104 分析和解答这个题感觉比较简单，先设置now_min为arr[0]，然后从角标1开始遍历，每次判断现在的arr[i]-now_min是否最大值，如果是则更新最大值。之后更新now_min，如果当前位置小于now_min就更新； 之前在一本算法书上应该看过这个题，想象一根从最低点到最高点的连线。 12345678910111213141516class Solution(object): def maxProfit(self, prices): # 异常处理 if len(prices) == 0: return 0 # 逻辑处理 max_p = 0 now_min = prices[0] for i in range(1, len(prices)): max_p = max(max_p, prices[i] - now_min) if prices[i] &lt; now_min: now_min = prices[i] return max_p","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"300.最长递增子序列-python","slug":"algorithms/leetcode-python/300-最长递增子序列-python","date":"2021-11-30T16:05:54.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/12/01/algorithms/leetcode-python/300-最长递增子序列-python/","link":"","permalink":"http://example.com/2021/12/01/algorithms/leetcode-python/300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-python/","excerpt":"300.最长递增子序列（中等） 题目大意：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。","text":"300.最长递增子序列（中等） 题目大意：给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 题目题目链接 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例1： 123输入：nums = [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例2： 12输入：nums = [0,1,0,3,2,3]输出：4 示例3： 12输入：nums = [7,7,7,7,7,7,7]输出：1 提示： 1 &lt;= nums.length &lt;= 2500 104 &lt;= nums[i] &lt;= 104 分析和解答解法一：O(n^2)向前查找法O(n^2)的解法还是比较好想的（简单题），先创建一个一维dp数组，然后走到每个位置的时候要往前看，看看前边比当前数字小的那些数组位置处，选择一个这些位置里dp值最大的，+1得到现在这个位置的dp值。最后返回max(dp)就可以 解题： 123456789101112131415class Solution(object): def lengthOfLIS(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; # 思路还是很简单的，设置dp数组，走到每个位置后，【往前找】比这个位置小的元素，然后选一个最大的dp[i] + 1当做当前位置的dp if len(nums) == 0: return 0 dp = [1 for i in range(len(nums))] for i in range(1, len(nums)): for j in range(i, -1, -1): if nums[i] &gt; nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) 解法二：优化解法（二分查找）待补充","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"TODO优化","slug":"TODO优化","permalink":"http://example.com/tags/TODO%E4%BC%98%E5%8C%96/"}]},{"title":"3.无重复字符的最长子串-python","slug":"algorithms/leetcode-python/3-无重复字符的最长子串-python","date":"2021-11-30T15:09:03.000Z","updated":"2022-11-20T01:50:08.883Z","comments":true,"path":"2021/11/30/algorithms/leetcode-python/3-无重复字符的最长子串-python/","link":"","permalink":"http://example.com/2021/11/30/algorithms/leetcode-python/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-python/","excerpt":"3.无重复字符的最长子串（中等） 题目大意：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度","text":"3.无重复字符的最长子串（中等） 题目大意：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度 题目题目链接 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例1： 123输入: s = &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2： 123输入: s = &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例3： 1234输入: s = &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 示例4： 12输入: s = &quot;&quot;输出: 0 提示： 0 &lt;= s.length &lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 分析和解答这个题要及时get到使用滑动窗口来解决这个问题，因为题目要求的是”子串“，这是一个连续的 在get到是用滑动窗口解决问题后，滑动窗口本身来讲感觉就是一个队列，这个题是变长的 整体上的思路是： 遍历字符串，如果遇到不在滑动窗口（队列）中的字符，就加入队列的右边。如果遇到出现在队列中的字符，则队列的左边要缩到这个字符出现的下一位（感觉也可以用find(xxx) + 1来优化），然后再把这个字符加入进去； 在每次遍历i的时候，判断当前变长滑动窗口的大小和当前的最大值，来更新最大值，用来最终返回 解题： 1234567891011121314class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; 滑动窗口对应的数据结构是queue &quot;&quot;&quot; if len(s) == 0: return 0 que = [] max_len = 0 for i in range(len(s)): while s[i] in que: que = que[1:] # que.append(s[i]) max_len = max(max_len, len(que)) return max_len","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"423.从英文中重建数字-python","slug":"algorithms/leetcode-python/423-从英文中重建数字-python","date":"2021-11-29T15:48:17.000Z","updated":"2022-11-20T01:50:08.884Z","comments":true,"path":"2021/11/29/algorithms/leetcode-python/423-从英文中重建数字-python/","link":"","permalink":"http://example.com/2021/11/29/algorithms/leetcode-python/423-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97-python/","excerpt":"423.从英文中重建数字（中等） 题目大意：给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。","text":"423.从英文中重建数字（中等） 题目大意：给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。 题目题目链接 给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。 示例1： 12输入：s = &quot;owoztneoer&quot;输出：&quot;012&quot; 示例2： 12输入：s = &quot;fviefuro&quot;输出：&quot;45&quot; 提示： 1 &lt;= s.length &lt;= 105 s[i] 为 [“e”,”g”,”f”,”i”,”h”,”o”,”n”,”s”,”r”,”u”,”t”,”w”,”v”,”x”,”z”] 这些字符之一 s 保证是一个符合题目要求的字符串 分析和解答这种题有一种脑筋急转弯的感觉，每个数字的英文中会有一些特点，这样可以统计出来每个英文字母在哪些数字中出现了，如下图所示。这样可以通过计数的方式来从“出现一次”的分析，例如“x”只在six中出现，之后可以像数独一样链着分析。 统计分析规律，列出每个字母在哪些数字的英文中出现了，然后有些字母实际上只在一个数字中出现了，统计这些字母的个数就是这个数字的个数。然后来有些字母在两个数字中出现的，贪心下 需要注意，尽量避免使用一个字母在一个单词中出现两次的，例如nine中的n 12345678910zeroonetwothree fourfivesixseveneightnine 解题： 1234567891011121314151617181920212223242526272829class Solution(object): def originalDigits(self, s): cnt_dict = &#123;&#125; m = [0 for i in range(10)] for i, c in enumerate(s): if cnt_dict.get(c) is None: cnt_dict[c] = 1 else: cnt_dict[c] += 1 # 单位的 m[8] = cnt_dict.get(&#x27;g&#x27;, 0) m[4] = cnt_dict.get(&#x27;u&#x27;, 0) m[2] = cnt_dict.get(&#x27;w&#x27;, 0) m[6] = cnt_dict.get(&#x27;x&#x27;, 0) m[0] = cnt_dict.get(&#x27;z&#x27;, 0) # 两位的 m[5] = cnt_dict.get(&#x27;f&#x27;, 0) - m[4] m[3] = cnt_dict.get(&#x27;h&#x27;, 0) - m[8] m[7] = cnt_dict.get(&#x27;v&#x27;, 0) - m[5] # 差0 1 和 9 m[0] = cnt_dict.get(&#x27;r&#x27;, 0) - m[3] - m[4] m[1] = cnt_dict.get(&#x27;o&#x27;, 0) - m[0] - m[2] - m[4] # m[9] = cnt_dict.get(&#x27;n&#x27;, 0) - m[1] - m[7] # 字母尽量选择出现1次的，所以n不行 m[9] = cnt_dict.get(&#x27;i&#x27;, 0) - m[5] - m[6] - m[8] # 可否优化 return &quot;&quot;.join(str(i) * m[i] for i in range(10))","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"700.二叉搜索树中的搜索-python","slug":"algorithms/leetcode-python/700-二叉搜索树中的搜索-python","date":"2021-11-29T14:46:10.000Z","updated":"2022-11-20T01:50:08.885Z","comments":true,"path":"2021/11/29/algorithms/leetcode-python/700-二叉搜索树中的搜索-python/","link":"","permalink":"http://example.com/2021/11/29/algorithms/leetcode-python/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-python/","excerpt":"700.二叉树中的搜索（简单） 题目大意：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。","text":"700.二叉树中的搜索（简单） 题目大意：给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 题目题目链接 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。 例如， 123456789给定二叉搜索树: 4 / \\ 2 7 / \\ 1 3和值: 2 应该返回如下子树： 123 2 / \\ 1 3 在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。 分析和解答这个题需要明白，return type如果是有类型的，例如这里是TreeNode类型，在此函数内部的递归循环中，每个返回值也要是TreeNode类型的，类似于这题里边的return self.searchBST(root.left, val)，调用的时候是return funct() TreeNode类，每次手写一下保持手感 12345class TreeNode(object): def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right 求解 123456789101112131415class Solution(object): def searchBST(self, root, val): &quot;&quot;&quot; :type root: TreeNode :type val: int :rtype: TreeNode &quot;&quot;&quot; if root is None: # None要放到前边 return None if val == root.val: return root if val &lt; root.val: return self.searchBST(root.left, val) elif val &gt; root.val: return self.searchBST(root.right, val)","categories":[{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"}],"tags":[{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"}]},{"title":"记录一次pycharm的配置过程","slug":"记录一次pycharm的配置过程","date":"2021-11-24T01:21:29.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2021/11/24/记录一次pycharm的配置过程/","link":"","permalink":"http://example.com/2021/11/24/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1pycharm%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/","excerpt":"在之前会用vscode远程连接服务器写代码，pycharm是另外一种的操作，用了pycharm后感觉可以在本地也备份一份的感觉 在同步的时候，可以本地不存储那些数据文件，只存储核心的代码文件，这样如果远程服务器和github无法连接的时候，就可以将本地的那些代码文件向github同步（正好在向github同步的时候要避免对于数据的同步，而只同步代码）","text":"在之前会用vscode远程连接服务器写代码，pycharm是另外一种的操作，用了pycharm后感觉可以在本地也备份一份的感觉 在同步的时候，可以本地不存储那些数据文件，只存储核心的代码文件，这样如果远程服务器和github无法连接的时候，就可以将本地的那些代码文件向github同步（正好在向github同步的时候要避免对于数据的同步，而只同步代码） 操作流程 新建project 选择路径这里，这里venv可以随意选择（个人感觉最好不选择，但是不一定能跳过这一步） 打开File -&gt; Preference，选择Interpreter 这里的Interpreter需要选择远程的ssh Interpreter 设置deployment，设置有远程文件夹和本地文件夹的同步 测试torch.cuda.is_available() 设置本地删除文件后，远程也会随之删除 Reference https://zhuanlan.zhihu.com/p/149040742https://blog.csdn.net/renhanchi/article/details/93769003","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"记录服务器miniconda配置虚拟环境","slug":"记录服务器miniconda配置虚拟环境","date":"2021-11-10T01:23:12.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2021/11/10/记录服务器miniconda配置虚拟环境/","link":"","permalink":"http://example.com/2021/11/10/%E8%AE%B0%E5%BD%95%E6%9C%8D%E5%8A%A1%E5%99%A8miniconda%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","excerpt":"在服务器上之前自己一直用的是virtualenv的环境建立虚拟环境，有一种比较依赖本机已经安装了相关python的感觉。另外昨天在使用virtualenv的时候发现pip的版本对应有些问题，会报sys.stderr.write(f”ERROR: {exc}”)这个错 大佬同学推荐了一个miniconda的方法，感觉安装起来很方便，虚拟环境感觉都可以使用类似的方法了","text":"在服务器上之前自己一直用的是virtualenv的环境建立虚拟环境，有一种比较依赖本机已经安装了相关python的感觉。另外昨天在使用virtualenv的时候发现pip的版本对应有些问题，会报sys.stderr.write(f”ERROR: {exc}”)这个错 大佬同学推荐了一个miniconda的方法，感觉安装起来很方便，虚拟环境感觉都可以使用类似的方法了 Reference：https://conda.io/en/latest/miniconda.html 安装Linux Installers 下载后会得到一个Miniconda3-latest-Linux-x86_64.sh，上传到服务器上后可通过bash直接安装 建立、启动虚拟环境可通过如下命令建立启动虚拟环境， 123$ conda create -n myenv python=3.8 // 安装python$ conda activate myenv(myenv)$ pip install ... 安装torch，torchvision，cudatoolkit使用conda可以不依赖pip进行安装，conda安装一些内容好像可以非常方便。自己在尝试pip install pytorch的时候经常出现和cuda版本对应不上的问题，还有就是pytorch0.4.1的版本中没有boolTensor，所以需要把pytorch搞成1.x版本并且和cuda版本对应的上 首先使用nvidia-smi查看当前cuda 在pytorch官网https://pytorch.org/get-started/previous-versions/上查看previous version，一般来说1.4.0，1.6.0比较稳定？ 输入命令进行安装： 测试如下： 另外一种直接pip install的方式（from zkh）1pip install torch==1.11.0+cu113 torchvision==0.12.0+cu113 torchaudio==0.11.0 --extra-index-url https://download.pytorch.org/whl/cu113","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"NLP代码学习笔记","slug":"research/code/NLP代码学习笔记","date":"2021-10-30T07:36:19.000Z","updated":"2022-11-20T01:50:08.892Z","comments":true,"path":"2021/10/30/research/code/NLP代码学习笔记/","link":"","permalink":"http://example.com/2021/10/30/research/code/NLP%E4%BB%A3%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"记录一些代码中常用的操作说明及bug解决记录","text":"记录一些代码中常用的操作说明及bug解决记录 nn.Embedding.from_pretrained整个代码的上下文是在做label_ids和slot_ids的embedding 123456789101112131415161718192021def initialize_slot_value_lookup(self, label_ids, slot_ids): &#x27;&#x27;&#x27; self.sv_encoder = BertForUtteranceEncoding.from_pretrained( os.path.join(args.bert_dir, &#x27;bert-base-uncased&#x27;) ) # 作者把调用sv_encoder的部分fix住 for p in self.sv_encoder.bert.parameters(): p.requires_grad = False &#x27;&#x27;&#x27; self.sv_encoder.eval() # 切换到evaluate模式 # Slot encoding，这个是fix住的部分 slot_type_ids = torch.zeros(slot_ids.size(), dtype=torch.long).to(self.device) # 初始化一个空的slot_type_ids slot_mask = slot_ids &gt; 0 hid_slot, _ = self.sv_encoder(slot_ids.view(-1, self.max_label_length), slot_type_ids.view(-1, self.max_label_length), slot_mask.view(-1, self.max_label_length), output_all_encoded_layers=False) # 获取CLS的token，hidden的 hid_slot = hid_slot[:, 0, :] # 博客中指出，这样的操作是在获取CLStoken，而CLStoken是用来进行分类的，也一般被认为是整句话的embedding hid_slot = hid_slot.detach() self.slot_lookup = nn.Embedding.from_pretrained(hid_slot, freeze=True) # slot的embedding结果，是不可以训练的 报在同时使用cpu和gpu的错误报在同时使用cpu和gpu的错误除了tensor要tensor.to(device)以外，model也要.to(device)，否则可能会报在同时使用cpu和gpu的错误 pytorch中判断两个tensor是否相等 tensor.equal()方法 1234# 该方法用于比较两个tensor是否一样，一样则返回True否则为Falsea = torch.tensor([1,2,3,4])b = torch.tensor([1,2,3,4])print(a.equal(b)) # 返回True tensor.eq()方法 1234# 该方法用于主元素比较是否相等，相等则在对应位置返回True，否则为Falsea = torch.tensor([1,2,2,3])b = torch.tensor([2,2,3,3])print(a.eq(b)) # 返回tensor([False,True,False,True]),与a==b返回的结果一样 pytorch输出整个tensor的方法1234torch.set_printoptions(profile=&quot;full&quot;)print(x) # prints the whole tensortorch.set_printoptions(profile=&quot;default&quot;) # resetprint(x) # prints the truncated tensor 在这样的输出下，之后就可以写到文件里了 tensor = tensor[0, :, 0]这种操作可能代表着仅需要获取bert的cls token的embedding结果，也被认为是整句话的embedding .contigous().view()1.contigous().view() 有些tensor并不是占用一整块内存，而是由不同的数据块组成，而tensor的view()操作依赖于内存是整块的，这时只需要执行contigous()这个函数，把tensor变成在内存中连续分布的形式，再使用view。 Pytorch0.4中，增加了一个reshape函数，就相当于contigous().view()的功能了！ pytorch常用的张量操作及归一化算法实现 https://zhuanlan.zhihu.com/p/76255917 .squeeze() 和 .unsqueeze()12.squeeze().unsqueeze() squeeze()为压缩的意思，即去掉维度数为1的dim，默认是去掉所有为1的，但是也可以自己指定，但如果指定的维度不为1则不会发生任何改变。 unsqueeze(dim)则与squeeze(dim)正好相反，为添加一个维度的作用。 123# print(&quot;hidden.shape: &quot;, hidden.shape) # torch.Size([96, 1, 768]hidden = hidden.squeeze() # .squeeze()舍弃维度# print(&quot;after .squeeze(), hidden.shape: &quot;, hidden.shape) # torch.Size([96, 768]) nn.GRU 与 nn.LSTM循环神经网络是一种能够自适应的变长网络，能够对带有上下文的连续序列很好地进行编码 https://pytorch.org/docs/stable/torch.html 基本文档说明参数设置 1234567891011121314151617181920input_size: 单个LSTM神经元的输入维度hidden_size: 单个LSTM神经元的隐含层输出维度num_layers: LSTM的层数，这里指的是叠起来的层数，而不是展开的层数，展开是自适应的。bias: 计算过程中是否需要偏置batch_first: batch是否位于第一个维度，很多时候容易混淆，将在之后进一步解释dropout: 其中每一层输出的dropout概率，默认为0即不进行dropout，需要注意的一点是最后一层的输出是不会加上dropout概率的。也就是说，当只用到一层LSTM的时候，这个参数是不起作用的。bidirectional: 是否双向，当设置为True的时候，输出会为将双向LSTM的输出进行拼接，输出的feature size会增加一倍proj_size: 很多博客中都没有解释，用到的时候可能需要参考 # https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html#torch.nn.LSTMself.nbt = nn.LSTM(input_size=self.bert_output_dim, hidden_size=self.hidden_dim, num_layers=self.rnn_num_layers, dropout=self.hidden_dropout_prob, batch_first=True)self.nbt = nn.GRU(input_size=self.bert_output_dim, hidden_size=self.hidden_dim, # args.hidden_dim num_layers=self.rnn_num_layers, dropout=self.hidden_dropout_prob, batch_first=True) Inputs 12345678910111213input: input, (h_0, c_0)input: 当batch_first = False的时候(L, N, H_in)，当batch_first=True的时候(N, L, H_in)h_0: (D*num_layers, N, H_out)，containing the initial hidden state for each element in the batch. Defaults to zeros if (h_0, c_0) is not provided.c_0: (D*num_layers, N, H_cell)，containing the initial cell state for each element in the batch. Defaults to zeros if (h_0, c_0) is not provided.其中： N是batch_size L是每句话的长度 如果使用双向LSTM则D是2，否则是1 H_in是输入的hiddendim（例如是bert的输出768） H_cell是LSTM内部的hidden_size H_out和输入参数中的proj_size相关，但基本可以理解为就是hidden_size， Outputs 12345Outputs: output, (h_n, c_n)output: 当batch_first=False的时候是(L, N, D*H_out)，当batch_first=True的时候是(N, L, D*H_out)，其中包括了LSTM最后一层的输出h_t，对于每个t时刻。在PackedSequence相关上还有其他的操作，不过暂时就先不管了h_n: (D*num_layers, N, H_out)包含了每个batch中最后的一个hidden state的elementc_n: (D*num_layersm N, H_cell)包含了最后一个cell的state，对于每个batch的最后一个element？ 关于循环神经网络关于输入输出的三个维度自：维度在tensor的变化中始终是最关键的部分，怎么理解维度背后的含义？ 对于输入输出，我们首先需要注意是传给的网络输出必须是三维的其中每个维度代表的意思，我们习惯的方式是[batch_size, sequence_length, feature_size]具体来说，假如输入的是句子的话，每个维度的含义就是： [一次投入到网络中的句子的条数，句子的长度，句子中每个单词对应的向量维度] 自：在SUMBT代码中，这里的输入该怎么一步步的理解 关于batch first这个是一个非常有趣的参数，他能够将输入的形式变为我们习惯的[batch_size, seq_len, feature_size] 也就是说原本输入参数的形式是[seq_len, batch_size, feature_size]可以视作原本为一列一句话，现在给我们改成了更习惯的一行一句话 更通俗的来说，就是原本一行为一个句子，变成每一列为一个句子，其实设置了batch_first，也不过是在内部也是使用了第1维度和第2维度的转置操作来变成初始形式 在SUMBT中怎么理解这个事情？…… DST任务中的slot_accuracy和joint_accuracyslot_accuracy: 1acc_slot = torch.sum(accuracy, 0).float() / torch.sum(labels.view(-1, slot_dim) &gt; -1, 0).float() 个人总结：按照三个槽分别算，对的除以总的（需要去除padding）就是slot_accuracy joint_accuracy: 1acc = sum(torch.sum(accuracy, 1) / slot_dim).float() / torch.sum(labels[:, :, 0].view(-1) &gt; -1, 0).float() # joint accuracy 个人总结：每轮对话的算成一个，例如在每轮对话中有3个槽，对了2个，该轮对话就是0.66，之后把所有轮对话的加在一起，除以对话的有效轮数就是joint_accuracy tqdm中的desc参数这里desc参数是进度条的前缀名称 1tqdm(dev_dataloader, desc=&quot;Validation&quot;) tensorboard的使用看起来tensorboard和tensorboardX不是一个东西？ 所以需要使用pip install进行安装(venv环境下) 12345$ pip install tensorboard...(venvsumbt) lyx@h1:/hdd1/lyx$ tensorboardTensorFlow installation not found - running with reduced feature set.Error: A logdir or db must be specified. For example `tensorboard --logdir mylogdir` or `tensorboard --db sqlite:~/.tensorboard.db`. Run `tensorboard --helpfull` for details and examples. 使用方法如下（SUMBT-lyx为例）： 123456789(venvsumbt) lyx@h1:/hdd1/lyx/SUMBT-lyx$ tensorboard --logdir=&#x27;SUMBT-lyx/tensorboard/output&#x27;TensorFlow installation not found - running with reduced feature set.NOTE: Using experimental fast data loading logic. To disable, pass &quot;--load_fast=false&quot; and report issues on GitHub. More details: https://github.com/tensorflow/tensorboard/issues/4784Serving TensorBoard on localhost; to expose to the network, use a proxy or pass --bind_allTensorBoard 2.7.0 at http://localhost:6007/ (Press CTRL+C to quit) 此时还需要配合一条端口转发命令： 1ssh lyx@xxx.xxx.xxx.xxx -L 6007:localhost:6007 注意要在训练前另开一个bash执行如下，然后再开启训练，否则可能会出现tensorboard没有显示的情况使用绝对路径！ 123tensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/ckpt-outputtensorboard --logdir=/hdd1/lyx/SUMBT-lyx/tensorboard/20211020-1152-lyx测试 TensorDataset，SequentialSampler，Dataloader相关Reference: https://pytorch.org/docs/stable/data.html?highlight=sequentialsampler#torch.utils.data.SequentialSampler 在代码中看到： 12xxx_sampler = SequentialSampler(xxx_data) or RandomSampler(xxx_data)xxx_dataloader = DataLoader(xxx_data, sampler=xxx_sampler, batch_size=...) 自：一般来说在训练过程中使用RandomSampler，dev和test过程中使用SequentialSampler， 在DST任务中因为和上下文一些状态有关，所以是不是只能顺序采样 CLASS torch.utils.data.SequentialSampler(data_source)按顺序采样元素，始终按相同顺序采样（构建一个迭代器） 源代码是： 12345678910111213141516class SequentialSampler(Sampler[int]): r&quot;&quot;&quot;Samples elements sequentially, always in the same order. Args: data_source (Dataset): dataset to sample from &quot;&quot;&quot; data_source: Sized def __init__(self, data_source: Sized) -&gt; None: self.data_source = data_source def __iter__(self) -&gt; Iterator[int]: return iter(range(len(self.data_source))) def __len__(self) -&gt; int: return len(self.data_source) CLASS torch.utils.data.RandomSampler(data_source, replacement=False, num_samples=None, generator=None)随机抽取元素样本。如果没有替换，则从无序数据集中采样。如果使用替换，则用户可以指定要绘制的样本数 源代码见： https://pytorch.org/docs/stable/_modules/torch/utils/data/sampler.html#RandomSampler np.prod()Reference: https://blog.csdn.net/weixin_40522801/article/details/106578775 np.prod()用来计算所有元素的乘积，pro应该是product的简写，开始的时候不是很明白为什么在计算acc的时候会使用np.prod这个函数，后来发现这个是在计算jointacc上的很好用的函数，因为对于jointacc来说一轮中只要有一个错就算错了 下边这个代码展示了一个JointGA的计算方式，注意在fuzz模式下，可能出现不是1的单轮jointacc值，但是还会有一种越乘越小的感觉 12# Joint goal accuracy.goal_acc[JOINT_GOAL_ACCURACY] = np.prod(list_acc) if list_acc else NAN_VAL fuzz.token_sort_ratio()在对于DST任务non-categorical槽进行评价的时候，很多方法中会使用fuzz这个模式匹配，代码如下，其中str_ref（erence）是真值字符串，str_hyp（othesis）是预测的那个字符串 1match_score = fuzz.token_sort_ratio(str_ref, str_hyp) / 100.0 解读下fuzz.token_sort_ratio这个函数，在源代码中调用顺序如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def token_sort_ratio(s1, s2, force_ascii=True, full_process=True): &quot;&quot;&quot;Return a measure of the sequences&#x27; similarity between 0 and 100 but sorting the token before comparing. &quot;&quot;&quot; return _token_sort(s1, s2, partial=False, force_ascii=force_ascii, full_process=full_process)@utils.check_for_nonedef _token_sort(s1, s2, partial=True, force_ascii=True, full_process=True): &quot;&quot;&quot; 自己注释：按照token进行排序 &quot;&quot;&quot; sorted1 = _process_and_sort(s1, force_ascii, full_process=full_process) sorted2 = _process_and_sort(s2, force_ascii, full_process=full_process) if partial: return partial_ratio(sorted1, sorted2) else: return ratio(sorted1, sorted2)def _process_and_sort(s, force_ascii, full_process=True): &quot;&quot;&quot;Return a cleaned string with token sorted 返回一个按照token排序的干净的string，这里这个干净就是调用full_process &quot;&quot;&quot; # pull tokens ts = utils.full_process(s, force_ascii=force_ascii) if full_process else s tokens = ts.split() # sort tokens and join sorted_string = u&quot; &quot;.join(sorted(tokens)) return sorted_string.strip()# utils.full_processdef full_process(s, force_ascii=False): &quot;&quot;&quot;Process string by -- removing all but letters and numbers -- trim whitespace -- force to lower case if force_ascii == True, force convert to ascii 这里是几种字符过滤方式， &quot;&quot;&quot; if force_ascii: s = asciidammit(s) # Keep only Letters and Numbers (see Unicode docs). string_out = StringProcessor.replace_non_letters_non_numbers_with_whitespace(s) # 用空格替代所有不是字母和数字的 # Force into lowercase. string_out = StringProcessor.to_lower_case(string_out) # Remove leading and trailing whitespaces. string_out = StringProcessor.strip(string_out) return string_out 首先把一个字符串不是字母、数字的字符都用空格替换并转化成小写，然后按照空格切分后进行排序，排序后按照字符级别计算编辑距离比。 编辑距离比的计算方式是：(len(str1)+len(str2)-编辑距离) / (len(str1)+len(str2)) 例如：“Curious San Francisco”（字符含空格长度为21） 和 “San Francisco”（字符不含空格长度为13），编辑距离为8(21 + 13 - 8) / (21 + 13) = 0.7647 “CuriousAAA San Francisco”（字符含空格长度为24） 和 “San Francisco”（字符不含空格长度为13），编辑距离为11(24 + 13 - 11) / (24 + 13) = 0.7027","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"}]},{"title":"macOS及Linux-统计文件夹下的文件目录个数","slug":"macOS及Linux-统计文件夹下的文件目录个数","date":"2021-10-27T16:34:37.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/10/28/macOS及Linux-统计文件夹下的文件目录个数/","link":"","permalink":"http://example.com/2021/10/28/macOS%E5%8F%8ALinux-%E7%BB%9F%E8%AE%A1%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%AA%E6%95%B0/","excerpt":"需求：希望直接在命令行中统计文件夹下的文件、目录个数","text":"需求：希望直接在命令行中统计文件夹下的文件、目录个数 统计文件夹下文件个数，包括子文件 1ls -lR | grep &quot;^-&quot;| wc -l 统计文件夹下目录个数，包括子目录 1ls -lR | grep &quot;^d&quot;| wc -l","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"macOS删除一个文件夹下的.DS_Store","slug":"macOS删除一个文件夹下的-DS-Store","date":"2021-10-11T00:47:34.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/10/11/macOS删除一个文件夹下的-DS-Store/","link":"","permalink":"http://example.com/2021/10/11/macOS%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84-DS-Store/","excerpt":"","text":"进入目标目录，输入以下代码 1find ./ -name &quot;.DS_Store&quot; -depth -exec rm &#123;&#125; \\;","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"Transformer积累阅读","slug":"research/others/Transformer积累阅读","date":"2021-10-07T15:57:00.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2021/10/07/research/others/Transformer积累阅读/","link":"","permalink":"http://example.com/2021/10/07/research/others/Transformer%E7%A7%AF%E7%B4%AF%E9%98%85%E8%AF%BB/","excerpt":"Transformer是Google的研究者在2017年《Attention Is All You Need》论文中提出的用于seq2seq任务的模型，它没有RNN的循环结构或CNN的卷积结构，在机器翻译等任务中取得了一定的提升。 主要的motivation在于RNN、LSTM、GRU类的序列结构中的固有顺序属性阻碍了训练样本之间的并行化，对于长序列，内存限制将阻碍对训练样本的批量处理。 Transformer中完全依赖于注意力机制对输入输出的全局依赖关系进行建模。因为对依赖的建模完全依赖于注意力机制，Transformer使用的注意力机制被称为自注意力（self-attention）","text":"Transformer是Google的研究者在2017年《Attention Is All You Need》论文中提出的用于seq2seq任务的模型，它没有RNN的循环结构或CNN的卷积结构，在机器翻译等任务中取得了一定的提升。 主要的motivation在于RNN、LSTM、GRU类的序列结构中的固有顺序属性阻碍了训练样本之间的并行化，对于长序列，内存限制将阻碍对训练样本的批量处理。 Transformer中完全依赖于注意力机制对输入输出的全局依赖关系进行建模。因为对依赖的建模完全依赖于注意力机制，Transformer使用的注意力机制被称为自注意力（self-attention） References: https://zhuanlan.zhihu.com/p/85864250http://jalammar.github.io/illustrated-transformer/ A High-Level Look把整个Transformer当做一个黑盒，在机器翻译任务中，一种语言作为Transformer的输入，另外一种经过翻译后的语言作为Transformer的输出。 略微细化下，我们看到Transformer架构由Encoding组件，Decoding组件，还有Encoding Decoding两个组件之间的连接组成。 其中的Encoding组件是一个由encoders组成的栈。Decoding组件是一个由和encoders相同数目的decoders组成的栈。 编码器在结构上都是相同的（但是互相之间不共享权重）。每一层分为两个子层，分别是Self-Attention机制和Feed Forward Neural Network 编码器的输入首先要通过一个self-attention层，一个帮助编码器在编码特定单词时查看输入句子中其他单词的层。将在之后进一步分析。 self-attention层的输出反馈给前馈神经网络（feed forward neural network），完全相同的前馈网络独立应用于每个位置。 解码器具有这两个层，但在这两个层之间有一个Encoder-Decoder注意力层，帮助解码器关注输入句子的相关部分（类似于seq2seq模型中注意力的作用）。 Bringing The Tensors Into The Picture首先使用embedding算法将每个输入字词转化为向量。使用这种小型的vectors来进行表示。（在SUMBT中，这一步对应了哪一步？为什么这里每个输入字词会变为vectors?） embedding只发生在最底层的编码器中。所有编码器都有一个共同的抽象概念，即它们接收一个大小为512的向量列表——在底部编码器中是word embedding，在其他编码器中则是直接位于下方的编码器的输出。这个列表的大小是我们可以设置的超参数，基本上是训练数据集中最长句子的长度。 在输入序列中word embedding后，每个单词都会流经编码器的两层。 在这里，我们看到Transformer的一个关键属性，即每个位置的字在编码器中通过自己的路径流动。在self-attention层中，这些路径之间存在依赖关系。然而前馈层（feed forward layer）没有这些依赖关系，因此在流经前馈层时，可以并行执行各种路径。 接下来，把示例切换到一个较短的句子，并查看编码器的每个子层中放生了什么。 Now We’re Encoding!正如我们已经提到的，编码器接收向量列表作为输入（在SUMBT中就是bert embedding后的那些内容）。它通过将这些向量传递到self-attention层，然后传入前馈神经网络，然后将输出向上发送到下一个编码器来处理该列表。每个位置的单词都经过一个自我注意过程。然后，它们各自通过一个前馈神经网络——一个完全相同的网络，每个向量分别通过它。 Self Attention at a High Level不要被我胡说“self-attention”这个词所愚弄，因为这是每个人都应该熟悉的概念。在阅读《Attention Is All You Need》这篇论文之前，博客作者从未想到过这个概念。让我们总结一下它的工作原理。 假设以下句子是我们要翻译的输入句子： 1The animal didn&#x27;t cross the street because it was too tired 在这一句子中，“it”指代的是什么？是指代的street还是animal？对于人类这是简单的，但是对于算法这是复杂的 当我们的模型在处理“it”这个单词的时候，self-attention允许把“it”和“animal”联系起来 当模型在处理每个单词的时候（输入语句的每个位置处），self-attention允许其关注输入语句的其他位置来寻求线索，并得出一种对于这个word更好的encoding 如果对RNN足够熟悉，请考虑如何维护hidden state，使得RNN能够将其已处理的先前单词/向量的表示形式与其正在处理的当前单词/向量结合起来。self-attention是Transformer用来将其他相关单词的“理解”bake到我们当前正在处理的单词中的方法。 当我们在编码器#5（堆栈中的顶部编码器）中对单词“it”进行编码时，部分注意力机制将注意力集中在“动物”上，并将其表示的一部分烘焙到“it”的编码中。 这里需要更加明确self-attention机制的输入输出分别是什么，从个人理解来说是3个输入，1个输出？ Self-Attention in Detail让我们先看看如何使用向量计算自我注意，然后继续看看它是如何实际实现的——使用矩阵 计算self-attention的第一步是从编码器的每个输入向量中创建三个向量（在本例中，是每个单词的embedding），所以对于每个单词，我们创建Query vector，一个Key vector， 和一个Value vector。这些向量是通过将embedding乘以我们在训练过程中训练的三个矩阵来创建的 突然注意到768 / 64 = 12 请注意，这些新向量的维数小于嵌入向量，它们的维数为64，而且如和编码器输入/输出向量的维数为512。它们不必更小，这是一种架构选择，可以使用MultiHeadAttention（多头注意力机制）来使得计算保持不变（这里是指维度？） 将x1乘以WQ权重矩阵生成q1，即与该单词相关联的“查询”向量。我们最终创建了输入句子中每个单词的“查询”、“键”和“值”投影。 （差一张手画的图插进来） 什么是query key value向量？ 根据师兄的解释，query感觉可以理解成一个自己的内容信息，而key理解成一个别人的信息，这样在和别人进行比较的时候就是上是用自己的q和别人所有的k进行比较 它们是用于计算和思考注意力机制的抽象概念，继续阅读下面的注意力是如何计算的，就会知道关于每个向量所扮演角色的几乎所有内容。 计算self-attention的第二步是计算分数，假设我们正在计算本例中第一个单词“Thinking”的自我关注度。我们需要给输入句子中的每个单词打分。分数决定了当我们在某个位置对一个单词进行编码时，要把多少注意力放在输入句子的其他部分上。 分数是通过将query向量的点积与我们正在评分的各个单词的key向量相结合来计算的。因此，如果我们处理位置#1的单词的自我注意，第一个分数将是q1和k1的点积。第二个分数是q1和k2的点积。（点积将会得到一个分数） 第三步和第四步是将分数除以8（论文中使用的关键向量维数的平方根–64。这会导致更稳定的梯度。这里可能有其他可能的值，但这是默认值），然后通过softmax操作传递结果。Softmax将分数标准化，使其全部为正值，加起来等于1。 此softmax分数确定每个单词在此位置的表达量。很明显，这个位置上的单词将具有最高的softmax分数，但有时关注与当前单词相关的另一个单词会很有用。 第五步是将每个值向量乘以softmax分数（准备将他们相加）。这里的直觉是保持我们想要关注的单词的完整值，并忽略不相关的单词（例如，将它们乘以0.001这样的小数字） 第六步是对加权值向量求和。这将在该位置（对于第一个单词）生成自我注意层的输出。 自我注意力计算到此结束。结果向量是我们可以发送到前馈神经网络的向量。然而，在实际实现中，这种计算是以矩阵形式进行的，以加快处理速度。现在我们来看一下，我们已经看到了单词级计算的直觉。 Matrix Calculation of Self-Attention第一步是计算查询、键和值矩阵。我们通过将嵌入项打包到矩阵X中，并将其乘以我们训练的权重矩阵（WQ，WK，WV）来实现这一点。 X矩阵中的每一行对应于输入句子中的一个单词。我们再次看到嵌入向量（512，或图中的4个框）和q/k/v向量（64，或图中的3个框）的大小差异 最后，由于我们处理的是矩阵，我们可以将第二步到第六步浓缩成一个公式来计算自我注意层的输出。 The Beast With Many Heads本文通过添加了一种称为“Multi-Head”注意力的机制，进一步细化了self-attention层。从这两个方面提高了注意层的性能： 它扩展了模型关注不同位置的能力。是的，在上面的例子中，z1包含了一些其他单词所产生的编码，但是它可能被更加实际的单词本身所支配（这里是指权重比较高？）。如果我们翻译一句话，比如“动物没有过马路是因为它太累了”，我们会想知道“它”指的是哪个词。 它为注意力层提供了多个“表示子空间”（有一种增大参数量的感觉？）。正如我们接下来将要看到的，对于multihead-attention，我们不仅有一组，而且有多组query/key/value权重矩阵（Transformer使用8个attentionhead，因此每个编码器/解码器有8组）。这些集合中的每一个都是随机初始化的。然后，在训练之后，使用每个集合将输入embedding（或来自较低编码器/解码器的向量）投影到不同的表示子空间。 通过multihead-attention，我们为每个head维护单独的Q/K/V权重矩阵，从而产生不同的Q/K/V矩阵。和前面一样，我们用X乘以W^Q/W^K/W^V矩阵，得到Q/K/V矩阵。 如果我们做上边所述的同样的self-attention计算，只需使用不同的权重矩阵进行八次不同的计算，我们最终得到八个不同的Z矩阵。 这给我们留下了一点挑战，前馈层不需要八个矩阵，它需要一个矩阵（每个单词对应一个向量（自：这里说的是z？））。所以我们需要一种方法把这八个元素压缩成一个矩阵。 我们怎么做？我们将矩阵合并（concatenate），然后将它们乘以一个额外的权重矩阵W^O。 这里感觉是concate表示了的不行，还要把这些融合到一起才行？或者说要保证输入的X和输出的Z是shape相同的？ multi-head如果是这样的操作的话就是一种增加参数量的作用？ 其亮点还主要在于“平权”的对待各个位置处，起到一种self-attention的作用。 这几乎就是multi-head attention的全部内容。这是相当多的矩阵，如果把他们放在一个图表示就可以更直观的看到这个过程。 既然我们已经谈到了multihead attention，那么让我们回顾一下之前示例，看看在我们的示例语句中对单词“it”进行编码时，不同的注意力头集中在哪里。 当我们对“它”这个词进行编码时，一个注意力集中在“动物”身上，而另一个注意力集中在“疲劳”身上——从某种意义上说，模型对“它”这个词的表达同时包含了一些“动物”和“疲劳”的表达。 然而，如果我们把所有的注意力都放在画面上，事情就更难解释了： 其余的Transformer部分和所要了解的代码暂时无关，未来再进一步学习了","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Transformer","slug":"Transformer","permalink":"http://example.com/tags/Transformer/"}]},{"title":"DST论文阅读-SUMBT","slug":"research/papers/DST论文阅读-SUMBT","date":"2021-09-27T01:46:05.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2021/09/27/research/papers/DST论文阅读-SUMBT/","link":"","permalink":"http://example.com/2021/09/27/research/papers/DST%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-SUMBT/","excerpt":"SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking论文阅读笔记SUMBT: 槽-话语匹配的对话状态跟踪器，用来进行通用和可扩展的信念跟踪","text":"SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking论文阅读笔记SUMBT: 槽-话语匹配的对话状态跟踪器，用来进行通用和可扩展的信念跟踪 References: Lee H, Lee J, Kim T Y. SUMBT: Slot-Utterance Matching for Universal and Scalable Belief Tracking[C]//Proceedings of the 57th Annual Meeting of the Association for Computational Linguistics. 2019: 5478-5483.对话状态跟踪学习笔记：https://blog.csdn.net/zerozzl01/article/details/112215175 注：分段和作者的文章不一定相同 一些基础概念的个人笔记补充简介对话状态跟踪（dialogue state tracking）是任务型（task-oriented）对话系统中的一部分。更具体的来说，是对话管理中的一部分。对话状态是从对话开始到当前对话的用户目标的总结，通常表现为多组槽-值（slot-value）的组合的形式，有时也会包括对话所属的领域、用户意图等信息。对话状态跟踪是指结合对话历史、当前对话、前一轮对话状态等信息，推断并更新当前对话状态的过程 关键概念1）领域（domain）：可以理解为业务场景，如hotel、train、restaurant等。2）意图（intention）：用户话语的目的，如请求信息、提供信息、确认信息等。3）槽（slot）：槽指某种信息，与完成任务所需要获得的某种信息相对应。比如在预定酒店这个任务中，相关的槽有name、area、price range等。餐馆示例：[area, food, price range]4）本体（ontology）：数据集中，涉及到的所有领域、意图、槽以及相关的所有值构成的数据字典，称为该数据集的本体。 评价指标1）联合目标准确率（joint goal accuracy）/ 联合状态准确率（joint state accuracy）：一般也简称joint accuracy。对于每轮对话，将预测的对话状态和真实的对话状态进行比较，当且仅当对话状态中所有的（domain，slot，value）预测正确时，才认为对话状态预测正确。问题记录：这里需要结合论文所给出的代码查看下联合目标准确率的具体含义，到底是不是一次对话过程中，全部状态正确才算正确？ 2）槽位准确率（slot accuracy）：单独比较每个（domain，slot，value），当预测值与真实值匹配时，认为预测正确。 3）推断时间复杂度（inference time complexity, ITC）：ITC的计算方式是完成一次对话状态预测，需要inference多少次。ITC越小越好。 Abstract在面向目标（goal-oriented）的对话系统中，信念跟踪器（belief trackers）预测每个对话回合时的槽值对概率分布。以前的神经网络方法已经为领域（ontology）和槽依赖的belief trackers进行了建模，导致领域本体配置缺乏灵活性。 问题记录： 以往的方法，建模的跟踪器都是领域/槽位依赖的，所以欠缺领域本体设置的灵活性。作者把这些以往的方法统称为slot-dependent methods。这个地方怎么理解，欠缺设置的灵活性？ 在本文中，作者提出了一种新的通用（universal）并可扩展（scalable）的信念跟踪器方法，被称作slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器，SUMBT）。模型通过基于上下文语义的注意力机制来学习领域槽类别（domain-slot-types）与对话中出现的槽-值对之间的关系。更进一步的，模型通过一种非参数的方法预测槽-值对的值。 这里所说的“基于上下文语义的注意力机制”类似就是用BERT作为tokenizer的这个感觉？ 根据作者在两个对话语料库WOZ2.0和MultiWOZ上的实验结果，与槽依赖的方法相比，该模型的性能有所提高，并达到了最先进的joint accuracy。 还要通过后文的阅读，理解这里作者所说的槽依赖（slot-dependent）的方法到底和作者所提的方法有什么不同。 Introduction随着会话代理的广泛使用，面向目标的系统越来越受到学术界和工业界的关注。面向目标的对话系统帮助用户实现目标，如在对话结束时预定餐厅或预定航班。随着对话的进行，系统需要更新对话状态的分布，对话状态包括用户的意图、可信息的槽位、和可请求的槽位。这被称作belief tracking（信念跟踪）或者被称作dialogue state tracking（对话状态跟踪, DST）。 问题记录： 这里对应到数据集上到底在预测什么，除了槽值对外，看起来还有很多需要记录的地方？ 例如，对于给定的域（domain）和槽类型（slot-types），（例：‘restaurant’ domain 和 ‘food’ 槽类型），这个任务估计了在领域本体中预定义的，相对应的候选槽值对（slot-value）概率（例：‘Korean’和‘Modern European’） 由于系统使用DST的预测输出，根据对话策略（Policy Learning环节？）选择下一个操作，因此DST的准确性对于提高系统整体性能至关重要。此外，对话系统应该能够以灵活的方式处理新添加的域和槽，因此开发可伸缩的对话状态跟踪器是不可避免的。 关于这一点，Chen等人提出一种从意图-话语对中捕捉关系的模型，用于意图扩展。 问题记录： 这里说以灵活的方式处理新添加的域和槽，这个不应该都是已定义好的，为什么会能增加，作者一直在围绕着可扩展性讲故事。（相对于去雾类的论文中的一些idea，这些想法是否属于在NLP领域中直观的想法） 传统基于统计方法的belief trackers容易受到词汇和形态变化的影响，因为他们依赖于手动构建的语义词典。随着深度学习方法的兴起，一些neural belief trackers（NBT）被提出，并通过学习单词的语义神经表征来提高性能。然而，可扩展性仍然是一个挑战，先前提出的方法要么对每个域、槽单独建模，要么难以添加本体中未定义的新槽值。 在本文中，我们致力于开发一个“可伸缩”和“通用”的belief tracker，其中只有一个信念跟踪器用于处理任何域和槽类型。为了解决这个问题，我们提出了一种新的方法，称为slot-utterance matching belief tracker（槽-话语匹配的对话状态跟踪器），他是一种与域和槽独立的对话状态跟踪器，其结构如figure 1所示。 灵感来自机器阅读理解技术，SUMBT考虑domain-slot type这个组合（例如 ‘restaurant-food’）将其视为一个问题，并在一对用户和系统话语中找到相应的槽值对，假设话语中存在期望的答案。 SUMBT使用最近提出的BERT对系统和用户的话语（utterance）进行编码，BERT提供句子的语境化语义表示。此外，domain-slot-types 和 slot-values也使用BERT进行字面编码 上边的意思是，这几个地方都会被BERT编码： [CLS] what type of food would you like? [SEP] a moderately priced modern European food.[SEP] [CLS] restaurant - food [SEP] [CLS] modern European [SEP] 然后SUMBT根据上下文语义向量，学习与话语词中domain-slot-type相关的“参加方式（the way where to attend）”。该模型基于某些度量以非参数方式预测slot-value的标签，从而使模型体系结构在结构上不依赖于域和slot-types。因此，单个SUMBT可以处理一对domain-slot-type和slot-value，还可以利用多个域和槽之间的共享知识 或许这篇文章是比较早把BERT结合进来的操作？ 作者在两个目标面向的对话语料库：WOZ2.0 和 MultiWOZ 上通过实验证明该提议模型的有效性。还将定性分析该模型的工作原理。并将其实现公开发布。 SUMBT所提出的模型由4部分组成，就像图1中所示的。① BERT encoders，用来对【槽】，【值】，【话语】进行encoding（图中的灰色和蓝色部分）② 一个 slot-用户话语匹配的network（图中的红色部分）③ 一个对话状态跟踪器（图中的橙色部分）④ 一个无参数的鉴别器（discriminator，图中的最上端虚线连接） Contextual Semantic Encoders对于句子编码器，我们采用了预训练的BERT模型，这是一个双向Transformer编码器的深层堆栈。与普通的词向量相比，这种方式提供了上下文带有语义化的词向量。更进一步的，它提供了词句和句子等词序列的聚合表示，因此我们可以获得由多个词组合的slot-types或slot-values。 这里主要记录下： slot-values: [[area_slot1, area_slot2, area_slot3…], [food_slot1, …], [price_range_1, …]] slot-types: [area, food, price range] 经过一系列操作处理后： y_vt label_token_ids根据v_t slot-values得到: [torch.Size([7, 32]), torch.Size([xx1, 32]), torch.Size([xx2, 32])]，这里xx1，xx2分别代表food和price range的标签数目 q_s slot_token_ids根据s domain-slot-types得到: torch.Size([3, 32])，因为在WOZ这个数据集中只有3个label Slot-Utterance Matching为了从话语中检索与domain-slot-type（area，food，price range）对应的相关信息，该模型使用注意力机制。把domain-slot-type经过encoder的encoded vector q^s作为一个query，将其与【每个each】单词位置的上下文语义向量u相匹配，然后计算注意力分数。 这里，作者采用了multi-head attention的注意力机制。多头注意力机制将查询矩阵Q、key矩阵K和value矩阵V映射为不同的线性h投影，然后在这些矩阵上执行缩放点积注意力机制。slot s 和 t处的话语之间的有注意上下文向量hst是： 这里的注意力机制可能需要结合代码和原理详细的学习一下，感觉主要是计算用户每一个词是在哪个domain-slot-type做一个分类的感觉？ Belief Tracker 对话状态跟踪器随着对话的进行，每个回合的belief state由之前的对话历史和当前的对话回合决定。这个对话流可以被RNN类的LSTM和GRU，或者Transformer decoders建模（例如：left-to-right uni-directional Transformers） 在本项工作中，上下文向量h_t，还有RNN的上一个state被送入到RNN中，这是用来学习与目标的slot-values相接近的语义向量 等于说每次训练的时候，送入的是当前domain-slot-type和用户utterance的结合，在WOZ数据集上的反应就是，每次训练使用[area, food, price range]这个domain-slot-type结合用户的话术，通过注意力机制实现了用户话语更加关注哪个，然后将这个注意力机制结合之前状态等得到的hidden计算结果与slot-values匹配得到最小的 作者考虑到BERT是使用layer normalization进行nomal化的，RNN输出的d_t也被送入到一个layer normalizaiton层，来帮助训练训练收敛。","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Dialogue State Tracking","slug":"Dialogue-State-Tracking","permalink":"http://example.com/tags/Dialogue-State-Tracking/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"}]},{"title":"macOS及Linux-命令行工具diff","slug":"macOS及Linux-命令行工具diff","date":"2021-09-16T12:22:05.000Z","updated":"2022-11-20T01:50:08.889Z","comments":true,"path":"2021/09/16/macOS及Linux-命令行工具diff/","link":"","permalink":"http://example.com/2021/09/16/macOS%E5%8F%8ALinux-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7diff/","excerpt":"需求：如果使用beyond compare等工具做diff还是有时候有些不方便的，或者说不够灵活。可以在macOS或者Linux系统中直接使用语句进行diff操作，并且在这里补充了一些关于zsh配置和colordiff的说明。","text":"需求：如果使用beyond compare等工具做diff还是有时候有些不方便的，或者说不够灵活。可以在macOS或者Linux系统中直接使用语句进行diff操作，并且在这里补充了一些关于zsh配置和colordiff的说明。 1. 流程和操作说明在目录下执行如下语句即可进行简单的diff操作 1$ diff -u [file A] [file B] 2. colordiff及zsh相关配置在目前使用的苹果电脑环境下，通过如上语句显示diff没有高亮不方便阅读，故通过如下命令安装colordiff 1$ brew install colordiff 安装完成后，可以在任意一个zsh窗口下执行命令进行带颜色的diff操作： 1$ colordiff -u [file A] [file B] 原来的diff已经不用了，可以指定diff直接到colordiff，在当前zsh窗口下执行如下命令，即可在当前窗口完成diff代替colordiff的操作（注：可以使用文件查看） 1$ alias diff=colordiff 如果要每次都生效，需要执行如下操作： 1234$ vim ~/.zshrc在最后一行加入alias diff=colordiff 3. 效果展示","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"}]},{"title":"Dialogue-State-Tracking简述","slug":"research/papers/Dialogue-State-Tracking简述","date":"2021-09-14T13:13:21.000Z","updated":"2022-11-20T01:50:08.929Z","comments":true,"path":"2021/09/14/research/papers/Dialogue-State-Tracking简述/","link":"","permalink":"http://example.com/2021/09/14/research/papers/Dialogue-State-Tracking%E7%AE%80%E8%BF%B0/","excerpt":"学习一些中文论文来大概理解下DST这个任务： Reference: 郑正凯. 基于深度学习端到端的对话状态跟踪研究[D].山东大学,2021.","text":"学习一些中文论文来大概理解下DST这个任务： Reference: 郑正凯. 基于深度学习端到端的对话状态跟踪研究[D].山东大学,2021. 1. Dialogue State Tracking简述dst任务一般用在任务型对话中，是pipeline中的一个部分。组成对话系统的各模块按照①自然语言理解（NLU）、②对话状态跟踪（DST）、③策略学习（Policy Learning）、④自然语言生成（NLG）四部分组成。 其中NLU模块将输入文本转化为结构化的语义表示，提取出对用户当前话语中与任务相关的信息，主要使用意图识别和槽值填充的方法； DST模块负责维护系统状态，即获取用户目标，对用户目标进行实时更新； PL模块负责根据系统状态选择合适的信息对用户进行反馈； NLG模块负责把系统反馈的信息转化为自然语言输出给用户。 2. 对话状态跟踪相关理论英文数据集MultiWOZ 2.0 2.1 2.2 2.3，其中2.3应该是非常新的版本 中文数据集CrossWOZ 2.1 数据组成结构在对话状态跟踪任务中，数据由以下几方面组成：基于特定任务的槽值对、用户当前轮输入、上轮次的系统反馈（以前所有轮？）、上轮次的系统状态（以前所有轮？） （1）槽值对（Slot-Value）“槽”指系统向用户提供服务之前需要事先确定的信息，而“槽值”是指用户需要提供给系统的具体信息。槽值是具体信息，槽是槽值的统称，一个槽可以对应多个槽值，同一领域内一个槽值只能对应一个槽。 在跨领域对话系统中，槽的上类称为领域，比如餐馆、酒店、景点等；一个领域可以对应很多槽（酒店有价格、酒店有地理位置……），一个槽也可以对应很多领域（酒店有价格、餐厅有价格……）。所以我们将领域与槽拼接起来作为槽，这样使得槽变成了唯一，例如“酒店-名称”，“景点-价格” 在任务型系统中，一般都会有多个槽，每个槽有多个值，用户的意图是多样且不确定的，系统需要与用户通过多轮互动获取用户的真实意图，如在旅游咨询系统中，将“景点-名称”、“酒店-价格”，“餐馆-推荐菜”等用户需要提供信息的类定义为槽，而“餐馆-推荐菜”对应的“北京烤鸭”，“小笼包”等均为槽值。对话状态追踪的目的是在每一轮对话中能够准确识别出用户是否表达出某个槽通过对数据集中槽值对进行统计分析可以获得槽值对形式的知识库，这个知识库能够作为主体文件参与模型的训练与预测。 （2）用户当前轮输入在多轮对话中，用户当前输入作为对话状态追踪的重要信息，当前轮输入可以是陈述需求或者有疑问推荐，也可以是对上一轮系统反馈的回答及提出新的要求。通过与系统的交互过程中，用户可以随时更新自己的需求，系统会根据用户输入的信息及时更新对话状态。 （3）上轮次的系统状态与系统反馈（系统角度）在DST任务中，一般都会初始化系统状态为{Slot: None}，通过不断地更新状态使得系统获取相关信息。在DST过程中，上下文信息在一定程度上影响了后续的动作，由于上一轮系统反馈与当前轮用户输入有着密切联系，所以一般对话状态跟踪模型均会将上一轮系统状态及反馈作为输入。 而上一轮的系统反馈无外乎两种信息，一种是针对上一轮用户输入给出的问答式回复或推荐，另一种是由于用户给与的信息量不足或者意图不明确，需要用户增加信息，所以系统会主动向用户发送确认或者请求。 系统确认是对用户进行槽值确认，如“你喜欢面条吗？”，此时系统的状态为{food: noodle，request: None …}【需要用户增加信息】 系统请求是询问用户特定槽对应的值，如“不幸的是，价格便宜的已售罄，请选择其他价格范围的菜品”，此时系统状态变为{food: noodle, request: price range}【需要用户增加信息】 2.2 对话状态追踪过程（DST）","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Dialogue State Tracking","slug":"Dialogue-State-Tracking","permalink":"http://example.com/tags/Dialogue-State-Tracking/"}]},{"title":"ConvLab-2 Getting Started","slug":"ConvLab-2 Getting Started","date":"2021-09-14T12:01:01.000Z","updated":"2022-11-20T01:50:08.881Z","comments":true,"path":"2021/09/14/ConvLab-2 Getting Started/","link":"","permalink":"http://example.com/2021/09/14/ConvLab-2%20Getting%20Started/","excerpt":"ConvLab-2.ipynb ConvLab-2是一个开源工具包，使研究人员能够使用最先进的模型构建面向任务的对话系统，执行端到端评估，并诊断系统的弱点。作为ConvLab的继承者，ConvLab-2继承了ConvLab的框架，但集成了更强大的对话模型并支持更多的数据集。此外，作者还开发了一个分析工具和一个交互式工具，以帮助研究人员诊断（diagnosing）对话系统。 从这里学习一些对话系列的模型，服务器上操作遇到一些问题，目前还是用google colab操作的 Reference： https://github.com/thu-coai/ConvLab-2","text":"ConvLab-2.ipynb ConvLab-2是一个开源工具包，使研究人员能够使用最先进的模型构建面向任务的对话系统，执行端到端评估，并诊断系统的弱点。作为ConvLab的继承者，ConvLab-2继承了ConvLab的框架，但集成了更强大的对话模型并支持更多的数据集。此外，作者还开发了一个分析工具和一个交互式工具，以帮助研究人员诊断（diagnosing）对话系统。 从这里学习一些对话系列的模型，服务器上操作遇到一些问题，目前还是用google colab操作的 Reference： https://github.com/thu-coai/ConvLab-2 1. 初始化准备，installationgit clone 自己fork git的内容（注意在colab环境下的修改一定要同步到本地中，或者说每次都是本地改完想办法传到colab/github上） 1!git clone https://github.com/yixuan004/ConvLab-2.git &amp;&amp; cd ConvLab-2 &amp;&amp; pip install -e . 安装spacy使用的en_core_web_sm，来解决BERTNLU中的内容 1!python -m spacy download en_core_web_sm 2. build an agent这里感觉是构建一个机器自动应答的pipeline，包括NLU，DST，Policy和NLG这些模块，组合在一起可以作为机器端的对话机器的感觉 12345678910111213from convlab2.nlu.jointBERT.multiwoz import BERTNLUfrom convlab2.nlu.milu.multiwoz import MILUfrom convlab2.dst.rule.multiwoz import RuleDSTfrom convlab2.policy.rule.multiwoz import RulePolicyfrom convlab2.nlg.template.multiwoz import TemplateNLGfrom convlab2.dialog_agent import PipelineAgent, BiSessionfrom convlab2.evaluator.multiwoz_eval import MultiWozEvaluatorfrom pprint import pprintimport randomimport numpy as npimport torchprint(&quot;import done!&quot;) 建立模型并建造一个agent 12345678910111213# go to README.md of each model for more information# BERT nlu，understandingsys_nlu = BERTNLU()# simple rule DST，trackingsys_dst = RuleDST()# rule policy，rulesys_policy = RulePolicy()# template NLG，生成sys_nlg = TemplateNLG(is_user=False)# assemble，集成到一个pipeline里sys_agent = PipelineAgent(sys_nlu, sys_dst, sys_policy, sys_nlg, name=&#x27;sys&#x27;)print(&quot;build agent done!&quot;) 和agent进行手动输入对话测试 123456789101112# 对话1sys_agent.response(&quot;I want to find a moderate hotel&quot;)&gt;&gt;&gt; We have 18 such places . How about bridge guest house ? Fits your request perfectly .sys_agent.response(&quot;Which type of hotel is it ?&quot;)&gt;&gt;&gt; It is a guesthouse .sys_agent.response(&quot;OK , where is its address ?&quot;)&gt;&gt;&gt; It is located at 124 tenison road.sys_agent.response(&quot;Thank you !&quot;)&gt;&gt;&gt; Thank you for contacting the help desk . Have a great day . 123456789# 对话2sys_agent.response(&quot;Try to find me a Chinese restaurant in south area .&quot;)&gt;&gt;&gt; There are 3 different places that match your description . The lucky star has some great reviews . How about chinese ?sys_agent.response(&quot;Which kind of food it provides ?&quot;)&gt;&gt;&gt; They serve chinese .sys_agent.response(&quot;Book a table for 5 , this Sunday .&quot;)&gt;&gt;&gt; Your reference number is 00000003 . 3. Build a simulator to chat with the agent and evaluate构建一个模拟器与代理聊天并评估 在许多一对一面向任务的对话系统中，模拟器对于训练RL代理是必不可少的。在我们的框架中，我们不区分用户和系统。所有发言者都是代理人。模拟器也是一个代理，内部有特定的策略以实现用户目标。 我们对模拟器使用Agenda策略，该策略需要对话行为输入，这意味着我们应该将PipelineAgent的DST参数设置为None。然后PipelineAgent将直接将对话act传递给策略。有关更多详细信息，请参阅PipelineAgent文档。（这里不是很明白为什么要把user_policy设置为None） 这里是模拟器，因为是模拟器所以代表了用户，这样在交互的过程中并不需要跟踪对话状态，所以不需要DST？ 12345678910# MILUuser_nlu = MILU()# not use dstuser_dst = None# rule policyuser_policy = RulePolicy(character=&#x27;usr&#x27;)# template NLGuser_nlg = TemplateNLG(is_user=True)# assembleuser_agent = PipelineAgent(user_nlu, user_dst, user_policy, user_nlg, name=&#x27;user&#x27;) # user的agent！ 现在我们有了一个simulator和一个agent。我们将使用现有的简单的一对一会话控制器BiSession，还可以定义自己的Session class来应对自己的特殊需求 我们添加了MultiWozEvaluator来评估性能。它使用的解析的对话框act input 和策略输出对话框act来计算inform f1、book rate以及任务是否成功 12evaluator = MultiWozEvaluator()sess = BiSession(sys_agent=sys_agent, user_agent=user_agent, kb_query=None, evaluator=evaluator) 让这两个代理进行会话！key是BiSession类的next_turn这个方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101def set_seed(r_seed): random.seed(r_seed) np.random.seed(r_seed) torch.manual_seed(r_seed)set_seed(20210914)sys_response = &#x27;&#x27;sess.init_session()print(&#x27;init goal:&#x27;)pprint(sess.evaluator.goal)print(&#x27;-&#x27;*50)for i in range(20): sys_response, user_response, session_over, reward = sess.next_turn(sys_response) print(&#x27;user:&#x27;, user_response) print(&#x27;sys:&#x27;, sys_response) print() if session_over is True: breakprint(&#x27;task success:&#x27;, sess.evaluator.task_success())print(&#x27;book rate:&#x27;, sess.evaluator.book_rate())print(&#x27;inform precision/recall/f1:&#x27;, sess.evaluator.inform_F1())print(&#x27;-&#x27;*50)print(&#x27;final goal:&#x27;)pprint(sess.evaluator.goal)print(&#x27;=&#x27;*100)&gt;&gt;&gt; init goal:&#123;&#x27;attraction&#x27;: &#123;&#x27;info&#x27;: &#123;&#x27;area&#x27;: &#x27;east&#x27;&#125;, &#x27;reqt&#x27;: &#123;&#x27;address&#x27;: &#x27;?&#x27;, &#x27;entrance fee&#x27;: &#x27;?&#x27;, &#x27;phone&#x27;: &#x27;?&#x27;&#125;&#125;&#125;--------------------------------------------------user: I am planning a trip to town and want to sight see a bit . Can you let me know some attractions I may be interested in ? Can you recommend some attractions in the east ?sys: There are 10 , anything in particular you are looking for ? I recommend saint barnabas press gallery. They are located at the belfast yard, coldham&#x27;s road .user: Sounds good . Could I get the phone number of the attraction ? Can you let me know what the entrance fee is too ?sys: The attraction phone number is 01223902088 . Its entrance fee is ? .user: Does it have an entrance fee ?sys: Its entrance fee is ? .user: Does it have an entrance fee ?sys: Their entrance fee is ? by our system currently .user: Does it have an entrance fee ?sys: Their entrance fee is ? by our system currently .user: I will need the entrance fee please .sys: Its entrance fee is ? .user: I would like to know the entrance fee .sys: Their entrance fee is ? by our system currently .user: What are the entrance fees ?sys: The entry fee is ? .user: Can you tell me the entrance fee ?sys: Their entrance fee is ? by our system currently .user: Does it have an entrance fee ?sys: Their entrance fee is ? by our system currently .user: Does it have an entrance fee ?sys: Its entrance fee is ? .user: Is there an entrance fee ?sys: The entry fee is ? .user: Can you let me know what the entrance fee is too ?sys: The entry fee is ? .user: Can you tell me the entrance fee ?sys: The entry fee is ? .user: I will need the entrance fee please .sys: Their entrance fee is ? by our system currently .user: I would like to know the entrance fee .sys: Their entrance fee is ? by our system currently .user: I just need to know how much the entrance fee is .sys: Their entrance fee is ? by our system currently .user: Can you give me the entrance fee ?sys: Their entrance fee is ? by our system currently .user: Can you let me know what the entrance fee is too ?sys: The entry fee is ? .user: Does it have an entrance fee ?sys: Its entrance fee is ? .task success: 0book rate: Noneinform precision/recall/f1: (1.0, 0.6666666666666666, 0.8)--------------------------------------------------final goal:&#123;&#x27;attraction&#x27;: &#123;&#x27;info&#x27;: &#123;&#x27;area&#x27;: &#x27;east&#x27;&#125;, &#x27;reqt&#x27;: &#123;&#x27;address&#x27;: &quot;the belfast yard, coldham&#x27;s road&quot;, &#x27;entrance fee&#x27;: &#x27;?&#x27;, &#x27;phone&#x27;: &#x27;01223902088&#x27;&#125;&#125;&#125;==================================================================================================== 还有一些其他简易操作，例如Try different module combinations，Use analysis tool to diagnose the system，见.ipynb中的整理了","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Dialogue","slug":"Dialogue","permalink":"http://example.com/tags/Dialogue/"}]},{"title":"MultiWOZ数据集学习","slug":"MultiWOZ数据集学习","date":"2021-09-13T12:25:07.000Z","updated":"2022-11-20T01:50:08.881Z","comments":true,"path":"2021/09/13/MultiWOZ数据集学习/","link":"","permalink":"http://example.com/2021/09/13/MultiWOZ%E6%95%B0%E6%8D%AE%E9%9B%86%E5%AD%A6%E4%B9%A0/","excerpt":"主要记录了通过了解数据集作为对DST任务的入门，MultiWOZ数据集是适用于任务型对话系统的数据集，目前看了一遍这个简介后还是不太明白，感觉还需要各种渠道多了解下 Reference： 任务型对话系统数据集详解大全（MultiWOZ /DSTC） https://zhuanlan.zhihu.com/p/200747822","text":"主要记录了通过了解数据集作为对DST任务的入门，MultiWOZ数据集是适用于任务型对话系统的数据集，目前看了一遍这个简介后还是不太明白，感觉还需要各种渠道多了解下 Reference： 任务型对话系统数据集详解大全（MultiWOZ /DSTC） https://zhuanlan.zhihu.com/p/200747822 2021.9.13 首次学习1. MultioWOZ的前世今生·New WOZ：2018年剑桥大学研究人员在提出一个新的multi-domain DST模型的同时，顺带提出了New WOZ数据集，被看作是1.0的最初版本，发表在ACL； ·MultiWOZ 2.0：在1.0版本不错后，这些研究人员首次提出了MultiWOZ这个数据集，也就是一般所说的MultiWOZ 2.0，是当年EMNLP的Best Paper； ·MultiWOZ 2.1：2019年亚马逊的研究人员对MultiWOZ 2.0数据集中的一些错误进行修正，添加了对槽位的解释和对话行为的标注，代表MultiWOZ 2.1版本 ·MultiWOZ 2.2：2020年google的研究人员在2.1的基础上提出升级版2.2； 2. MultiWOZ这个名字的由来MultiWOZ的全称是Multi Domain Wizard-of-Oz，其中Wizard-of-Oz是Wizard-of-Oz Experiment或者Wizard-of-Oz Testing或者Wizard-of-Oz Method，是一种方法、技术。简单来说，你以为你在跟机器对话，实际上这个机器的背后是另一个人，是一种使还没有实现的技术先通过人工模拟系统的相应的技术手段。 因为用到了Wizard-of-Oz方法进行数据的制作和收集，所以采用这个名字。也提到了crowd-sourcing众包的方法，比较通俗的解释是“众包找人来干活，但不花钱，找社会上的志愿者，你一点我一点大家一起把这个事情完成”。关于这个方法作者还展示了他们做的GUI，专门用来让大众制作收集数据集。 3. MultiWOZ 2.0数据集细节：·主要目标：在旅游城市的信息中心获取旅游者查询的高度自然对话 ·Domain（域）：Attraction，Hospital，Police，Hotel，Restaurant，Taxi，Train，其中后四个域属于扩展域，包括子任务Booking。每段对话涉及1-5个领域，因此长度和复杂性差别很大。全部的act和slot如下： ·数量及分布：10438个对话，其中3406个单领域对话，7032个多领域对话，多领域中，包含最少2-5个领域。70%的对话超过10个会和，其中单领域平均轮数为8.93，多领域为15.39。在数据里，对话的序号前面是SNG的就是单轮，MUL的就是多轮。 ·数据结构：每个对话包含a goal，multiple user，system utterances(系统话语)，belief state（？信度状态），dialogue acts and slots（可能需要结合具体数据进一步理解下） ·Belief state：有三个部分，分别是semi，book，booked、其中semi是特定领域里的槽值；book在特定领域的booking slots；booked是book的一个子集，在book这个字典里，是booked entity ↑这段话不太好理解，感觉还得从具体数据内容来看 4. MultiWOZ as a New BenchmarkMultiWOZ作为新的benchmark，提供了三个子任务，分别是，dialogue state tracking、dialogue-act-to-text generation，dialogue context-to-text generation 其中·Dialogue state tracking：用在餐厅子领域的overall和joint goals的accuracy作为评价指标 相关指标更新见：https://github.com/budzianowski/multiwoz 感觉理解的还不是很清楚，还需要进一步看下对话相关的任务一类的来理解吧 2021.10.24 笔记补充 MultiWOZ2.2以及MultiWOZ系列的前世今生OverviewMultiWOZ2.2数据集发表在ACL2020上，发布了MultiWOZ数据集的升级版，作者来自google和伊利诺伊大学芝加哥分校 https://aclanthology.org/2020.nlp4convai-1.13/ MultiWOZ发展史 NewWOZ（ACL2018），但好像用的人不多？ MultiWOZ2.0（EMNLP2018） MultiWOZ2.1 针对2.0中的一些错误进行修正，添加了对槽位的解释和对对话行为的标注，亚马逊研究人员。 Eric M, Goel R, Paul S, et al. MultiWOZ 2.1: A Consolidated Multi-Domain Dialogue Dataset with State Corrections and State Tracking Baselines[C]//Proceedings of the 12th Language Resources and Evaluation Conference. 2020: 422-428. MultiWOZ2.2（ACL 2020），是2.1的进一步升级版 标注错误下面开始介绍2.2对2.1的改进，首先是标注错误。在了解标注错误之前，首先了解一下什么是Wizard-of-Oz setup。Wizard-of-Oz setup是由两个众包工人组成一队，一个扮演user，一个扮演agent。每组对话由一个特定的目标来驱动。在每轮user对话结束后，扮演agent的众包工会标注出更新后的对话状态，并依此生成一个回复。由于这种方法是完全靠人工去标注的，那么就会容易产生噪声。 Hallucinated Values（直译为“幻觉价值观”）作者将标注中错误的value分为4类。如下的4种 Early Markup：未来会出现的槽值被agent标注为了当前的值，如图所示，User说了：Help me find a moderate price british food place please，此时系统回复了restaurant one seven is a nice place. Do you want to book? 此时应该意图还没有锁在r-name=one seven上 Annotation from Database：这些值没有在对话中出现，而是被程序错误的从数据库中抽取出来的。 Typo：一些印刷或者排版书写错误 Implicit Time Processing：一些隐式的时间表示，有可能是根据前面的相对时间加减计算出来的时间，也有时候会四舍五入到最接近的时间。这样会家中模型学习的负担 状态更新不一致状态更新不一致的主要原因有两种： value来源有多个：一个槽值在对话状态可能有各种来源：由用户提供、由系统提供、从对话状态中不同的domain下的值继承过来的、来源于本体中定义的。 value的释义不规范：多个value其实含义是一样的。2.1在定义这些内容的时候缺乏一个显式的规则。这就使得模型训练的时候造成困惑，比如说同时有18：00和6pm，其实都是对的，但是训练过程中ground truth只有一个，那么就会错误的惩罚另一个 跟踪策略不一致：众包工人标注时的标准不一致，有的只标注了用户提到的value，有的将用户统一的agent提到的value也标了进来 本体中的问题在MultiWOZ2.0中定义了一个本体，他声称美居乐所有slot的value。但是后来的研究人员发现这个本体其实是很不完整的，所以为了达到很好的效果，研究人员往往要自己再重新定义一个自己的本体。为了解决这个问题，2.1试图列出对话状态中的所有值来重建本体，但是仍然存在一些未解决的问题。 比如说： 在同一槽位中具有相同语义的多个value 8pm=20:00，a and b guesthouse = a and b guest house 本体中多个slot-value无法与数据库中的实体相关联（这个地方不是很理解） 纠正程序为了解决上面提到了这些问题，作者这里提到了一套纠正程序 首先，关于本体。在本体为slot枚举所有可能的value是一件很不现实的事情。比如餐馆的名称，订餐的时间。 因此这里沿用了一种Schema的概念，也就是categorical和non-categorical的区别 categorical：slot中value有限（数量小于50），value列举出所有可能的值non-categorical：具有大量possible values的slot，value从对话历史中提取出来 schema将所有slot分成两类，一类叫做non-categorical，另一类叫做categorical non-categorical包括那些具有大量可能value的slot，schema中对这些slot不去预定义一个value的list，对于这类slot的value是从对话历史中提取出来的 categorical包含了那些value有限的slot，以及在训练数据中具体value数量少于50个的slot。在schema里头对这类slot会列举出所有可能的value 自：MWZ2.0数据集中的schema好像是比较明显的。 Categorical Slots对于分类槽位，所有可能的值都是由2.1的数据库构建的。 其中有两个特殊的词，dont-care和unknown don’t care是用户在对某一个值没有偏好的时候使用的 unknown指的是那些在schema中的值无法满足用户特定的需求 例如： Non-categorical Slots对于非分类槽位。上面已经说过，它的value是从历史对话中提取出来的。作者这里使用一种字符串匹配的方式找到对话历史中语义最接近的值。如果有多个，就取最近提到的那个 在2.2中，在标注中允许一个slot有多个value，模型预测出来任意一个都算对 当多个slot对应的是同一个value的时候，作者这里采用链式存储的思想。后来的slot不标注span，而是标注这个value对应的原始的slot 这个图也显示了有在categorical和non-categorical上分别计算JointAcc的习惯","categories":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Dialogue State Tracking","slug":"Dialogue-State-Tracking","permalink":"http://example.com/tags/Dialogue-State-Tracking/"},{"name":"Dataset","slug":"Dataset","permalink":"http://example.com/tags/Dataset/"}]},{"title":"我的首篇github博客!","slug":"mixed/hexo/我的首篇github博客","date":"2021-09-13T00:01:04.000Z","updated":"2022-11-20T01:50:08.892Z","comments":true,"path":"2021/09/13/mixed/hexo/我的首篇github博客/","link":"","permalink":"http://example.com/2021/09/13/mixed/hexo/%E6%88%91%E7%9A%84%E9%A6%96%E7%AF%87github%E5%8D%9A%E5%AE%A2/","excerpt":"何老版推荐的github.io+hexo好用啊 个人代码管理+笔记博客什么的都可以写在github这里了 主要写了hexo + github.io的双分支部署说明和步骤，以及本地运维和新建修改，切换主题等操作。","text":"何老版推荐的github.io+hexo好用啊 个人代码管理+笔记博客什么的都可以写在github这里了 主要写了hexo + github.io的双分支部署说明和步骤，以及本地运维和新建修改，切换主题等操作。 References： 简易部署相关：https://www.jianshu.com/p/390f202c5b0e多分支部署相关：https://blog.csdn.net/sherlockyb/article/details/94180548切换主题相关：https://github.com/stkevintan/hexo-theme-material-flow 1. hexo + github.io的双分支部署的说明简易部署带来的问题： 如果使用简单的hexo配置，那么本地的一些md等文件将丢失，所以现在有master（存储hexo生成的）和coding-pages（静态的）两个分支； master用来存储hexo生成的+yixuan004.github.io页面显示的内容（html），而coding-pages存放了一些原本的markdown文件，还有一些_config.yml等，这样如果未来某一天本地环境崩溃了，还可以很快的git clone恢复； 2. hexo + github.io的双分支部署步骤 在github建立一个包含README.md的项目，命名为 username.github.io，主分支为master分支； 直接在github branch的位置处新建一个coding-pages分支，并将其设置为默认分支。此时master分支和coding-pages分支应该都会有一个README.md文件，但实际上是不需要的，在后边可能需要用强制推分支的方法把这个README覆盖掉 在本地的一个文件夹中（例如yixuan004.github.io文件夹）中初始化一个hexo项目 1$ hexo init 将本地的hexo项目与远程仓库关联，在本地的那个地方使用git init生成隐藏的.git文件 1$ git init 在之后通过如下命令将远程的那个git关联上的感觉 1$ git remote add origin https://github.com/yixuan004/yixuan004.github.io.git 在之后，由于远程的默认分支是coding-pages，所以本地也需要新建一个coding-pages分支（注：本地的操作因为仅需要向coding-pages同步，所以本地工作也要切换到这个分支的感觉） 1$ git checkout -b coding-pages 由于远程之前可能有一个没什么用处的README，这里可以使用强制推的方法解决，但这个应该不是合理的解决办法，只是自己用来省事解决一下了 1234# 把本地的所有内容都加入git（hexo会自动生成一个git init，那些内容每次可能hexo clean会clean掉，所以要忽略那些）$ git add . $ git commit -m &quot;update ...&quot;$ git push -u origin coding-pages -f 安装hexo向git推送的包（在文件夹下操作） 1$ npm install hexo-deployer-git --save 修改hexo项目中的_config.yml，这里要写上master分支，因为貌似hexo在github.io上默认显示master分支的内容 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/yixuan004/yixuan004.github.io branch: master 推送相关（联合第4步使用） 123456$ git add .$ git commit -m &quot;update ...&quot;$ git push origin coding-pages$ hexo clean # 这个步骤放在第一步也可以，但是感觉有gitignore在应该这样就可以了$ hexo g$ hexo d 个人感觉远程的master分支是通过这个hexo自动推送，而远程的coding-pages分支是自己手工推送的感觉 3. hexo + github.io的本地操作说明3.1 新增博客文章1hexo new [文章名称] 在这之后，会在source/_posts目录下生成[文章名称].md文件，对其进行编写即可进行博客书写，注意在最开始会自动生成如下内容，可以通过自己编辑增加tags和categories 12345678---title: 我的首篇github博客!date: 2021-09-13 08:01:04tags: - hexo相关categories: - 编程开发--- 3.2 本地修改运维操作在本地完成一些修改后，建议顺序执行 123456$ git add .$ git commit -m &quot;update ...&quot;$ git push origin coding-pages$ hexo clean$ hexo g$ hexo d 4. 切换hexo主题可参考： https://github.com/stkevintan/hexo-theme-material-flow","categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"Crsenal","slug":"Crsenal","permalink":"http://example.com/categories/Crsenal/"},{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/categories/LeetCode-python/"},{"name":"LeetCode周赛","slug":"LeetCode-python/LeetCode周赛","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E5%91%A8%E8%B5%9B/"},{"name":"笔试练习-python","slug":"笔试练习-python","permalink":"http://example.com/categories/%E7%AC%94%E8%AF%95%E7%BB%83%E4%B9%A0-python/"},{"name":"LeetCode每日一题","slug":"LeetCode-python/LeetCode每日一题","permalink":"http://example.com/categories/LeetCode-python/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"LeetCode-热题 HOT 100","slug":"LeetCode-python/LeetCode-热题-HOT-100","permalink":"http://example.com/categories/LeetCode-python/LeetCode-%E7%83%AD%E9%A2%98-HOT-100/"},{"name":"docker","slug":"docker","permalink":"http://example.com/categories/docker/"},{"name":"NLP","slug":"NLP","permalink":"http://example.com/categories/NLP/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"EASY","slug":"EASY","permalink":"http://example.com/tags/EASY/"},{"name":"MEDIUM","slug":"MEDIUM","permalink":"http://example.com/tags/MEDIUM/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"计数","slug":"计数","permalink":"http://example.com/tags/%E8%AE%A1%E6%95%B0/"},{"name":"模拟","slug":"模拟","permalink":"http://example.com/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"数组","slug":"数组","permalink":"http://example.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"排序","slug":"排序","permalink":"http://example.com/tags/%E6%8E%92%E5%BA%8F/"},{"name":"贪心","slug":"贪心","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"回溯","slug":"回溯","permalink":"http://example.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"状态压缩","slug":"状态压缩","permalink":"http://example.com/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"},{"name":"数学","slug":"数学","permalink":"http://example.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"几何","slug":"几何","permalink":"http://example.com/tags/%E5%87%A0%E4%BD%95/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"HARD","slug":"HARD","permalink":"http://example.com/tags/HARD/"},{"name":"树","slug":"树","permalink":"http://example.com/tags/%E6%A0%91/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"二叉搜索树","slug":"二叉搜索树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"枚举","slug":"枚举","permalink":"http://example.com/tags/%E6%9E%9A%E4%B8%BE/"},{"name":"哈希函数","slug":"哈希函数","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0/"},{"name":"滚动哈希","slug":"滚动哈希","permalink":"http://example.com/tags/%E6%BB%9A%E5%8A%A8%E5%93%88%E5%B8%8C/"},{"name":"二叉树","slug":"二叉树","permalink":"http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"堆","slug":"堆","permalink":"http://example.com/tags/%E5%A0%86/"},{"name":"优先队列","slug":"优先队列","permalink":"http://example.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"macOS基础操作","slug":"macOS基础操作","permalink":"http://example.com/tags/macOS%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"name":"LeetCode-python","slug":"LeetCode-python","permalink":"http://example.com/tags/LeetCode-python/"},{"name":"栈","slug":"栈","permalink":"http://example.com/tags/%E6%A0%88/"},{"name":"递归","slug":"递归","permalink":"http://example.com/tags/%E9%80%92%E5%BD%92/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://example.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"链表","slug":"链表","permalink":"http://example.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"分治","slug":"分治","permalink":"http://example.com/tags/%E5%88%86%E6%B2%BB/"},{"name":"归并排序","slug":"归并排序","permalink":"http://example.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"name":"二分查找","slug":"二分查找","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"设计","slug":"设计","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"组合数学","slug":"组合数学","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"并查集","slug":"并查集","permalink":"http://example.com/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"双向链表","slug":"双向链表","permalink":"http://example.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"TODO优化","slug":"TODO优化","permalink":"http://example.com/tags/TODO%E4%BC%98%E5%8C%96/"},{"name":"水塘抽样","slug":"水塘抽样","permalink":"http://example.com/tags/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A0%B7/"},{"name":"随机化","slug":"随机化","permalink":"http://example.com/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96/"},{"name":"NLP","slug":"NLP","permalink":"http://example.com/tags/NLP/"},{"name":"Transformer","slug":"Transformer","permalink":"http://example.com/tags/Transformer/"},{"name":"Dialogue State Tracking","slug":"Dialogue-State-Tracking","permalink":"http://example.com/tags/Dialogue-State-Tracking/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Dialogue","slug":"Dialogue","permalink":"http://example.com/tags/Dialogue/"},{"name":"Dataset","slug":"Dataset","permalink":"http://example.com/tags/Dataset/"}]}